<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Programlama Dili</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Rust Programlama Dili</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Ön söz</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Başlangıç</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Başlarken</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Yükleme</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Merhaba, Dünya!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Merhaba, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Tahmin Oyunu Programlamak</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Yaygın Programlama Kavramları</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Değişkenler ve Değişebilirlik</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Fonksiyonlar</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Yorum Satırları</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrol Akışı</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Sahipliği Anlamak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Sahiplik Nedir?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referanslar ve Ödünç Alma Mekanizması</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Dilim Türü</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> İlintili Verileri Yapılandırmak için Yapıları Kullanmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Yapıları Tanımlamak ve Örneklendirmek</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Yapıları Kullanan Örnek Bir Program</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Metod Söz dizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Numaralandırılmış Yapılar ve Model Eşleme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Numaralandırılmış Yapı Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match Kontrol Akış Yapısı</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let ile Kısa Kontrol Akış Yapısı</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Büyüyen Projeleri Paketler, Kasalar ve Modüllerle Yönetme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paketler ve Kasalar</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Gizlilik ve Kontrol Kapsamı için Modüller Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Modül Ağacındaki bir Öğeyi Referanslama Yolları</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use Kullanarak Yolları Kapsama Getirmek</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Modülleri Farklı Dosyalara Ayırmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Yaygın Koleksiyon Türleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Veri Listelerini Vektörlerle Tutmak</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8 ile Kodlanmış Dizgiyi Tutmak</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> İlişkili Değerlerle Anahtarları Saklamak</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Hata Yönetimi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! ile Kurtarılamayan Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result ile Kurtarılabilir Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!lemek ya da panic!lememek</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Yaygın Türler, Tanımlar ve Ömürlükler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Yaygın Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Tanımlar: Yaygın Davranış Tanımlama</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Ömürlük Yapısıyla Referans Doğrulama</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Otomatikleşmiş Testler Yazma</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Testler Nasıl Yazılır</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Testlerin Nasıl Çalıştığını Kontrol Etmek</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organizasyonu</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Bir G/Ç Projesi: Komut Satırı Programı Yazmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Komut Satırı Argümanlarını Ayrıştırmak</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Dosya Okumak</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Modülerliği ve Hata Yönetimini Geliştirmek için Yeniden Düzenlemek</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Test Odaklı Geliştirme ile Kütüphanenin İşlevliğini Artırmak</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Ortam Değişkenlerini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Hata Mesajlarını Standart Çıktı yerine Standart Hata Akışına Yazdırmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Fonksiyonel Dil Özellikleri: Yineleyiciler ve Kapanış İfadeleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Kapanış İfadeleri: Ortamda Tutulabilen Anonim Fonksiyonlar</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Yineleyicilerle Bir Dizi Öğeyi İşlemek</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> G/Ç Projemizi Geliştirmek</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performans Kıyaslaması: Döngüler vs. Yineleyiciler</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo ve Crates.io Hakkında Daha Fazla Bilgi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Dağıtım Profilleriyle İnşaları Özelleştirmek</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io'da Bir Kasa Paylaşmak</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Çalışma Alanları</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install ile Crates.io'dan Derlenmişleri Yüklemek</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Özel Komutlarla Cargo'yu Genişletmek</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Akıllı İşaretçiler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Yığındaki Verileri İşaretlemek için Box&lt;T&gt; Kullanmak</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Akıllı İşaretçilere Deref ile Normal Referanslar Gibi Tanım Yapmak</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop Tanımlamasıyla Temizlik Aşamasında Kod Çalıştırmak</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Referans Sayaçlı Akıllı İşaretçi</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; ve İç Değişebilirlik Modeli</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referans Döngüleri Bellek Sızdırabilir</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Korkusuz Eşzamanlılık</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Kodu Eşzamanlı Çalıştırmak için İş Parçacıklarını Kullanmak</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Konular Arasında Veri Aktarmak için İleti Geçişini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Paylaşımlı Eşzamanlık</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync ve Send Tanımlarıyla Genişletilebilir Eşzamanlılık</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust'taki Nesne Yönemimli Programlama Özellikleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Nesne Yönelimli Dillerin Karakteristik Özellikleri</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Farklı Türlerdeki Değerlere İzin Veren Özellik Tanımlarını Kullanma</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Nesneye Yönelik Tasarım Modelini Süreklemek</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Modeller ve Eşleştirme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Modeller Her Yerde Kullanılabilir</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Reddedilebilirlik: Modelin Eşleştirmede Başarısız Olup Olmayacağı</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Model Söz Dizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Gelişmiş Özellikler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Güvensiz Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Gelişmiş Tanımlar</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Gelişmiş Türler</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Gelimiş Fonksiyonlar ve Kapanış İfadeleri</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makrolar</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Projesi: Çoklu İş Parçacıklı Web Sunucusu İnşa Etmek</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Tek İş Parçacıklı Web Sunucusu İnşa Etmek</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Tek İş Parçacıklı Sunucumuzu Çok Parçacıklı Sunucuya Çevirmek</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Zarifçe Kapatmak ve Temizlemek</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Eklemeler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Anahtar Sözcükler</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatörler ve Semboller</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Türetilebilir Tanımlar</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Kullanışlı Geliştirme Araçları</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Sürümler</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Kitap'ın Çevirileri</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust ve “Gecelik Rust” Nasıl Yapıldı</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Programlama Dili</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ferhatgec/kitap" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-programlama-dili"><a class="header" href="#rust-programlama-dili">Rust Programlama Dili</a></h1>
<p><em>Steve Klabnik ve Carol Nichols tarafından, Rust Topluluğunun katkılarıyla</em></p>
<p>Yazının bu versiyonu, Rust 1.59 ya da daha yenisini kullandığınızı varsayar (2022-02-24 tarihinde yayınlandı). 
Rust'ı güncellemek ya da yüklemek için <a href="ch01-01-installation.html">Bölüm 1'in “Yükleme” kısmına bakınız</a><!-- ignore --></p>
<p>HTML formatı <a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a> sayfasından erişilebilir
ve <code>rustup</code>; <code>rustup docs --book</code> ile açılabilir.</p>
<p>Sayılı çeviriler <a href="appendix-06-translation.html">translations</a> kısmında mevcuttur.</p>
<p>Bu yazı <a href="https://nostarch.com/rust">No Starch Press'den baskılı ve e-kitap formatı şeklinde temin edilebilir</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Ön-söz"><a class="header" href="#Ön-söz">Ön söz</a></h1>
<p>Her zaman bu kadar net değildi ancak Rust programlama dili temel olarak <em>güçlendirme</em> ile ilgilidir: 
şu anda ne tarz bir kod yazdığının bir önemi yok. Rust, daha önce yaptığınızdan 
çok ama çok daha geniş bir alan yelpazesinde güvenle programlama yapmanız için size güç verir.</p>
<p>Örneğin, bellek yönetimi, veri gösterimi ve eşzamanlılığın alt düzey ayrıntılarıyla ilgilenen 
&quot;sistemsel düzeyde&quot; bir çalışmayı ele alalım. Geleneksel olarak, bu programlama alanı gizemli 
olarak görülür ve yalnızca yıllarını kötü şöhretli tuzaklarından kaçınmayı öğrenmeye adayan 
seçkin birkaç kişi tarafından erişilebilir. Ve bunu uygulayanlar bile, kodları istismarlara, 
çökmelere veya ağır sıkıntılara açık olmasın diye bunu dikkatli yapıyorlar.</p>
<p>Rust, eski tuzakları ortadan kaldırarak ve yol boyunca size yardımcı olacak samimi, 
cilalı bir araç seti sağlayarak bu engelleri ortadan kaldırır. 
Daha düşük seviyeli kontrole &quot;dalması&quot; gereken programcılar, bunu Rust ile, 
geleneksel çökme veya güvenlik açıkları riskini üstlenmeden ve 
kararsız bir alet zincirinin ince noktalarını öğrenmek zorunda kalmadan yapabilirler. 
Daha da iyisi, bu dil, sizi hız ve bellek kullanımı açısından verimli, 
güvenilir koda doğru doğal olarak yönlendirmek için tasarlanmıştır.</p>
<p>Halihazırda düşük seviyeli kodla çalışan programcılar, hedeflerini yükseltmek için Rust'ı kullanabilir.
Örneğin, Rust'a paralellik eklemek nispeten düşük riskli bir işlemdir: derleyici sizin için klasik hataları yakalayacaktır. 
Ve kazara çökmeler veya güvenlik açıkları oluşturmayacağınıza güvenerek kodunuzdaki daha agresif 
optimizasyonların üstesinden gelebilirsiniz.</p>
<p>Ancak Rust, sadece düşük seviyeli sistem programlama ile sınırlı değildir. 
Komut satırı uygulamalarını, web sunucularını ve diğer birçok kod türünü yazmayı oldukça keyifli kılacak 
kadar etkileyici ve ergonomiktir — kitabın ilerleyen bölümlerinde her ikisinin de basit örneklerini bulacaksınız. 
Rust ile çalışmak, bir alandan diğerine aktarılan beceriler oluşturmanıza olanak tanır; Rust'ı bir web uygulaması yazarak öğrenebilir, ardından aynı becerileri Raspberry Pi'nizi hedeflemek için kullanabilirsiniz.</p>
<p>Bu kitap, Rust'ın kullanıcılarını güçlendirme potansiyelini tamamen benimsiyor. 
Bu, yalnızca Rust hakkındaki bilginizi değil, aynı zamanda genel olarak bir programcı olarak erişiminizi 
ve buna karşı olan güveninizi artırmanıza yardımcı olmayı amaçlayan samimi ve ulaşılabilir bir metindir. 
Öyleyse dalın, öğrenmeye hazır olun—ve Rust Topluluğuna hoş geldiniz!</p>
<p>— Nicholas Matsakis ve Aaron Turon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="başlangıç"><a class="header" href="#başlangıç">Başlangıç</a></h1>
<blockquote>
<p>Not: Kitabın bu sürümü İngilizce olarak <a href="https://nostarch.com/rust">Rust Programlama
Dili</a>'da ve basılı ve e-kitap formatında <a href="https://nostarch.com/">No Starch
Press</a>'dan temin edilebilir.</p>
</blockquote>
<p><em>Rust Programlama Diline</em> hoş geldiniz. Bu kitap size Rust'ı tanıtacaktır.
Rust programlama dili size daha hızlı, daha güvenli program yazmanız için yardım eder.
Yüksek seviyeli ergonomi ve düşük seviyeli kontrol, programlama dili tasarımında genellikle çelişkili olarak lanse edilir; 
Rust, işte bu çatışmaya meydan okur. Güçlü teknik kapasiteyi ve harika bir geliştirici deneyimini dengeleyen Rust, size düşük seviyeli ayrıntıları (bellek kullanımı gibi) bu tür kontrollerle geleneksel olarak ilişkilendirilen tüm güçlükler olmadan kontrol etme seçeneği sunar.</p>
<h2 id="rust-kimin-İçin"><a class="header" href="#rust-kimin-İçin">Rust Kimin İçin</a></h2>
<p>Rust çeşitli nedenlerden dolayı çoğu kişi için idealdir. Hadi bazı çok önemli gruplara göz atalım.</p>
<h3 id="geliştirici-ekipleri"><a class="header" href="#geliştirici-ekipleri">Geliştirici Ekipleri</a></h3>
<p>Rust, farklı düzeylerde sistem programlama bilgisi olan büyük geliştirici ekipleri arasında iş birliği yapmak için 
üretken bir araç olduğunu kanıtlıyor. Düşük seviyeli kod, diğer birçok dilde yalnızca deneyimli geliştiriciler tarafından
kapsamlı testler ve dikkatli kod incelemesi yoluyla yakalanabilen çeşitli ince hatalara yönelimlidir. Rust'ta derleyici, 
eşzamanlılık hataları da dahil olmak üzere bu anlaşılması zor hatalarla kod derlemeyi reddederek bir kapı bekçisi rolü oynar. 
Derleyici ile birlikte çalışarak ekip, zamanlarını hataları aramak yerine programın mantığına odaklanarak geçirebilir.</p>
<p>Rust ayrıca çağdaş geliştirici araçlarını sistem programlama dünyasına getiriyor:</p>
<ul>
<li>Cargo, dahili bağımlılık yöneticisi ve inşa aracı, eklemeler yapar,
derler, sorunsuzca bağımlılıkları yönetir ve Rust ekosisteminin en önemli parçalarından birisidir.</li>
<li>Rustfmt, geliştiriciler arasında tutarlı bir kodlama stili sağlar.</li>
<li>Rust Dil Sunucusu, Entegre Geliştirme Ortamına (IDE) kod tamamlama ve hata mesajları için güç verir.</li>
</ul>
<p>Geliştiriciler, Rust ekosisteminde bunları ve farklı araçları kullanarak sistem programlama seviyesinde daha üretken olabilirler.</p>
<h3 id="Öğrenciler"><a class="header" href="#Öğrenciler">Öğrenciler</a></h3>
<p>Rust, öğrenciler ve sistem kavramlarını öğrenmek isteyenler içindir. 
Rust'ı kullanarak birçok kişi, işletim sistemi geliştirme gibi konuları öğrendi. 
Topluluk çok sıcakkanlı ve öğrencilerin sorularını yanıtlamaktan mutluluk duyuyor. 
Rust ekipleri, bu kitap gibi çaba göstererek sistem kavramlarını, özellikle programlamada 
yeni olanlar için daha fazla insan için daha erişilebilir hale getirmek istiyor.</p>
<h3 id="Şirketler"><a class="header" href="#Şirketler">Şirketler</a></h3>
<p>Büyük ya da küçük yüzlerce şirket, çeşitli görevler için üretimde Rust kullanıyor. 
Bu görevler arasında komut satırı araçları, web hizmetleri, DevOps araçları, gömülü cihazlar, 
ses ve video analizi ve kod dönüştürme, kripto para birimleri, biyoinformatik, arama motorları, Nesnelerin İnterneti uygulamaları, 
makine öğrenimi ve hatta Firefox web tarayıcısının büyük bölümleri de yer alıyor.</p>
<h3 id="açık-kaynak-geliştiricileri"><a class="header" href="#açık-kaynak-geliştiricileri">Açık Kaynak Geliştiricileri</a></h3>
<p>Rust, Rust programlama dili, topluluk, geliştirici araçları ve kitaplıklar oluşturmak isteyenler içindir.
Rust diline katkıda bulunmanızı çok isteriz.</p>
<h3 id="hıza-ve-kararlılığa-Önem-verenler"><a class="header" href="#hıza-ve-kararlılığa-Önem-verenler">Hıza ve Kararlılığa Önem Verenler</a></h3>
<p>Rust, bir dilde hız ve istikrar isteyen insanlar içindir. 
Hız derken, Rust ile oluşturabileceğiniz programların hızını ve Rust'ın bunları yazmanıza izin verdiği hızı kastediyoruz. 
Rust derleyicisinin denetimleri, yeni özellik eklemeleri ve yeniden düzenleme yoluyla kararlılık sağlar. 
Bu, geliştiricilerin genellikle değiştirmekten korktukları, bu kontrollerin olmadığı dillerdeki kırılgan eski kodun aksine. 
Rust, sıfır maliyetli soyutlamalar, elle yazılan kod kadar hızlı bir şekilde daha düşük seviyeli koda derlenen daha yüksek seviyeli özellikler için çabalayarak her güvenli kodun da hızlı kod olmasını sağlamaya çalışır.</p>
<p>Rust dili, diğer birçok kullanıcıyı da desteklemeyi umuyor; burada bahsedilenler sadece en büyük paydaşlardan bazılarıdır. 
Genel olarak, Rust'ın en büyük amacı, güvenlik ve üretkenlik olmak üzere artı olarak hız ve ergonomi sağlayarak 
geliştiriclerin on yıllardır kabul ettiği ödünleri ortadan kaldırmaktır. 
Rust'ı deneyin ve seçeneklerinin sizin için işe yarayıp yaramadığını görün.</p>
<h2 id="bu-kitap-kimler-İçin"><a class="header" href="#bu-kitap-kimler-İçin">Bu Kitap Kimler İçin</a></h2>
<p>Bu kitap, başka bir programlama dilinde kod yazdığınızı varsayar. Kitabı çok çeşitli programlama geçmişlerinden gelenler için geniş çapta 
erişilebilir hale getirmeye çalıştık. Programlamanın ne olduğu veya onun hakkında nasıl düşünüleceği hakkında konuşmak için çok zaman harcamıyoruz. Programlama konusunda tamamen yeniyseniz, özellikle programlamaya giriş sağlayan bir kitap okuyarak daha fazla bilgi alarak bu serüvene atılabilirsiniz.</p>
<h2 id="kitabı-nasıl-kullanmalı"><a class="header" href="#kitabı-nasıl-kullanmalı">Kitabı Nasıl Kullanmalı</a></h2>
<p>Genel olarak, bu kitap önden arkaya sırayla okuduğunuzu varsayarak anlatır. Sonraki bölümler, önceki bölümlerdeki kavramların üzerine inşa edilmiştir ve önceki bölümler bir konunun ayrıntılarına girmeyebilir; Konuyu genellikle daha sonraki bir bölümde tekrar ele alırız.</p>
<p>Bu kitapta iki tür bölüm bulacaksınız: kavram bölümleri ve proje bölümleri. Konsept bölümlerinde Rust'ın farklı bir yönü hakkında bilgi edineceksiniz. Proje bölümlerinde, şimdiye kadar öğrendiklerinizi uygulayarak birlikte küçük programlar oluşturacağız. Bölüm 2, 12 ve 20 proje bölümleridir; geri kalanı kavram bölümleridir.</p>
<p>Bölüm 1, Rust'ın nasıl kurulacağını, “Hello, World!”'ün nasıl yazılacağını, Rust'ın paket yöneticisi ve oluşturma aracı olan Cargo'nun nasıl kullanılacağını açıklar. 2. Bölüm, Rust diline uygulamalı bir giriştir. Burada kavramları yüksek düzeyde ele alıyoruz. Eğer kavramlarla kafanız karışmışsa sonraki bölümlerdeki ek ayrıntılar size ek bilgiler verecektir. Ellerinizi hemen kirletmek istiyorsanız, bunun yeri Bölüm 2'dir. İlk başta, diğer programlama dillerine benzer Rust özelliklerini kapsayan Bölüm 3'ü atlayabilir ve Rust'ın sahiplik sistemi hakkında bilgi edinmek için doğrudan Bölüm 4'e gidebilirsiniz. Ancak, bir sonrakine geçmeden önce her ayrıntıyı öğrenmeyi tercih eden özellikle titiz bir öğrenciyseniz, Bölüm 2'yi atlayıp doğrudan Bölüm 3'e geçebilir, bir konu üzerinde çalışmak istediğinizde Bölüm 2'ye dönebilirsiniz. öğrendiğiniz detayları uygulayarak projelendirmeyi unutmayın.</p>
<p>Bölüm 5 yapıları ve yöntemleri tartışır ve Bölüm 6 numaralandırmaları, eşleşme ifadelerini ve <code>if let</code> kontrol akışı yapısını kapsar. Rust'ta özel türler oluşturmak için yapıları ve numaralandırmaları kullanacaksınız.</p>
<p>Bölüm 7'de, Rust'ın modül sistemi ve kodunuzu ve onun genel Uygulama Programlama Arayüzü'nü (API) düzenlemek için gereken gizlilik kuralları hakkında bilgi edineceksiniz. Bölüm 8, vektörler, diziler ve karma haritalar (hash map) gibi standart kitaplığın sağladığı bazı ortak veri toplama yapılarını tartışır. 9. Bölüm, Rust'ın hata işleme felsefesini ve tekniklerini anlatır.</p>
<p>Bölüm 10, size birden çok tür için geçerli olan kodu tanımlama gücü veren yaygın türler, özellikler ve ömürlükleri inceler. Bölüm 11, programınızın mantığının doğru olduğundan emin olmak için Rust'ın güvenlik garantileriyle bile gerekli olan testlerle ilgilidir. 12. Bölümde, dosyalar içinde metin arayan &quot;grep&quot; komut satırı aracının yaptığıyla benzer olarak kendi uygulamamızı oluşturacağız. Bunun için önceki bölümlerde tartıştığımız kavramların birçoğunu kullanacağız.</p>
<p>Bölüm 13, kapanış ifadelerini ve yineleyicileri anlatıyor: işlevsel programlama dillerinden gelen Rust özellikleri. 14. Bölümde, Cargo'yu daha derinlemesine inceleyeceğiz ve kitaplıklarınızı başkalarıyla paylaşmak için kullanılabilecek en iyi tekniklerden bahsedeceğiz. Bölüm 15'te, standart kütüphanenin sağladığı akıllı işaretçileri ve bunların işlevselliğini sağlayan özellikleri tartışacağız.</p>
<p>Bölüm 16'da, farklı eşzamanlı programlama modellerini inceleyeceğiz ve Rust'ın birden çok iş parçacığında korkusuzca programlamanıza nasıl yardımcı olduğu hakkında konuşacağız. Bölüm 17, Rust deyimlerinin aşina olabileceğiniz nesne yönelimli programlama ilkeleriyle nasıl karşılaştırıldığını inceler.</p>
<p>Bölüm 18, Rust programları boyunca fikirleri ifade etmenin güçlü yolları olan kalıplar ve kalıp eşleştirme hakkında bir referanstır. Bölüm 19, güvenli olmayan Rust, makrolar ve ömürlükler, tanımlar, türler, fonksiyonlar ve kapanış türleri hakkında daha fazlası dahil olmak üzere ileri düzey ilgi çekici konulardan oluşan bir <em>İsveç masasını</em> içerir.</p>
<p>Bölüm 20'de, düşük seviyeli çok iş parçacıklı bir web sunucusu uygulayacağımız bir projeyi tamamlayacağız!</p>
<p>Son olarak, Ekleme A, Rust'ın anahtar sözcüklerini, Ekleme B, Rust'ın operatörlerini ve sembollerini kapsar, Ekleme C, standart kütüphane tarafından sağlanan türevlenebilir özellikleri kapsar, Ekleme D, bazı yararlı geliştirme araçlarını kapsar ve Ekleme E, Rust sürümlerini açıklar.</p>
<p>Bu kitabı okumanın yanlış bir yolu yok: Nasıl ilerlemek istiyorsanız, devam edin! Herhangi bir karışıklık yaşarsanız, önceki bölümlere geri dönmeniz gerekebilir. Ama bu kitabı istediğin gibi kullanabilirsin, yapabileceğinin en iyisini yap!</p>
<p><span id="ferris"></span></p>
<p>Rust öğrenme sürecinin önemli bir parçası, derleyicinin görüntülediği hata mesajlarının nasıl okunacağını öğrenmektir: bunlar sizi çalışma koduna yönlendirecektir. Bu nedenle, derleyicinin her durumda size göstereceği hata mesajıyla birlikte derlenmeyen birçok örnek sunacağız. Rastgele bir örnek girip çalıştırırsanız derlenmeyebileceğini bilin! Çalıştırmaya çalıştığınız örneğin hata amaçlı olup olmadığını görmek için çevreleyen metni okuduğunuzdan emin olun. Ferris, çalışması mümkün olmayan ya da düzgün çalışmayan kodları ayırt etmenize de yardımcı olacaktır:</p>
<table><thead><tr><th>Ferris</th><th>Anlamı</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ferris with a question mark"/></td><td>Bu kod derlenmiyor!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain" alt="Ferris throwing up their hands"/></td><td>Bu kod paniğe sahip!</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ferris with one claw up, shrugging"/></td><td>Bu kod belirtilen davranışı sergilemiyor.</td></tr>
</tbody></table>
<p>Çoğu durumda, sizi derlenmeyen herhangi bir kodun derlenen doğru sürümüne yönlendireceğiz.</p>
<h2 id="kaynak-kod"><a class="header" href="#kaynak-kod">Kaynak Kod</a></h2>
<p>Bu kitabın oluşturulduğu kaynak dosyalar şu adreste bulunabilir: <a href="https://github.com/rust-lang/book/tree/main/src">GitHub, Rust deposu</a>.
Türkçeye çevrilmiş kaynak dosyaları şu adreste bulunabilir: <a href="https://github.com/ferhatgec/kitap/tree/patch-1/src">GitHub, ferhatgec deposu</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="başlarken"><a class="header" href="#başlarken">Başlarken</a></h1>
<p>Hadi sizin Rust yolculuğunuza başlayalım! Öğrenecek çok şey var... Ama her yolculuk bir yerden başlar. 
Bu bölümde şunları tartışacağız:</p>
<ul>
<li>Linux, macOS, and Windows platformları için Rust'ı yüklemek</li>
<li><code>Hello, world!</code> yazan bir program yazmak</li>
<li>Rust'ın paket yöneticisi ve inşa sistemi olan <code>cargo</code>'yu kullanmak</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kurulum"><a class="header" href="#kurulum">Kurulum</a></h2>
<p>İlk adım Rust'ı kurmaktır. Rust'ı, Rust sürümlerini 
ve ilgili araçları yönetmek için bir komut satırı aracı olan <code>rustup</code> aracılığıyla indireceğiz. 
İndirmek için bir internet bağlantısına ihtiyacınız olacak.</p>
<blockquote>
<p>Not: Eğer bir nedenden ötürü <code>rustup</code> kullanmak istemiyorsanız, lütfen
<a href="https://forge.rust-lang.org/infra/other-installation-methods.html">Rust'ı Kurmanın Diğer Yolları sayfasına</a> bir göz atın.</p>
</blockquote>
<p>Aşağıdaki adımlar, Rust derleyicisinin en son kararlı sürümünü yükler. 
Rust'ın kararlılık garantisi, kitaptaki tüm örneklerin daha yeni Rust sürümleriyle derlenmeye devam etmesini sağlar. 
Çıktı, sürümler arasında biraz farklılık gösterebilir, çünkü Rust yeni sürümlerde genellikle hata mesajlarını ve uyarıları iyileştirir. 
Başka bir deyişle, bu adımları kullanarak kurduğunuz her yeni, kararlı Rust sürümü bu kitabın içeriğiyle beklendiği gibi çalışmalıdır.</p>
<blockquote>
<h3 id="komut-satırı-gösterimi"><a class="header" href="#komut-satırı-gösterimi">Komut Satırı Gösterimi</a></h3>
<p>Bu bölümde hatta kitabın çoğu yerinde komutları uçbirimde kullanıldığı haliyle
göstereceğiz. Yazacağınız satırlar <code>$</code> ile başlamalıdır. Bu karakteri yazmanıza 
gerek yoktur, sadece komutun başladığını belirtir ve her komutta belirir
<code>$</code> ile başlamayan satırlar çoğu zaman önceki komutun çıktısını gösterir.
Farklı olarak, PowerShell özelindeki örneklerde <code>&gt;</code> karakterini kullanacağız.</p>
</blockquote>
<h3 id="linux-ya-da-macos-üzerinde-rustupı-indirmek"><a class="header" href="#linux-ya-da-macos-üzerinde-rustupı-indirmek">Linux ya da macOS üzerinde <code>rustup</code>'ı indirmek</a></h3>
<p>Eğer Linux ya da macOS kullanıyorsanız, uçbirimi açın ve şu komutu girin.</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.3 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Bu komut bir betik indirir ve Rust'ın son stabil sürümünü kuran araç olan <code>rustup</code>'ı başlatır. 
Eğer çıkış hariç herhangi bir seçeneği seçerseniz şifrenizi girmeniz gerektiği belirtilmiş olmalıdır. 
Eğer kurulum başarılı olursa, şu satırlar görünmüş olmalıdır:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>Ayrıca bir Rust'ın kullandığı, derlenmiş çıktıları tek dosyala toplayan bir bağlayıcıya ihtiyacınız olacak. 
Büyük ihtimalle sizde bir tanesi vardır, eğer herhangi bir bağlayıcı hatası alıyorsanız Bağlayıcı içeren 
bir C derleyicisi yüklemeniz gerekir. Bir C derleyicisi ayrıca C kodu içeren Rust paketlerini derlemek için de 
kullanışlıdır.</p>
<p>macOS'ta C derleyicisini şu kodu çalıştırarak elde edebilirsiniz:</p>
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<p>Linux kullanıcıları dağıtımlarının dokümantasyonlarına bağlı olarak genel olarak GCC ya da Clang yüklemelidir. 
Örnek olarak, eğer Ubuntu kullanıyorsanız, <code>build-essential</code> paketini yükleyebilirsiniz.</p>
<h3 id="windows-üzerinde-rustupı-indirmek"><a class="header" href="#windows-üzerinde-rustupı-indirmek">Windows üzerinde <code>rustup</code>'ı indirmek</a></h3>
<p>Windows'ta, <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> sitesine gidin ve 
Rust'ı kurmak için belirtilen yönergeleri uygulayın. Yüklemenin bazı noktalarında
Visual Studio 2013 ya da yeni sürümleri için C++ inşa araçlarına ihtiyacınız olduğuna
dair bir mesaj alacaksınız. En kolay yolla gerekli inşa araçlarını alabilmek için <a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">Build Tools for Visual Studio 2019</a>'ı
kurabilirsiniz. Her ne zaman hangilerini indirmeniz gerektiği sorulduğunda “C++ inşa araçları”,
Windows 10 SDK ve İngilizce dil paketi dahil edilmş olmalıdır.</p>
<p>Bu kitap hem <em>cmd.exe</em> de hem de PowerShell de çalışan komutları kullanmaktadır. Eğer bir farklılık var ise
hangisini kullanmanız gerektiğini açıklayacağız.</p>
<h3 id="güncelleme-ve-kaldırma"><a class="header" href="#güncelleme-ve-kaldırma">Güncelleme ve Kaldırma</a></h3>
<p><code>rustup</code> yoluyla kurduktan sonra son sürüme güncelleştirmek aşırı kolaydır. Kabuğunuzdan (PowerShell) şu güncelleme betiğini çalıştırın:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>Rust ve <code>rustup</code>'ı kaldırmak için kabuğunuzdan şu kaldırma betiğini çalıştırın:</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<h3 id="sorun-giderme"><a class="header" href="#sorun-giderme">Sorun giderme</a></h3>
<p>Rust'ı doğru yüklediğinizden emin olmak için kabuğunuzu açın ve şu betiği girin:</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>Versiyon sayısını, son stabil sürüm için depoya gönderilen gönderim tarihini görmüş olmalısınızdır:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Eğer bu bilgileri görebiliyorsanız, Rust'ı doğru bir biçimde kurmuşsunuz demektir!
Eğer göremiyorsanız ve Windows üzerindeyseniz, <code>%PATH%</code> sistem değişkenini kontrol edinç
Eğer her şey yolunda ve Rust hala çalışmıyorsa, yardım alabileceğiniz birçok yer vardır. 
En kolay yol, <a href="https://discord.gg/rust-lang">resmi Rust Discord sunucusunda</a> #beginners kanalına mesaj atmaktır. 
Burada, size yardımcı olabilecek diğer Rustseverler (Rustaceans) ile mesajlaşabilirsiniz.
Diğer güzel kaynaklara <a href="https://users.rust-lang.org/">Kullanıcılar forumu</a> ve <a href="https://stackoverflow.com/questions/tagged/rust">Stack Overflow</a> örnek verilebilir.</p>
<h3 id="yerel-dokümantasyon"><a class="header" href="#yerel-dokümantasyon">Yerel Dokümantasyon</a></h3>
<p>Rust kurulumu ayrıca dokümantasyonun bir kopyasını yerelde tutar, yani bunu çevrimdışı da 
okuyabilirsiniz. Tarayıcınızda okumak için <code>rustup doc</code> komutunu çalıştırabilirsiniz.</p>
<p>Standart kütüphanede bulunan ve nasıl ya da nerede kullanacağınızı bilmediğiniz tür ya da fonksiyonları
uygulama programlama arayüzü (API) dokümantasyonunu kullanarak bulabilirsiniz!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="merhaba-dünya"><a class="header" href="#merhaba-dünya">Merhaba, Dünya!</a></h2>
<p>Artık Rust'u yüklediğinize göre ilk Rust programınızı yazalım. Yeni bir dil öğrenirken <code>Hello, world!</code> metnini yazdıran küçük bir program yazmak gelenekseldir. Bu yüzden burada da aynısını yapacağız!</p>
<blockquote>
<p>Not: Bu kitap, komut satırına temel düzeyde aşina olduğunuzu varsayar. 
Rust, araçlarınızı ya da kodunuzun nerede tutulduğunu umursamaz, çoğu editörde Rust dili desteği vardır. 
Bu nedenle komut satırı yerine entegre bir geliştirme ortamı (IDE) kullanmayı tercih ederseniz, favori IDE'nizi kullanmaktan çekinmeyin. 
Birçok IDE artık bir dereceye kadar Rust desteğine sahiptir; ayrıntılar için IDE dokümantasyonlarına bakabilirsiniz. 
Son zamanlarda, Rust ekibi harika IDE desteği sağlamaya odaklandı ve bu cephede hızla ilerleme kaydedildi!</p>
</blockquote>
<h3 id="proje-dizini-oluşturma"><a class="header" href="#proje-dizini-oluşturma">Proje Dizini Oluşturma</a></h3>
<p>Rust kodunuzu tutmak için bir <em>dizine</em> ihtiyacınız var, Rust bunu otomatik olarak oluşturur. Normalde,
Rust için kodunuzun nerede tutulduğu hiç de önemli değildir ancak bu kitaptaki alıştırmalar ve projeler için ana dizininizde bir proje dizini oluşturmanızı ve tüm projelerinizi orada tutmanızı öneririz.</p>
<p>Bir <em>proje dizini</em> ve başlangıç kodu oluşturmak için bir uçbirim açın ve aşağıdaki komutları girin:</p>
<p>Linux'ta, macOS'ta ve PowerShell'de (Windows'ta) çalıştırmak için şunları girin:</p>
<pre><code class="language-console">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>Windows Komut Satırı (CMD) için şunları girin:</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<h3 id="rust-programı-yazma-ve-Çalıştırma"><a class="header" href="#rust-programı-yazma-ve-Çalıştırma">Rust Programı Yazma ve Çalıştırma</a></h3>
<p>Ardından, yeni bir kaynak dosya oluşturun ve <em>main.rs</em> olarak adlandırın. Rust dosyaları her zaman <em>.rs</em> uzantısıyla biter. 
Dosya adınızda birden fazla kelime kullanıyorsanız, bunları ayırmak için alt çizgi kullanın. Örneğin, <em>helloworld.rs</em> yerine <em>hello_word.rs</em> kullanın.</p>
<p>Şimdi az önce oluşturduğunuz main.rs dosyasını açın ve Liste 1-1'deki kodu yapıştırın.</p>
<p><span class="filename">Dosya adı: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><span class="caption">Liste 1-1: <code>Hello, world!</code> Yazan Bir Program</span></p>
<p>Dosyayı kaydedin ve uçbirime geri dönün. Linux'ta ya da macOS'ta derlemek ve çalıştırmak için şu komutları girin:</p>
<pre><code class="language-console">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>Windows'ta, komutu <code>./main</code> şeklinde değil <code>.\main.exe</code> şeklinde girin:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<p>İşletim sisteminizden bağımsız olarak <code>Hello, world!</code> dizgisi uçbirime yazılmış olmalıdır. Eğer çıktıyı göremiyorsanız, 
<a href="ch01-01-installation.html#troubleshooting">“Hata giderme”</a><!-- ignore --> kısmına giderek çözüm arayın, büyük ihtimalle bir şeyi kaçırmışssınızdır!</p>
<p>Eğer <code>Hello, world!</code> çıktısını gördüyseniz, tebrikleeeeeeer! Rust programı yazdınız. Bu da sizi Rust programcısı yapar—Hoş geldiniz!</p>
<h3 id="bir-rust-programının-anatomisi"><a class="header" href="#bir-rust-programının-anatomisi">Bir Rust Programının Anatomisi</a></h3>
<p>Hadi sizin “Hello, world!” programınızda nelerin olduğunu detaylıca inceleyelim. Burası yapbozun ilk parçası:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>Bu satırlar Rust'ta bir fonksiyonu tanımlar. <code>main</code> fonksiyonu özel bir fonksiyondur: yürütülebilir her Rust programında çalışan ilk koddur. 
İlk satır, parametresi olmayan ve hiçbir şey döndürmeyen <code>main</code> adlı bir işlev bildirir. Parametreler olsaydı, parametreler parantez <code>()</code> içine girerlerdi.</p>
<p>Ayrıca, fonksiyon gövdesinin <code>{}</code> süslü parantezlerine sarıldığına dikkat edin. Rust'ta bunlar gereklidir. Aralarına bir boşluk ekleyerek, giriş süslü parantezini fonksiyon ile aynı satıra yerleştirmek iyi bir stildir.</p>
<p>Rust projelerinde standart bir stile bağlı kalmak istiyorsanız, kodunuzu belirli bir stille biçimlendirmek için <code>rustfmt</code> adlı otomatik biçimlendirici aracı kullanabilirsiniz. Rust ekibi, bu aracı <code>rustc</code> gibi standart Rust dağıtımına dahil etti, bu nedenle bilgisayarınızda zaten yüklü olmalıdır! Daha fazla ayrıntı için çevrimiçi belgelere bakın.</p>
<p><code>main</code> fonksiyonunun içinde aşağıdaki kod bulunur:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;Hello, world!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Bu satır, bu küçük programdaki tüm işi yapar: metni ekrana yazdırır. Burada dikkat edilmesi gereken dört önemli detay var.</p>
<p>İlk olarak, Rust stili bir TAB karakteriyle değil, dört boşlukla girinti yapar.</p>
<p>İkincisi, <code>println!</code> bir Rust makrosu çağırır. Bunun yerine bir fonksiyon çağırsaydı, 
<code>println</code> olarak girilirdi (<code>!</code> olmadan). Rust makrolarını Bölüm 19'da daha ayrıntılı olarak tartışacağız. Şimdilik, bir <code>!</code> normal bir fonksiyon yerine bir makro çağırdığınız ve makroların her zaman fonksiyonlarla aynı kurallara uymadığı anlamına gelir.</p>
<p>Üçüncüsü, <code>&quot;Hello, world!&quot;</code> dizgisi. Bu dizgiyi <code>println!</code>'e bir argüman olarak iletiyoruz ve dizgi ekrana yazdırılıyor.</p>
<p>Dördüncü olarak, satırı noktalı virgül (<code>;</code>) ile bitiriyoruz, bu karakter ile ifadenin bittiğini ve bir sonrakinin başlamaya hazır olduğunu gösteriyoruz. 
Rust kodunun çoğu satırı noktalı virgülle biter.</p>
<h3 id="derleme-ve-Çalıştırma-ayrı-adımlardır"><a class="header" href="#derleme-ve-Çalıştırma-ayrı-adımlardır">Derleme ve Çalıştırma Ayrı Adımlardır</a></h3>
<p>Az önce yeni oluşturulmuş bir programı çalıştırdınız, bu yüzden süreçteki her adımı inceleyelim. 
Bir Rust programını çalıştırmadan önce, Rust derleyicisini kullanarak, yani <code>rustc</code> komutunu girerek ve 
kaynak dosyanızın adını ona şu şekilde ileterek onu derlemelisiniz:</p>
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<p>C veya C++ geçmişiniz varsa, bunun <code>GCC</code> veya <code>Clang</code>'a benzediğini fark edeceksiniz. Başarılı bir şekilde derlendikten sonra Rust, derlenmiş ve yürütülebilir dosya çıkarır. Linux, macOS ve PowerShell'de (yani Windows'ta), kabuğunuza <code>ls</code> komutunu girerek yürütülebilir dosyayı görebilirsiniz. Linux ve macOS'ta iki dosya göreceksiniz. PowerShell (Windows) ile, CMD kullanarak göreceğiniz aynı üç dosyayı göreceksiniz.</p>
<pre><code class="language-console">$ ls
main  main.rs
</code></pre>
<p>Windows'ta CMD kullanırsanız, şunları göreceksinizdir:</p>
<pre><code class="language-cmd">&gt; dir /B %= /B seçeneği yalnızca dosya adlarını göstermeyi garantiler =%
main.exe
main.pdb
main.rs
</code></pre>
<p>Bu, <code>.rs</code> uzantılı kaynak kod dosyasını, yürütülebilir dosyayı (Windows'ta <code>main.exe</code>, ancak diğer tüm platformlarda <code>main</code>) ve Windows kullananlar için <code>.pdb</code> uzantılı hata ayıklama bilgilerini içeren bir dosyayı gösterir. Buradan <code>main</code> veya <code>main.exe</code> dosyasını şu şekilde çalıştırırsınız:</p>
<pre><code class="language-console">$ ./main # ya da Windows üzerinde .\main.exe şeklinde kullanılabilir
</code></pre>
<p>Eğer derlenmiş <em>main.rs</em>, “Hello, world!” programı ise, çalıştırdığınız zaman <code>Hello, world!</code> çıktısını uçbiriminizde görmüşsünüzdür.</p>
<p>Ruby, Python veya JavaScript gibi dinamik bir dille haşır neşirseniz, bir programı ayrı adımlar olarak derlemeye ve çalıştırmaya alışkın olmayabilirsiniz. Rust <em>derlenmeye ihtiyaç duyan</em> bir dildir, yani bir programı derleyebilir ve yürütülebilir dosyayı başka birine verebilirsiniz ve onlar Rust'u kurmadan bile çalıştırabilirler. Birine <em>.rb</em>, <em>.py</em> veya <em>.js</em> dosyası verirseniz, o kişinin (sırasıyla) bir Ruby, Python veya JavaScript süreklemesine sahip olması gerekir. Ancak bu dillerde, programınızı derlemek ve çalıştırmak için yalnızca bir komuta ihtiyacınız vardır. Dil tasarımında her şey bir değiş tokuştur.</p>
<p>Basit programları <code>rustc</code> kullanarak derlemek hoştur fakat projeniz büyüdükçe kodunuzu kolayca paylaşabilmeniz ve 
yönetebilmeniz için bir yöneticiye ihtiyacınız olacaktır. Sonraki aşamalarda size, siz gerçek-dünya programları yazarken size yardımcı
olacağını düşündüğümüz Cargo aracını tanıtacağız.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="merhaba-cargo"><a class="header" href="#merhaba-cargo">Merhaba, Cargo!</a></h2>
<p>Cargo, Rust'ın yapı sistemi ve paket yöneticisidir. Çoğu Rustsever, Rust projelerini yönetmek için bu aracı kullanır çünkü Cargo, kodunuzu oluşturmak, kodunuzun bağlı olduğu kitaplıkları indirmek ve bu kitaplıkları derlemek gibi birçok görevi sizin yerinize gerçekleştirir. </p>
<p>Şimdiye kadar yazdığımız gibi en basit Rust programlarının herhangi bir bağımlılığı yoktur. Yani “Hello, world!” projeniz Cargo ile oluşturulduğunda, yalnızca Cargo'nun kodunuzu oluşturmayı yöneten bölümünü kullanır. 
Daha karmaşık Rust programları yazdıkça, bağımlılıklar ekleyeceksiniz ve Cargo kullanarak bir projeye başlarsanız, bağımlılıkları eklemek çok daha kolay olacaktır.</p>
<p>Rust projelerinin büyük çoğunluğu Kargo kullandığından, bu kitabın tamamında sizin de Cargo kullandığınız
varsayılır. Eğer resmi yükleyicileri <a href="ch01-01-installation.html#installation">“Yükleme”</a><!-- ignore --> kısmından çekerek çalıştırdıysanız,
Cargp önceden yüklü olarak gelmiş olur. Eğer farklı yollarla Rust'ı yüklediyseniz, Cargo'nun yüklü olup olmadığını şu kodu 
uçbiriminizde çalıştırarak öğrenebilirsiniz:</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>Eğer sürüm numarasını görüyorsanız, zaten yüklüdür! Eğer hata görüyorsanız, mesela <code>komut bulunamadı</code>, yükleme metodunuzun 
dokümantasyonuna bakarak Cargo'yu nasıl ayrı olarak kurabileceğinizi bulabilirsiniz.</p>
<h3 id="cargoyla-proje-oluşturmak"><a class="header" href="#cargoyla-proje-oluşturmak">Cargo'yla Proje Oluşturmak</a></h3>
<p>Hadi Cargo ile yeni proje oluşturalım ve orijinal “Hello, world!” projesiyle olan farklılıklarına bir göz gezdirelim. 
Projelerinizi tuttuğunuz (örneğin <em>projects</em> dizini) dizine ya da kodunuzu tutmak istediğiniz dizinde 
herhangi bir işletim sistemi farklılığı gözetmeksizin şu komutu çalıştırın:</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>İlk komut <em>hello_cargo</em> adında yeni bir dizin oluşturdu. Biz projemize <em>hello_cargo</em> adını vermek istedik ve Cargo 
aynı addaki dizine temel dosyaları oluşturdu. </p>
<p><em>hello_cargo</em> dizinine gidin ve dosyaları listeleyin. Göreceksiniz ki Cargo sizin için
iki tane dosya oluşturmuş: bir <em>Cargo.toml</em> dosyası ve içinde <em>main.rs</em>'i tutan bir <em>src</em> dizini.</p>
<p>Cargo ayrıca yeni bir Git deposunu <em>.gitignore</em> dosyası oluşturmakla beraber başlatır. 
Git dosyaları eğer halihazırda bir Git deposundaysanız <code>cargo new</code> komutuyla oluşturulmaz.
Bu davranışı <code>cargo new --vcs=git</code> komutunu kullanarak değiştirebilirsiniz ve Git dosyaları otomatik olarak oluşturulmuş olur.</p>
<blockquote>
<p>Not: Git yaygın bir versiyon kontrol sistemidir. <code>cargo new</code> komutunu <code>--vcs</code> argümanıyla birlikte 
farklı bir versiyon kontrol sistemiyle ya da VKS (VCS) olmadan da kullanabilirsiniz.
<code>cargo new --help</code> komutunu çalıştırarak seçenekleri görebilirsiniz.</p>
</blockquote>
<p><em>Cargo.toml</em> dosyasını yazı editörünüzle açabilirsiniz. Liste 1-2'dekine benzer bir kodla
karşılaşmanız beklenir.</p>
<p><span class="filename">Dosya adı: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
</code></pre>
<p><span class="caption">Liste 1-2: <em>Cargo.toml</em>'ın içeriği <code>cargo new</code> tarafından oluşturulmuştur</span></p>
<p>Bu dosya, <a href="https://toml.io"><em>TOML</em></a><!-- ignore --> (<em>Tom’un Bariz,
Minimal Dili</em>) Cargo'nun kullandığı dahili konfigürasyon formatıyla oluşturulmuştur.</p>
<p>İlk satır <code>[package]</code>, konu başlığını belirtir. Bu başlık bize üye yapıları hakkında bazı bilgiler 
verir ve onları sınırlandırmamızı sağlar.</p>
<p>Sonraki üç satır Cargo'nun kodunuzu derlemesi için gerekli konfigürasyon bilgilerini içerir: paketinizin adı, sürümü ve hangi
Rust sürümünü kullandığı. <a href="appendix-05-editions.html">Ekleme E</a><!-- ignore -->'de <code>edition</code> anahtarı hakkında daha fazla konuşacağız.</p>
<p>Son satırda <code>[dependencies]</code>, projenizin kullandığı bağımlılıkların bir listesidir. 
Rust'ta, kod paketleri <em>kasalar</em> olarak adlandırılır. Bu basit proje için bir diğer kasaya ihtiyacımız yok fakat
Bölüm 2'de bağımlılıklar konusunu işleyeceğiz.</p>
<p>Şimdi <em>src/main.rs</em> dosyasını açın ve bir bakış atın:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargo sizin için bir “Hello, world!” programı oluşturmuştu aynı Liste 1-1'de yazdığımız gibi!
Çok yakın, eski projemiz ile arasındaki farklardan bazıları: Cargo kodu <em>src</em> dizininde oluşturdu, biz ise kök dizinde oluşturduk. 
Ayrıca biz <em>Cargo.toml</em> şeklinde bir dosya oluşturmadık. </p>
<p>Cargo sizin tüm kaynak dosyalarınızın <em>src</em> dizininde olmasını bekler. Kök dizin daha çok BENİOKU (README) dosyaları, lisans bilgileri,
konfigürasyon dosyaları gibi çeşitli yardımcı elemanlar için kullanılması beklenir. Burada her şey için bir yer var ve her şeyin de 
bir yeri var ve her şey yerli yerinde olmalı.</p>
<p>Cargo kullanmayan “Hello, world!” projenizi Cargo kullanabilir hale getirmek getirmek için tüm kodlarınızı <em>src</em> dizinine taşıyabilir ve <em>Cargo.toml</em> adında bir konfigürasyon dosyası oluşturabilirsiniz.</p>
<h3 id="cargo-projesini-derleme-ve-Çalıştırma"><a class="header" href="#cargo-projesini-derleme-ve-Çalıştırma">Cargo Projesini Derleme ve Çalıştırma</a></h3>
<p>Şimdi “Hello, world!” projesinde neyin farklı olduğunu bulalım! <em>hello_cargo</em> dizininizde, projenizi şu kodla derleyebilirsiniz:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>Bu komut kök dizinde oluşturmak yerine <em>target/debug/hello_cargo</em> dizininde yürütülebilir bir dosya oluşturur (Windows'ta
<em>target\debug\hello_cargo.exe</em> dizininde). Bu dosyayı şu komutla çalıştırabilirsiniz:</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # Windows'ta .\target\debug\hello_cargo.exe komutunu kullanın 
Hello, world!
</code></pre>
<p>Eğer her şey yolunda gitmişse, <code>Hello, world!</code> uçbirimde yazılmış olmalıdır. <code>cargo build</code> komutunu ilk defa çalıştırmak ayrıca kök dizinde <em>Cargo.lock</em> adında bir dosya oluşturur. 
Bu dosya projenizin bağımlılıklarını kayıtta tutar. Tabii bu projenin standart kütüphane hariç herhangi bir bağımlılığı olmadığından
dolayı dosya biraz boş görünebilir. Bu dosyayı elle değiştirmeniz gerekmez, Cargo bunu sizin için otomatik yönetir.</p>
<p><code>cargo build</code> ile derledik ve <code>./target/debug/hello_cargo</code> ile çalıştırdık, ama ayrıca <code>cargo run</code> komutunu da kullanarak
kodu derleyip çalıştırabiliriz:</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Not olarak, eğer kaynak kodunuzu değiştirmediyseniz, Cargo herhangi bir derleme gereksinimi olmadan programınızı çalıştıracaktır.
Eğer kaynak kodunuzu değiştirdiyseniz, Cargo projenizi yeniden derleyecektir ve eğer kodunuz sorunsuz ise şu çıktıyı görmeniz olasıdır:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo ayrıca <code>cargo check</code> adında bir komut sunar. Bu komut kodunuzu hızlıca kontrol 
eder ve onu derlenebilir hale sokar fakat herhangi bir yürütülebilir dosya oluşturmaz:</p>
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>Niye yürütülebilir dosya istenmesin ki? Yaygın olarak, <code>cargo check</code> <code>cargo build</code>'ten daha hızlıdır, 
çünkü yürütülebilir dosya oluşturma kısmını es geçer. Eğer kod yazarken kodunuzu sürekli kontrol ediyorsanız
<code>cargo check</code> kullanmak işlemlerinize hız katacaktır! Ayrıca, çoğu Rustsever <code>cargo check</code> komutunu derleneceğinden
emin olabilmek için sıklıkla çalıştırır. Onlar ayrıca <code>cargo build</code> komutunu her ne zaman proje yürütülebilirliğe hazır olduğu vakit
çalıştırırlar.</p>
<p>Hadi şimdi Cargo ile neler öğrendiğimize yakından bakalım:</p>
<ul>
<li><code>cargo new</code> ile proje oluşturabiliyoruz.</li>
<li><code>cargo build</code> ile proje derleyebiliyoruz.</li>
<li><code>cargo run</code> ile hem derleyip hem çalıştırabiliyoruz.</li>
<li>Yürütülebilir kod oluşturmadan <code>cargo check</code> ile kodumuzu kontrol edebiliyoruz.</li>
<li>Aynı dizinde yürütülebilirleri tutmak yerine Cargo'nun <em>target/debug</em> dizininde
tuttuğunu artık biliyoruz.</li>
</ul>
<p>Ayrıca iyi bir avantaj olaraktan, Cargo her ne işletim sistemini kullanıyorsanız olun aynı komutlara ve işleve sahiptir.
Yani, bu saatten sonra işletim sistemlerine yönelik spesifik talimatlar sunmayacağız.</p>
<h3 id="yayın-için-derlemek"><a class="header" href="#yayın-için-derlemek">Yayın için Derlemek</a></h3>
<p>Her ne zaman projeniz yayınlanmak için hazırsa, <code>cargo build --release</code> komutunu kullanarak
kodunuzu optimizasyonlarla derleyebilirsiniz. Bu komut, yürütülebilir dosyaları <em>target/debug</em> dizini
yerine <em>target/release</em> dizininde tutar. Optimizasyonlar Rust kodunuzu hızlandırır fakat
derlenmesi için gerekli yer ve sürenizi artırır. İşte bu neden iki farklı profil türüne sahip olduğumuzu açıklar. 
Eğer kodunuzun çalıştırılma zamanını merak ediyor ve bunu test etmek istiyorsanız <code>cargo build --release</code> komutuyla
derlediğinizden emin olun.</p>
<h3 id="cargo-hakkında"><a class="header" href="#cargo-hakkında">Cargo Hakkında</a></h3>
<p>Basit projelerde Cargo direkt <code>rustc</code> kullanmanın önüne aşırı yenilikler katmıyor fakat bu halen
kodunuzun büyüdükçe ve karmaşıklaştıkça, farklı farklı kasalarla birlikte kullanıldığında Cargo ile koordine bir 
biçimde derlememenin daha kolay olacağı kanaatine varıyorsunuz.</p>
<p>Hatta <code>hello_cargo</code> projesi basit bir proje olmasına rağmen Rust kariyerinizde her zaman kullanacağınız
önemli araca ev sahipliği yapmış oluyor. Halihazırda var olan projeler üzerinde çalışmak için şu komutla
yerelde bu depoyu tutabilir, depoyu derleyebilirsiniz:</p>
<pre><code class="language-console">$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>Cargo hakkında daha fazla bilgi almak için, kontrol edin <a href="https://doc.rust-lang.org/cargo/">its documentation</a>.</p>
<h2 id="Özet"><a class="header" href="#Özet">Özet</a></h2>
<p>Rust serüveninize iyi bir başlangıç yaptınız! Tüm bu bölümde birçok yeni şey öğrendiniz, bunlardan bazıları:</p>
<ul>
<li><code>rustup</code> ile son stabil sürümü yükleme</li>
<li>En sonki Rust sürümüne güncelleme</li>
<li>Yereldeki dokümantasyonu açma</li>
<li>Direkt <code>rustc</code> komutunu kullanarak “Hello, world!” programı yazıp çalıştırma</li>
<li>Cargo projesi oluşturma ve çalıştırma</li>
</ul>
<p>Okuduklarınız ve yazdıklarınızla daha karmaşık programlar yazmanın tam zamanı. Yani, Bölüm 2'de
bir tahmin oyunu inşa edeceğiz. Eğer daha önceden yaygın programlama kavramlarını öğrenmek istiyorsanız,
Bölüm 3'e bakabilirsiniz ve sonra tekrar Bölüm 2'ye dönebilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programming-a-guessing-game"><a class="header" href="#programming-a-guessing-game">Programming a Guessing Game</a></h1>
<p>Let’s jump into Rust by working through a hands-on project together! This
chapter introduces you to a few common Rust concepts by showing you how to use
them in a real program. You’ll learn about <code>let</code>, <code>match</code>, methods, associated
functions, using external crates, and more! In the following chapters, we’ll
explore these ideas in more detail. In this chapter, you’ll practice the
fundamentals.</p>
<p>We’ll implement a classic beginner programming problem: a guessing game. Here’s
how it works: the program will generate a random integer between 1 and 100. It
will then prompt the player to enter a guess. After a guess is entered, the
program will indicate whether the guess is too low or too high. If the guess is
correct, the game will print a congratulatory message and exit.</p>
<h2 id="setting-up-a-new-project"><a class="header" href="#setting-up-a-new-project">Setting Up a New Project</a></h2>
<p>To set up a new project, go to the <em>projects</em> directory that you created in
Chapter 1 and make a new project using Cargo, like so:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>The first command, <code>cargo new</code>, takes the name of the project (<code>guessing_game</code>)
as the first argument. The second command changes to the new project’s
directory.</p>
<p>Look at the generated <em>Cargo.toml</em> file:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new --name guessing_game no-listing-01-cargo-new
cd no-listing-01-cargo-new
cargo run
-->
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>As you saw in Chapter 1, <code>cargo new</code> generates a “Hello, world!” program for
you. Check out the <em>src/main.rs</em> file:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Now let’s compile this “Hello, world!” program and run it in the same step
using the <code>cargo run</code> command:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>The <code>run</code> command comes in handy when you need to rapidly iterate on a project,
as we’ll do in this game, quickly testing each iteration before moving on to
the next one.</p>
<p>Reopen the <em>src/main.rs</em> file. You’ll be writing all the code in this file.</p>
<h2 id="processing-a-guess"><a class="header" href="#processing-a-guess">Processing a Guess</a></h2>
<p>The first part of the guessing game program will ask for user input, process
that input, and check that the input is in the expected form. To start, we’ll
allow the player to input a guess. Enter the code in Listing 2-1 into
<em>src/main.rs</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {guess}&quot;);
}
</code></pre>
<p><span class="caption">Listing 2-1: Code that gets a guess from the user and
prints it</span></p>
<p>This code contains a lot of information, so let’s go over it line by line. To
obtain user input and then print the result as output, we need to bring the
<code>io</code> input/output library into scope. The <code>io</code> library comes from the
standard library, known as <code>std</code>:</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>By default, Rust has a set of items defined in the standard library that it brings
into the scope of every program. This set is called the <em>prelude</em>, and you can
see everything in it <a href="../std/prelude/index.html">in the standard library documentation</a>.</p>
<p>If a type you want to use isn’t in the prelude, you have to bring that type
into scope explicitly with a <code>use</code> statement. Using the <code>std::io</code> library
provides you with a number of useful features, including the ability to accept
user input.</p>
<p>As you saw in Chapter 1, the <code>main</code> function is the entry point into the
program:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>The <code>fn</code> syntax declares a new function, the parentheses, <code>()</code>, indicate there
are no parameters, and the curly bracket, <code>{</code>, starts the body of the function.</p>
<p>As you also learned in Chapter 1, <code>println!</code> is a macro that prints a string to
the screen:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>This code is printing a prompt stating what the game is and requesting input
from the user.</p>
<h3 id="storing-values-with-variables"><a class="header" href="#storing-values-with-variables">Storing Values with Variables</a></h3>
<p>Next, we’ll create a <em>variable</em> to store the user input, like this:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>Now the program is getting interesting! There’s a lot going on in this little
line. We use the <code>let</code> statement to create the variable. Here’s another example:</p>
<pre><code class="language-rust ignore">let apples = 5;
</code></pre>
<p>This line creates a new variable named <code>apples</code> and binds it to the value 5. In
Rust, variables are immutable by default, meaning once we give the variable a
value, the value won't change. We’ll be discussing this concept in detail in
the <a href="ch03-01-variables-and-mutability.html#variables-and-mutability">“Variables and Mutability”</a><!-- ignore -->
section in Chapter 3. To make a variable mutable, we add <code>mut</code> before the
variable name:</p>
<pre><code class="language-rust ignore">let apples = 5; // immutable
let mut bananas = 5; // mutable
</code></pre>
<blockquote>
<p>Note: The <code>//</code> syntax starts a comment that continues until the end of the
line. Rust ignores everything in comments. We’ll discuss comments in more
detail in <a href="ch03-04-comments.html">Chapter 3</a><!-- ignore -->.</p>
</blockquote>
<p>Returning to the guessing game program, you now know that <code>let mut guess</code> will
introduce a mutable variable named <code>guess</code>. The equal sign (<code>=</code>) tells Rust we
want to bind something to the variable now. On the right of the equals sign is
the value that <code>guess</code> is bound to, which is the result of calling
<code>String::new</code>, a function that returns a new instance of a <code>String</code>.
<a href="../std/string/struct.String.html"><code>String</code></a><!-- ignore --> is a string type provided by the standard
library that is a growable, UTF-8 encoded bit of text.</p>
<p>The <code>::</code> syntax in the <code>::new</code> line indicates that <code>new</code> is an associated
function of the <code>String</code> type. An <em>associated function</em> is a function that’s
implemented on a type, in this case <code>String</code>. This <code>new</code> function creates a
new, empty string. You’ll find a <code>new</code> function on many types, because it’s a
common name for a function that makes a new value of some kind.</p>
<p>In full, the <code>let mut guess = String::new();</code> line has created a mutable
variable that is currently bound to a new, empty instance of a <code>String</code>. Whew!</p>
<h3 id="receiving-user-input"><a class="header" href="#receiving-user-input">Receiving User Input</a></h3>
<p>Recall that we included the input/output functionality from the standard
library with <code>use std::io;</code> on the first line of the program. Now we’ll call
the <code>stdin</code> function from the <code>io</code> module, which will allow us to handle user
input:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>If we hadn’t imported the <code>io</code> library with <code>use std::io</code> at the beginning of
the program, we could still use the function by writing this function call as
<code>std::io::stdin</code>. The <code>stdin</code> function returns an instance of
<a href="../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, which is a type that represents a
handle to the standard input for your terminal.</p>
<p>Next, the line <code>.read_line(&amp;mut guess)</code> calls the <a href="../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!--
ignore --> method on the standard input handle to get input from the user.
We’re also passing <code>&amp;mut guess</code> as the argument to <code>read_line</code> to tell it what
string to store the user input in. The full job of <code>read_line</code> is to take
whatever the user types into standard input and append that into a string
(without overwriting its contents), so we therefore pass that string as an
argument. The string argument needs to be mutable so the method can change the
string’s content.</p>
<p>The <code>&amp;</code> indicates that this argument is a <em>reference</em>, which gives you a way to
let multiple parts of your code access one piece of data without needing to
copy that data into memory multiple times. References are a complex feature,
and one of Rust’s major advantages is how safe and easy it is to use
references. You don’t need to know a lot of those details to finish this
program. For now, all you need to know is that like variables, references are
immutable by default. Hence, you need to write <code>&amp;mut guess</code> rather than
<code>&amp;guess</code> to make it mutable. (Chapter 4 will explain references more
thoroughly.)</p>
<h3 id="handling-potential-failure-with-the-result-type"><a class="header" href="#handling-potential-failure-with-the-result-type">Handling Potential Failure with the <code>Result</code> Type</a></h3>
<p>We’re still working on this line of code. We’re now discussing a third line of
text, but note that it’s still part of a single logical line of code. The next
part is this method:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect(&quot;Failed to read line&quot;);
<span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>We could have written this code as:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);
</code></pre>
<p>However, one long line is difficult to read, so it’s best to divide it. It’s
often wise to introduce a newline and other whitespace to help break up long
lines when you call a method with the <code>.method_name()</code> syntax. Now let’s
discuss what this line does.</p>
<p>As mentioned earlier, <code>read_line</code> puts whatever the user enters into the string
we pass to it, but it also returns a <code>Result</code> value. <a href="../std/result/enum.Result.html"><code>Result</code></a><!--
ignore --> is an <a href="ch06-00-enums.html"><em>enumeration</em></a><!-- ignore -->, often called an <em>enum</em>,
which is a type that can be in one of multiple possible states. We call each
possible state a <em>variant</em>.</p>
<p>Chapter 6 will cover enums in more detail. The purpose of these <code>Result</code> types
is to encode error-handling information.</p>
<p><code>Result</code>'s variants are <code>Ok</code> and <code>Err</code>. The <code>Ok</code> variant indicates the
operation was successful, and inside <code>Ok</code> is the successfully generated value.
The <code>Err</code> variant means the operation failed, and <code>Err</code> contains information
about how or why the operation failed.</p>
<p>Values of the <code>Result</code> type, like values of any type, have methods defined on
them. An instance of <code>Result</code> has an <a href="../std/result/enum.Result.html#method.expect"><code>expect</code> method</a><!-- ignore -->
that you can call. If this instance of <code>Result</code> is an <code>Err</code> value, <code>expect</code>
will cause the program to crash and display the message that you passed as an
argument to <code>expect</code>. If the <code>read_line</code> method returns an <code>Err</code>, it would
likely be the result of an error coming from the underlying operating system.
If this instance of <code>Result</code> is an <code>Ok</code> value, <code>expect</code> will take the return
value that <code>Ok</code> is holding and return just that value to you so you can use it.
In this case, that value is the number of bytes in the user’s input.</p>
<p>If you don’t call <code>expect</code>, the program will compile, but you’ll get a warning:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `guessing_game` (bin &quot;guessing_game&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust warns that you haven’t used the <code>Result</code> value returned from <code>read_line</code>,
indicating that the program hasn’t handled a possible error.</p>
<p>The right way to suppress the warning is to actually write error handling, but
in our case we just want to crash this program when a problem occurs, so we can
use <code>expect</code>. You’ll learn about recovering from errors in <a href="ch09-02-recoverable-errors-with-result.html">Chapter
9</a><!-- ignore -->.</p>
<h3 id="printing-values-with-println-placeholders"><a class="header" href="#printing-values-with-println-placeholders">Printing Values with <code>println!</code> Placeholders</a></h3>
<p>Aside from the closing curly bracket, there’s only one more line to discuss in
the code so far:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>    println!(&quot;You guessed: {guess}&quot;);
<span class="boring">}
</span></code></pre>
<p>This line prints the string that now contains the user’s input. The <code>{}</code> set of
curly brackets is a placeholder: think of <code>{}</code> as little crab pincers that hold
a value in place. You can print more than one value using curly brackets: the
first set of curly brackets holds the first value listed after the format
string, the second set holds the second value, and so on. Printing multiple
values in one call to <code>println!</code> would look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {} and y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>This code would print <code>x = 5 and y = 10</code>.</p>
<h3 id="testing-the-first-part"><a class="header" href="#testing-the-first-part">Testing the First Part</a></h3>
<p>Let’s test the first part of the guessing game. Run it using <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>At this point, the first part of the game is done: we’re getting input from the
keyboard and then printing it.</p>
<h2 id="generating-a-secret-number"><a class="header" href="#generating-a-secret-number">Generating a Secret Number</a></h2>
<p>Next, we need to generate a secret number that the user will try to guess. The
secret number should be different every time so the game is fun to play more
than once. We’ll use a random number between 1 and 100 so the game isn’t too
difficult. Rust doesn’t yet include random number functionality in its standard
library. However, the Rust team does provide a <a href="https://crates.io/crates/rand"><code>rand</code> crate</a> with
said functionality.</p>
<h3 id="using-a-crate-to-get-more-functionality"><a class="header" href="#using-a-crate-to-get-more-functionality">Using a Crate to Get More Functionality</a></h3>
<p>Remember that a crate is a collection of Rust source code files. The project
we’ve been building is a <em>binary crate</em>, which is an executable. The <code>rand</code>
crate is a <em>library crate</em>, which contains code intended to be used in other
programs and can't be executed on its own.</p>
<p>Cargo’s coordination of external crates is where Cargo really shines. Before we
can write code that uses <code>rand</code>, we need to modify the <em>Cargo.toml</em> file to
include the <code>rand</code> crate as a dependency. Open that file now and add the
following line to the bottom beneath the <code>[dependencies]</code> section header that
Cargo created for you. Be sure to specify <code>rand</code> exactly as we have here, with
this version number, or the code examples in this tutorial may not work.</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">rand = &quot;0.8.3&quot;
</code></pre>
<p>In the <em>Cargo.toml</em> file, everything that follows a header is part of that
section that continues until another section starts. In <code>[dependencies]</code> you
tell Cargo which external crates your project depends on and which versions of
those crates you require. In this case, we specify the <code>rand</code> crate with the
semantic version specifier <code>0.8.3</code>. Cargo understands <a href="http://semver.org">Semantic
Versioning</a><!-- ignore --> (sometimes called <em>SemVer</em>), which is a
standard for writing version numbers. The number <code>0.8.3</code> is actually shorthand
for <code>^0.8.3</code>, which means any version that is at least <code>0.8.3</code> but below
<code>0.9.0</code>.</p>
<p>Cargo considers these versions to have public APIs compatible with version
<code>0.8.3</code>, and this specification ensures you’ll get the latest patch release
that will still compile with the code in this chapter. Any version <code>0.9.0</code> or
greater is not guaranteed to have the same API as what the following examples
use.</p>
<p>Now, without changing any of the code, let’s build the project, as shown in
Listing 2-2.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo clean
cargo build -->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  Downloaded getrandom v0.2.2
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.10
  Downloaded rand_chacha v0.3.0
  Downloaded rand_core v0.6.2
   Compiling rand_core v0.6.2
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<p><span class="caption">Listing 2-2: The output from running <code>cargo build</code> after
adding the rand crate as a dependency</span></p>
<p>You may see different version numbers (but they will all be compatible with the
code, thanks to SemVer!), different lines (depending on the operating system),
and the lines may be in a different order.</p>
<p>When we include an external dependency, Cargo fetches the latest versions of
everything that dependency needs from the <em>registry</em>, which is a copy of data
from <a href="https://crates.io/">Crates.io</a>. Crates.io is where people in the Rust ecosystem
post their open source Rust projects for others to use.</p>
<p>After updating the registry, Cargo checks the <code>[dependencies]</code> section and
downloads any crates listed that aren’t already downloaded. In this case,
although we only listed <code>rand</code> as a dependency, Cargo also grabbed other crates
that <code>rand</code> depends on to work. After downloading the crates, Rust compiles
them and then compiles the project with the dependencies available.</p>
<p>If you immediately run <code>cargo build</code> again without making any changes, you
won’t get any output aside from the <code>Finished</code> line. Cargo knows it has already
downloaded and compiled the dependencies, and you haven’t changed anything
about them in your <em>Cargo.toml</em> file. Cargo also knows that you haven’t changed
anything about your code, so it doesn’t recompile that either. With nothing to
do, it simply exits.</p>
<p>If you open up the <em>src/main.rs</em> file, make a trivial change, and then save it
and build again, you’ll only see two lines of output:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>These lines show Cargo only updates the build with your tiny change to the
<em>src/main.rs</em> file. Your dependencies haven’t changed, so Cargo knows it can
reuse what it has already downloaded and compiled for those.</p>
<h4 id="ensuring-reproducible-builds-with-the-cargolock-file"><a class="header" href="#ensuring-reproducible-builds-with-the-cargolock-file">Ensuring Reproducible Builds with the <em>Cargo.lock</em> File</a></h4>
<p>Cargo has a mechanism that ensures you can rebuild the same artifact every time
you or anyone else builds your code: Cargo will use only the versions of the
dependencies you specified until you indicate otherwise. For example, say that
next week version 0.8.4 of the <code>rand</code> crate comes out, and that version
contains an important bug fix, but it also contains a regression that will
break your code. To handle this, Rust creates the <em>Cargo.lock</em> file the first
time you run <code>cargo build</code>, so we now have this in the <em>guessing_game</em>
directory.</p>
<p>When you build a project for the first time, Cargo figures out all the
versions of the dependencies that fit the criteria and then writes them to
the <em>Cargo.lock</em> file. When you build your project in the future, Cargo will
see that the <em>Cargo.lock</em> file exists and use the versions specified there
rather than doing all the work of figuring out versions again. This lets you
have a reproducible build automatically. In other words, your project will
remain at <code>0.8.3</code> until you explicitly upgrade, thanks to the <em>Cargo.lock</em>
file. Because the <em>Cargo.lock</em> file is important for reproducible builds, it's
often checked into source control with the rest of the code in your project.</p>
<h4 id="updating-a-crate-to-get-a-new-version"><a class="header" href="#updating-a-crate-to-get-a-new-version">Updating a Crate to Get a New Version</a></h4>
<p>When you <em>do</em> want to update a crate, Cargo provides the command <code>update</code>,
which will ignore the <em>Cargo.lock</em> file and figure out all the latest versions
that fit your specifications in <em>Cargo.toml</em>. Cargo will then write those
versions to the <em>Cargo.lock</em> file. Otherwise, by default, Cargo will only look
for versions greater than <code>0.8.3</code> and less than <code>0.9.0</code>. If the <code>rand</code> crate
has released the two new versions <code>0.8.4</code> and <code>0.9.0</code> you would see the
following if you ran <code>cargo update</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -&gt; v0.8.4
</code></pre>
<p>Cargo ignores the <code>0.9.0</code> release. At this point, you would also notice a
change in your <em>Cargo.lock</em> file noting that the version of the <code>rand</code> crate
you are now using is <code>0.8.4</code>. To use <code>rand</code> version <code>0.9.0</code> or any version in
the <code>0.9.x</code> series, you’d have to update the <em>Cargo.toml</em> file to look like
this instead:</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.9.0&quot;
</code></pre>
<p>The next time you run <code>cargo build</code>, Cargo will update the registry of crates
available and reevaluate your <code>rand</code> requirements according to the new version
you have specified.</p>
<p>There’s a lot more to say about <a href="http://doc.crates.io">Cargo</a><!-- ignore --> and <a href="http://doc.crates.io/crates-io.html">its
ecosystem</a><!-- ignore --> which we’ll discuss in Chapter 14, but
for now, that’s all you need to know. Cargo makes it very easy to reuse
libraries, so Rustaceans are able to write smaller projects that are assembled
from a number of packages.</p>
<h3 id="generating-a-random-number"><a class="header" href="#generating-a-random-number">Generating a Random Number</a></h3>
<p>Let’s start using <code>rand</code> to generate a number to guess. The next step is to
update <em>src/main.rs</em>, as shown in Listing 2-3.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!(&quot;The secret number is: {secret_number}&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {guess}&quot;);
}
</code></pre>
<p><span class="caption">Listing 2-3: Adding code to generate a random
number</span></p>
<p>First, we add the line <code>use rand::Rng</code>. The <code>Rng</code> trait defines methods that
random number generators implement, and this trait must be in scope for us to
use those methods. Chapter 10 will cover traits in detail.</p>
<p>Next, we’re adding two lines in the middle. In the first line, we call the
<code>rand::thread_rng</code> function that gives us the particular random number
generator that we’re going to use: one that is local to the current thread of
execution and seeded by the operating system. Then we call the <code>gen_range</code>
method on the random number generator. This method is defined by the <code>Rng</code>
trait that we brought into scope with the <code>use rand::Rng</code> statement. The
<code>gen_range</code> method takes a range expression as an argument and generates a
random number in the range. The kind of range expression we’re using here takes
the form <code>start..=end</code> and is inclusive on the lower and upper bounds, so we
need to specify <code>1..=100</code> to request a number between 1 and 100.</p>
<blockquote>
<p>Note: You won’t just know which traits to use and which methods and functions
to call from a crate, so each crate has documentation with instructions for
using it. Another neat feature of Cargo is that running the <code>cargo doc --open</code> command will build documentation provided by all of your dependencies
locally and open it in your browser. If you’re interested in other
functionality in the <code>rand</code> crate, for example, run <code>cargo doc --open</code> and
click <code>rand</code> in the sidebar on the left.</p>
</blockquote>
<p>The second new line prints the secret number. This is useful while we’re
developing the program to be able to test it, but we’ll delete it from the
final version. It’s not much of a game if the program prints the answer as soon
as it starts!</p>
<p>Try running the program a few times:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>You should get different random numbers, and they should all be numbers between
1 and 100. Great job!</p>
<h2 id="comparing-the-guess-to-the-secret-number"><a class="header" href="#comparing-the-guess-to-the-secret-number">Comparing the Guess to the Secret Number</a></h2>
<p>Now that we have user input and a random number, we can compare them. That step
is shown in Listing 2-4. Note that this code won’t compile quite yet, as we
will explain.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span>
    println!(&quot;You guessed: {guess}&quot;);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p><span class="caption">Listing 2-4: Handling the possible return values of
comparing two numbers</span></p>
<p>First we add another <code>use</code> statement, bringing a type called
<code>std::cmp::Ordering</code> into scope from the standard library. The <code>Ordering</code> type
is another enum and has the variants <code>Less</code>, <code>Greater</code>, and <code>Equal</code>. These are
the three outcomes that are possible when you compare two values.</p>
<p>Then we add five new lines at the bottom that use the <code>Ordering</code> type. The
<code>cmp</code> method compares two values and can be called on anything that can be
compared. It takes a reference to whatever you want to compare with: here it’s
comparing the <code>guess</code> to the <code>secret_number</code>. Then it returns a variant of the
<code>Ordering</code> enum we brought into scope with the <code>use</code> statement. We use a
<a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> expression to decide what to do next based on
which variant of <code>Ordering</code> was returned from the call to <code>cmp</code> with the values
in <code>guess</code> and <code>secret_number</code>.</p>
<p>A <code>match</code> expression is made up of <em>arms</em>. An arm consists of a <em>pattern</em> to
match against, and the code that should be run if the value given to <code>match</code>
fits that arm’s pattern. Rust takes the value given to <code>match</code> and looks
through each arm’s pattern in turn. Patterns and the <code>match</code> construct are
powerful Rust features that let you express a variety of situations your code
might encounter and make sure that you handle them all. These features will be
covered in detail in Chapter 6 and Chapter 18, respectively.</p>
<p>Let’s walk through an example with the <code>match</code> expression we use here. Say that
the user has guessed 50 and the randomly generated secret number this time is
38. When the code compares 50 to 38, the <code>cmp</code> method will return
<code>Ordering::Greater</code>, because 50 is greater than 38. The <code>match</code> expression gets
the <code>Ordering::Greater</code> value and starts checking each arm’s pattern. It looks
at the first arm’s pattern, <code>Ordering::Less</code>, and sees that the value
<code>Ordering::Greater</code> does not match <code>Ordering::Less</code>, so it ignores the code in
that arm and moves to the next arm. The next arm’s pattern is
<code>Ordering::Greater</code>, which <em>does</em> match <code>Ordering::Greater</code>! The associated
code in that arm will execute and print <code>Too big!</code> to the screen. The <code>match</code>
expression ends after the first successful match, so it won’t look at the last
arm in this scenario.</p>
<p>However, the code in Listing 2-4 won’t compile yet. Let’s try it:</p>
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`

error[E0283]: type annotations needed for `{integer}`
   --&gt; src/main.rs:8:44
    |
8   |     let secret_number = rand::thread_rng().gen_range(1..=100);
    |         -------------                      ^^^^^^^^^ cannot infer type for type `{integer}`
    |         |
    |         consider giving `secret_number` a type
    |
    = note: multiple `impl`s satisfying `{integer}: SampleUniform` found in the `rand` crate:
            - impl SampleUniform for i128;
            - impl SampleUniform for i16;
            - impl SampleUniform for i32;
            - impl SampleUniform for i64;
            and 8 more
note: required by a bound in `gen_range`
   --&gt; /Users/carolnichols/.cargo/registry/src/github.com-1ecc6299db9ec823/rand-0.8.3/src/rng.rs:129:12
    |
129 |         T: SampleUniform,
    |            ^^^^^^^^^^^^^ required by this bound in `gen_range`
help: consider specifying the type arguments in the function call
    |
8   |     let secret_number = rand::thread_rng().gen_range::&lt;T, R&gt;(1..=100);
    |                                                     ++++++++

Some errors have detailed explanations: E0283, E0308.
For more information about an error, try `rustc --explain E0283`.
error: could not compile `guessing_game` due to 2 previous errors
</code></pre>
<p>The core of the error states that there are <em>mismatched types</em>. Rust has a
strong, static type system. However, it also has type inference. When we wrote
<code>let mut guess = String::new()</code>, Rust was able to infer that <code>guess</code> should be
a <code>String</code> and didn’t make us write the type. The <code>secret_number</code>, on the other
hand, is a number type. A few of Rust’s number types can have a value between 1
and 100: <code>i32</code>, a 32-bit number; <code>u32</code>, an unsigned 32-bit number; <code>i64</code>, a
64-bit number; as well as others. Unless otherwise specified, Rust defaults to
an <code>i32</code>, which is the type of <code>secret_number</code> unless you add type information
elsewhere that would cause Rust to infer a different numerical type. The reason
for the error is that Rust cannot compare a string and a number type.</p>
<p>Ultimately, we want to convert the <code>String</code> the program reads as input into a
real number type so we can compare it numerically to the secret number. We do so
by adding this line to the <code>main</code> function body:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span>    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {guess}&quot;);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
<span class="boring">}
</span></code></pre>
<p>The line is:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</code></pre>
<p>We create a variable named <code>guess</code>. But wait, doesn’t the program already have
a variable named <code>guess</code>? It does, but helpfully Rust allows us to <em>shadow</em> the
previous value of <code>guess</code> with a new one. Shadowing lets us reuse the <code>guess</code>
variable name rather than forcing us to create two unique variables, such as
<code>guess_str</code> and <code>guess</code> for example. We’ll cover this in more detail in Chapter
3, but for now know that this feature is often used when you want to convert a
value from one type to another type.</p>
<p>We bind this new variable to the expression <code>guess.trim().parse()</code>. The <code>guess</code>
in the expression refers to the original <code>guess</code> variable that contained the
input as a string. The <code>trim</code> method on a <code>String</code> instance will eliminate any
whitespace at the beginning and end, which we must do to be able to compare the
string to the <code>u32</code>, which can only contain numerical data. The user must press
<span class="keystroke">enter</span> to satisfy <code>read_line</code> and input their
guess, which adds a newline character to the string. For example, if the user
types <span class="keystroke">5</span> and presses <span
class="keystroke">enter</span>, <code>guess</code> looks like this: <code>5\n</code>. The <code>\n</code>
represents “newline”. (On Windows, pressing <span
class="keystroke">enter</span> results in a carriage return and a newline,
<code>\r\n</code>). The <code>trim</code> method eliminates <code>\n</code> or <code>\r\n</code>, resulting in just <code>5</code>.</p>
<p>The <a href="../std/primitive.str.html#method.parse"><code>parse</code> method on strings</a><!-- ignore --> converts a string to
another type. Here, we use it to convert from a string to a number. We need to
tell Rust the exact number type we want by using <code>let guess: u32</code>. The colon
(<code>:</code>) after <code>guess</code> tells Rust we’ll annotate the variable’s type. Rust has a
few built-in number types; the <code>u32</code> seen here is an unsigned, 32-bit integer.
It’s a good default choice for a small positive number. You’ll learn about
other number types in Chapter 3. Additionally, the <code>u32</code> annotation in this
example program and the comparison with <code>secret_number</code> means that Rust will
infer that <code>secret_number</code> should be a <code>u32</code> as well. So now the comparison
will be between two values of the same type!</p>
<p>The <code>parse</code> method will only work on characters that can logically be converted
into numbers and so can easily cause errors. If, for example, the string
contained <code>A👍%</code>, there would be no way to convert that to a number. Because it
might fail, the <code>parse</code> method returns a <code>Result</code> type, much as the <code>read_line</code>
method does (discussed earlier in <a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">“Handling Potential Failure with the
<code>Result</code> Type”</a><!-- ignore
-->). We’ll treat this <code>Result</code> the same way by using the <code>expect</code> method
again. If <code>parse</code> returns an <code>Err</code> <code>Result</code> variant because it couldn’t create
a number from the string, the <code>expect</code> call will crash the game and print the
message we give it. If <code>parse</code> can successfully convert the string to a number,
it will return the <code>Ok</code> variant of <code>Result</code>, and <code>expect</code> will return the
number that we want from the <code>Ok</code> value.</p>
<p>Let’s run the program now!</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>Nice! Even though spaces were added before the guess, the program still figured
out that the user guessed 76. Run the program a few times to verify the
different behavior with different kinds of input: guess the number correctly,
guess a number that is too high, and guess a number that is too low.</p>
<p>We have most of the game working now, but the user can make only one guess.
Let’s change that by adding a loop!</p>
<h2 id="allowing-multiple-guesses-with-looping"><a class="header" href="#allowing-multiple-guesses-with-looping">Allowing Multiple Guesses with Looping</a></h2>
<p>The <code>loop</code> keyword creates an infinite loop. We’ll add a loop to give users
more chances at guessing the number:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --snip--

    println!(&quot;The secret number is: {secret_number}&quot;);

    loop {
        println!(&quot;Please input your guess.&quot;);

        // --snip--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; println!(&quot;You win!&quot;),
        }
    }
}
</code></pre>
<p>As you can see, we’ve moved everything from the guess input prompt onward into
a loop. Be sure to indent the lines inside the loop another four spaces each
and run the program again. The program will now ask for another guess forever,
which actually introduces a new problem. It doesn’t seem like the user can quit!</p>
<p>The user could always interrupt the program by using the keyboard shortcut
<span class="keystroke">ctrl-c</span>. But there’s another way to escape this
insatiable monster, as mentioned in the <code>parse</code> discussion in <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“Comparing the
Guess to the Secret Number”</a><!--
ignore -->: if the user enters a non-number answer, the program will crash. We
can take advantage of that to allow the user to quit, as shown here:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Typing <code>quit</code> will quit the game, but as you’ll notice so will entering any
other non-number input. This is suboptimal to say the least; we want the game
to also stop when the correct number is guessed.</p>
<h3 id="quitting-after-a-correct-guess"><a class="header" href="#quitting-after-a-correct-guess">Quitting After a Correct Guess</a></h3>
<p>Let’s program the game to quit when the user wins by adding a <code>break</code> statement:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span>        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Adding the <code>break</code> line after <code>You win!</code> makes the program exit the loop when
the user guesses the secret number correctly. Exiting the loop also means
exiting the program, because the loop is the last part of <code>main</code>.</p>
<h3 id="handling-invalid-input"><a class="header" href="#handling-invalid-input">Handling Invalid Input</a></h3>
<p>To further refine the game’s behavior, rather than crashing the program when
the user inputs a non-number, let’s make the game ignore a non-number so the
user can continue guessing. We can do that by altering the line where <code>guess</code>
is converted from a <code>String</code> to a <code>u32</code>, as shown in Listing 2-5.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {guess}&quot;);

        // --snip--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 2-5: Ignoring a non-number guess and asking for
another guess instead of crashing the program</span></p>
<p>We switch from an <code>expect</code> call to a <code>match</code> expression to move from crashing
on an error to handling the error. Remember that <code>parse</code> returns a <code>Result</code>
type and <code>Result</code> is an enum that has the variants <code>Ok</code> and <code>Err</code>. We’re using
a <code>match</code> expression here, as we did with the <code>Ordering</code> result of the <code>cmp</code>
method.</p>
<p>If <code>parse</code> is able to successfully turn the string into a number, it will
return an <code>Ok</code> value that contains the resulting number. That <code>Ok</code> value will
match the first arm’s pattern, and the <code>match</code> expression will just return the
<code>num</code> value that <code>parse</code> produced and put inside the <code>Ok</code> value. That number
will end up right where we want it in the new <code>guess</code> variable we’re creating.</p>
<p>If <code>parse</code> is <em>not</em> able to turn the string into a number, it will return an
<code>Err</code> value that contains more information about the error. The <code>Err</code> value
does not match the <code>Ok(num)</code> pattern in the first <code>match</code> arm, but it does
match the <code>Err(_)</code> pattern in the second arm. The underscore, <code>_</code>, is a
catchall value; in this example, we’re saying we want to match all <code>Err</code>
values, no matter what information they have inside them. So the program will
execute the second arm’s code, <code>continue</code>, which tells the program to go to the
next iteration of the <code>loop</code> and ask for another guess. So, effectively, the
program ignores all errors that <code>parse</code> might encounter!</p>
<p>Now everything in the program should work as expected. Let’s try it:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>Awesome! With one tiny final tweak, we will finish the guessing game. Recall
that the program is still printing the secret number. That worked well for
testing, but it ruins the game. Let’s delete the <code>println!</code> that outputs the
secret number. Listing 2-6 shows the final code.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {guess}&quot;);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listing 2-6: Complete guessing game code</span></p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>At this point, you’ve successfully built the guessing game. Congratulations!</p>
<p>This project was a hands-on way to introduce you to many new Rust concepts:
<code>let</code>, <code>match</code>, functions, the use of external crates, and more. In the next
few chapters, you’ll learn about these concepts in more detail. Chapter 3
covers concepts that most programming languages have, such as variables, data
types, and functions, and shows how to use them in Rust. Chapter 4 explores
ownership, a feature that makes Rust different from other languages. Chapter 5
discusses structs and method syntax, and Chapter 6 explains how enums work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yaygın-programlama-kavramları"><a class="header" href="#yaygın-programlama-kavramları">Yaygın Programlama Kavramları</a></h1>
<p>Bu bölüm, hemen hemen her programlama dilinde görünen kavramları ve bunların Rust'ta nasıl çalıştığını kapsar. 
Birçok programlama dilinin özünde çokça ortak nokta vardır. Bu bölümde sunulan kavramların hiçbiri Rust'a özgü değildir, ancak bunları Rust bağlamında tartışacağız ve bu kavramların kullanımına ilişkin kuralları açıklayacağız. 
Özellikle değişkenler, temel türler, fonksiyonlar, yorum satırları ve kontrol akışı hakkında bilgi edineceksiniz. 
Bu temeller her Rust programında yer alacaktır ve bunları erkenden öğrenmek size başlangıç için güçlü bir temel sağlayacaktır. </p>
<blockquote>
<h4 id="anahtar-sözcükler"><a class="header" href="#anahtar-sözcükler">Anahtar Sözcükler</a></h4>
<p>Rust dilinde, diğer dillerde olduğu gibi, yalnızca dil tarafından kullanılmak üzere ayrılmış bir dizi anahtar sözcük vardır.
Bu kelimeleri değişken veya fonksiyon adı olarak kullanamayacağınızı unutmayın. Anahtar kelimelerin çoğunun özel anlamları vardır ve 
bunları Rust programlarınızda çeşitli görevleri yapmak için kullanacaksınız; birkaçının kendileriyle ilişkili mevcut bir işlevi yoktur, 
ancak gelecekte Rust'a eklenebilecek işlevsellik için ayrılmıştır. Anahtar kelimelerin bir listesini <a href="appendix-01-keywords.html">Ekleme A</a><!-- ignore -->'da bulabilirsiniz.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="değişkenler-ve-değişkenlik"><a class="header" href="#değişkenler-ve-değişkenlik">Değişkenler ve Değişkenlik</a></h2>
<p><a href="ch02-00-guessing-game-tutorial.html#storing-values-with-variables">“Değişkenlerle Değerleri Saklama”</a><!-- ignore --> bölümünde belirtildiği gibi, varsayılan olarak değişkenler değişmezdir. Bu, Rust'ın size sunduğu güvenlik ve kolay eşzamanlılıktan yararlanarak kodunuzu yazmanız için size verdiği birçok dürtüden biridir. Ancak yine de değişkenlerinizi değiştirilebilir yapma seçeneğiniz vardır. Rust'ın sizi değişmezliği tercih etmeye nasıl ve neden teşvik ettiğini ve bazen neden vazgeçmek isteyebileceğinizi keşfedelim.</p>
<p>Bir değişken değişmez olduğunda, bir değer bir ada bağlandıktan sonra bu değeri değiştiremezsiniz. Bunu örneklemek için, <code>cargo new variables</code>
komutunu kullanarak <em>proje dizininizde</em> <em>variables</em> adında yeni bir proje oluşturalım.</p>
<p>Ardından, yeni <em>variables</em> dizininizde bulunan <em>src/main.rs</em> dosyasını açın ve kodunu aşağıdaki kodla değiştirin. 
Bu kod henüz derlenmeyecek, bundan dolayı önce değişmezlik hatasını inceleyeceğiz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {x}&quot;);
    x = 6;
    println!(&quot;The value of x is: {x}&quot;);
}
</code></pre>
<p><code>cargo run</code> komutunu kullanarak programı kaydedin ve çalıştırın. 
Bu çıktıda gösterildiği gibi bir hata mesajı almalısınız:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!(&quot;The value of x is: {x}&quot;);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
</code></pre>
<p>Bu örnek, derleyicinin programlarınızdaki hataları bulmanıza nasıl yardımcı olduğunu gösterir.
Derleyici hataları can sıkıcı olabilir, ancak gerçekte bunlar yalnızca programınızın henüz yapmak istediğiniz 
şeyi güvenli bir şekilde yapmadığı anlamına gelir; iyi bir programcı olmadığınız anlamına gelmezler! 
Deneyimli Rustseverler hala derleyici hataları alıyor.</p>
<p>Hata mesajı, hatanın nedeninin, değişmez <code>x</code> değişkenine ikinci bir değer atamaya çalıştığınız 
için değişmez &quot;x&quot; değişkenine ikinci kez atayamamanız olduğunu gösterir.</p>
<p>Değişmez olarak belirlenmiş bir değeri değiştirmeye çalıştığımızda derleme zamanı hataları almamız önemlidir çünkü bu durum hatalara yol açabilir. Kodumuzun bir kısmı, bir değerin asla değişmeyeceği varsayımıyla çalışıyorsa ve kodumuzun başka bir kısmı bu değeri değiştiriyorsa, kodun ilk kısmının tasarlandığı şeyi yapmaması olasıdır. Bu tür bir hatanın nedenini, özellikle ikinci kod parçası değeri yalnızca bazen değiştirdiğinde, olaydan sonra bulmak zor olabilir. Rust derleyicisi, bir değerin değişmeyeceğini belirttiğinizde, gerçekten değişmeyeceğini garanti eder, bu nedenle onu kendiniz takip etmek zorunda kalmazsınız. Bu nedenle kodunuzun akıl yürütmesi daha kolaydır.</p>
<p>Ancak değişebilirlik çok faydalı olabilir ve kod yazmayı daha uygun hale getirebilir. Değişkenler yalnızca varsayılan olarak değişmezdir; Bölüm 2'de yaptığınız gibi, değişken adının önüne <code>mut</code> ekleyerek bunları değiştirilebilir yapabilirsiniz. <code>mut</code> eklemek ayrıca kodun diğer bölümlerinin bu değişkenin değerini değiştireceğini belirterek kodun gelecekteki okuyucularına niyet iletir.</p>
<p>Örneğin, <em>src/main.rs</em>'yi aşağıdaki şekilde değiştirelim:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {x}&quot;);
    x = 6;
    println!(&quot;The value of x is: {x}&quot;);
}
</code></pre></pre>
<p>Programı şimdi çalıştırdığımızda şunu görürüz:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
</code></pre>
<p><code>mut</code> kullanıldığında <code>x</code>'e bağlı değeri <code>5</code>'ten <code>6</code>'ya değiştirmemize izin verilir. 
Nihayetinde, <code>mut</code> kullanıp kullanmamaya karar vermek size bağlıdır.</p>
<h3 id="sabitler"><a class="header" href="#sabitler">Sabitler</a></h3>
<p>Değişmez değişkenler gibi, 
<em>sabitler</em> de bir ada bağlı ve değişmesine izin verilmeyen değerlerdir, 
ancak sabitler ve değişkenler arasında birkaç fark vardır.</p>
<p>İlk olarak, <code>mut</code>'u sabitlerle kullanamazsınız. 
Sabitler yalnızca varsayılan olarak değişmez değildir, 
her zaman değişmezdirler. Sabitleri <code>let</code> anahtar sözcüğü yerine <code>const</code> anahtar sözcüğünü kullanarak bildirirsiniz 
ve değerin türü verilmiş olmalıdır. 
Bir sonraki <a href="ch03-02-data-types.html#data-types">“Veri Türleri”</a><!-- ignore --> bölümünde türleri ve tür ek açıklamalarını ele alacağız, 
bu nedenle şu anda ayrıntılar için endişelenmeyin. Her zaman türe değer vermeniz gerektiğini bilin. 
Sabitler, <code>global</code> kapsam da dahil olmak üzere herhangi bir kapsamda bildirilebilir, bu da onları kodun birçok bölümünün bilmesi gereken değerler için faydalı kılar. Son fark olarak, sabitlerin çalışma zamanında hesaplanabilecek bir değerin sonucu olarak değil, 
yalnızca sabit bir ifadeye ayarlanabilmesidir. İşte bir sabit bildirim örneği:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}
</span></code></pre></pre>
<p>Sabitin adı <code>THREE_HOURS_IN_SECONDS</code>'dır ve değeri 60 (bir dakikadaki saniye sayısı) ile 60 (bir saatteki dakika sayısı) ile 3 (bu programda saymak istediğimiz saat sayısı) çarpılmasının sonucuna ayarlanır. Rust'ın sabitler için adlandırma kuralı, sözcükler arasında alt çizgi ile tüm büyük harfleri kullanmaktır. Derleyici, derleme zamanında sınırlı bir dizi işlemi değerlendirebilir; 
bu, bu sabiti 10,800 değerine ayarlamak yerine, bu değeri anlaşılması ve doğrulanması daha kolay bir şekilde yazmayı seçmemize olanak tanır. 
Sabitleri bildirirken hangi işlemlerin kullanılabileceği hakkında daha fazla bilgi için <a href="../reference/const_eval.html">Rust Reference’ın sabitleri hesaplama</a> bölümüne bakın. Sabitler, bir programın çalıştığı tüm süre boyunca, bildirildikleri kapsam dahilinde geçerlidir. Bu özellik, sabitleri, uygulama etki alanınızdaki, herhangi bir maksimum nokta sayısı gibi, programın birden fazla bölümünün bilmesi gerekebilecek değerler için kullanışlı hale getirir. 
Programınız boyunca kullanılan sabit kodlanmış değerleri sabitler olarak adlandırmak, bu değerin anlamını kodun gelecekteki koruyucularına iletmede faydalıdır. Ayrıca, gelecekte sabit kodlanmış değerin güncellenmesi gerekiyorsa değiştirmeniz gereken kodunuzun yalnızca bir bölümü olacaktır.</p>
<h3 id="gölgeleme"><a class="header" href="#gölgeleme">Gölgeleme</a></h3>
<p><a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">Bölüm 2</a><!-- ignore -->'deki tahmin oyununda gördüğünüz gibi, önceki değişkenle aynı ada sahip yeni bir değişken bildirebilirsiniz. Rustseverler, ilk değişkenin ikinci tarafından <em>gölgelendiğini</em> söylüyor, bu da ikinci değişkenin, değişkenin adını kullandığınızda derleyicinin göreceği şey olduğu anlamına geliyor. Gerçekte, ikinci değişken birinciyi <em>gölgede</em> bırakır ve değişken adının herhangi bir kullanımını kendisi gölgelenene veya kapsam sona erene kadar kendisine alır. Aynı değişkenin adını kullanarak ve <code>let</code> anahtar sözcüğünü aşağıdaki gibi tekrarlayarak bir değişkeni gölgeleyebiliriz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!(&quot;The value of x in the inner scope is: {x}&quot;);
    }

    println!(&quot;The value of x is: {x}&quot;);
}
</code></pre></pre>
<p>Bu program önce <code>x</code>'e <code>5</code> değerini atar, sonra <code>let x =</code>'i tekrar ederek, orijinal değeri alıp <code>1</code> ekleyerek yeni bir <code>x</code> değişkeni oluşturur, 
böylece <code>x</code> değeri <code>6</code> olur. Parantez içindeki üçüncü <code>let</code> ifadesi de <code>x</code>'i gölgeler ve <code>x</code>'e <code>12</code> değerini vermek için 
önceki değeri <code>2</code> ile çarparak yeni bir değişken oluşturur. Bu kapsam sona erdiğinde, iç gölgeleme sona erer ve <code>x</code>, <code>6</code>'ya döner. Bu programı çalıştırdığımızda, aşağıdaki çıktıyı verecektir:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
</code></pre>
<p>Gölgeleme, bir değişkeni <code>mut</code> olarak işaretlemekten farklıdır çünkü <code>let</code> anahtar sözcüğünü kullanmadan 
yanlışlıkla bu değişkene yeniden atamaya çalışırsak derleme zamanı hatası alırız. <code>let</code> kullanarak, bir değer üzerinde birkaç dönüşüm gerçekleştirebiliriz, ancak bu dönüşümler tamamlandıktan sonra değişkenin değişmez olmasını sağlayabiliriz.</p>
<p><code>mut</code> ve shadowing arasındaki diğer fark, <code>let</code> anahtar sözcüğünü tekrar kullandığımızda etkin bir şekilde yeni bir değişken oluşturduğumuz için, 
değerin türünü değiştirebilir ancak aynı adı yeniden kullanabiliriz. 
Örneğin, programımızın bir kullanıcıdan boşluk karakterleri girerek bazı metinler arasında kaç boşluk istediğini göstermesini istediğini ve ardından bu girişi bir sayı olarak saklamak istediğimizi varsayalım:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let spaces = &quot;   &quot;;
    let spaces = spaces.len();
<span class="boring">}
</span></code></pre></pre>
<p>İlk <code>spaces</code> değişkeni bir dize türüdür ve ikinci <code>spaces</code> değişkeni bir sayı türüdür. 
Böylece gölgeleme, bizi <code>space_str</code> ve <code>space_num</code> gibi farklı isimler kullanmaktan kurtarır; bunun yerine, daha basitçe <code>spaces</code> adını yeniden kullanabiliriz. Ancak, burada gösterildiği gibi bunun için <code>mut</code> kullanmaya çalışırsak, bir derleme zamanı hatası alırız:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut spaces = &quot;   &quot;;
    spaces = spaces.len();
<span class="boring">}
</span></code></pre>
<p>Hata, bu değişkenin türünü değiştirmemize izin verilmediğini söylüyor:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut spaces = &quot;   &quot;;
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` due to previous error
</code></pre>
<p>Artık değişkenlerin nasıl çalıştığını anladığımıza göre, 
sahip olabilecekleri daha fazla veri türüne bakalım.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="veri-türleri"><a class="header" href="#veri-türleri">Veri Türleri</a></h2>
<p>Rust'taki her değer, 
Rust'a bu verilerle nasıl çalışacağını bilmesi için ne tür verilerin belirtildiğini söyleyen belirli bir veri türündendir. İki veri türü alt kümesine bakacağız: skaler ve bileşik. </p>
<p>Rust'ın <em>statik yazılmış</em> bir dil olduğunu unutmayın; bu, derleme zamanında tüm değişkenlerin türlerini bilmesi gerektiği anlamına gelir. Derleyici genellikle değere ve onu nasıl kullandığımıza bağlı olarak ne tür kullanmak istediğimizi çıkarabilir. 
Birçok türün mümkün olduğu durumlarda, örneğin Bölüm 2'deki <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“Tahminle Gizli Numarayı Karşılaştırma”</a><!-- ignore --> bölümünde <code>parse</code>'ı kullanarak bir <code>String</code>'i sayısal bir türe dönüştürdüğümüzde, aşağıdaki gibi bir tür ek açıklaması eklemeliyiz:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Yukarıdaki gibi <code>: u32</code> tipini eklemezsek, Rust aşağıdaki hatayı döndürür, 
bu da derleyicinin hangi türü kullanmak istediğimizi bilmesi için bizden daha fazla bilgiye ihtiyacı olduğu anlamına gelir:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^ consider giving `guess` a type

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
</code></pre>
<p>Diğer veri türleri için farklı tür ek açıklamaları göreceksiniz.</p>
<h3 id="skaler-tipler"><a class="header" href="#skaler-tipler">Skaler Tipler</a></h3>
<p>Bir <em>skaler</em> tip, tek bir değeri temsil eder. 
Rust'ın dört birincil skaler türü vardır: 
tamsayılar, kayan noktalı sayılar, Boole'ler ve karakterler. 
Bunları diğer programlama dillerinden tanıyabilirsiniz. Hadi Rust'ta nasıl çalıştıklarına geçelim.</p>
<h4 id="tam-sayı-türleri"><a class="header" href="#tam-sayı-türleri">Tam Sayı Türleri</a></h4>
<p>Tam sayı, kesirli bileşeni olmayan bir sayıdır. 
Bölüm 2'de bir tam sayı türü olan <code>u32</code> türü kullandık. Bu tür bildirimi, ilişkilendirildiği değerin 32 bit yer kaplayan işaretsiz bir tam sayı (işaretli tamsayı türleri <code>u</code> yerine <code>i</code> ile başlar) olması gerektiğini belirtir. 
Tablo 3-1, Rust'taki yerleşik tam sayı türlerini gösterir. Bir tam sayı değerinin türünü bildirmek için bu değişkenlerden herhangi birini kullanabiliriz. </p>
<p><span class="caption">Tablo 3-1: Rust'ta Tam Sayı Türleri</span></p>
<table><thead><tr><th>Büyüklüğü</th><th>İşaretli</th><th>İşaretsiz</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>(mimariye bağlı)</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<p>Her varyant işaretli veya işaretsiz olabilir ve açık bir boyutu vardır. 
<em>İşaretli</em> ve <em>işaretsiz</em>, sayının negatif olmasının mümkün olup olmadığına - başka bir deyişle, sayının onunla bir işareti olması gerekip gerekmediğine (işaretli) veya yalnızca pozitif olup olmayacağına ve bu nedenle işaretsiz temsil edilip edilemeyeceğine (işaretsiz) atıfta bulunur. Kağıda sayılar yazmak gibidir: işaret önemli olduğunda, bir sayı artı veya eksi işaretiyle gösterilir; ancak, sayının pozitif olduğunu varsaymak güvenli olduğunda, işaretsiz olarak gösterilir. İşaretli sayılar, <a href="https://en.wikipedia.org/wiki/Two%27s_complement">ikinin tümleyen gösterimi</a><!-- ignore --> 
kullanılarak saklanır. </p>
<p>Her işaretli varyant -(2<sup>n - 1</sup>) ile 2<sup>n - 1</sup> - 1 arasındaki sayıları saklayabilir; 
burada n, varyantın kullandığı bit sayısıdır.</p>
<p>Böylece bir <code>i8</code>, -(2<sup>7</sup>) ile 2<sup>7</sup> - 1 arasındaki sayıları saklayabilir, bu da -128 ile 127'ye eşittir. 
İşaretsiz değişkenler 0 ile 2<sup>n</sup> - 1 arasındaki sayıları saklayabilir, dolayısıyla bir <code>u8</code> 0 ile 2<sup>8</sup> - 1 arasındaki sayıları saklayabilir, bu da 0 ila 255'e eşittir. </p>
<p>Ek olarak, <code>isize</code> ve <code>usize</code>, programınızın üzerinde çalıştığı bilgisayarın mimarisine bağlıdır; bu, tabloda “arch” olarak gösterilir: 
64 bit mimarideyseniz 64 bit; 32 bit eğer 32 bit mimarideyseniz. Tam sayı değişmezlerini Tablo 3-2'de gösterilen herhangi bir biçimde yazabilirsiniz. 
Birden çok sayısal tür olabilen sayı değişmezlerinin, <code>57u8</code> gibi bir tür son ekinin türü belirlemesine izin verdiğini unutmayın. 
Sayı değişmezleri, <code>1000</code> şeklinde belirttiğiniz gibi aynı değere sahip olacak <code>1_000</code> gibi sayının okunmasını kolaylaştırmak için görsel ayırıcı olarak <code>_</code>'yi de kullanabilir.</p>
<p><span class="caption">Tablo 3-2: Rust'ta Tamsayı Değişmezlerit</span></p>
<table><thead><tr><th>Sayı değişmezleri</th><th>Örnek</th></tr></thead><tbody>
<tr><td>Ondalıklı</td><td><code>98_222</code></td></tr>
<tr><td>On altılık tabanda</td><td><code>0xff</code></td></tr>
<tr><td>Sekizlik tabanda</td><td><code>0o77</code></td></tr>
<tr><td>İkilik tabanda</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Bit (sadece <code>u8</code> türü için)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<p>Peki hangi tamsayı türünü kullanacağınızı nasıl bileceksiniz? 
Emin değilseniz, Rust'ın varsayılanları genellikle başlamak için iyi yerlerdir: 
tam sayı türleri varsayılan olarak <code>i32</code>'dir. <code>isize</code> veya <code>usize</code> kullandığınız birincil durum, bir tür koleksiyonu dizine eklerken olur.</p>
<blockquote>
<h5 id="tam-sayı-taşması"><a class="header" href="#tam-sayı-taşması">Tam sayı taşması</a></h5>
<p>Diyelim ki 0 ile 255 arasında değerler tutabilen <code>u8</code> tipinde bir değişkeniniz var. 
Değişkeni bu aralığın dışında, örneğin 256 gibi bir değerle değiştirmeye çalışırsanız, <em>tam sayı taşması</em> meydana gelir ve 
bu iki davranıştan biriyle sonuçlanabilir. Hata ayıklama modunda derleme yaparken; Rust, 
bu davranış ortaya çıkarsa programınızın çalışma zamanında panik yapmasına neden olan <em>tam sayı taşması</em> için bazı kontroller içerir. 
Rust, bir program bir hatayla çıktığında panikleme terimini kullanır; <a href="ch09-01-unrecoverable-errors-with-panic.html">“<code>panic!</code>'le Kurtarılamayan Hatalar”</a><!-- ignore -->  bölümünde panikleri daha derinlemesine tartışacağız. 
<code>--release</code> bayrağıyla yayın modunda derlediğinizde, Rust paniklere neden olan <em>tam sayı taşması</em> denetimlerini içermez. 
Bunun yerine, taşma meydana gelirse, Rust iki tamamlayıcı sarmayı gerçekleştirir. Kısacası, türün tutabileceği maksimum değerden daha büyük 
değerler, türün tutabileceği değerlerin minimumuna &quot;sarılır&quot;. Bir <code>u8</code> durumunda, 256 değeri 0 olur, 257 değeri 1 olur ve bu böyle devam eder. 
Program paniğe kapılmaz, ancak değişken muhtemelen beklediğiniz değerde olmayan bir değere sahip olacaktır. <em>Tam sayı taşmasının</em> sarma davranışına 
güvenmek bir hata olarak kabul edilir. </p>
<p>Taşma olasılığını açıkça ele almak için, ilkel sayı türleri için standart kütüphane tarafından sağlanan bu metodları kullanabilirsiniz:</p>
<ul>
<li><code>wrapping_add</code> gibi <code>wrapping_*</code> metodlarını kullanabilirsiniz</li>
<li><code>checked_*</code> yöntemlerinde taşma varsa <code>None</code> değerini döndürebilirsiniz</li>
<li><code>overflowing_*</code> yöntemleriyle taşma olup olmadığını gösteren değeri Boole olarak döndürebilirsiniz</li>
<li><code>saturating_*</code> yöntemleri ile değerin minimum veya maksimum değerlerinde 'doyurun' </li>
</ul>
</blockquote>
<h4 id="kayan-nokta-türleri"><a class="header" href="#kayan-nokta-türleri">Kayan Nokta Türleri</a></h4>
<p>Rust ayrıca ondalık basamaklı sayılar olan <em>kayan noktalı sayılar</em> için iki temel türe sahiptir. 
Rust'ın kayan nokta türleri, sırasıyla 32 bit ve 64 bit boyutunda olan <code>f32</code> ve <code>f64</code>'tür. 
Varsayılan tür <code>f64</code>'tür çünkü modern CPU'larda kabaca <code>f32</code> ile aynı hızdadır ancak daha fazla hassasiyete sahiptir. 
Tüm kayan nokta türleri işaretlidir. </p>
<p>İşte kayan noktalı sayılarını çalışırken gösteren bir örnek:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>Kayan nokta sayıları, <em>IEEE-754 standardına</em> göre tanımlanmıştır. <code>f32</code> türü tek duyarlıklı bir kayan noktadır 
ve <code>f64</code> çift duyarlıklıdır.</p>
<h4 id="sayısal-İşlemler"><a class="header" href="#sayısal-İşlemler">Sayısal İşlemler</a></h4>
<p>Rust, tüm sayı türleri için beklediğiniz temel matematiksel işlemleri destekler: 
toplama, çıkarma, çarpma, bölme ve kalan. </p>
<p>Tam sayı bölümü en yakın tam sayıya yuvarlar. </p>
<p>Aşağıdaki kod, bir <code>let</code> ifadesinde her bir sayısal işlemi nasıl kullanacağınızı gösterir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0

    // remainder
    let remainder = 43 % 5;
}
</code></pre></pre>
<p>Bu ifadelerdeki her ifade bir matematiksel operatör kullanır ve daha sonra bir değişkene bağlanan tek bir değer olarak değerlendirilir. 
<a href="appendix-02-operators.html">Ekleme B</a><!-- ignore -->, Rust'ın sağladığı tüm operatörlerin bir listesini içerir.</p>
<h4 id="boole-türü"><a class="header" href="#boole-türü">Boole Türü</a></h4>
<p>Diğer programlama dillerinin çoğunda olduğu gibi, Rust'ta da bir Boole türünün iki olası değeri vardır: 
<code>true</code> ve <code>false</code>. Boole'ların boyutu bir bayttır. Rust'taki Boole türü <code>bool</code> kullanılarak belirtilir. </p>
<p>Örneğin:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
</code></pre></pre>
<p>Boole değerlerini kullanmanın ana yolu, <code>if</code> ifadesi gibi koşullu ifadelerdir. 
Rust'ta ifadelerin nasıl çalışacağını <a href="ch03-05-control-flow.html#control-flow">“Kontrol Akışı”</a><!-- ignore --> bölümünde ele alacağız.</p>
<h4 id="karakter-türü"><a class="header" href="#karakter-türü">Karakter Türü</a></h4>
<p>Rust'ın <code>char</code> türü, dilin en temel alfabetik türüdür. </p>
<p>Aşağıda, <code>char</code> değerlerinin bildirilmesine ilişkin bazı örnekler verilmiştir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // with explicit type annotation
    let heart_eyed_cat = '😻';
}
</code></pre></pre>
<p>Çift tırnak kullanan dize değişmezlerinin aksine, 
tek tırnaklı <code>char</code> değişmezlerini belirttiğimize dikkat edin. 
Rust'ın <code>char</code> türü, dört bayt boyutundadır ve bir Unicode Skaler Değerini temsil eder; 
bu, yalnızca ASCII'den çok daha fazlasını temsil edebileceği anlamına gelir. </p>
<p>Aksanlı harfler; Çince, Japonca ve Korece karakterler; emoji; ve sıfır genişlikli boşlukların tümü Rust'taki geçerli karakter değerleridir. </p>
<p>Unicode Skaler Değerleri, <code>U+0000</code> ile <code>U+D7FF</code> ve <code>U+E000</code> ile <code>U+10FFFF</code> dahil arasında değişir. 
Bununla birlikte, bir <code>char</code>, Unicode'da gerçekten bir kavram değildir, bu nedenle, bir “karakterin” ne olduğuna ilişkin insan sezginiz, 
Rust'ta bir karakterin ne olduğu ile eşleşmeyebilir. Bu konuyu Bölüm 8'deki <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">“UTF-8 Kodlu Metinleri Dizgilerde Depolama”</a><!-- ignore --> bölümünde ayrıntılı olarak tartışacağız.</p>
<h3 id="bileşik-türler"><a class="header" href="#bileşik-türler">Bileşik Türler</a></h3>
<p><em>Bileşik türler</em> birden çok değeri tek bir türde gruplayabilir. 
Rust'ın iki temel bileşik türü vardır: demetler ve diziler.</p>
<h4 id="demet-türü"><a class="header" href="#demet-türü">Demet Türü</a></h4>
<p>Demet, çeşitli türlere sahip bir dizi değeri tek bir bileşik türde gruplandırmanın genel bir yoludur. 
Demetlerin sabit bir uzunluğu vardır: bir kez bildirildiğinde, boyut olarak büyüyemez veya küçülemezler.</p>
<p>Parantez içinde virgülle ayrılmış bir değerler listesi yazarak bir demet oluşturuyoruz. 
Tanımlama grubundaki her konumun bir türü vardır ve tanımlama grubundaki farklı değerlerin türlerinin aynı olması gerekmez.
Bu örnekte isteğe bağlı tür ek açıklamaları ekledik:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p>Değişken <code>tup</code>'a bütün bir demet atanır, çünkü bir demet tek bir bileşik eleman olarak kabul edilir. 
Bir tanımlama grubundan tek tek değerleri elde etmek için, bir tanımlama grubunu yok etmek için <em>model eşleştirmeyi</em> kullanabiliriz, 
bunun gibi:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {y}&quot;);
}
</code></pre></pre>
<p>Bu program önce bir tanımlama grubu oluşturur ve onu <code>tup</code> değişkenine atar. Daha sonra <code>let</code> <code>tup</code>'u alıp onu <code>x</code>, <code>y</code> ve <code>z</code> 
olmak üzere üç ayrı değişkene dönüştüren bir model kullanır. Buna <em>yıkım</em> denir, çünkü tek demeti üç parçaya böler. 
Son olarak, program <code>y</code>'nin <code>6.4</code> değerini yazdırır.</p>
<p>Ayrıca, bir nokta (<code>.</code>) ve ardından erişmek istediğimiz değerin sırasını (indeksini) kullanarak bir 
tanımlama grubu öğesine doğrudan erişebiliriz. </p>
<p>Örneğin:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<p>Bu program, <code>x</code> demetini oluşturur ve ardından ilgili dizinleri kullanarak grubun her bir öğesine erişir. 
Çoğu programlama dilinde olduğu gibi, bir demet içindeki ilk sıra 0'dır.</p>
<p>Herhangi bir değeri olmayan demetin özel bir adı vardır, birim. Bu değer ve buna karşılık gelen tür yazılır <code>()</code> 
ve boş bir değeri veya boş bir dönüş türünü temsil eder. 
İfadeler, başka bir değer döndürmezlerse örtük olarak birim değerini döndürür.</p>
<h4 id="dizi-türü"><a class="header" href="#dizi-türü">Dizi Türü</a></h4>
<p>Birden çok değerden oluşan bir koleksiyona sahip olmanın başka bir yolu da dizi kullanmaktır. 
Demetlerden farklı olarak, bir dizinin her elemanı aynı tipte olmalıdır. 
Diğer bazı dillerdeki dizilerin aksine, Rust'taki dizilerin sabit bir uzunluğu vardır.</p>
<p>Bir dizideki değerleri köşeli parantezler içinde virgülle ayrılmış bir liste olarak yazıyoruz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>Diziler, verilerinizin yığın yerine yığına atanmasını istediğinizde (yığın (stack) ve yığıtı (heap) <a href="ch04-01-what-is-ownership.html#the-stack-and-the-heap">Bölüm 4</a><!-- ignore -->'te daha fazla tartışacağız) veya her zaman sabit sayıda öğeye sahip olduğunuzdan emin olmak istediğinizde yararlıdır. 
Yine de bir dizi, vektör türü kadar esnek değildir. 
Vektör, standart kütüphane tarafından sağlanan ve boyutunun büyümesine veya küçülmesine izin verilen benzer bir koleksiyon türüdür. 
Dizi mi yoksa vektör mü kullanacağınızdan emin değilseniz, büyük olasılıkla bir vektör kullanmalısınız. <a href="ch08-01-vectors.html">Bölüm 8</a><!-- ignore -->, vektörleri daha ayrıntılı olarak tartışır.</p>
<p>Ancak diziler, eleman sayısının değişmesi gerekmediğini bildiğiniz zaman daha kullanışlıdır.
Örneğin, bir programda ayın adlarını kullanıyor olsaydınız, her zaman 12 öğe içereceğini bildiğiniz için vektör yerine muhtemelen bir dizi kullanırdınız:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
<span class="boring">}
</span></code></pre></pre>
<p>Her öğenin türü, noktalı virgül ve ardından dizideki öğelerin sayısıyla birlikte köşeli
parantezler kullanarak bir dizinin türünü yazarsınız, şöyle:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Burada <code>i32</code>, her bir elemanın tipidir. 
Noktalı virgülden sonraki <code>5</code> sayısı, dizinin beş eleman içerdiğini gösterir.</p>
<p>Ayrıca, burada gösterildiği gibi ilk değeri, ardından noktalı virgül ve
ardından dizinin uzunluğunu köşeli parantez içinde belirterek her öğe için aynı değeri içerecek bir dizi tanımlayabilirsiniz:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<p><code>a</code> adlı dizi, tümü başlangıçta <code>3</code> değerine ayarlanacak <code>5</code> öğe içerecektir. Bu, <code>let a = [3, 3, 3, 3, 3];</code> ile aynıdır
fakat daha yalındır.</p>
<h5 id="dizi-Öğelerine-erişim"><a class="header" href="#dizi-Öğelerine-erişim">Dizi Öğelerine Erişim</a></h5>
<p>Dizi, yığına ayrılabilen, bilinen, sabit boyuttaki tek bir bellek yığınıdır. 
Dizinin öğelerine aşağıdaki gibi dizin oluşturmayı kullanarak erişebilirsiniz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre></pre>
<p>Bu örnekte, <code>first</code> olarak adlandırılan değişken <code>1</code> değerini alacaktır, çünkü bu, dizideki <code>[0]</code> dizinindeki değerdir. 
<code>second</code> adlı değişken, dizideki <code>[1]</code> dizininden <code>2</code> değerini alacaktır.</p>
<h5 id="geçersiz-dizi-Öğesine-erişmek"><a class="header" href="#geçersiz-dizi-Öğesine-erişmek">Geçersiz Dizi Öğesine Erişmek</a></h5>
<p>Dizinin sonunu aşan bir dizinin bir öğesine erişmeye çalışırsanız ne olacağını birlikte görelim. 
Kullanıcıdan bir dizi sırası almak için Bölüm 2'deki tahmin oyununa benzer şekilde 
bu kodu çalıştırdığınızı varsayalım:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!(&quot;Please enter an array index.&quot;);

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect(&quot;Failed to read line&quot;);

    let index: usize = index
        .trim()
        .parse()
        .expect(&quot;Index entered was not a number&quot;);

    let element = a[index];

    println!(&quot;The value of the element at index {index} is: {element}&quot;);
}
</code></pre>
<p>Bu kod başarıyla derlenir. Bu kodu <code>cargo run</code> komutunu kullanarak çalıştırırsanız ve girdi olarak
0, 1, 2, 3 veya 4 girerseniz, program dizideki o sırada karşılık gelen değeri yazdıracaktır.
Bunun yerine, 10 gibi; dizinin sonunu aşan bir sayı girerseniz, şöyle bir çıktı görürsünüz:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Program, <em>sırasına koyma</em> (indeksleme) işleminde geçersiz bir değer kullanma noktasında 
bir <em>çalışma zamanı hatasıyla</em> sonuçlandı. Program bir hata mesajıyla çıktı ve son eklenen <code>println</code>'i çalıştırmadı! 
Sırasına koyma işlemini kullanarak bir elemana erişmeye çalıştığınızda Rust, 
belirttiğiniz sıranın dizi uzunluğundan küçük olup olmadığını kontrol eder. Sıra, uzunluktan büyük veya ona eşitse, 
Rust panikleyecektir. Bu kontrol, özellikle bu durumda ve bu kodda, çalışma zamanında yapılmalıdır, çünkü derleyici, 
bir kullanıcının kodu daha sonra çalıştırdığında hangi değeri gireceğini muhtemelen bilemez.</p>
<p>Bu, Rust'ın bellek güvenliği ilkelerinin uygulamadaki bir örneğidir. 
Birçok düşük seviyeli dilde bu tür bir kontrol yapılmaz ve yanlış bir sıra verdiğinizde geçersiz hafızaya erişilebilir. 
Rust, belleğe erişime izin vermek ve devam etmek yerine hemen çıkarak sizi bu tür hatalara karşı korur. </p>
<p>Bölüm 9, Rust'ın hata işlemesini ve panik yaratmayan veya geçersiz bellek erişimine izin vermeyen okunabilir, güvenli kodu nasıl yazabileceğinizi daha fazla tartışıyor olacak.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fonksiyonlar"><a class="header" href="#fonksiyonlar">Fonksiyonlar</a></h2>
<p>Fonksiyonlar Rust kodunda sıklıkla kullanılır. 
Dildeki en önemli fonksiyonlardan birini zaten gördünüz: 
birçok programın giriş noktası olan <code>main</code> fonksiyonu. 
Ayrıca, yeni fonksiyonlar tanımlamanızı sağlayan <code>fn</code> anahtar sözcüğünü de gördünüz.</p>
<p>Rust kodu, tüm harflerin küçük olduğu ve ayrı sözcüklerin altını çizdiği, 
fonksiyon ve değişken adları için geleneksel stil olan <em>yılan stilini</em> kullanır. </p>
<p>Örnek bir fonksiyon tanımı içeren bir program:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Another function.&quot;);
}
</code></pre></pre>
<p>Rust'ta <code>fn</code> ve ardından bir fonksiyon adı ve bir parantez dizisi girerek bir fonksiyon tanımlarız. 
Parantezler derleyiciye fonksiyon argüman gövdesinin nerede başlayıp nerede bittiğini söyler.</p>
<p>Tanımladığımız herhangi bir fonksiyonu, adını ve ardından bir parantez dizisini girerek çağırabiliriz. 
Programda <code>another_function</code> tanımlı olduğundan, <code>main</code> fonksiyonu içinden çağrılabilir. 
Kaynak kodda ana fonksiyondan <em>sonra</em> <code>another_function</code>'u tanımladığımızı unutmayın; 
daha önce de tanımlayabilirdik. Rust, fonksiyonlarınızı nerede tanımladığınızla ilgilenmez, 
yalnızca arayanın görebileceği bir kapsamda bir yerde tanımlanmalarını ister. Kapsam dışı fonksiyonları geleneksel
yöntemle çağıramazsınız.</p>
<p>İşlevleri daha fazla keşfetmek için <em>functions</em> adında yeni bir proje başlatalım. 
<code>other_function</code> örneğini <em>src/main.rs</em> içine atın ve çalıştırın. 
Aşağıdaki çıktıyı görmelisiniz:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Another function.
</code></pre>
<p>Satırlar, ana fonksiyonda göründükleri sırayla yürütülür. 
İlk olarak, “Hello, world!” ekrana yazdırılır ve ardından <code>another_function</code> fonksiyonu
çağrılır ve belirtilen parametrelerle birlikte yürütülür.</p>
<h3 id="parametreler"><a class="header" href="#parametreler">Parametreler</a></h3>
<p>Fonksiyonları, bir fonksiyonun yapısının parçası olan özel değişkenler 
olan <em>parametrelere</em> sahip olacak şekilde tanımlayabiliriz. 
Bir fonksiyonun parametreleri olduğunda, ona bu parametreler için somut değerler sağlayabilirsiniz. 
Teknik olarak somut değerlere <em>argümanlar</em> denir, ancak gündelik konuşmalarda insanlar 
<em>parametre</em> ve <em>argüman</em> kelimelerini bir fonksiyonun tanımındaki değişkenler veya 
bir fonksiyonu çağırdığınızda iletilen somut değerler için birbirinin yerine kullanma eğilimindedir.</p>
<p><code>another_function</code>'un bu sürümünde bir parametre ekliyoruz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;The value of x is: {x}&quot;);
}
</code></pre></pre>
<p>Şimdi bu kodu çalıştırmaya çalışın; şu çıktıyı almalısınız:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p><code>another_function</code> tanımı, <code>x</code> adında bir parametreye sahiptir. 
<code>x</code>'in tipi <code>i32</code> olarak belirtilmiştir. 
<code>5</code>'i <code>another_function</code> fonksiyonuna parametre olarak verdiğimizde, 
<code>println!</code> makrosu, <code>x</code>'i içeren parametre listesinde <code>x</code> yerine <code>5</code>'i koyar.</p>
<p>Fonksiyon yapılarında, her parametrenin türünü belirtmelisiniz. 
Bu, Rust'ın tasarımında bilinçli olarak verilmiş bir karardır: fonksiyon tanımlarında tip açıklamalarının zorunluluğu, 
derleyicinin, ne türü istediğinizi anlamak için kodun başka bir yerinde bu tarz yaygın tür tanımlarını 
kullanmanıza neredeyse hiç ihtiyaç duymadığı anlamına gelir. Derleyici, fonksiyonun ne tür beklediğini biliyorsa, 
daha yararlı hata mesajları da verebilir.</p>
<p>Birden çok parametre tanımlarken, parametre bildirimlerini aşağıdaki gibi virgülle ayırın:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!(&quot;The measurement is: {value}{unit_label}&quot;);
}
</code></pre></pre>
<p>Bu örnek, iki parametreli <code>print_labeled_measurement</code> adlı bir fonksiyon oluşturur. 
İlk parametre <code>value</code> olarak adlandırılmıştır ve türü <code>i32</code>'dir. 
İkincisi, <code>unit_label</code> olarak adlandırılmıştır ve <code>char</code> türündendir. 
Fonksiyon hem <code>value</code> hem de <code>unit_label</code>'in değerini içeren metni ekrana yazdırır.</p>
<p>Bu kodu çalıştırmayı deneyelim. 
<em>functions</em> klasörünüzün <em>src/main.rs</em> dosyasındaki mevcut programı önceki 
örnekle değiştirin ve <code>cargo run</code> komutunu kullanarak çalıştırın:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The measurement is: 5h
</code></pre>
<p>Fonksiyonu <code>value</code>'nin değeri <code>5</code> ve <code>unit_label</code>'in değeri <code>'h'</code> olacak şekilde 
çağırdığımız için program çıktısı bu değerleri içerecektir.</p>
<h3 id="İfade-yapıları-ve-İfadeler"><a class="header" href="#İfade-yapıları-ve-İfadeler">İfade Yapıları ve İfadeler</a></h3>
<p>Fonksiyon gövdeleri, 
isteğe bağlı olarak ifade yapılarıyla biten bir dizi ifadeden oluşur. 
Şimdiye kadar ele aldığımız fonksiyonlar bir bitiş ifadesi içermemişti, 
ancak bir ifade yapısının parçası olarak ifadeler görmüştünüz. 
Rust ifade tabanlı bir dil olduğundan, bu anlaşılması gereken önemli bir ayrımdır. 
Diğer diller aynı ayrımlara sahip değildir, o halde şimdi ifade yapılarının ve ifadelerin ne olduğuna ve 
farklılıklarının fonksiyon gövdelerini nasıl etkilediğine bakalım.</p>
<p><em>İfade yapıları</em>, bazı eylemleri gerçekleştiren ve bir değer döndürmeyen talimatlardır. 
<em>İfadeler</em> bir sonuç değeri olarak değerlendirilir. Bazı örneklere bakalım.</p>
<p>Aslında zaten ifade yapılarını ve ifadeleri kullandık. 
<code>let</code> anahtar sözcüğü ile bir değişken oluşturmak ve ona bir değer atamak 
bir ifade yapısıdır. Liste 3-1'deki <code>let y = 6;</code> bir ifade yapısıdır.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<p><span class="caption">Liste 3-1: Bir ifade yapısı içeren <code>main</code> fonksiyonu tanımı</span></p>
<p>Fonksiyon tanımları da ayrıca ifade yapıları olarak değerlendirilir. 
Önceki örneğin tamamı kendi içinde bir ifade yapısıdır.</p>
<p>İfade yapıları herhangi bir değer döndürmez. Statements do not return values. Buna göre, 
<code>let</code> ifade yapısıyla başka bir değeri halihazırda tanımlanmış bir değerle eşitleyemezsiniz.
Bunu denerseniz, şu hatayı alacaksınızdır:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>Bu programı çalıştırırsanız, şuna benzer bir hata alacaksınızdır:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement

error[E0658]: `let` expressions in this position are experimental
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information
  = help: you can write `matches!(&lt;expr&gt;, &lt;pattern&gt;)` instead of `let &lt;pattern&gt; = &lt;expr&gt;`

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  | 

For more information about this error, try `rustc --explain E0658`.
warning: `functions` (bin &quot;functions&quot;) generated 1 warning
error: could not compile `functions` due to 2 previous errors; 1 warning emitted
</code></pre>
<p><code>let y = 6</code> ifade yapısı bir değer döndürmez, 
dolayısıyla <code>x</code>'e atanacak bir şey yoktur. 
Bu, atamanın; atanan değeri döndürdüğü C ve Ruby gibi diğer dillerden farklıdır. 
Bu dillerde <code>x = y = 6</code> yazabilir ve hem <code>x</code> hem de <code>y</code>'nin <code>6</code> değerine sahip olmasını sağlayabilirsiniz; 
ancak Rust'ta durum böyle değil.</p>
<p>İfadeler bir değer olarak değerlendirilir ve Rust'ta yazacağınız kodun geri kalanının çoğunu oluşturur. 
<code>11</code> değerini veren bir ifade olan <code>5 + 6</code> gibi bir matematik işlemini düşünün. 
İfadeler ifade yapılarının bir parçası olabilir: 
Liste 3-1'de, <code>let y = 6</code> ifade yapısındaki <code>6</code>; <code>6</code> değerini <code>y</code>'ye veren bir ifadedir. 
Bir fonksiyonu çağırmak bir ifadedir. 
Makro çağırmak bir ifadedir. Parantezlerle oluşturulan bir kapsam bloğu bir ifadedir, örneğin:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;The value of y is: {y}&quot;);
}
</code></pre></pre>
<p>Bu ifade:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<p>bu durumda <code>4</code> olarak değerlendirilen bir bloktur. 
Bu değer, <code>let</code> ifade yapısının bir parçası olarak <code>y</code>'ye atanır. 
Şu ana kadar gördüğünüz çoğu satırın aksine <code>x + 1</code> satırının sonunda noktalı virgül bulunmadığına dikkat edin. 
İfadeler en sona noktalı virgül eklenmesini gerektirmez. 
Bir ifadenin sonuna noktalı virgül eklerseniz, onu bir ifade yapısına dönüştürürsünüz ve o, bir değer döndürmeyecektir. 
Bir sonraki başlığımız olacak olan fonksiyon dönüş değerlerini 
ve ifadelerini keşfederken bunu aklınızda bulundurun.</p>
<h3 id="dönüş-değerleri-olan-fonksiyonlar"><a class="header" href="#dönüş-değerleri-olan-fonksiyonlar">Dönüş Değerleri Olan Fonksiyonlar</a></h3>
<p>Fonksiyonlar, onları çağıran koda değerler döndürebilir. 
Dönüş değerlerini adlandırmıyoruz, ancak türlerini bir oktan (<code>-&gt;</code>) sonra bildirmeliyiz. 
Rust'ta, fonksiyonun dönüş değeri, bir fonksiyonun gövdesinin bloğundaki son ifadenin değeri ile eş anlamlıdır. 
<code>return</code> anahtar sözcüğünü kullanarak ve ona bir değer belirterek bir fonksiyondan erken dönebilirsiniz, 
ancak çoğu fonksiyon son ifadeyi örtük yapıda döndürür. Değer döndüren bir fonksiyon örneği:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;The value of x is: {x}&quot;);
}
</code></pre></pre>
<p><code>five</code> fonksiyonunda hiçbir fonksiyon çağrısı, 
makro ve hatta <code>let</code> ifade yapısı yoktur; 
yalnızca <code>5</code> sayısı tek başınadır. Bu, Rust'ta tamamen geçerli bir fonksiyondur. 
Fonksiyon dönüş türünün de <code>-&gt; i32</code> olarak belirtildiğine dikkat edin. </p>
<p>Bu kodu çalıştırmayı deneyin -hatasız çalışmalıdır-, çıktı şöyle görünmelidir:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p><code>five</code>'ın içindeki <code>5</code>, fonksiyonun dönüş değeridir, 
bu nedenle fonksiyonun dönüş türü <code>i32</code>'dir. 
Bunu daha detaylı inceleyelim. İki önemli yer vardır: birincisi, <code>let x = five();</code> satırı bir değişkeni başlatmak için bir fonksiyonun
dönüş değerini kullandığımızı gösterir. <code>five</code> fonksiyonu <code>5</code> döndürdüğünden, bu satır aşağıdakiyle tamamen aynıdır:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>Ayrıca, <code>five</code> fonksiyonunda parametre yoktur ve dönüş değerinin türünü tanımlayan herhangi bir ifade yoktur, 
ancak işlevin gövdesi, değerini döndürmek istediğimiz bir ifade olduğu için noktalı virgül içermez. Yalnızca 
<code>5</code> yazabiliriz.</p>
<p>Başka bir daha örneğe bakalım:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {x}&quot;);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<p>Bu kodu çalıştırmak bize <code>The value of x is: 6</code> çıktısını verecektir. 
Ancak <code>x + 1</code>'i içeren satırın sonuna noktalı virgül koyarsak, 
onu bir ifadeden bir ifade yapısına çevirmiş oluruz ve bir hata alırız.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {x}&quot;);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>Bu kodun derlenmesi aşağıdaki gibi bir hata üretir:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` due to previous error
</code></pre>
<p>Hata mesajı, “uyumsuz türler“ bu kodla ilgili temel sorunu ortaya koymaktadır. 
<code>plus_one</code> fonksiyonunun tanımı, bir <code>i32</code> döndüreceğini söyler, 
ancak ifade yapısı <code>()</code> ile ifade edilen bir değer olarak değerlendirilmez. İstenilen şey <code>i32</code> türünde döndürmektir,
bir ifade yapısının döndürdüğü gibi <code>()</code>'i döndürmek değildir.
Bu nedenle, fonksiyon tanımıyla çelişen ve bir hatayla sonuçlanan hiçbir şey döndürülmemiş olur. 
Bu çıktıda Rust, muhtemelen bu sorunun düzeltilmesine yardımcı olacak bir mesaj gösterir: 
Rust, noktalı virgülün kaldırılmasını önerir, bu da hatayı düzeltir.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="yorum-satırları"><a class="header" href="#yorum-satırları">Yorum Satırları</a></h2>
<p>Tüm programcılar, kodlarının anlaşılmasını kolaylaştırmak için çaba gösterir,
ancak bazen ek açıklamalar gerekir. Bu durumlarda, programcılar kaynak kodlarında derleyicinin görmezden geleceği yorum satırları bırakırlar. 
Bunları kaynak kodu okuyan insanlar faydalı bulabilir. </p>
<p>İşte basit bir yorum satırı:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Merhaba, Dünya!
<span class="boring">}
</span></code></pre></pre>
<p>Rust'ta, deyimsel yorum stili bir yoruma iki eğik çizgi ile başlar ve yorum satırın sonuna kadar devam eder. 
Tek bir satırın ötesine geçen yorumlar için, her satıra <code>//</code> eklemeniz gerekir, örneğin:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Yani burada karmaşık şeyler yapıyoruz sanki, bu kadar uzun
// ve satırlarca süren bir yorum satırı ancak karışık
// fonksiyonlar içindir diye düşünmeliyim gibime geliyor
<span class="boring">}
</span></code></pre></pre>
<p>Yorum satırları ayrıca kodunuzun sonuna da konabilir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}
</code></pre></pre>
<p>Ancak, bunların şu biçimde kullanıldığını daha sık göreceksiniz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
}
</code></pre></pre>
<p>Rust'ın ayrıca, Bölüm 14'ün &quot;Bir Kasayı Crates.io'da Yayınlamak&quot; bölümünde tartışacağımız belgeleme 
yorumları gibi başka bir yorum satırı çeşidi daha vardır.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kontrol-akışı"><a class="header" href="#kontrol-akışı">Kontrol Akışı</a></h2>
<p>Bir koşulun doğru olup olmadığına bağlı olarak bazı kodları çalıştırma veya bir
koşul doğruyken bazı kodları tekrar tekrar çalıştırma yeteneği, 
çoğu programlama dili için temel yapı taşıdır. Rust kodunun yürütme akışını kontrol etmenizi 
sağlayan en yaygın yapılar <code>if</code> ifadeleri ve döngülerdir.</p>
<h3 id="if-İfadeleri"><a class="header" href="#if-İfadeleri"><code>if</code> İfadeleri</a></h3>
<p>Bir <code>if</code> ifadesi, koşullara bağlı olarak kodunuzu dallandırmanıza olanak tanır. 
Bir koşul sağlarsınız ve ardından “Eğer bu koşul karşılanırsa, bu kod bloğunu çalıştırın. Koşul karşılanmazsa, bu kod bloğunu çalıştırmayın” emrini verirsiniz.</p>
<p><code>if</code> ifadesini keşfetmek için proje dizininizde <em>branches</em> adında yeni bir proje oluşturun. 
<em>src/main.rs</em> dosyasına aşağıdakini girin:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;condition was true&quot;);
    } else {
        println!(&quot;condition was false&quot;);
    }
}
</code></pre></pre>
<p>Tüm <code>if</code> ifadeleri, <code>if</code> anahtar sözcüğüyle başlar ve ardından bir koşul gelir. 
Bu durumda koşul, <code>number</code>'ın 5'ten küçük bir değere sahip olup olmadığını kontrol eder. 
Koşul doğruysa yürütülecek kod bloğunu, koşulun hemen ardından süslü parantezler içine yerleştiririz. 
<code>if</code> ifadelerindeki koşullarla ilişkili kod blokları, tıpkı Bölüm 2'deki <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“Tahmin ile Gizli Numarayı Karşılaştırma”</a><!--
ignore --> bölümünde tartıştığımız <code>match</code> ifadelerindeki <em>kollar</em> gibi bazen <em>kol</em> olarak adlandırılır.</p>
<p>İsteğe bağlı olarak, koşulun yanlış olarak değerlendirilmesi durumunda programa yürütülecek alternatif bir kod bloğu
vermek için burada yapmayı seçtiğimiz başka bir ifade de ekleyebiliriz. Başka bir ifade sağlamazsanız ve koşul yanlışsa, 
program <code>if</code> bloğunu atlar ve bir sonraki kod parçasına geçer.</p>
<p>Bu kodu çalıştırmayı deneyin, aşağıdaki çıktıyı görmelisiniz:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
</code></pre>
<p>Ne olduğunu görmek için <code>number</code>ın değerini koşulu <code>false</code> yapan bir değerle değiştirmeyi deneyelim:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!(&quot;condition was true&quot;);
</span><span class="boring">    } else {
</span><span class="boring">        println!(&quot;condition was false&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Programı tekrar çalıştırın ve çıktıya bakın:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
</code></pre>
<p>Bu koddaki koşulun <code>bool</code> türünden <em>olması gerektiğini</em> de belirtmekte fayda var. 
Koşul <code>bool</code> değilse, bir hata alırız. Örneğin, aşağıdaki kodu çalıştırmayı deneyin:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!(&quot;number was three&quot;);
    }
}
</code></pre>
<p><code>if</code> koşulu bu sefer <code>3</code> değerini değerlendiriyor ve Rust buna karşılık bir hata veriyor:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<p>Hata, Rust'ın bir <code>bool</code> beklediğini ancak bir tam sayı aldığını gösteriyor. 
Ruby ve JavaScript gibi dillerin aksine Rust, Boole olmayan türleri otomatik olarak 
Boole'a dönüştürmeye çalışmaz. Açık olmalısınız ve her zaman koşulun Boole olup olmadığını sağlamalısınız. 
Örneğin <code>if</code> kod bloğunun yalnızca bir sayı <code>0</code>'a eşit olmadığında çalışmasını istiyorsak, <code>if</code> ifadesini aşağıdaki gibi değiştirebiliriz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;number was something other than zero&quot;);
    }
}
</code></pre></pre>
<p>Bu kodu çalıştırmak bize şu çıktıyı verecektir: <code>number was something other than zero</code>.</p>
<h4 id="else-if-ile-birden-Çok-koşulun-İşlenmesi"><a class="header" href="#else-if-ile-birden-Çok-koşulun-İşlenmesi"><code>else if</code> ile Birden Çok Koşulun İşlenmesi</a></h4>
<p>Bir <code>else if</code> ifadesini <code>if</code> ve <code>else</code> ile birleştirerek birden çok koşul durumunda kullanabilirsiniz. 
Örneğin:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre></pre>
<p>Bu programın alabileceği dört olası durum vardır. Çalıştırdıktan sonra aşağıdaki çıktıyı görmelisiniz</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<p>Bu program yürütüldüğünde, sırayla her bir <code>if</code> ifadesini kontrol eder ve koşulun doğru 
olduğu ilk gövdeyi yürütür. <code>6</code>'nın 2<code>'</code>ye bölünebilmesine rağmen, çıktıda <code>number is divisible by 2</code>'yu görmüyor 
ve <code>else</code>'e rağmen çıktıda <code>number is not divisible by 4, 3, or 2</code>'yu görmüyoruz. 
Bunun nedeni, Rust'ın bloğu yalnızca ilk gerçek koşul için çalıştırmasıdır ve 
bir kez doğru koşulu bulduğunda gerisini kontrol bile etmez.</p>
<p>Çok fazla <code>else if</code> ifadesi kullanmak kodunuzu karıştırabilir, bu nedenle birden fazla varsa, 
kodunuzu yeniden düzenlemek isteyebilirsiniz. Bölüm 6, bu durumlar için <code>match</code> adı verilen güçlü bir 
Rust dallanma yapısını açıklar.</p>
<h4 id="ifi-lette-İfade-yapısı-olarak-kullanmak"><a class="header" href="#ifi-lette-İfade-yapısı-olarak-kullanmak"><code>if</code>'i <code>let</code>'te İfade Yapısı Olarak Kullanmak</a></h4>
<p><code>if</code> bir ifade olduğu için, Liste 3-2'de olduğu gibi sonucu bir değişkene atamak için <code>let</code> ifadesinin sağ tarafında kullanabiliriz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&quot;The value of number is: {number}&quot;);
}
</code></pre></pre>
<p><span class="caption">Liste 3-2: Bir <code>if</code> ifadesinin sonucunu bir değişkene atama</span></p>
<p><code>number</code> değişkenine, <code>if</code> ifadesinin sonucuna göre bir değer atanacaktır. 
Ne olduğunu görmek için bu kodu çalıştırın:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<p>Kod bloklarının içlerindeki son ifadeyi değerlendirdiğini ve sayıların 
kendi başlarına da ifadeler olduğunu unutmayın. Bu durumda, <code>if</code> ifadesinin tamamının değeri, 
hangi kod bloğunun yürütüldüğüne bağlıdır. Bu, <code>if</code>'in her bir kolundan sonuç alma potansiyeline sahip 
değerlerin aynı tür olması gerektiği anlamına gelir; Liste 3-2'de, hem <code>if</code> kolunun hem de <code>else</code> kolunun sonuçları 
<code>i32</code> tam sayı türündendi. Aşağıdaki örnekte olduğu gibi, türler uyumsuzsa bir hata alırız:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { &quot;six&quot; };

    println!(&quot;The value of number is: {number}&quot;);
}
</code></pre>
<p>Bu kodu derlemeye çalıştığımızda bir hata alacağız. <code>if</code> ve <code>else</code> kollarının uyumsuz değer türleri vardır 
ve Rust, sorunun programda tam olarak nerede bulunacağını bir hata mesajıyla belirtir:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { &quot;six&quot; };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<p><code>if</code> bloğundaki ifade bir tam sayı olarak değerlendirilir ve <code>else</code> bloğundaki ifade bir 
dizgi olarak değerlendirilir. Bu işe yaramaz çünkü değişkenlerin tek bir türü olması gerekir ve 
Rust'ın derleme zamanında sayı değişkeninin ne tür olduğunu kesin olarak bilmesi gerekir. 
Sayının türünü bilmek, derleyicinin sayıyı kullandığımız her yerde türün geçerli olduğunu doğrulamasını sağlar. 
Sayının türü yalnızca çalışma zamanında belirlenmiş olsaydı Rust bunu yapamazdı; derleyici daha karmaşık olurdu ve herhangi bir değişken için birden çok varsayımsal türü takip etmesi gerekiyorsa kod hakkında daha az garanti verirdi.</p>
<h3 id="döngülerle-yinelemek"><a class="header" href="#döngülerle-yinelemek">Döngülerle Yinelemek</a></h3>
<p>Bir kod bloğunu bir kereden fazla yürütmek genellikle yararlıdır. 
Bu görev için Rust, döngü gövdesi içindeki kodu sonuna kadar çalıştıracak ve ardından hemen 
baştan başlayacak birkaç <em>döngü</em> sağlar. Döngüleri denemek için <em>loops</em> adında yeni bir proje yapalım.</p>
<p>Rust'un üç tür döngüsü vardır: <code>loop</code>, <code>while</code> ve <code>for</code>. Her birini deneyelim.</p>
<h4 id="loop-ile-kod-yinelemek"><a class="header" href="#loop-ile-kod-yinelemek"><code>loop</code> ile Kod Yinelemek</a></h4>
<p><code>loop</code> anahtar sözcüğü, Rust'a bir kod bloğunu sonsuza kadar veya siz açıkça durmasını söyleyene kadar tekrar tekrar yürütmesini söyler.</p>
<p>Örnek olarak, <em>loops</em> dizininizdeki <em>src/main.rs</em> dosyasını şöyle görünecek şekilde değiştirin:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;again!&quot;);
    }
}
</code></pre>
<p>Bu programı çalıştırdığımızda, programı manuel olarak durdurana kadar sürekli olarak <code>again!</code> 
yazdırıldığını göreceğiz. Çoğu uçbirim <span class="keystroke">ctrl-c</span> kısayolunu döngüden çıkabilmek
için sunar. Bir şans verin:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p><code>^C</code> sembolü, <span class="keystroke">ctrl-c</span> tuşlarına bastığınız yeri gösterir.
Kesme sinyalini aldığınızda kodun döngüde nerede olduğuna bağlı olarak <code>^C</code>'den sonra döngü durur.</p>
<p>Neyse ki, Rust ayrıca kod kullanarak bir döngüden çıkmanın bir yolunu da sağlar. 
Programa döngüyü yürütmeyi ne zaman durduracağını söylemek için <code>break</code> anahtar sözcüğünü döngünün içine yerleştirebilirsiniz. 
Bunu Bölüm 2'deki <a href="ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess">“Doğru Tahminden Sonra Çıkma”</a><!-- ignore
-->  bölümündeki tahmin oyununda, kullanıcı doğru sayıyı tahmin ederek oyunu kazandığında programdan çıkmak için yaptığımızı hatırlayın.</p>
<p>Ayrıca, bir döngüde programa döngünün bu yinelemesinde kalan herhangi bir kodu atlamasını ve bir sonraki yinelemeye geçmesini söyleyen tahmin oyununda <code>continue</code>'ı kullandık.</p>
<h4 id="döngülerden-değer-döndürmek"><a class="header" href="#döngülerden-değer-döndürmek">Döngülerden Değer Döndürmek</a></h4>
<p><code>loop</code>'un kullanımlarından biri, bir iş parçacığının işini tamamlayıp tamamlamadığını kontrol etmek 
gibi başarısız olabileceğini bildiğiniz bir işlemi yeniden denemektir. Ayrıca, bu işlemin sonucunu döngüden kodunuzun geri kalanına aktarmanız gerekebilir. Bunu yapmak için, döngüyü durdurmak için kullandığınız <code>break</code> ifadesinden sonra döndürülmesini istediğiniz değeri ekleyebilirsiniz; bu değer, burada gösterildiği gibi kullanabilmeniz için döngüden döndürülecektir:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;The result is {result}&quot;);
}
</code></pre></pre>
<p>Döngüden önce <code>counter</code> adında bir değişken tanımlıyoruz ve onu <code>0</code> olarak başlatıyoruz. 
Ardından döngüden dönen değeri tutacak <code>result</code> adında bir değişken tanımlıyoruz. 
Döngünün her yinelemesinde <code>counter</code> değişkenine <code>1</code> ekliyoruz ve ardından <code>counter</code>'ın <code>10</code>'a eşit olup olmadığını kontrol ediyoruz. Eşitse <code>counter * 2</code> değerini <code>break</code> anahtar sözcüğüyle kullanıyoruz. Döngüden sonra noktalı virgül kullanıyoruz. 
<code>result</code>'a değer atayan ifadeyi bitirmek için; son olarak, <code>20</code> olan <code>result</code> değerini yazdırıyoruz.</p>
<h4 id="birden-Çok-döngü-arasındaki-belirsizliği-gidermek-için-döngü-etiketleri"><a class="header" href="#birden-Çok-döngü-arasındaki-belirsizliği-gidermek-için-döngü-etiketleri">Birden Çok Döngü Arasındaki Belirsizliği Gidermek için Döngü Etiketleri</a></h4>
<p>Döngüler içinde döngüleriniz varsa, o noktada en içteki döngü için <code>break</code> ve <code>continue</code> ifadeleri uygulanır. 
İsteğe bağlı olarak bir döngü üzerinde bir <em>döngü etiketi</em> belirleyebilirsiniz ve daha sonra bu anahtar sözcüklerin en içteki döngü yerine etiketli döngüye uygulanacağını belirtmek için <code>break</code> veya <code>continue</code> ile kullanabiliriz.
İşte iki iç içe döngü içeren bir örnek:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!(&quot;count = {count}&quot;);
        let mut remaining = 10;

        loop {
            println!(&quot;remaining = {remaining}&quot;);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!(&quot;End count = {count}&quot;);
}
</code></pre></pre>
<p>Dış döngü <code>'counting_up</code> etiketine sahiptir ve 0'dan 2'ye kadar sayar. 
Etiketsiz iç döngü 10'dan 9'a geri sayım yapar. Bir etiket belirtmeyen ilk <code>break</code> yalnızca iç döngüden çıkar. 
<code>break 'counting_up</code>; ifadesi dış döngüden çıkar:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
</code></pre>
<h4 id="while-ile-koşullu-döngüler"><a class="header" href="#while-ile-koşullu-döngüler"><code>while</code> ile Koşullu Döngüler</a></h4>
<p>Bir programın genellikle bir döngü içindeki bir koşulu değerlendirmesi gerekir. 
Koşul doğru olduğunda döngü çalışır. Koşul doğru olmadığında, program <code>break</code>'i çağırarak döngüyü durdurur. 
Böyle bir davranışı <code>loop</code>, <code>if</code>, <code>else</code> ve <code>break</code> kombinasyonunu kullanarak uygulamak mümkündür; 
İsterseniz bunu şimdi bir programda deneyebilirsiniz. Ancak, bu model o kadar yaygındır ki, 
Rust'ın bunun için <code>while</code> döngüsü adı verilen yerleşik bir dil yapısı vardır. 
Liste 3-3'te, programı üç kez döngüye almak, her seferinde geri saymak ve ardından döngüden sonra bir mesaj yazdırıp çıkmak 
için <code>while</code> kullanıyoruz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{number}!&quot;);

        number -= 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p><span class="caption">Liste 3-3: Bir koşul doğruyken kodu çalıştırmak için <code>while</code> döngüsü kullanma</span></p>
<p>Bu yapı, <code>loop</code>, <code>if</code>, <code>else</code> ve <code>break</code> kullandıysanız gerekli olacak birçok iç içe yerleştirmeyi ortadan kaldırır ve daha
nettir. Bir koşul doğru olduğunda kod çalışır; aksi takdirde döngüden çıkar.</p>
<h4 id="for-ile-bir-koleksiyonda-yineleme-yapmak"><a class="header" href="#for-ile-bir-koleksiyonda-yineleme-yapmak"><code>for</code> ile Bir Koleksiyonda Yineleme Yapmak</a></h4>
<p>Dizi gibi bir koleksiyonun öğeleri üzerinde döngü oluşturmak için <code>while</code> yapısını kullanmayı seçebilirsiniz. 
Örneğin, Liste 3-4'teki döngü <code>a</code> dizisindeki her öğeyi yazdırır.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;the value is: {}&quot;, a[index]);

        index += 1;
    }
}
</code></pre></pre>
<p><span class="caption">Liste 3-4: Bir <code>while</code> döngüsü kullanarak bir koleksiyonun her bir öğesi arasında döngü yapmak</span></p>
<p>Burada kod, dizideki öğeleri sayar. <code>0</code> dizininde başlar ve ardından dizideki son dizine ulaşana kadar döner 
(yani <code>index &lt; 5</code> doğru olmayana kadar). Bu kodu çalıştırmak dizideki her öğeyi yazdıracaktır.</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>Beş dizi değerinin tümü beklendiği gibi terminalde görünür. 
Dizin bir noktada <code>5</code> değerine ulaşacak olsa da, diziden altıncı bir değer getirmeye çalışmadan önce 
döngü kendini yürütmeyi durdurur.</p>
<p>Ancak bu yaklaşım hataya açıktır; <code>index</code> değeri veya test koşulu yanlışsa programın paniğe 
kapılmasına neden olabiliriz. Örneğin, <code>a</code> dizisinin tanımını dört öğeye sahip olacak şekilde değiştirdiyseniz 
ancak <code>index &lt; 4</code> iken koşulu güncellemeyi unuttuysanız, kod panikleyecektir. 
Ayrıca bu yavaştır, çünkü derleyici döngü boyunca her yinelemede dizinin dizinin sınırları içinde olup 
olmadığının koşullu kontrolünü gerçekleştirmek için çalışma zamanı kodu ekler.</p>
<p>Daha özlü bir alternatif olarak, bir <code>for</code> döngüsü kullanabilir ve bir koleksiyondaki her öğe için bir miktar kod çalıştırabilirsiniz. <code>for</code> döngüsü, Liste 3-5'teki koda benzer.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!(&quot;the value is: {element}&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Liste 3-5: Bir <code>for</code> döngüsü kullanarak bir koleksiyonun her bir öğesi arasında yinelemek</span></p>
<p>Bu kodu çalıştırdığımızda, Liste 3-4'teki çıktının aynısını göreceğiz. 
Daha da önemlisi, artık kodun güvenliğini artırdık ve dizinin sonunun ötesine geçmek veya 
yeterince uzağa gitmemek ve bazı öğeleri kaçırmaktan kaynaklanabilecek hata olasılığını ortadan kaldırdık.</p>
<p><code>for</code> döngüsünü kullanarak, Liste 3-4'te kullanılan yöntemde olduğu gibi dizideki değerlerin 
sayısını değiştirdiyseniz, başka herhangi bir kodu değiştirmeniz gerekmez.</p>
<p><code>for</code> döngülerinin güvenliği ve kısa olması, onları Rust'ta en yaygın kullanılan 
döngü yapısı haline getirir. Liste 3-3'te <code>while</code> döngüsü kullanan geri sayım örneğinde olduğu gibi, bazı kodları belirli sayıda çalıştırmak istediğiniz durumlarda bile, çoğu <code>Rustacean</code> bir <code>for</code> döngüsü kullanır. 
Bunu yapmanın yolu, bir sayıdan başlayıp diğer bir sayıdan önce biten tüm sayıları sırayla üreten 
standart kütüphane tarafından sağlanan <code>Range</code> tanımını kullanmaktır.</p>
<p>Aralığı tersine çevirmek için bir <code>for</code> döngüsü ve henüz bahsetmediğimiz başka bir yöntem olan <code>rev</code> kullanarak geri 
sayım işleminin nasıl görüneceği aşağıda açıklanmıştır:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{number}!&quot;);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p>Bu kod sizce de daha hoş durmuyor mu?</p>
<h2 id="Özet-1"><a class="header" href="#Özet-1">Özet</a></h2>
<p>Başardın! Bu oldukça büyük bir bölümdü: değişkenler, skaler ve bileşik veri türleri, fonksiyonlar, yorumlar, 
<code>if</code> ifadeleri ve döngüler hakkında çokça bilgi edindiniz! 
Bu bölümde tartışılan kavramlarla pratik yapmak için aşağıdaki programları oluşturmaya
çalışın:</p>
<ul>
<li>Fahrenheit ve Santigrat türleri arasında dönüşüm yapan programı yazın.</li>
<li>n'inci Fibonaccı sayısını oluşturan programı yazın.</li>
<li>Şarkıdaki tekrarlardan yararlanarak Noel şarkısı “The Twelve Days of Christmas”'ın sözlerini yazdırın.</li>
</ul>
<p>Devam etmeye hazır olduğunuzda, Rust'ta diğer programlama dillerinde <em>olmayan</em> bir kavram olan <em>sahiplikten</em>
bahsedeceğiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sahipliği-anlamak"><a class="header" href="#sahipliği-anlamak">Sahipliği Anlamak</a></h1>
<p>Sahiplik, Rust'ın en benzersiz özelliğidir ve dilin geri kalanı için derin etkileri vardır. 
Bu benzersiz özellik, Rust'ın bir çöp toplayıcıya ihtiyaç duymadan bellek güvenliği garantisi vermesini sağlar, 
bu nedenle sahipliğin nasıl çalıştığını anlamak önemlidir. Bu bölümde, sahiplik ve ilgili birkaç özellik hakkında konuşacağız: 
ödünç alma, dilimler ve Rust'ın verileri belleğe nasıl yerleştirdiği.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sahiplik-nedir"><a class="header" href="#sahiplik-nedir">Sahiplik Nedir?</a></h2>
<p><em>Sahiplik</em>, bir Rust programının belleği nasıl yönettiğini yöneten bir dizi kuraldır. 
Tüm programlar, çalışırken bilgisayarın belleğini kullanma şeklini yönetmek zorundadır. 
Bazı dillerde, program çalışırken düzenli olarak artık kullanılmayan belleği arayan çöp toplama vardır; diğer dillerde, 
programcı belleği açıkça tahsis etmeli ve serbest bırakmalıdır. Rust üçüncü bir yaklaşım kullanır: 
bellek, derleyicinin kontrol ettiği bir dizi kurala sahip bir sahiplik sistemi aracılığıyla yönetilir. 
Kurallardan herhangi biri ihlal edilirse program derlenmeyecektir. Sahiplik özelliklerinin hiçbiri, 
çalışırken programınızı yavaşlatmaz.</p>
<p>Sahiplik birçok programcı için yeni bir kavram olduğu için alışması biraz zaman alıyor. 
İyi haber şu ki, Rust ve sahiplik sisteminin kuralları konusunda ne kadar deneyimli olursanız, 
doğal olarak güvenli ve verimli kod geliştirmeyi o kadar kolay bulacaksınız. Öğrenmeye devam edin!</p>
<p>Sahipliği anladığınızda, Rust'ı benzersiz kılan özellikleri anlamak için sağlam bir temele sahip olacaksınız. 
Bu bölümde, çok yaygın bir veri yapısına odaklanan bazı örnekler üzerinde çalışarak sahipliği öğreneceksiniz (bkz. <em>dizgiler</em>).</p>
<blockquote>
<h3 id="yığıt-ve-yığın"><a class="header" href="#yığıt-ve-yığın">Yığıt ve Yığın</a></h3>
<p>Çoğu programlama dili, yığıt ve yığın hakkında çok sık düşünmenizi gerektirecek  özelliklere sahip değildir. 
Ancak Rust gibi bir sistem programlama dilinde, bir değerin yığıtta mı yoksa yığında mı olması dilin nasıl davrandığını 
ve neden belirli kararlar vermeniz gerektiğini etkiler. Sahiplik, bu bölümün ilerleyen kısımlarında yığıt ve yığınla ilgili olarak 
açıklanacaktır, bu nedenle burada hazırlık aşamasında olan kısa bir açıklama bulunmaktadır.
Hem yığıt hem de yığın, çalışma zamanında kodunuzun kullanabileceği bellek parçalarıdır, 
ancak bunlar farklı şekillerde yapılandırılmıştır. Yığıt, değerleri aldığı sırayla saklar ve değerleri ters sırada tutar. 
Buna <em>son giren ilk çıkar</em> (LIFO) denir. 
Bir tabak yığıtını düşünün: daha fazla tabak eklediğinizde, 
onları yığıtın üstüne koyarsınız ve bir tabağa ihtiyacınız olduğunda üstten bir tane alırsınız. 
Ortadan veya alttan tabak eklemek veya çıkarmak da işe yaramaz! 
Veri eklemeye yığıta itme denir ve veri kaldırmaya yığıttan çıkarma denir. 
Yığıtta depolanan tüm verilerin bilinen, sabit bir boyutu olmalıdır. Derleme zamanında bilinmeyen bir boyuta veya değişebilecek bir
boyuta sahip veriler, yığın (heap) üzerinde depolanmalıdır.</p>
<p>Yığın daha az organizedir: yığına veri koyduğunuzda, belirli bir miktar alan talep edersiniz. 
Bellek ayırıcı, yığında yeterince büyük boş bir nokta bulur, onu kullanımda olarak işaretler ve o konumun adresi olan bir işaretçi
döndürür. Bu işleme yığın üzerinde ayırma denir ve bazen sadece ayırma olarak kısaltılır (değerleri yığına itmek ayırma olarak kabul edilmez). 
Yığın işaretçisi bilinen, sabit bir boyut olduğundan, işaretçiyi yığında saklayabilirsiniz, ancak gerçek verileri istediğinizde 
işaretçiyi izlemelisiniz. Bir restoranda oturduğunuzu düşünün. Girdiğinizde grubunuzdaki kişi sayısını 
belirtiyorsunuz ve görevliler herkese uygun boş bir masa bulup sizi oraya yönlendiriyor. 
Grubunuzdan biri geç gelirse, sizi bulmak için nerede oturduğunuzu sorabilir.
Yığıta itme, yığında tahsis etmekten daha hızlıdır, çünkü ayırıcı hiçbir zaman yeni verileri depolamak için 
bir yer aramak zorunda kalmaz; bu konum her zaman yığıtın en üstündedir. Nispeten, yığın üzerinde alan tahsis 
etmek daha fazla iş gerektirir, çünkü tahsis edenin önce verileri tutacak kadar büyük bir alan bulması ve 
ardından bir sonraki tahsise hazırlanmak için defter tutma yapması gerekir.
Yığındaki verilere erişmek, oraya ulaşmak için bir işaretçiyi izlemeniz gerektiğinden yığıttaki 
verilere erişmekten daha yavaştır. Çağdaş işlemciler, bellekte daha az zıplarlarsa daha hızlı 
olarak kabul edilir. Analojiye devam edersek, bir restoranda birçok masadan sipariş alan bir sunucu düşünün. 
Bir sonraki masaya geçmeden önce tüm siparişleri bir masada toplamak en verimli yöntemdir. 
A masasından bir sipariş, sonra B masasından, sonra tekrar A'dan ve sonra tekrar B'den bir sipariş almak çok 
daha yavaş bir süreç olacaktır. Aynı şekilde, bir işlemci daha uzakta (yığın üzerinde olabileceği gibi) yerine diğer 
verilere yakın olan (yığıt üzerinde olduğu gibi) veriler üzerinde çalışıyorsa işini daha iyi yapabilir.</p>
<p>Kodunuz bir fonksiyonu çağırdığında, fonksiyona iletilen değerler (potansiyel olarak yığın üzerindeki verilere işaretçiler de dahil) 
ve işlevin yerel değişkenleri yığıta aktarılır. Fonksiyon bittiğinde, bu değerler yığıttan atılır.
Kodun hangi bölümlerinin yığındaki hangi verileri kullandığını takip etmek, yığındaki yinelenen veri miktarını 
en aza indirmek ve alanınız bitmemek için yığındaki kullanılmayan verileri temizlemek, 
sahipliğin ele aldığı sorunlardır. Sahipliği anladıktan sonra, yığıt ve yığın hakkında çok sık düşünmenize gerek kalmayacak, 
ancak sahipliğin asıl amacının yığın verilerini yönetmek olduğunu bilmek, neden böyle çalıştığını açıklamaya yardımcı olabilir.</p>
</blockquote>
<h3 id="sahiplik-kuralları"><a class="header" href="#sahiplik-kuralları">Sahiplik Kuralları</a></h3>
<p>İlk olarak, sahiplik kurallarına bir göz atalım. 
Bunları gösteren örnekler üzerinde çalışırken bu kuralları aklınızda bulundurun:</p>
<ul>
<li>Rust'ta her değerin bir <em>sahibi</em> vardır.</li>
<li>Aynı zamanda sadece bir sahip olabilir.</li>
<li>Sahip kapsam dışına çıktığında değer düşürülür.</li>
</ul>
<h3 id="değişken-kapsamı"><a class="header" href="#değişken-kapsamı">Değişken Kapsamı</a></h3>
<p>Artık temel Rust söz dizimini geride bıraktığımıza göre, 
örneklere <code>fn main() {</code> kodunu dahil etmeyeceğiz, bu nedenle takip ediyorsanız, aşağıdaki örnekleri
<code>main</code> fonksiyonunun içine koyduğunuzdan emin olun. Sonuç olarak, örneklerimiz biraz daha kısa olacak ve 
ortak kod yerine gerçek ayrıntılara odaklanmamıza izin verecek.</p>
<p>İlk sahiplik örneği olarak, bazı değişkenlerin kapsamına bakacağız. 
Kapsam, bir öğenin geçerli olduğu bir program içindeki aralıktır. Aşağıdaki değişkeni bakın:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;;
<span class="boring">}
</span></code></pre></pre>
<p><code>s</code> değişkeni, dizgi değerinin programımızın metnine sabit kodlanmış olduğu bir dizgi değişmezi anlamına gelir. 
Değişken, bildirildiği noktadan geçerli kapsamın sonuna kadar geçerlidir. Liste 4-1, <code>s</code> değişkeninin nerede geçerli 
olacağını açıklayan açıklamalar içeren bir programı gösterir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {                      // s is not valid here, it’s not yet declared
        let s = &quot;hello&quot;;   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 4-1: Bir değişken ve geçerli olduğu kapsam
</span></p>
<p>Başka bir deyişle, burada iki önemli nokta vardır:</p>
<ul>
<li><code>s</code>'in <em>kapsama</em> girmesi geçerli bir durumdur.</li>
<li><em>kapsam dışına</em> çıkana kadar geçerliliğini korur.</li>
</ul>
<p>Bu noktada, kapsamlar ve değişkenlerin ne zaman geçerli olduğu arasındaki ilişki diğer programlama dillerindekine benzer.
Şimdi <code>String</code> türünü tanıtarak bu anlayışın üzerine inşa edeceğiz.</p>
<h3 id="string-türü"><a class="header" href="#string-türü"><code>String</code> Türü</a></h3>
<p>Sahiplik kurallarını göstermek için, Bölüm 3'ün <a href="ch03-02-data-types.html#data-types">“Veri Türleri”</a><!-- ignore --> bölümünde ele aldıklarımızdan daha 
karmaşık bir veri tipine ihtiyacımız var. Yığıt, kapsamı sona erdiğinde ve kodun başka bir bölümünün aynı değeri farklı bir kapsamda kullanması gerekiyorsa, yeni, bağımsız bir örnek oluşturmak için hızlı ve önemsiz bir şekilde kopyalanabilir. 
Ancak yığında depolanan verilere bakmak ve Rust'ın bu verileri ne zaman temizleyeceğini nasıl bildiğini keşfetmek istiyoruz ve <code>String</code> türü 
bu durum için harika bir örnek.</p>
<p><code>String</code>'in sahiplikle ilgili kısımlarına odaklanacağız. Bu yönler, standart küyüphane tarafından sağlanmış veya sizin tarafınızdan 
oluşturulmuş olsun (ki diğer karmaşık veri türleri için de geçerlidir). <code>String</code>'i <a href="ch08-02-strings.html">Bölüm 8</a><!-- ignore -->'de daha derinlemesine tartışacağız.</p>
<p>Bir dizgi değerinin programımıza sabit kodlanmış olduğu dizgi değişmezlerini zaten gördük. 
Dizgi değişmezleri uygundur, ancak metin kullanmak isteyebileceğimiz her durum için uygun değildirler. 
Bunun bir nedeni, değişmez olmalarıdır. Bir diğeri ise, kodumuzu yazarken her dizgi değeri bilinemez: 
örneğin, kullanıcı girdisini alıp depolamak istersek ne olur? Bu durumlar için Rust'ın ikinci bir dizgi türü vardır, 
<code>String</code>. Bu tür, yığına ayrılan verileri yönetir ve bu nedenle derleme zamanında bizim için bilinmeyen bir miktarda metin depolayabilir. 
<code>from</code> fonksiyonunu kullanarak bir dizgi değişmezinden bir <code>String</code> oluşturabilirsiniz, şöyle:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Çift iki nokta üst üste <code>::</code> operatörü, 
<code>string_from</code> gibi bir tür isim kullanmak yerine, bu özel fonksiyondan <code>String</code> tipi altında isim-alanına izin verir. 
Bu söz dizimini Bölüm 5'in <a href="ch05-03-method-syntax.html#method-syntax">“Metod Söz Dizimi”</a><!-- ignore --> bölümünde ve Bölüm 7'deki <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Modül Ağacındaki Bir Öğeye Başvurma Yolları”</a><!-- ignore --> daha fazla tartışacağız.</p>
<p>Bu tür bir dizgi de <em>değiştirilebilir</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    s.push_str(&quot;, world!&quot;); // push_str() appends a literal to a String

    println!(&quot;{}&quot;, s); // This will print `hello, world!`
<span class="boring">}
</span></code></pre></pre>
<p>Peki, buradaki fark nedir? Neden <code>String</code> değiştirilebilir, ancak değişmezler (<em>adı üstünde</em>) değişemezler? 
Aradaki fark, bu iki türün bellekle nasıl başa çıktığıdır.</p>
<h3 id="bellek-ve-tahsis"><a class="header" href="#bellek-ve-tahsis">Bellek ve Tahsis</a></h3>
<p>Bir dizgi değişmezi durumunda, içeriğini derleme zamanında biliyoruz, bu nedenle metin doğrudan son yürütülebilir
dosyaya sabit kodlanmıştır. Bu nedenle dize değişmezleri hızlı ve verimlidir. Ancak bu özellikler yalnızca dize değişmezinin 
değişmezliğinden gelir. Ne yazık ki, derleme zamanında boyutu bilinmeyen ve programı çalıştırırken boyutu değişebilecek her metin 
parçası için yürütülebilir ikili dosyaya bir bellek bloğu koyamıyoruz.</p>
<p><code>String</code> türüyle; değişebilir, büyütülebilir bir metin parçasını desteklemek ve içeriğini tutmak 
için yığın üzerinde derleme zamanında bilinmeyen bir miktar bellek ayırmamız gerekir. </p>
<p>Bu, şu anlama gelir:</p>
<ul>
<li>Bellek, çalışma zamanında bellek ayırıcıdan talep edilmelidir.</li>
<li><code>String</code> ile işimiz bittiğinde bu hafızayı ayırıcıya geri döndürmenin 
bir yoluna ihtiyacımız vardır.</li>
</ul>
<p>Bu ilk kısım bizim tarafımızdan yapılır: <code>String::from</code>'u çağırdığımızda, 
süreklemesi ihtiyaç duyduğu hafızayı ister. Bu, programlama dillerinde oldukça evrenseldir.</p>
<p>Ancak ikinci kısım farklıdır. <em>Çöp toplayıcı (GC)</em> olan dillerde, GC artık kullanılmayan belleği izler ve 
temizler. Bellek tahsisi hakkında düşünmemize gerek yoktur. 
GC olmayan çoğu dilde, belleğin artık kullanılmadığını belirlemek ve tıpkı bizim talep ettiğimiz gibi, 
belleği açıkça boşaltmak için kodu çağırmak bizim sorumluluğumuzdadır. Bunu doğru yapmak, tarihsel olarak zor bir programlama problemi olmuştur. Unutursak, hafızayı boşa harcarız. Çok erken yaparsak geçersiz bir değişkenimiz olur. İki kez yaparsak, bu da bir hatadır. 
Tam olarak bir <code>tahsisi</code> tam olarak bir <code>geri verme</code> ile eşleştirmemiz gerekiyor.</p>
<p>Rust farklı bir yol izler: sahip olduğu değişken kapsam dışına çıktığında bellek otomatik olarak döndürülür. 
Aşağıda, bir dizgi değişmezi yerine bir <code>String</code> kullanarak Liste 4-1'deki kapsam örneğimizin farklı bir sürümü verilmiştir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let s = String::from(&quot;hello&quot;); // s is valid from this point forward

        // do stuff with s
    }                                  // this scope is now over, and s is no
                                       // longer valid
<span class="boring">}
</span></code></pre></pre>
<p><code>String</code>'imizin ihtiyaç duyduğu belleği ayırıcıya döndürebileceğimiz doğal bir nokta vardır: 
<code>s</code>'in kapsam dışına çıkması. Bir değişken kapsam dışına çıktığında Rust bizim için özel bir fonksiyon çağırır. 
Bu fonksiyona <code>drop</code> denir ve <code>String</code> yazarının belleği geri döndürmek için kodu koyabileceği yerdir. 
Rust çağrıları, kapanış parantezinde otomatik olarak <code>drop</code> fonksiyonunu çağırır.</p>
<blockquote>
<p>Not: C++'ta, bir öğenin kullanım süresinin sonunda kaynakları serbest bırakma modeline
<em>Resource Acquisition Is Initialization (RAII)</em> adı verilir. 
RAII kalıplarını kullandıysanız, Rust'taki <code>drop</code> fonksiyonu size tanıdık gelecektir.</p>
</blockquote>
<p>Bu model, Rust kodunun yazılma şekli üzerinde derin bir etkiye sahiptir.
Şu anda basit görünebilir, ancak yığında tahsis ettiğimiz verileri birden çok değişkenin kullanmasını istediğimizde, 
daha karmaşık durumlarda kodun davranışı beklenmedik olabilir. 
Şimdi bu durumlardan bazılarını inceleyelim.</p>
<h4 id="değişkenlerin-ve-veri-etkileşiminin-yolları-hareket-ettirme"><a class="header" href="#değişkenlerin-ve-veri-etkileşiminin-yolları-hareket-ettirme">Değişkenlerin ve Veri Etkileşiminin Yolları: Hareket Ettirme</a></h4>
<p>Birden çok değişken, Rust'ta aynı verilerle farklı şekillerde etkileşime girebilir. Liste 4-2'de, 
tam sayı kullanan bir örneğe bakalım.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 4-2: <code>x</code> değişkeninin tam sayı değerini <code>y</code>'ye atama</span></p>
<p>Muhtemelen bunun ne yaptığını tahmin edebiliriz: 
“<code>5</code>'i <code>x</code>'e ata; sonra <code>x</code>'deki değerin bir kopyasını al ve onu <code>y</code>'ye ata.&quot;.
Yani iki değişkenimiz olmuş oluyor, <code>x</code> ve <code>y</code>'nin her ikisi de <code>5</code>'e eşittir. Bu gerçekten olan şeydir, 
çünkü tam sayılar bilinen, sabit bir boyuta sahip basit değerlerdir ve bu iki <code>5</code> değeri yığına itilir.</p>
<p>Hadi <code>String</code> versiyonuna bakalım:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>Bu çok benzer duruyor, bu yüzden çalışma şeklinin aynı olacağını varsayabiliriz: 
yani ikinci satır <code>s1</code>'deki değerin bir kopyasını alır ve onu <code>s2</code>'ye atar. Ama bu tam olarak ne olduğunu açıklamıyor.</p>
<p>Arka kapılar ardında <code>String</code>'e ne olduğunu görmek için Şekil 4-1'e bakın. 
Bir <code>String</code>, solda gösterilen üç bölümden oluşur: dizginin içeriğini, uzunluğunu ve kapasitesini tutan belleğe yönelik 
bir işaretçi. 
Bu veri grubu yığıtta depolanır. Sağda, içeriği tutan yığın üzerindeki bellek bulunur.</p>
<img alt="Bellekteki String" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Şekil 4-1: <code>s1</code>'e atanmış <code>&quot;hello&quot;</code> değerini tutan bir <code>String</code>'in bellekteki temsili</span></p>
<p>Uzunluk, <code>String</code> içeriğinin bayt cinsinden ne kadar bellek kullandığıdır. 
Kapasite, <code>String</code>'in ayırıcıdan aldığı bayt cinsinden toplam bellek miktarıdır. 
Uzunluk ve kapasite arasındaki fark önemlidir, ancak bu bağlamda değil, bu nedenle şimdilik kapasiteyi göz ardı etmekte fayda var.</p>
<p><code>s1</code>'i <code>s2</code>'ye atadığımızda, <code>String</code> verileri kopyalanır, yani yığıttaki işaretçiyi, uzunluğu ve kapasiteyi kopyalarız. 
İşaretçinin başvurduğu yığın üzerindeki verileri kopyalamayız. 
Başka bir deyişle, bellekteki veri gösterimi Şekil 4-2'ye benzer.</p>
<img alt="s1 ve s2 aynı değere işaret ediyor" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
<p><span class="caption">Şekil 4-2: İşaretçinin, uzunluğun ve <code>s1</code> kapasitesinin bir kopyasına sahip olan <code>s2</code> değişkeninin bellekteki temsili</span></p>
<p>Temsil, Şekil 4-3'e <em>benzemiyor</em>; bu, Rust'un yığın verilerini de kopyalaması durumunda belleğin nasıl görüneceğini gösterir. 
Bunu Rust yapsaydı, yığın üzerindeki veriler de büyük olsaydı <code>s2 = s1</code> işlemi çalışma zamanı performansı açısından çok pahalı olabilirdi.</p>
<img alt="s1 ve s2 iki farklı yeri işaret ediyor" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
<p><span class="caption">Şekil 4-3: Rust yığın verilerini de kopyalasaydı <code>s2 = s1</code>'in neler yapabileceğine dair başka bir olasılık</span></p>
<p>Daha önce, bir değişken kapsam dışına çıktığında Rust'ın otomatik olarak <code>drop</code> fonksiyonunu çağırdığını ve o değişken için 
yığın belleğini temizlediğini söylemiştik. Ancak Şekil 4-2, aynı konuma işaret eden her iki veri işaretçisini de göstermektedir. 
Bu bir sorundur: <code>s2</code> ve <code>s1</code> kapsam dışına çıktığında, ikisi de aynı belleği boşaltmaya çalışacaklardır. 
Bu, <em>çifte serbest bırakma hatası</em> olarak bilinir ve daha önce bahsettiğimiz bellek güvenlik hatalarından biridir. 
Belleği iki kez boşaltmak bellek bozulmasına neden olabilir ve bu da potansiyel olarak güvenlik açıklarına yol açabilir.</p>
<p>Bellek güvenliğini sağlamak için, <code>let s2 = s1</code> satırından sonra Rust, <code>s1</code>'in artık geçerli olmadığını düşünür. 
Bu nedenle, <code>s1</code> kapsam dışına çıktığında Rust'ın hiçbir şeyi serbest bırakmasına gerek yoktur. 
<code>s2</code> oluşturulduktan sonra <code>s1</code>'i kullanmaya çalıştığınızda ne olduğuna bakın; çalışmayacaktır:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;

    println!(&quot;{}, world!&quot;, s1);
<span class="boring">}
</span></code></pre>
<p>Rust, geçersiz kılınan referansı kullanmanızı engellediği için şöyle bir hata alırsınız:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from(&quot;hello&quot;);
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Diğer dillerle çalışırken <em>sığ kopyalama</em> ve <em>derin kopyalama</em> terimlerini duymuşsanız, verileri kopyalamadan işaretçiyi, 
uzunluğu ve kapasiteyi kopyalama kavramı muhtemelen sığ bir kopya oluşturmaya benziyor. 
Ancak Rust aynı zamanda ilk değişkeni de geçersiz kıldığı için, onu sığ bir kopya olarak adlandırmak yerine <em>hareket</em> olarak adlandırırız. 
Bu örnekte, <code>s1</code>'in <code>s2</code>'ye hareket ettiğini söyleyebiliriz. Yani gerçekte ne olduğu Şekil 4-4'te gösterilmektedir.</p>
<img alt="s1, s2'ye hareket ettirildi" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
<p><span class="caption">Şekil 4-4: <code>s1</code> geçersiz kılındıktan sonra hafızadaki temsili</span></p>
<p>Bu bizim sorunumuzu çözüyor! Yalnızca <code>s2</code> geçerli olduğunda, 
kapsam dışına çıktığında tek başına belleği boşaltır ve yapmamız gereken bir ley kalmaz.</p>
<p>Ek olarak, bununla ima edilen bir tasarım seçeneği vardır: 
Rust, verilerinizin “derin” kopyalarını asla otomatik olarak oluşturmaz. 
Bu nedenle, herhangi bir otomatik kopyalamanın çalışma zamanı performansı açısından ucuz olduğu varsayılabilir.</p>
<h4 id="değişkenlerin-ve-veri-etkileşiminin-yolları-klonlama"><a class="header" href="#değişkenlerin-ve-veri-etkileşiminin-yolları-klonlama">Değişkenlerin ve Veri Etkileşiminin Yolları: Klonlama</a></h4>
<p>Yalnızca yığıt verilerini değil, <code>String</code>'in yığın verilerini de derinlemesine kopyalamak istiyorsak, 
<code>clone</code> adı verilen ortak metodu kullanabiliriz. 
Metod söz dizimini Bölüm 5'te tartışacağız, ancak metodlar birçok programlama dilinde ortak bir özellik olduğundan, 
muhtemelen onları daha önce görmüşsünüzdür.</p>
<p>İşte çalışma halindeki <code>clone</code> metodunun bir örneği:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1.clone();

    println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<p>Bu gayet iyi çalışır ve yığın verilerinin kopyalandığı Şekil 4-3'te gösterilen davranışı açıkça <em>üretir</em>.</p>
<p>Bir <code>clone</code> çağrısı gördüğünüzde, bazı rastgele kodların yürütüldüğünü ve bu kodun pahalı olabileceğini bilirsiniz. 
Bu, farklı bir şeyin olup bittiğinin bir göstergesidir.</p>
<h4 id="yalnızca-yığıt-kullanan-veriler-kopyalama"><a class="header" href="#yalnızca-yığıt-kullanan-veriler-kopyalama">Yalnızca Yığıt Kullanan Veriler: Kopyalama</a></h4>
<p>Henüz bahsetmediğimiz başka bir olay daha var. Bir kısmı Liste 4-2'de gösterilen 
tam sayıları kullanan bu kod çalışır ve geçerlidir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>Ancak bu kod, az önce öğrendiklerimizle çelişiyor gibi görünüyor: <code>clone</code> çağrımız yok, ancak <code>x</code> hala geçerli ve <code>y</code>'ye hareket ettirilmedi.</p>
<p>Bunun nedeni, derleme zamanında boyutu bilinen tam sayılar gibi türlerin tamamen yığıtta saklanmasıdır, 
bu nedenle gerçek değerlerin kopyaları hızlı bir şekilde oluşturulur. Bu, <code>y</code> değişkenini oluşturduktan sonra <code>x</code>'in geçerli olmasını engellemek istememiz için hiçbir neden olmadığı anlamına gelir. Başka bir deyişle, burada derin ve sığ kopyalama arasında bir fark yoktur, 
bu nedenle <code>clone</code> çağırmak normal sığ kopyalamadan farklı bir şey yapmaz ve bunu dışarıda bırakabiliriz.</p>
<p>Rust'ın, tam sayılar gibi yığıtta depolanan türlere yerleştirebileceğimiz <code>Copy</code> tanımı adı verilen özel bir açıklaması vardır 
(tanımlar hakkında <a href="ch10-02-traits.html">Bölüm 10</a><!-- ignore -->'da daha fazla konuşacağız). 
Bir tür, <code>Copy</code> özelliğini süreklerse (uygularsa), onu kullanan değişkenler hareket etmez, 
bunun yerine önemsiz bir şekilde kopyalanır, bu da onları başka bir değişkene atandıktan sonra hala geçerli hale getirir.</p>
<p>Rust, tür veya türün herhangi bir parçası <code>Drop</code> tanımını süreklemişse, bir türe <code>Copy</code> ile açıklama eklememize izin vermez. 
Değer kapsam dışına çıktığında türün özel bir şeye ihtiyacı varsa ve bu türe <code>Copy</code> ek açıklamasını eklersek, 
bir derleme zamanı hatası alırız. Niteliği uygulamak için <code>Copy</code> ek açıklamasını türünüze nasıl ekleyeceğinizi öğrenmek için 
Ek C'deki <a href="appendix-03-derivable-traits.html">“Türetilebilir Tanımlar”</a><!-- ignore --> başlığına bakın.</p>
<p>Peki, <code>Copy</code> tanımını hangi türler sürekler? Emin olmak için verilen türün dokümantasyonunu kontrol edebilirsiniz, 
ancak genel bir kural olarak, herhangi bir basit skaler değer grubu <code>Copy</code>'i sürekleyebilir. 
<code>Copy</code>'i sürekleyen türlerden bazıları şunlardır:</p>
<ul>
<li>Tüm tam sayı türleri, meselax <code>u32</code>.</li>
<li>Boole türü, <code>bool</code>, <code>true</code> ve <code>false</code>.</li>
<li>Tüm kayan nokta türleri, mesela <code>f64</code>.</li>
<li>Karakter türü, <code>char</code>.</li>
<li>Demetler, eğer tutulan tür de <code>Copy</code>'i süreklemiş ise. Mesela,
<code>(i32, i32)</code>, <code>Copy</code>i sürekler fakat <code>(i32, String)</code> süreklemez.</li>
</ul>
<h3 id="sahiplik-ve-fonksiyonlar"><a class="header" href="#sahiplik-ve-fonksiyonlar">Sahiplik ve Fonksiyonlar</a></h3>
<p>Bir fonksiyona değer aktarmanın mekanikleri, bir değişkene değer atamaya benzer. 
Bir fonksiyona değişken iletmek, tıpkı atamada olduğu gibi taşınır veya kopyalanır. 
Liste 4-3, değişkenlerin nerede kapsam içine girip nerede kapsam dışında kaldığını 
gösteren bazı açıklamalar içeren bir örneğe sahiptir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it's okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!(&quot;{}&quot;, some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!(&quot;{}&quot;, some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
</code></pre></pre>
<p><span class="caption">Liste 4-3: Sahiplik ve kapsam açıklamalı fonksiyonlar</span></p>
<p><code>takes_ownership</code> çağrısından sonra <code>s</code>'i kullanmaya çalışırsak, 
Rust bir derleme zamanı hatası verir. Bu tarz statik kontroller bizi hatalardan korur. 
Bunları nerede kullanabileceğinizi ve sahiplik kurallarının bunu yapmanızı nerede engellediğini görmek 
için <code>s</code> ve <code>x</code> kullanan kodu <code>main</code>'e eklemeyi deneyin.</p>
<h3 id="dönüş-değerleri-ve-kapsam"><a class="header" href="#dönüş-değerleri-ve-kapsam">Dönüş Değerleri ve Kapsam</a></h3>
<p>Dönen değerler de sahipliği aktarabilir. 
Liste 4-4, Liste 4-3'tekilere benzer açıklamalarla bir değer döndüren bir fonksiyon örneğini gösterir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from(&quot;hello&quot;);     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -&gt; String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from(&quot;yours&quot;); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// This function takes a String and returns one
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
</code></pre></pre>
<p><span class="caption">Liste 4-4: Dönüş değerlerinin sahipliğini aktarma</span></p>
<p>Bir değişkenin sahipliği her seferinde aynı kalıbı takip eder: 
başka bir değişkene bir değer atamak onu hareket ettirir. 
Yığın üzerindeki verileri içeren bir değişken kapsam dışına çıktığında, 
verilerin sahipliği başka bir değişkene taşınmadıkça değer <code>drop</code> ile temizlenir.</p>
<p>Bu işe yararken, sahiplik almak ve ardından her fonksiyonla birlikte sahipliğini iade etmek biraz sıkıcıdır. 
Ya bir fonksiyonun bir değer kullanmasına izin vermek istiyorsak ancak sahipliğini almak istemiyorsak? 
Döndürmek isteyebileceğimiz fonksiyonun gövdesinden kaynaklanan herhangi bir veriye ek olarak, 
tekrar kullanmak istiyorsak ilettiğimiz herhangi bir şeyin de geri iletilmesinin gerekmesi oldukça can sıkıcıdır.</p>
<p>Rust, Liste 4-5'te gösterildiği gibi, bir demet kullanarak birden çok değer döndürmemize izin verir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
</code></pre></pre>
<p><span class="caption">Liste 4-5: Parametrelerin sahipliğini geri döndürme</span></p>
<p>Ancak bu, yaygın olması gereken bir konsept için çok fazla başımıza iş açıyor. 
Şansımıza Rust, <em>referans</em> adı verilen, sahipliği devretmeden bir değeri kullanma özelliğine sahip.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="referanslar-ve-Ödünç-alma"><a class="header" href="#referanslar-ve-Ödünç-alma">Referanslar ve Ödünç Alma</a></h2>
<p>Liste 4-5'teki tanımlama grubu koduyla ilgili sorun, <code>String</code>'i çağıran fonksiyona döndürmemizi gerektirmesidir, 
böylece <code>String</code>, <code>calculate_length</code> çağrısından sonra hala <code>String</code>'i kullanabiliriz, çünkü <code>String</code>, içine taşınmıştır. 
Bunun yerine, <code>String</code> değerine bir referans sağlayabiliriz. Referans, bir işaretçi gibidir, çünkü o adreste depolanan verilere erişmek için takip edebileceğimiz bir adrestir; bu veriler başka bir değişkene aittir. Bir işaretçiden farklı olarak, bir referansın, o referansın ömrü boyunca belirli bir türün geçerli bir değerine işaret etmesi garanti edilir. Değerin sahipliğini almak yerine parametre olarak bir nesneye referansı olan bir 
<code>calculate_length</code> fonksiyonunu nasıl tanımlayacağınız ve kullanacağınız aşağıda açıklanmıştır:</p>
<p>Değerin sahipliğini almak yerine parametre olarak bir nesneye referansı olan bir <code>calculate_length</code> fonksiyonunu nasıl tanımlayacağınız ve 
kullanacağınız aşağıda açıklanmıştır:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>İlk olarak, değişken bildirimindeki tüm tanımlama grubu kodunun ve fonksiyonun dönüş değerinin kaybolduğuna dikkat edin. 
İkinci olarak, <code>&amp;s1</code>'i <code>calculate_length</code>'e ilettiğimizi ve tanımında <code>String</code> yerine <code>&amp;String</code>'i kullandığımızı unutmayın. 
Bu ve bunun işaretleri, <em>referansları</em> temsil eder ve sahipliğini almadan bazı değerlere başvurmanıza izin verir. 
Şekil 4-5 bu konsepti tasvir ediyor.</p>
<img alt="&amp;String s String s1'e işaret ediyor" src="img/trpl04-05.svg" class="center" />
<p><span class="caption">Şekil 4-5: <code>String s1</code>'i gösteren <code>&amp;String s</code> diyagramı</span></p>
<blockquote>
<p>Not: <code>&amp;</code> kullanılarak yapılan referansın tersi, referanstan çıkarma operatörü <code>*</code> ile 
gerçekleştirilen <em>referanstan çıkarma</em>'dır. Bölüm 8'de referans kaldırma operatörünün 
bazı kullanımlarını göreceğiz ve 
Bölüm 15'te referans kaldırmanın ayrıntılarını tartışacağız.</p>
</blockquote>
<p>Fonksiyon çağrısına daha yakından bakalım:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);
<span class="boring">
</span><span class="boring">    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}
</span></code></pre></pre>
<p><code>&amp;s1</code> söz dizimi, <code>s1</code> değerine refere eden ancak kendisine ait olmayan bir referans oluşturmamıza izin verir. 
Kendisine ait olmadığı için, referansın kullanımı durduğunda işaret ettiği değer düşürülmeyecektir. 
Benzer şekilde, fonksiyonun imzası, <code>s</code> parametresinin türünün bir referans olduğunu belirtmek için <code>&amp;</code> kullanır. </p>
<p>Bazı açıklayıcı notlar ekleyelim:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from(&quot;hello&quot;);
</span><span class="boring">
</span><span class="boring">    let len = calculate_length(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
</span><span class="boring">}
</span><span class="boring">
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s is a reference to a String
    s.len()
} // Here, s goes out of scope. But because it does not have ownership of what
  // it refers to, it is not dropped.
</code></pre></pre>
<p><code>s</code> değişkeninin geçerli olduğu kapsam, herhangi bir fonksiyonla aynıdır.
Sahipliği olmadığı için <code>s</code> kullanımı durduğunda parametrenin kapsamı bırakılır. 
Ancak referansın gösterdiği değer bırakılmaz.
Sahipliği geri vermek için değerleri döndürmelisiniz, çünkü hiç sahibi olmadınız.</p>
<p>Peki ödünç aldığımız bir şeyi değiştirmeye çalışırsak ne olur?
Liste 4-6'daki kodu deneyin. Uyarı: çalışmıyor!</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from(&quot;hello&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>
<p><span class="caption">Liste 4-6: Ödünç alınan bir değeri değiştirmeye çalışmak</span></p>
<p>İşte hata:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut String`
8 |     some_string.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Değişkenler varsayılan olarak değişmez olduğu gibi, referanslar da öyledir. 
Referansımız olan bir şeyi değiştirmemize izin verilmez.</p>
<h3 id="değişebilir-referanslar"><a class="header" href="#değişebilir-referanslar">Değişebilir Referanslar</a></h3>
<p>Liste 4-6'daki kodu, ödünç alınan bir değeri, bunun yerine <em>değişken bir referans</em> kullanan sadece birkaç küçük ince ayar ile 
değiştirmemize izin verecek şekilde düzeltebiliriz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<p>İlk olarak, <code>s</code>'i <code>mut</code> olarak değiştiriyoruz. 
Sonra <code>&amp;mut s</code> ile değiştirilebilen bir referans yaratır ve burada <code>change</code> fonksiyonunu çağırırız ve 
fonksiyon imzasını, <code>some_string: &amp;mut String</code> ile değiştirilebilir bir referansı kabul edecek şekilde güncelleriz. 
Bu, <code>change</code> fonksiyonunun ödünç aldığı değeri değiştireceğini açıkça ortaya koymaktadır.</p>
<p>Değişken referansların büyük bir kısıtlaması vardır: bir değere değiştirilebilir referansınız varsa, 
o değere başka referansınız olamaz. <code>s</code> için iki değişken referans oluşturmaya çalışan bu kod başarısız olur:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}
</span></code></pre>
<p>İşte hata:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Bu hata, <code>s</code>'i bir defada birden fazla değişken olarak ödünç alamayacağımız için bu kodun geçersiz olduğunu söylüyor. 
İlk değişken ödünç alma <code>r1</code>'dedir ve <code>println!</code>'de kullanılana kadar sürmelidir, ancak bu değişken referansın oluşturulması ve 
kullanımı arasında, <code>r2</code>'de <code>r1</code> ile aynı verileri ödünç alan başka bir değişken referans oluşturmaya çalıştık.</p>
<p>Aynı anda aynı verilere birden fazla değişken referansı engelleyen kısıtlama, değişkenliğe izin verir, 
ancak çok kontrollü bir şekilde. Bu, yeni Rustseverlerin uğraştığı bir şey çünkü çoğu dil, istediğiniz zaman 
değişkenliğe uğramanıza izin veriyor. Bu kısıtlamaya sahip olmanın yararı, Rust'ın derleme zamanında <em>veri yarışlarını</em> önleyebilmesidir. 
Bir veri yarışı, bir yarış durumuna benzer ve şu üç davranış gerçekleştiğinde gerçekleşir:</p>
<ul>
<li>İki veya daha fazla işaretçi aynı verilere aynı anda erişir.</li>
<li>Verilere yazmak için işaretçilerden en az biri kullanılıyor.</li>
<li>Verilere erişimi senkronize etmek için kullanılan hiçbir mekanizma yoktur.</li>
</ul>
<p><em>Veri yarışları</em> tanımsız davranışlara neden olur ve bunları çalışma zamanında izlemeye çalışırken 
teşhis edilmesi ve düzeltilmesi zor olabilir; Rust, veri yarışlarıyla dolu kodu derlemeyi reddederek bu sorunu önler!</p>
<p>Her zaman olduğu gibi, yeni bir kapsam oluşturmak için süslü parantezleri kullanabiliriz ve 
birden çok değişken referansa izin verebiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    {
        let r1 = &amp;mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<p>Rust, değiştirilebilir ve değişmez referansları birleştirmek için benzer bir kural uygular. Bu kod hata verir:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    let r3 = &amp;mut s; // BIG PROBLEM

    println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
<span class="boring">}
</span></code></pre>
<p>İşte hata:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Vay be! Aynı değere değişmez bir referansımız <em>varken</em> değiştirilebilir bir referansımız <em>da</em> olamaz.</p>
<p>Değişmez bir referansın kullanıcıları, değerin aniden altlarında değişmesini beklemezler! 
Bununla birlikte, birden fazla değişmez referansa izin verilir, çünkü yalnızca verileri okuyan hiç kimse, 
başka birinin verileri okumasını etkileme yeteneğine sahip değildir.</p>
<p>Bir referansın kapsamının tanıtıldığı yerden başladığını ve o referansın son kullanıldığı zamana kadar devam ettiğini unutmayın. 
Örneğin, değişmez referansların son kullanımı olan <code>println!</code>, değiştirilebilir referans tanıtılmadan önce gerçekleştiği için bu kod derlenecektir:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    println!(&quot;{} and {}&quot;, r1, r2);
    // variables r1 and r2 will not be used after this point

    let r3 = &amp;mut s; // no problem
    println!(&quot;{}&quot;, r3);
<span class="boring">}
</span></code></pre></pre>
<p>Değişmez <code>r1</code> ve <code>r2</code> referanslarının kapsamları <code>println!</code>'den sonra biter. Bu kapsamlar çakışmaz, bu nedenle bu koda izin verilir. 
Derleyicinin, kapsamın bitiminden önceki bir noktada bir referansın artık kullanılmadığını söyleyebilmesi, <em>Sözcük Dışı Ömürlükler</em> (kısaca NLL) 
olarak adlandırılır ve bununla ilgili daha fazla bilgiyi <a href="https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html">The Edition Guide</a>'dan okuyabilirsiniz.</p>
<p>Ödünç alma hataları bazen can sıkıcı olsa da, Rust derleyicisinin olası bir hatayı erkenden (çalışma zamanından ziyade derleme zamanında) 
ve sorunun tam olarak nerede olduğunu size gösterdiğini unutmayın. 
O zaman verilerinizin neden düşündüğünüz gibi olmadığını bulmak zorunda değilsiniz.</p>
<h3 id="sarkan-referanslar"><a class="header" href="#sarkan-referanslar">Sarkan Referanslar</a></h3>
<p>İşaretçileri olan dillerde, belleğin bir kısmını boşaltırken, o belleğe bir işaretçiyi koruyarak, 
yanlışlıkla sarkan bir işaretçi (bellekte başka birine verilmiş olabilecek bir konuma başvuran bir işaretçi) oluşturmak kolaydır. 
Buna karşılık Rust'ta derleyici, referansların asla sarkan referanslar olmayacağını garanti eder: 
eğer bazı verilere referansınız varsa, derleyici, veriye yapılan referanstan önce verilerin kapsam dışına çıkmamasını sağlayacaktır.</p>
<p>Rust'ın derleme zamanı hatasıyla bunları nasıl önlediğini görmek için sarkan bir referans oluşturmaya çalışalım:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<p>İşte hata:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Bu hata mesajı, henüz ele almadığımız bir özelliğe atıfta bulunuyor: ömürler. 
Ömürleri Bölüm 10'da ayrıntılı olarak tartışacağız. 
Ancak, ömürlerle ilgili kısımları göz ardı ederseniz, mesaj bu kodun neden bir sorun olduğunun anahtarını içerir:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
</code></pre>
<pre><code class="language-text">bu fonksiyonun dönüş türü ödünç alınan bir değer içeriyor, ancak ödünç alınacak bir değer yok
</code></pre>
<p><em>Sarkan</em> kodumuzun her aşamasında tam olarak neler olduğuna daha yakından bakalım.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_to_nothing = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // dangle returns a reference to a String

    let s = String::from(&quot;hello&quot;); // s is a new String

    &amp;s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
</code></pre>
<p><code>s</code>, <code>dangle</code> içinde oluşturulduğundan, <code>dangle</code> kodu bittiğinde, <code>s</code> serbest bırakılır. 
Ama ona bir referans döndürmeye çalıştık. Bu, bu referansın geçersiz bir <code>String</code>'e işaret edeceği anlamına gelir. 
Bu iyi bir fikir değildir! Rust bunu yapmamıza izin vermez.</p>
<p>Buradaki çözüm, <code>String</code>'i doğrudan döndürmektir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string = no_dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
</code></pre></pre>
<p>Bu herhangi bir sorun olmadan çalışır. Sahiplik taşınır ve hiçbir şey serbest bırakılmaz.</p>
<h3 id="referans-kuralları"><a class="header" href="#referans-kuralları">Referans Kuralları</a></h3>
<p>Referanslar hakkında konuştuklarımızı gözden geçirelim:</p>
<ul>
<li>
<p>Herhangi bir zamanda <em>ya</em> bir değişken referansa <em>ya da</em> 
istediğiniz sayıda değişmez referansa sahip olabilirsiniz.</p>
</li>
<li>
<p>Referanslar her zaman geçerli olmalıdır.</p>
</li>
</ul>
<p>Bundan sonraki başlığımızda, farklı bir referans türü olan <em>dilimlere</em> bakacağız.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dilim-türü"><a class="header" href="#dilim-türü">Dilim Türü</a></h2>
<p><em>Dilimler</em>, koleksiyonun tamamı yerine bir koleksiyondaki bitişik bir öğe dizisine başvurmanıza izin verir. 
Bir dilim bir tür referanstır, dolayısıyla sahipliği yoktur.</p>
<p>İşte küçük bir programlama problemi: boşluklarla ayrılmış bir dizi sözcük alan ve bu dizgide bulduğu 
ilk sözcüğü döndüren bir fonksiyon yazın. Fonksiyon dizgide bir boşluk bulamazsa, dizgi döndürülmelidir.</p>
<p>Dilimlerin çözeceği problemi anlamak için dilimleri kullanmadan bu fonksiyonun imzasını 
nasıl yazacağımız üzerinde çalışalım:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<p><code>first_word</code> fonksiyonu, parametre olarak bir <code>&amp;String</code>'e sahiptir. 
Sahiplik istemiyoruz, bu yüzden referansını kullanıyoruz. 
Ama neyi iade etmeliyiz? Bir dizginin bir <em>parçası</em> hakkında konuşmanın gerçekten bir yolu yok. 
Ancak, bir boşlukla gösterilen kelimenin sonunun indeksini döndürebiliriz. </p>
<p>Bunu Liste 4-7'de gösterildiği gibi deneyelim.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Liste 4-7: <code>String</code> parametresine bir bayt indeks değeri döndüren <code>first_word</code> fonksiyonu</span></p>
<p><code>String</code> öğesini eleman bazında gözden geçirmemiz ve bir değerin boşluk olup olmadığını kontrol etmemiz gerektiğinden, 
<code>as_bytes</code> metodunu kullanarak <code>String</code>'imizi bir bayt dizgisine dönüştüreceğiz:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Ardından, <code>iter</code> metodunu kullanarak bayt dizgisi üzerinde bir yineleyici oluştururuz.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Yineleyicileri <a href="ch13-02-iterators.html">Bölüm 13</a><!-- ignore -->'te daha ayrıntılı olarak tartışacağız. 
Şimdilik, <code>iter</code>'ın bir koleksiyondaki her öğeyi döndüren bir metod olduğunu ve numaralandırmanın yinelemenin 
sonucunu sararak bunun yerine her öğeyi bir demetin parçası olarak döndürdüğünü bilin. </p>
<p>Numaralandırmadan döndürülen grubun ilk öğesi indekstir ve ikinci öğe öğeye bir referanstır. </p>
<p>Bu, indeksi kendimiz hesaplamaktan biraz daha uygundur.</p>
<p>Numaralandırma metodu bir tanımlama grubu döndürdüğü için, bu tanımlama grubunu yok etmek için modelleri kullanabiliriz. 
Modelleri Bölüm 6'da daha fazla tartışacağız. <code>for</code> döngüsünde, tanımlama grubundaki indeks için <code>i</code> ve 
tanımlama grubundaki tek bayt için <code>&amp;item</code> içeren bir model belirledik. <code>.iter().enumerate()</code> öğesinden öğeye bir referans aldığımız için, 
kalıpta <code>&amp;</code> kullanırız.</p>
<p><code>for</code> döngüsünün içinde, değişmez bayt söz dizimini kullanarak alanı temsil eden baytı ararız. 
Bir boşluk bulursak, konumu döndürürüz. 
Aksi takdirde, <code>s.len()</code> kullanarak dizginin uzunluğunu döndürürüz:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Artık dizgideki ilk kelimenin sonunun indeksini bulmanın bir yolu var, ancak bir sorun var. 
<code>usize</code>'ı kendi başına döndürüyoruz, ancak bu yalnızca <code>&amp;String</code> bağlamında anlamlı bir sayıdır. 
Başka bir deyişle, <code>String</code>'den ayrı bir değer olduğu için gelecekte hala geçerli olacağının garantisi yoktur. 
Liste 4-7'deki <code>first_word</code> fonksiyonunu kullanan Liste 4-8'deki programı düşünün.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to &quot;&quot;

    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
}
</code></pre></pre>
<p><span class="caption">Liste 4-8: <code>first_word</code> fonksiyonunun sonucunu saklama ve 
ardından <code>String</code> içeriğini değiştirme</span></p>
<p>Bu program hatasız derlenir ve <code>s.clear()</code>'ı çağırdıktan sonra 
<code>word</code> kullansaydık da derlenecekti. <code>word</code>, <code>s</code> durumuna hiç bağlı olmadığı için, <code>word</code> <code>5</code> değerini içerir. 
İlk <code>word</code>'ü çıkarmaya çalışmak için bu <code>5</code> değerini <code>s</code> değişkeni ile kullanabiliriz, 
ancak bu bir hata olur çünkü <code>word</code>'e <code>5</code>'i atadığımızdan beri <code>s</code>'in içeriği değişti.</p>
<p><code>word</code>'deki indeksin <code>s</code>'deki verilerle senkronizasyondan çıkması konusunda endişelenmek sıkıcı ve hataya açık! 
Bir <code>second_word</code> fonksiyonu yazarsak, bu dizginleri yönetmek daha rahat olacak. Yapısı şöyle görünmelidir:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>Şimdi bir başlangıç ve bitiş indeksini izliyoruz ve belirli bir durumdaki verilerden hesaplanan ancak bu duruma hiç 
bağlı olmayan daha da fazla değere sahibiz. Senkronize tutulması gereken, etrafta dolaşan üç alakasız değişkenimiz var.</p>
<p>Şansımıza ki, Rust'ın bu soruna bir çözümü var: <code>String</code> dilimleri.</p>
<h3 id="dizgi-dilimleri"><a class="header" href="#dizgi-dilimleri">Dizgi Dilimleri</a></h3>
<p><em>Dizgi dilimi</em>, bir dizginin parçasına yapılan bir başvurudur ve şöyle görünür:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello world&quot;);

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<p><code>hello</code>, <code>String</code>'in tamamına bir referans yerine, <code>String</code>'in fazladan <code>[0..5]</code> bitinde belirtilen bir bölümüne referanstır. <code>[starting_index..end_index]</code>'i belirterek parantez içinde bir aralık kullanarak dilimler oluştururuz, burada <code>starting_index</code> dilimdeki ilk konumdur ve <code>end_index</code> dilimdeki son konumdan bir fazlasıdır. Dahili olarak, dilim veri yapısı, son eksi başa karşılık gelen başlangıç konumunu ve dilimin uzunluğunu saklar. Yani <code>let world = &amp;s[6..11];</code> durumunda; <code>world</code> <code>s</code>'in indeks <code>6</code>'sındaki bayta işaretçi ve uzunluk değeri <code>5</code> olan bir dilim olacaktır.</p>
<img alt="world, s'in indeks 6'daki pointerını ve 5 uzunluğunu tutan işaretçiyi tutar" src="img/trpl04-06.svg" class="center" style="width: 50%;" />
<p><span class="caption">Şekil 4-6: Bir <code>String</code> parçasına atıfta bulunan dizgi dilimi
</span></p>
<p>Rust'ın <code>..</code> aralık söz dizimi ile indeks sıfırdan başlamak istiyorsanız, 
değeri iki noktadan önce bırakabilirsiniz. Başka bir deyişle, bunlar eşittir:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<p>Aynı şekilde, diliminiz <code>String</code>'in son baytını içeriyorsa, sondaki sayıyı bırakabilirsiniz.
Demek ki bunlar eşit:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<p>Ayrıca tüm dizgiden bir dilim almak için her iki değeri de bırakabilirsiniz:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Not: <code>String</code> dilim aralığı indeksleri, geçerli UTF-8 karakter sınırlarında oluşmalıdır. 
Çok baytlı bir karakterin ortasında bir dizgi dilimi oluşturmaya çalışırsanız, 
programınız bir hata ile çıkacaktır. Dize dilimlerini tanıtmak amacıyla, sadece bu bölümde ASCII'yi varsayıyoruz; 
UTF-8 işleme hakkında daha ayrıntılı bir tartışma, 
Bölüm 8'in <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">“UTF-8 Kodlu Metni Dizgilerde Depolama”</a><!-- ignore --> kısmındadır.</p>
</blockquote>
<p>Tüm bu bilgileri göz önünde bulundurarak, bir dilim döndürmek için <code>first_word</code>'ü yeniden yazalım. 
“Dizgi dilimi” anlamına gelen tür <code>&amp;str</code> olarak yazılır:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Bir boşluğun ilk oluşumunu arayarak, Liste 4-7'de yaptığımız gibi, kelimenin sonu için indeksi elde ederiz. 
Bir boşluk bulduğumuzda, başlangıç ve bitiş indeksleri olarak dizgenin başlangıcını ve boşluğun indeksini kullanarak bir dizgi dilimi 
döndürürüz.</p>
<p>Şimdi <code>first_word</code>'ü çağırdığımızda, temeldeki verilere bağlı tek bir değeri geri alıyoruz. Değer, dilimin başlangıç noktasına yapılan bir referanstan ve dilimdeki eleman sayısından oluşur.</p>
<p>Bir dilim döndürmek, <code>second_word</code> fonksiyonu için de işe yarar:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Derleyici, <code>String</code>'e yapılan referansların geçerli kalmasını sağlayacağından, artık karıştırılması çok daha zor olan basit bir API'ye sahibiz. 
Liste 4-8'deki programdaki hatayı hatırlıyor musunuz? İndeksi ilk kelimenin sonuna kadar aldık ama sonra dizgiyi temizledik, 
böylece dizgimiz geçersiz olmuştu. Bu kod mantıksal olarak yanlıştı ancak herhangi bir hata göstermemişti. 
İlk kelime dizgisini boş bir dizgiyle kullanmaya devam edersek, sorunlar daha sonra ortaya çıkacaktı. 
Dilimler bu hatayı imkansız kılar ve kodumuzla ilgili bir sorunumuz olduğunu çok daha erken bildirir. 
<code>first_word</code>'ün dilim sürümünü kullanmak derleme zamanı hatası verir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // error!

    println!(&quot;the first word is: {}&quot;, word);
}
</code></pre>
<p>Derleyici hatası:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!(&quot;the first word is: {}&quot;, word);
   |                                       ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>Ödünç alma kurallarından hatırlayın, eğer bir şeye değişmez bir referansımız varsa, 
aynı zamanda değişken bir referans alamayız. <code>clear</code>'ın <code>String</code>'i temizlemesi gerektiğinden, 
değişken bir referans alması gerekir. <code>println!</code> <code>clear</code> çağrısı <code>word</code>'deki referansı kullandıktan sonra, 
değişmez referansın o noktada hala aktif olması gerekir. Rust, <code>clear</code> değiştirilebilir referansın ve <code>word</code>'deki değişmez referansın aynı anda var olmasına izin vermez ve derleme başarısız olur. Rust yalnızca API'mizin kullanımını kolaylaştırmakla kalmadı, aynı zamanda derleme zamanında bir dizi hatayı da ortadan kaldırdı!</p>
<h4 id="dizgi-değişmezleri-bir-tür-dilimdir"><a class="header" href="#dizgi-değişmezleri-bir-tür-dilimdir">Dizgi Değişmezleri Bir Tür Dilimdir</a></h4>
<p>İkili dosyada saklanan dizgi değişmezlerinden bahsettiğimizi hatırlayın. Artık dilimleri bildiğimize göre, dizgi değişmezlerini doğru bir şekilde anlayabiliriz:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>Buradaki <code>s</code>'in türü <code>&amp;str</code>'dir: ikili dosyanın o belirli noktasına işaret eden bir dilimdir. 
Bu aynı zamanda dizgi değişmezlerinin değişmez olmasının nedenidir; <code>&amp;str</code> değişmez bir referanstır.</p>
<h4 id="parametre-olarak-dizgi-dilimleri"><a class="header" href="#parametre-olarak-dizgi-dilimleri">Parametre Olarak Dizgi Dilimleri</a></h4>
<p>Hazır bilgi ve <code>String</code> değerlerinin dilimlerini alabileceğinizi bilmek, 
bizi <code>first_word</code> üzerinde bir iyileştirmeye daha götürüyor ve bu da onun yapısı:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Daha deneyimli bir Rustsever, bunun yerine Liste 4-9'da gösterilen yapıyı kullanırdı çünkü aynı fonksiyonu hem 
<code>&amp;String</code> hem de <code>&amp;str</code> değerlerinde kullanmamıza izin verir.</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // `first_word` works on slices of `String`s, whether partial or whole
</span><span class="boring">    let word = first_word(&amp;my_string[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">    // `first_word` also works on references to `String`s, which are equivalent
</span><span class="boring">    // to whole slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // `first_word` works on slices of string literals, whether partial or whole
</span><span class="boring">    let word = first_word(&amp;my_string_literal[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 4-9: <code>s</code> parametresinin türü için bir dizgi dilimi kullanarak <code>first_word</code> 
fonksiyonunu geliştirme</span></p>
<p>Eğer elimizde bir dizgi dilimi varsa onu direkt argüman olarak verebiliriz. 
Bir <code>String</code>'imiz varsa, <code>String</code>'in bir dilimini veya <code>String</code>'e bir referansı iletebiliriz. 
Bu esneklik, Bölüm 15'in <a href="ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">“Fonksiyonlar ve Metodlarla Örtülü Deref Zorlamaları”</a><!--ignore--> bölümünde ele alacağımız bir özellik olan deref zorlamalarından yararlanır. 
Bir <code>String</code> referansı yerine bir dizgi dilimi alacak bir fonksiyon tanımlamak, 
API'mizi daha genel ve herhangi bir işlevsellik kaybetmeden kullanmamızı sağlar:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&amp;my_string);

    let my_string_literal = &quot;hello world&quot;;

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<h3 id="diğer-dilimler"><a class="header" href="#diğer-dilimler">Diğer Dilimler</a></h3>
<p>Dizgi dilimleri, tahmin edebileceğiniz gibi, dizgilere özgüdür. Ancak daha genel bir dilim türü de var. Bu diziyi düşünün:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Tıpkı bir dizginin bir kısmına atıfta bulunmak isteyebileceğimiz gibi, 
bir dizinin bir kısmına atıfta bulunmak isteyebiliriz. Biz böyle yapardık:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}
</span></code></pre></pre>
<p>Bu dilim <code>&amp;[i32]</code> türüne sahip. İlk öğeye ve bir uzunluğa bir referans depolayarak, 
dizgi dilimlerinin yaptığını yapar. Bu tür dilimi diğer tüm koleksiyonlar için kullanacaksınız. 
Bölüm 8'de vektörler hakkında konuşurken bu koleksiyonları ayrıntılı olarak tartışacağız.</p>
<h2 id="Özet-2"><a class="header" href="#Özet-2">Özet</a></h2>
<p>Sahiplik, ödünç alma ve dilim kavramları, derleme zamanında Rust programlarında bellek güvenliğini sağlar. 
Rust dili, diğer sistem programlama dilleriyle aynı şekilde bellek kullanımınız üzerinde kontrol sağlar, 
ancak veri sahibinin kapsam dışına çıktığında bu verileri otomatik olarak temizlemesi, fazladan kod yazmanız ve 
hata ayıklamanız gerekmediği anlamına gelir. Bu kontrolü elde etmek için.</p>
<p>Sahiplik, Rust'ın diğer birçok bölümünün nasıl çalıştığını etkiler, bu yüzden kitabın geri kalanında bu kavramlar 
hakkında daha fazla konuşacağız. Bölüm 5'e geçelim ve veri parçalarını bir <code>struct</code> içinde gruplandırmaya bakalım.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="İlgili-verileri-yapılandırmak-için-yapıları-kullanma"><a class="header" href="#İlgili-verileri-yapılandırmak-için-yapıları-kullanma">İlgili Verileri Yapılandırmak için Yapıları Kullanma</a></h1>
<p><em>Yapı</em>, ya da <em>yapı :)</em>, anlamlı bir grup oluşturan ilgili birden çok değeri bir araya getirmenize ve adlandırmanıza olanak tanıyan özel bir veri türüdür. Nesne yönelimli bir dile aşina iseniz, <em>yapı</em> bir nesnenin veri tanımlayıcıları gibidir. 
Bu bölümde, zaten bildiklerinizin üzerine inşa etmek ve yapıların ne zaman verileri gruplamak için daha iyi bir yol olduğunu göstermek için demet türlerini yapılarla karşılaştıracağız. Yapıların nasıl tanımlanacağını ve somutlaştırılacağını göstereceğiz. Bir yapı türüyle ilişkili davranışı belirtmek için ilişkili fonksiyonların, özellikle <em>metod</em> adı verilen ilişkili fonksiyonların nasıl tanımlanacağını tartışacağız. Yapılar ve numaralandırılmış yapılar (Bölüm 6'da ele alınmıştır), Rust'ın derleme zamanı tür kontrolünden tam olarak yararlanmak için programınızın etki alanında yeni türler oluşturmak için yapı taşlarıdır.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="yapıları-tanımlama-ve-Örnekleme"><a class="header" href="#yapıları-tanımlama-ve-Örnekleme">Yapıları Tanımlama ve Örnekleme</a></h2>
<p>Yapılar, her ikisinin de birden çok ilişkili değeri içermesi bakımından <a href="ch03-02-data-types.html#the-tuple-type">“Demet Türü”</a><!--
ignore --> bölümünde tartışılan demetlere benzer. Demetler gibi, bir yapının parçaları farklı türleri olabilir. 
Demetlerden farklı olarak, bir yapı içinde, değerlerin ne anlama geldiğini netleştirmek için her bir veri parçasını adlandıracaksınız. 
Bu adların eklenmesi, yapıların tanımlama gruplarından daha esnek olduğu anlamına gelir: bir örneğin değerlerini belirtmek veya bunlara erişmek için verilerin sırasına güvenmeniz gerekmez.</p>
<p>Bir yapı tanımlamak için, <code>struct</code> anahtar sözcüğünü girer ve tüm yapıyı adlandırırız. Bir yapının adı, birlikte gruplandırılan veri parçalarının önemini açıklamalıdır. Ardından süslü parantezler içinde <em>üye</em> dediğimiz veri parçalarının adlarını ve türlerini tanımlarız. 
Örneğin, Liste 5-1, bir kullanıcı hesabı hakkında bilgi depolayan bir yapı gösterir.</p>
<pre><pre class="playground"><code class="language-rust">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Liste 5-1: Bir <code>User</code> yapı tanımı</span></p>
<p>Bir yapıyı tanımladıktan sonra kullanmak için, üyelerin her biri için somut değerler belirterek o yapının bir <em>örneğini</em> yaratırız. 
Yapının adını belirterek bir örnek oluşturuyoruz ve ardından anahtarların üye adları olduğu ve değerlerin bu üyelerde depolamak istediğimiz veriler olduğu anahtar: değer çiftlerini içeren süslü parantezleri ekliyoruz. 
Üyeleri <code>struct</code> içinde belirttiğimiz sırayla belirtmemize gerek yok. 
Başka bir deyişle, <code>struct</code> tanımı, tür için genel bir şablon gibidir ve örnekler, 
türün değerlerini oluşturmak için bu şablonu belirli verilerle doldurur. 
Örneğin, Liste 5-2'de gösterildiği gibi belirli bir kullanıcıyı bildirebiliriz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };
}
</code></pre></pre>
<p><span class="caption">Liste 5-2: <code>User</code> yapısının bir örneğini oluşturma</span></p>
<p>Bir yapıdan belirli bir değer elde etmek için nokta gösterimini kullanırız. 
Örneğin, bu kullanıcının e-posta adresine erişmek için <code>user1.email</code> kullanıyoruz. 
Örnek değişken ise, nokta gösterimini kullanarak ve belirli bir alana atayarak bir değeri değiştirebiliriz. Liste 5-3, 
değiştirilebilir bir <code>User</code> örneğinin <code>email</code> alanındaki değerin nasıl değiştirileceğini gösterir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from(&quot;anotheremail@example.com&quot;);
}
</code></pre></pre>
<p><span class="caption">Liste 5-3: Bir <code>User</code> örneğinin <code>email</code> alanındaki değeri değiştirme</span></p>
<p>Tüm örneğin değiştirilebilir olması gerektiğini unutmayın; Rust, yalnızca belirli alanları değiştirilebilir olarak 
işaretlememize izin verme. Herhangi bir ifadede olduğu gibi, bu yeni örneği örtük olarak döndürmek 
için fonksiyon gövdesindeki son ifade olarak yapının yeni bir örneğini oluşturabiliriz.</p>
<p>Liste 5-4, verilen <code>email</code> ve <code>username</code> ile bir <code>User</code> örneği döndüren bir <code>build_user</code> fonksiyonunu gösterir. 
<code>active</code> üyesi <code>true</code> değerini, <code>sign_in_count</code> ise <code>1</code> değerini alır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        String::from(&quot;someusername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 5-4: Bir e-posta ve kullanıcı adı alan ve bir <code>User</code> 
örneği döndüren bir <code>build_user</code> fonksiyonu</span></p>
<p>Fonksiyon parametrelerini yapı üyeleriyle aynı adla adlandırmak mantıklıdır, 
ancak <code>email</code> ve <code>username</code> üye adlarını ve değişkenlerini tekrarlamak biraz sıkıcıdır. 
Yapının daha fazla üyesi olsaydı, her adı tekrarlamak daha da can sıkıcı olurdu. </p>
<p>Neyse ki, uygun bir kısayol var!</p>
<p><a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a></p>
<h3 id="Üye-başlatıcı-kısayolu-kullanma"><a class="header" href="#Üye-başlatıcı-kısayolu-kullanma">Üye Başlatıcı Kısayolu Kullanma</a></h3>
<p>Parametre adları ve yapı üye adları Liste 5-4'te tamamen aynı olduğundan, 
<code>build_user</code>'ı yeniden yazmak için üye başlatıcı kısayolu söz dizimini kullanabiliriz, 
böylece tam olarak aynı şeyi elde ederiz ve <code>email</code> ve <code>username</code> tekrarı olmaz. Liste 5-5'te gösterilmiştir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        String::from(&quot;someusername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 5-5: <code>email</code> ve <code>username</code> parametreleri yapı üyeleriyle 
aynı ada sahip olduğundan üye başlatıcı kısayolunu kullanan <code>build_user</code> fonksiyonu</span></p>
<p>Burada, <code>email</code> adlı bir üyeye sahip olan <code>User</code> yapısının yeni bir örneğini oluşturuyoruz. 
<code>email</code> üyesinin değerini <code>build_user</code> fonksiyonunun <code>email</code> parametresindeki değere atamak istiyoruz. 
<code>email</code> üyesi ve <code>email</code> parametresi aynı ada sahip olduğundan, <code>email: email</code> yerine sadece <code>email</code> yazmamız gerekiyor.</p>
<h3 id="yapı-güncelleme-söz-dizimi-ile-diğer-Örneklerden-Örnekler-oluşturma"><a class="header" href="#yapı-güncelleme-söz-dizimi-ile-diğer-Örneklerden-Örnekler-oluşturma">Yapı Güncelleme Söz Dizimi ile Diğer Örneklerden Örnekler Oluşturma</a></h3>
<p>Başka bir örnekteki değerlerin çoğunu içeren ancak bazılarını değiştiren bir yapının 
yeni bir örneğini oluşturmak genellikle yararlıdır. Bunu <em>yapı güncelleme söz dizimini</em> kullanarak yapabilirsiniz.</p>
<p>İlk olarak, Liste 5-6'da, güncelleme söz dizimi olmadan <code>user2</code>'de düzenli olarak yeni bir <code>User</code> örneğinin nasıl oluşturulacağını 
gösteriyoruz. <code>email</code> için yeni bir değer belirledik, ancak bunun dışında <code>user1</code>'den Liste 5-2'de oluşturduğumuz aynı değerleri kullanıyoruz</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from(&quot;another@example.com&quot;),
        sign_in_count: user1.sign_in_count,
    };
}
</code></pre></pre>
<p><span class="caption">Liste 5-6: <code>user1</code>'deki değerlerden birini kullanarak yeni bir <code>User</code> 
örneği oluşturma</span></p>
<p><em>Yapı güncelleme söz dizimini</em> kullanarak, Liste 5-7'de gösterildiği gibi aynı etkiyi daha az kodla elde edebiliriz. 
<code>..</code> söz dizimi, açıkça ayarlanmayan kalan üyelerin verilen örnekteki üyelerle aynı değere sahip olması gerektiğini belirtir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        email: String::from(&quot;another@example.com&quot;),
        ..user1
    };
}
</code></pre></pre>
<p><span class="caption">Liste 5-7: Bir <code>User</code> örneği için yeni bir <code>email</code> değeri ayarlamak için <em>yapı güncelleme söz dizimini</em> 
<code>user1</code>'den kalan değerlerle kullanmak.</span></p>
<p>Liste 5-7'deki kod ayrıca <code>user2</code>'de <code>email</code> için farklı bir değere sahip olan ancak <code>user1</code>'den <code>username</code>, <code>active</code> ve <code>sign_in_count</code> üyeleri için aynı değerlere sahip bir örnek oluşturur. 
<code>..user1</code>'de kalan üyelerin değerlerini <code>user1</code>'deki karşılık gelen üyelerden alması gerektiğini belirtmek için en son gelmelidir, 
ancak üyelerin sırasına bakılmaksızın herhangi bir sırayla istediğimiz kadar üye için değer belirtmeyi seçebiliriz.</p>
<p>Yapı güncelleme söz diziminin bir atama gibi <code>=</code> kullandığını unutmayın; bunun nedeni, tıpkı <a href="ch04-01-what-is-ownership.html#ways-variables-and-data-interact-move">“Değişkenlerin ve Veri Etkileşiminin Yolları: 
Hareket Ettirme”</a><!-- ignore --> bölümünde gördüğümüz gibi verileri hareket ettirmesidir. 
Bu örnekte, <code>user1</code>'in <code>username</code> üyesindeki <code>String</code>, <code>user2</code>'ye taşındığından, <code>user2</code> oluşturulduktan sonra artık 
<code>user1</code>'i kullanamayız. <code>user2</code>'ye hem <code>email</code> hem de <code>username</code> için yeni <code>String</code> değerleri vermiş olsaydık ve 
bu nedenle yalnızca <code>user1</code>'den <code>active</code> ve <code>sign_in_count</code> değerlerini kullansaydık, o zaman <code>user1</code>, <code>user2</code> oluşturulduktan sonra da 
geçerli olurdu. <code>active</code> ve <code>sign_in_count</code> türleri, <code>Copy</code> tanımını uygulayan türlerdir, bu nedenle 
<a href="ch04-01-what-is-ownership.html#stack-only-data-copy">“Sadece Yığıtı Kullanan Tür: Copy”</a><!-- ignore --> bölümünde tartıştığımız davranış geçerli olur.</p>
<h3 id="farklı-türler-oluşturmak-için-adlandırılmış-alanlar-olmadan-demet-yapılarını-kullanma"><a class="header" href="#farklı-türler-oluşturmak-için-adlandırılmış-alanlar-olmadan-demet-yapılarını-kullanma">Farklı Türler Oluşturmak için Adlandırılmış Alanlar Olmadan Demet Yapılarını Kullanma</a></h3>
<p>Rust ayrıca, <em>demet yapıları</em> adı verilen demetlere benzeyen yapıları da destekler. 
Demet yapıları, yapı adının sağladığı ek anlama sahiptir, ancak alanlarıyla ilişkilendirilmiş adları yoktur; 
daha ziyade, sadece alanların türlerine sahiptirler. Demet yapıları, tüm demete bir ad vermek ve demeti diğer demetlerden farklı bir tür yapmak istediğinizde ve her alanı normal bir yapıdaki gibi adlandırmak ayrıntılı veya gereksiz olduğunda yararlıdır.</p>
<p>Bir demet yapısı tanımlamak için, <code>struct</code> anahtar sözcüğü ve yapı adıyla başlayın ve ardından demetteki türleri takip edin. 
Örneğin, burada <code>Color</code> ve <code>Point</code> adında iki demet yapısı tanımlıyor ve kullanıyoruz:</p>
<pre><pre class="playground"><code class="language-rust">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
</code></pre></pre>
<p><code>black</code> ve <code>origin</code> değerlerinin farklı türler olduğuna dikkat edin, çünkü bunlar farklı demet yapılarının örnekleridir. 
Tanımladığınız her yapı, yapı içindeki üyeler aynı türlere sahip olsa bile kendine özgü türe sahiptir. Örneğin, <code>Color</code> türünde bir parametre 
alan bir fonksiyon, her iki tür de üç <code>i32</code> değerinden oluşsa bile argüman olarak bir <code>Point</code> alamaz.</p>
<h3 id="Üyesiz-birim-benzeri-yapılar"><a class="header" href="#Üyesiz-birim-benzeri-yapılar">Üyesiz Birim Benzeri Yapılar</a></h3>
<p>Ayrıca üyesi olmayan yapılar da tanımlayabilirsiniz! Bunlara <em>birim benzeri yapılar</em> denir, çünkü <a href="ch03-02-data-types.html#the-tuple-type">“Demet Türü”</a><!-- ignore --> bölümünde 
bahsettiğimiz birim tipine <code>()</code> benzer şekilde davranırlar. Birim benzeri yapılar, bir tür üzerinde bir özellik uygulamanız gerektiğinde ancak türün kendisinde depolamak istediğiniz herhangi bir veriniz olmadığında faydalı olabilir. Nitelikleri Bölüm 10'da tartışacağız. 
İşte <code>AlwaysEqual</code> adlı bir birim yapısının bildirilmesine ve somutlaştırılmasına bir örnek:</p>
<pre><pre class="playground"><code class="language-rust">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
</code></pre></pre>
<p><code>AlwaysEqual</code>'ı tanımlamak için <code>struct</code> anahtar sözcüğünü, istediğimiz adı ve ardından noktalı virgül kullanırız. 
Süslü parantezlere veya parantezlere gerek yok! Daha sonra, benzer bir şekilde konu değişkeninde <code>AlwaysEqual</code> örneğini alabiliriz: 
tanımladığımız adı kullanarak, herhangi bir süslü parantez kullanmadan. Daha sonra, her <code>AlwaysEqual</code> örneğinin her zaman diğer herhangi bir türün her örneğine eşit olduğu, belki de test amacıyla bilinen bir sonuca sahip olacak şekilde bu tür için davranış uygulayacağımızı hayal edin. Bu davranışı uygulamak için herhangi bir veriye ihtiyacımız olmazdı! Bölüm 10'da özelliklerin nasıl tanımlanacağını ve birim benzeri yapılar da dahil olmak üzere herhangi bir türe nasıl uygulanacağını göreceksiniz.</p>
<blockquote>
<h3 id="yapı-verilerinin-sahipliği"><a class="header" href="#yapı-verilerinin-sahipliği">Yapı Verilerinin Sahipliği</a></h3>
<p>Liste 5-1'deki <code>User</code> yapısı tanımında, <code>&amp;str</code> dizgi dilim tipi yerine sahip olunan <code>String</code> tipini kullandık. 
Bu bilinçli bir seçimdir çünkü bu yapının her örneğinin tüm verilerine sahip olmasını ve 
bu verilerin tüm yapı geçerli olduğu sürece geçerli olmasını istiyoruz.</p>
<p>Yapıların başka bir şeye ait verilere başvuruları depolaması da mümkündür, ancak bunu yapmak için yaşam sürelerinin kullanılması gerekir; 
bu, Bölüm 10'da tartışacağımız bir Rust özelliğidir. Ömürler, bir yapı tarafından başvurulan verilerin aşağıdakiler için geçerli olmasını 
sağlar. yapı olduğu sürece. Diyelim ki aşağıdaki gibi yaşam süreleri belirtmeden bir <code>struct</code> içinde bir referans depolamaya çalışıyorsunuz; 
bu işe yaramaz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<!-- AYRIŞTIRAMIYOR İMİŞ (CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127) -->
<pre><code class="language-rust ignore does_not_compile">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre>
<p>Derleyici, ömürlük belirteçlere ihtiyaç duyduğundan hata verecektir:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` due to 2 previous errors
</code></pre>
<p>Bölüm 10'da, referansları yapılarda saklayabilmeniz için bu hataların nasıl düzeltileceğini tartışacağız, 
ancak şimdilik, <code>&amp;str</code> gibi referanslar yerine <code>String</code> gibi sahip olunan türleri kullanarak bu gibi hataları 
düzelteceğiz.</p>
</blockquote>
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="yapıları-kullanan-Örnek-bir-program"><a class="header" href="#yapıları-kullanan-Örnek-bir-program">Yapıları Kullanan Örnek Bir Program</a></h2>
<p>Yapıları ne zaman kullanmak isteyebileceğimizi anlamak için, bir dikdörtgenin alanını hesaplayan bir program yazalım. 
Tek değişkenler kullanarak başlayacağız ve ardından bunun yerine yapıları kullanana kadar programı yeniden düzenleyeceğiz.</p>
<p>Piksel cinsinden belirtilen bir dikdörtgenin genişlik ve yüksekliğini alacak <em>rectangles</em> adlı,
Cargo ile yeni bir ikili proje oluşturalım ve dikdörtgenin alanını hesaplayalım. 
Liste 5-8, projemizin <em>src/main.rs</em> dosyasında tam olarak bunu yapmanın bir yolunu içeren kısa bir program göstermektedir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}
</code></pre></pre>
<p><span class="caption">Liste 5-8: Ayrı genişlik ve yükseklik değişkenleri 
tarafından belirtilen bir dikdörtgenin alanını hesaplama</span></p>
<p>Şimdi, bu programı <code>cargo run</code> kullanarak çalıştırın.</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
The area of the rectangle is 1500 square pixels.
</code></pre>
<p>Bu kod, her bir boyutta <code>alan</code> fonksiyonunu çağırarak dikdörtgenin alanını bulmayı başarır, ancak bu kodu açık ve okunabilir hale getirmek için daha fazlasını yapabiliriz.</p>
<p>Bu kodla ilgili sorun, <code>area</code>'nın imzasında belirgindir:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;The area of the rectangle is {} square pixels.&quot;,
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}
</span></code></pre>
<p><code>area</code> fonksiyonunun bir dikdörtgenin alanını hesaplaması gerekiyor, 
ancak yazdığımız fonksiyonun iki parametresi var ve programımızın 
hiçbir yerinde parametrelerin ilişkili olduğu net değil. 
Genişliği ve yüksekliği birlikte gruplamak daha okunaklı ve daha 
yönetilebilir olurdu. Bunu, Bölüm 3'ün <a href="ch03-02-data-types.html#the-tuple-type">“Demet Türü”</a><!-- ignore --> bölümünde, demetleri kullanarak yapabileceğimizin bir yolunu zaten tartışmıştık.</p>
<h3 id="demetlerle-yeniden-düzenleme"><a class="header" href="#demetlerle-yeniden-düzenleme">Demetlerle Yeniden Düzenleme</a></h3>
<p>Liste 5-9, programımızın demet kullanan başka bir sürümünü gösterir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<p><span class="caption">Liste 5-9: Bir demet ile 
dikdörtgenin genişliğini ve yüksekliğini belirtme</span></p>
<p>Bir bakıma bu program daha iyi. Demetler yapı eklememize izin 
verir ve biz sadece bir argümanı geçeceğiz. Ancak başka bir şekilde, 
bu versiyon daha az açıktır: demetler öğelerini adlandırmaz, 
bu nedenle demetin bölümlerine indekslememiz gerekir, 
bu da hesaplamamızı daha az belirgin hale getirir.</p>
<p>Genişlik ve yüksekliğin karıştırılması alan hesabı için önemli değil, 
ancak dikdörtgeni ekranda çizmek istiyorsak önemlidir! Genişliğin <code>0</code> küme indeksi ve yüksekliğin küme indeksi <code>1</code> olduğunu aklımızda tutmalıyız. 
Eğer bizim kodumuzu kullanacak olsaydı, başka birinin bunu anlaması ve 
akılda tutması daha da zor olurdu. Verilerimizin anlamını kodumuzda iletmediğimiz için, hataları tanıtmak artık daha kolay.</p>
<h3 id="yapılarla-yeniden-düzenleme-daha-fazla-anlam-ekleme"><a class="header" href="#yapılarla-yeniden-düzenleme-daha-fazla-anlam-ekleme">Yapılarla Yeniden Düzenleme: Daha Fazla Anlam Ekleme</a></h3>
<p>Verileri etiketleyerek anlam eklemek için yapılar kullanırız. 
Kullandığımız demeti, Liste 5-10'da gösterildiği gibi, 
parçaların adlarının yanı sıra bütün için bir ad içeren bir yapıya dönüştürebiliriz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}
</code></pre></pre>
<p><span class="caption">Liste 5-10: Bir <code>Rectangle</code> yapı tanımlama</span></p>
<p>Burada bir yapı tanımladık ve onu <code>Rectangle</code> olarak adlandırdık. 
Kıvrımlı parantezler içinde, her ikisi de <code>u32</code> tipinde olan alanları 
<code>width</code> ve <code>height</code> olarak tanımladık. Ardından, ana olarak, 
<code>30</code> genişliğinde ve <code>50</code> yüksekliğinde belirli bir 
<code>Rectangle</code> tanımı oluşturduk.</p>
<p><code>area</code> fonksiyonumuz şimdi, türü bir <code>struct Rectangle</code> tanımının değişmez bir ödünç alma şekli olan <code>rectangle</code> adını verdiğimiz bir parametre ile tanımlanır. Bölüm 4'te bahsedildiği gibi, yapıyı sahiplenmek yerine ödünç 
almak istiyoruz. Bu şekilde <code>main</code>, sahipliğini korur ve fonksiyon 
imzasında ve fonksiyonu çağırdığımız yerde <code>&amp;'</code>yi kullanmamızın nedeni 
olan <code>rect1</code>'i kullanmaya devam edebilir.</p>
<p><code>area</code> fonksiyonu, <code>Rectangle</code> tanımının <code>width</code> ve <code>height</code> üyelerine
erişir (ödünç alınan bir yapı tanımının üyelerine erişmenin 
üye değerlerini hareket ettirmediğini, bu nedenle sık sık yapı 
ödünçlerini gördüğünüzü unutmayın). 
<code>area</code> için fonksiyon imzamız şimdi tam olarak ne demek istediğimizi söylüyor: 
<code>width</code> ve <code>height</code> üyelerini kullanarak <code>Rectangle</code> alanını hesaplayın. 
Bu, genişlik ve yüksekliğin birbiriyle ilişkili olduğunu ifade eder ve 
<code>0</code> ve <code>1</code>'lik demet indeks değerlerini kullanmak yerine değerlere 
açıklayıcı isimler verir. Bu, netlik için bir kazançtır.</p>
<h3 id="türetilmiş-tanımlar-ile-faydalı-İşlevsellik-ekleme"><a class="header" href="#türetilmiş-tanımlar-ile-faydalı-İşlevsellik-ekleme">Türetilmiş Tanımlar ile Faydalı İşlevsellik Ekleme</a></h3>
<p>Programımızda hata ayıklarken bir <code>Rectangle</code> tanımını yazdırabilmek 
ve tüm üyelerin değerlerini görebilmek faydalı olacaktır. 
Liste 5-11 <a href="../std/macro.println.html"><code>println!</code> makrosunu</a><!-- ignore --> önceki bölümlerde kullandığımız gibi
kullanmayı dener. Ancak bu işe yaramayacaktır.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 is {}&quot;, rect1);
}
</code></pre>
<p><span class="caption">Liste 5-11: Bir <code>Rectangle</code> tanımını yazdırmaya 
çalışmak</span></p>
<p>Bu kodu derlediğimizde, bir hata alıyoruz:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p><code>println!</code> makrosu birçok türde biçimlendirme yapabilir ve varsayılan olarak 
süslü parantezler <code>println!</code>'e <code>Display</code> olarak bilinen biçimlendirmeyi kullanmasını söyler.
Şimdiye kadar gördüğümüz ilkel tipler varsayılan olarak <code>Display</code>'i uygular, çünkü bunu yapabileceğiniz
tek yoldur.</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Hadi deneyelim! <code>println!</code> makro çağrısı şimdi <code>println!(&quot;rect1 is {:?}&quot;, rect1);</code>. 
<code>:?</code> belirtecini küme parantezlerinin içine koymak şunu söyler: <code>println!</code> için <code>Debug</code> adında bir 
çıktı formatı kullanmak istiyoruz. <code>Debug</code> tanımı yapımızı geliştiriciler için yararlı 
olacak şekilde yazdırmamızı sağlar, böylece kodumuz ayıklanırken değerini görebilirsiniz.</p>
<p>Kodu bu değişiklikle derleyin. Hala bir hata alıyoruz:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<p>Ama yine de derleyici bize yardımcı olacak bir not veriyor:</p>
<pre><code class="language-text">   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>Rust, hata ayıklama bilgilerini yazdırma fonksiyonunu <em>içerir</em>, 
ancak bu fonksiyonu yapımız için kullanılabilir hale getirmek için açıkça seçmeliyiz. 
Bunu yapmak için, Liste 5-12'de gösterildiği gibi, yapı tanımından hemen önce <code>#[derive(Debug)]</code> dış niteliğini ekleriz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 is {:?}&quot;, rect1);
}
</code></pre></pre>
<p><span class="caption">Liste 5-12: <code>Debug</code> tanımını türetmek için özniteliği ekleme ve 
hata ayıklama biçimlendirmesini kullanarak <code>Rectangle</code> tanımı yazdırma</span></p>
<p>Şimdi programı çalıştırdığımızda herhangi bir hata almayacağız ve aşağıdaki çıktıyı göreceğiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>Güzel! En güzel çıktı değil, ancak hata ayıklama sırasında kesinlikle yardımcı olacak bu 
örnek için tüm alanların değerlerini gösterir. Daha büyük yapılarımız olduğunda, okunması biraz daha
kolay çıktılara sahip olmak yararlıdır; bu durumlarda <code>println!</code>'de <code>{:?}</code> yerine <code>{:#?}</code> kullanabiliriz. 
Bu örnekte, <code>{:#?}</code> stilinin kullanılması şu sonucu verecektir:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p><code>Debug</code> formatını kullanarak bir değer yazdırmanın başka bir yolu da <a href="../std/macro.dbg.html"><code>dbg!</code>
makrosudur</a><!-- ignore -->.
Bu makro ifadenin sahipliğini alır (bir referans alan <code>println!</code>'nin aksine) ve bu ifadenin sonuç değeriyle birlikte kodunuzda 
gerçekleşir ve değerin sahipliğini döndürür.</p>
<blockquote>
<p>Not: <code>dbg!</code>'yi çağırmak, <code>println!</code>'nin aksine standart hata konsolu 
akışına (<code>stderr</code>) yazdırır. 
Bölüm 12'deki <a href="ch12-06-writing-to-stderr-instead-of-stdout.html">“Standart Çıktı Yerine Standart Hataya Hata Mesajları Yazma”</a><!-- ignore -->
bölümünde <code>stderr</code> ve <code>stdout</code> hakkında daha fazla konuşacağız.</p>
</blockquote>
<p>İşte, genişlik alanına atanan değerle ve ayrıca <code>rect1</code>'deki tüm yapının değeriyle ilgilendiğimiz bir örnek:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1);
}
</code></pre></pre>
<p><code>30 * scale</code> ifadesine <code>dbg!</code> makrosunu koyabiliriz çünkü <code>dbg!</code> ifadenin değerinin sahipliğini döndürür.
Biz ise <code>dbg!</code>'nin <code>rect1</code>'in sahipliğini almasını istemiyor olduğumuzdan dolayı bir diğer çağrıda 
<code>rect1</code>'in bir referansını kullanacağız.</p>
<p>Bu örneğin çıktısı şuna benzemelidir:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10] 30 * scale = 60
[src/main.rs:14] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<p>Çıktının ilk bitinin <em>src/main.rs</em> 10. satırdan geldiğini görebiliriz, 
burada <code>30 * scale</code> ifadesinin hatalarını ayıklıyoruz. <code>dbg!</code> <em>src/main.rs</em> dosyasının 14. satırındaki çağrı, 
<code>Rectangle</code> yapısı olan <code>&amp;rect1</code> değerini verir. Bu çıktı, <code>Rectangle</code> türünün güzel <code>Debug</code> biçimlendirmesini kullanır. 
<code>dbg!</code> makrosu, kodunuzun ne yaptığını anlamaya çalışırken gerçekten yardımcı olabilir!</p>
<p>Rust, <code>Debug</code> tanımına ek olarak, <code>derive</code> özelliğiyle birlikte kullanmamız için özel türlerimize faydalı davranışlar ekleyebilecek bir 
dizi özellik sağlamıştır. Bu özellikler ve davranışları <a href="appendix-03-derivable-traits.html">Ekleme C</a><!--
ignore -->'de listelenmiştir. Bu özellikleri özel davranışlarla nasıl uygulayacağınızı ve kendi özelliklerinizi nasıl oluşturacağınızı 
Bölüm 10'da ele alacağız. <code>derive</code>'ın dışında da birçok nitelik vardır; daha fazla bilgi için, 
<a href="../reference/attributes.html">Rust Reference'ın “Nitelikler”</a> bölümüne bakın.</p>
<p><code>area</code> fonksiyonumuz çok spesifiktir: sadece dikdörtgenlerin alanını hesaplar. 
Bu davranışı <code>Rectangle</code> yapımıza daha yakından bağlamak faydalı olacaktır, çünkü başka hiçbir türle çalışmayacaktır. 
<code>area</code> fonksiyonunu <code>Rectangle</code> türümüzde tanımlı bir <code>area</code> metoduna çevirerek bu kodu nasıl yeniden düzenlemeye devam 
edebileceğimizebakalım.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="method-syntax"><a class="header" href="#method-syntax">Method Syntax</a></h2>
<p><em>Methods</em> are similar to functions: we declare them with the <code>fn</code> keyword and a
name, they can have parameters and a return value, and they contain some code
that’s run when the method is called from somewhere else. Unlike functions,
methods are defined within the context of a struct (or an enum or a trait
object, which we cover in Chapters 6 and 17, respectively), and their first
parameter is always <code>self</code>, which represents the instance of the struct the
method is being called on.</p>
<h3 id="defining-methods"><a class="header" href="#defining-methods">Defining Methods</a></h3>
<p>Let’s change the <code>area</code> function that has a <code>Rectangle</code> instance as a parameter
and instead make an <code>area</code> method defined on the <code>Rectangle</code> struct, as shown
in Listing 5-13.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<p><span class="caption">Listing 5-13: Defining an <code>area</code> method on the
<code>Rectangle</code> struct</span></p>
<p>To define the function within the context of <code>Rectangle</code>, we start an <code>impl</code>
(implementation) block for <code>Rectangle</code>. Everything within this <code>impl</code> block
will be associated with the <code>Rectangle</code> type. Then we move the <code>area</code> function
within the <code>impl</code> curly brackets and change the first (and in this case, only)
parameter to be <code>self</code> in the signature and everywhere within the body. In
<code>main</code>, where we called the <code>area</code> function and passed <code>rect1</code> as an argument,
we can instead use <em>method syntax</em> to call the <code>area</code> method on our <code>Rectangle</code>
instance. The method syntax goes after an instance: we add a dot followed by
the method name, parentheses, and any arguments.</p>
<p>In the signature for <code>area</code>, we use <code>&amp;self</code> instead of <code>rectangle: &amp;Rectangle</code>.
The <code>&amp;self</code> is actually short for <code>self: &amp;Self</code>. Within an <code>impl</code> block, the
type <code>Self</code> is an alias for the type that the <code>impl</code> block is for. Methods must
have a parameter named <code>self</code> of type <code>Self</code> for their first parameter, so Rust
lets you abbreviate this with only the name <code>self</code> in the first parameter spot.
Note that we still need to use the <code>&amp;</code> in front of the <code>self</code> shorthand to
indicate this method borrows the <code>Self</code> instance, just as we did in <code>rectangle: &amp;Rectangle</code>. Methods can take ownership of <code>self</code>, borrow <code>self</code> immutably as
we’ve done here, or borrow <code>self</code> mutably, just as they can any other parameter.</p>
<p>We’ve chosen <code>&amp;self</code> here for the same reason we used <code>&amp;Rectangle</code> in the
function version: we don’t want to take ownership, and we just want to read the
data in the struct, not write to it. If we wanted to change the instance that
we’ve called the method on as part of what the method does, we’d use <code>&amp;mut self</code> as the first parameter. Having a method that takes ownership of the
instance by using just <code>self</code> as the first parameter is rare; this technique is
usually used when the method transforms <code>self</code> into something else and you want
to prevent the caller from using the original instance after the transformation.</p>
<p>The main reason for using methods instead of functions, in addition to providing
method syntax and not having to repeat the type of <code>self</code> in every method’s
signature, is for organization. We’ve put all the things we can do with an
instance of a type in one <code>impl</code> block rather than making future users of our
code search for capabilities of <code>Rectangle</code> in various places in the library we
provide.</p>
<p>Note that we can choose to give a method the same name as one of the struct’s
fields. For example, we can define a method on <code>Rectangle</code> also named <code>width</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!(&quot;The rectangle has a nonzero width; it is {}&quot;, rect1.width);
    }
}
</code></pre></pre>
<p>Here, we’re choosing to make the <code>width</code> method return <code>true</code> if the value in
the instance’s <code>width</code> field is greater than 0, and <code>false</code> if the value is 0:
we can use a field within a method of the same name for any purpose. In <code>main</code>,
when we follow <code>rect1.width</code> with parentheses, Rust knows we mean the method
<code>width</code>. When we don’t use parentheses, Rust knows we mean the field <code>width</code>.</p>
<p>Often, but not always, when we give methods with the same name as a field we
want it to only return the value in the field and do nothing else. Methods like
this are called <em>getters</em>, and Rust does not implement them automatically for
struct fields as some other languages do. Getters are useful because you can
make the field private but the method public and thus enable read-only access
to that field as part of the type’s public API. We will be discussing what
public and private are and how to designate a field or method as public or
private in Chapter 7.</p>
<blockquote>
<h3 id="wheres-the---operator"><a class="header" href="#wheres-the---operator">Where’s the <code>-&gt;</code> Operator?</a></h3>
<p>In C and C++, two different operators are used for calling methods: you use
<code>.</code> if you’re calling a method on the object directly and <code>-&gt;</code> if you’re
calling the method on a pointer to the object and need to dereference the
pointer first. In other words, if <code>object</code> is a pointer,
<code>object-&gt;something()</code> is similar to <code>(*object).something()</code>.</p>
<p>Rust doesn’t have an equivalent to the <code>-&gt;</code> operator; instead, Rust has a
feature called <em>automatic referencing and dereferencing</em>. Calling methods is
one of the few places in Rust that has this behavior.</p>
<p>Here’s how it works: when you call a method with <code>object.something()</code>, Rust
automatically adds in <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code> so <code>object</code> matches the signature of
the method. In other words, the following are the same:</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<p>The first one looks much cleaner. This automatic referencing behavior works
because methods have a clear receiver—the type of <code>self</code>. Given the receiver
and name of a method, Rust can figure out definitively whether the method is
reading (<code>&amp;self</code>), mutating (<code>&amp;mut self</code>), or consuming (<code>self</code>). The fact
that Rust makes borrowing implicit for method receivers is a big part of
making ownership ergonomic in practice.</p>
</blockquote>
<h3 id="methods-with-more-parameters"><a class="header" href="#methods-with-more-parameters">Methods with More Parameters</a></h3>
<p>Let’s practice using methods by implementing a second method on the <code>Rectangle</code>
struct. This time, we want an instance of <code>Rectangle</code> to take another instance
of <code>Rectangle</code> and return <code>true</code> if the second <code>Rectangle</code> can fit completely
within <code>self</code> (the first <code>Rectangle</code>); otherwise it should return <code>false</code>. That
is, once we’ve defined the <code>can_hold</code> method, we want to be able to write the
program shown in Listing 5-14.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<p><span class="caption">Listing 5-14: Using the as-yet-unwritten <code>can_hold</code>
method</span></p>
<p>And the expected output would look like the following, because both dimensions
of <code>rect2</code> are smaller than the dimensions of <code>rect1</code> but <code>rect3</code> is wider than
<code>rect1</code>:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>We know we want to define a method, so it will be within the <code>impl Rectangle</code>
block. The method name will be <code>can_hold</code>, and it will take an immutable borrow
of another <code>Rectangle</code> as a parameter. We can tell what the type of the
parameter will be by looking at the code that calls the method:
<code>rect1.can_hold(&amp;rect2)</code> passes in <code>&amp;rect2</code>, which is an immutable borrow to
<code>rect2</code>, an instance of <code>Rectangle</code>. This makes sense because we only need to
read <code>rect2</code> (rather than write, which would mean we’d need a mutable borrow),
and we want <code>main</code> to retain ownership of <code>rect2</code> so we can use it again after
calling the <code>can_hold</code> method. The return value of <code>can_hold</code> will be a
Boolean, and the implementation will check whether the width and height of
<code>self</code> are both greater than the width and height of the other <code>Rectangle</code>,
respectively. Let’s add the new <code>can_hold</code> method to the <code>impl</code> block from
Listing 5-13, shown in Listing 5-15.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-15: Implementing the <code>can_hold</code> method on
<code>Rectangle</code> that takes another <code>Rectangle</code> instance as a parameter</span></p>
<p>When we run this code with the <code>main</code> function in Listing 5-14, we’ll get our
desired output. Methods can take multiple parameters that we add to the
signature after the <code>self</code> parameter, and those parameters work just like
parameters in functions.</p>
<h3 id="associated-functions"><a class="header" href="#associated-functions">Associated Functions</a></h3>
<p>All functions defined within an <code>impl</code> block are called <em>associated functions</em>
because they’re associated with the type named after the <code>impl</code>. We can define
associated functions that don’t have <code>self</code> as their first parameter (and thus
are not methods) because they don’t need an instance of the type to work with.
We’ve already used one function like this: the <code>String::from</code> function that’s
defined on the <code>String</code> type.</p>
<p>Associated functions that aren’t methods are often used for constructors that
will return a new instance of the struct. These are often called <code>new</code>, but
<code>new</code> isn’t a special name and isn’t built into the language. For example, we
could choose to provide an associated function named <code>square</code> that would have
one dimension parameter and use that as both width and height, thus making it
easier to create a square <code>Rectangle</code> rather than having to specify the same
value twice:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}
</span></code></pre></pre>
<p>The <code>Self</code> keywords in the return type and in the body of the function are
aliases for the type that appears after the <code>impl</code> keyword, which in this case
is <code>Rectangle</code>.</p>
<p>To call this associated function, we use the <code>::</code> syntax with the struct name;
<code>let sq = Rectangle::square(3);</code> is an example. This function is namespaced by
the struct: the <code>::</code> syntax is used for both associated functions and
namespaces created by modules. We’ll discuss modules in Chapter 7.</p>
<h3 id="multiple-impl-blocks"><a class="header" href="#multiple-impl-blocks">Multiple <code>impl</code> Blocks</a></h3>
<p>Each struct is allowed to have multiple <code>impl</code> blocks. For example, Listing
5-15 is equivalent to the code shown in Listing 5-16, which has each method
in its own <code>impl</code> block.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-16: Rewriting Listing 5-15 using multiple <code>impl</code>
blocks</span></p>
<p>There’s no reason to separate these methods into multiple <code>impl</code> blocks here,
but this is valid syntax. We’ll see a case in which multiple <code>impl</code> blocks are
useful in Chapter 10, where we discuss generic types and traits.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Structs let you create custom types that are meaningful for your domain. By
using structs, you can keep associated pieces of data connected to each other
and name each piece to make your code clear. In <code>impl</code> blocks, you can define
functions that are associated with your type, and methods are a kind of
associated function that let you specify the behavior that instances of your
structs have.</p>
<p>But structs aren’t the only way you can create custom types: let’s turn to
Rust’s enum feature to add another tool to your toolbox.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numaralandırılmışlar-ve-model-eşleme"><a class="header" href="#numaralandırılmışlar-ve-model-eşleme">Numaralandırılmışlar ve Model Eşleme</a></h1>
<p>Bu bölümde <em>numaralandırılmış yapılara</em>, bir diğer deyişle <em>numaralandırışmışlara</em> göz atacağız.
Numaralandırılmışlar, olası varyantları numaralandırarak bir türü tanımlamanıza olanak tanır. 
İlk olarak, bir numaralandırmanın verilerle birlikte anlamı nasıl kodlayabileceğini göstermek için bir numaralandırma tanımlayacağız ve kullanacağız. Ardından, bir değerin bir şey ya da hiçbir şey olabileceğini ifade eden <code>Option</code> adlı tanımla yararlı bir numaralandırmayı keşfedeceğiz. Ardından, eşleşme ifadesindeki kalıp eşleştirmenin, bir numaralandırmanın farklı değerleri için farklı kod çalıştırmayı nasıl kolaylaştırdığına bakacağız. Son olarak, <code>if let</code> yapısının kodunuzdaki numaralandırmaları işlemek için kullanılabilen başka bir kullanışlı ve özlü deyim olduğunu ele alacağız.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="numaralandırılmış-yapı-tanımlamak"><a class="header" href="#numaralandırılmış-yapı-tanımlamak">Numaralandırılmış Yapı Tanımlamak</a></h2>
<p>Yapıların size <code>width</code> ve <code>height</code> üyeleri olan bir <code>Rectangle</code> gibi ilgili üyeleri ve 
verileri gruplandırmanın bir yolunu verdiği yerde, numaralandırmalar size bir değerin 
olası bir değer kümesinden biri olduğunu söylemenin bir yolunu verir. 
Örneğin, <code>Rectangle</code>'ın <code>Circle</code> ve <code>Triangle</code>'ı da içeren olası şekillerden biri 
olduğunu söylemek isteyebiliriz. Bunu yapmak için Rust, bu olasılıkları bir <code>enum</code> 
olarak kodlamamıza izin verir.</p>
<p>Kodda ifade etmek isteyebileceğimiz bir duruma bakalım ve bu durumda numaralandırmaların 
neden yapılardan daha yararlı ve daha uygun olduğunu görelim. IP adresleriyle çalışmamız 
gerektiğini farz edin. Şu anda IP adresleri için iki ana standart kullanılmaktadır: 
V4 ve V6. Programımızın karşılaşacağı bir IP adresi için tek olasılık bunlar olduğundan, 
tüm olası değişkenleri sıralayabiliriz, bu da numaralandırmanın adını aldığı yerdir.</p>
<p>Herhangi bir IP adresi, V4 veya V6 adresi olabilir, 
ancak ikisi aynı anda olamaz. IP adreslerinin bu özelliği, <code>enum</code> veri yapısını 
uygun hale getirir, çünkü bir <code>enum</code> değeri onun türevlerinden yalnızca biri olabilir. 
Hem V4 hem de V6 adresleri hala temelde IP adresleridir, bu nedenle kod herhangi bir 
IP adresi için geçerli olan durumları işlerken aynı tür olarak ele alınmalıdır.</p>
<p>Bu kavramı bir <code>IpAddrKind</code> numaralandırması tanımlayarak ve bir IP adresinin olabileceği 
olası türleri V4 ve V6 olarak listeleyerek kodda ifade edebiliriz. 
Bunlar, numaralandırmanın varyantlarıdır:</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p><code>IpAddrKind</code> artık kodumuzun başka bir yerinde kullanabileceğimiz özel bir veri türüdür.</p>
<h3 id="enum-değerleri"><a class="header" href="#enum-değerleri"><code>enum</code> Değerleri</a></h3>
<p><code>IpAddrKind</code>'in iki varyantının her birinin örneklerini şu şekilde oluşturabiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>Numaralandırmanın türevlerinin, tanımlayıcısının altında ad alanlı olduğuna ve 
ikisini ayırmak için çift iki nokta üst üste (<code>:</code>) kullandığımıza dikkat edin. 
Bu kullanışlıdır çünkü artık her iki <code>IpAddrKind::V4</code> ve <code>IpAddrKind::V6</code> değeri aynı 
türdedir: <code>IpAddrKind</code>. Daha sonra, örneğin, herhangi bir <code>IpAddrKind</code> alan bir 
fonksiyon tanımlayabiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}
</code></pre></pre>
<p>Ve bu fonksiyonu her iki değişkenle de çağırabiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>Numaralandırma kullanmanın daha da fazla avantajı vardır. IP adresi <em>türümüz</em> hakkında daha 
fazla düşünürsek, şu anda gerçek IP adresi verilerini saklamanın bir yolu yok; sadece ne tür olduğunu biliyoruz. Bölüm 5'te yapılar hakkında yeni öğrendiğinize göre, bu sorunu Liste 6-1'de gösterildiği gibi yapılarla çözmeye cazip gelebilirsiniz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from(&quot;127.0.0.1&quot;),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from(&quot;::1&quot;),
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 6-1: Bir IP adresinin verilerinin ve <code>IpAddrKind</code> değişkeninin
<code>struct</code> kullanılarak saklanması</span></p>
<p>Burada, iki üyesi olan bir <code>IpAddr</code> yapısı tanımladık: 
<code>IpAddrKind</code> türünde bir tür üyesi (daha önce tanımladığımız numaralandırma) ve 
<code>String</code> türünde bir adres üyesi. Bu yapının iki örneğine sahibiz. 
Birincisi <code>home</code>'dır ve <code>127.0.0.1</code> ilişkili adres verileriyle kendi türünde 
<code>IpAddrKind::V4</code> değerine sahiptir. İkinci örnek geri döngüdür. Tür değeri <code>V6</code> olarak 
<code>IpAddrKind</code>'in diğer türevine sahiptir ve onunla ilişkili <code>::1</code> adresine sahiptir. 
Tür ve adres değerlerini bir araya toplamak için bir yapı kullandık, 
bu yüzden şimdi değişken değerle ilişkilendirildi.</p>
<p>Bununla birlikte, aynı kavramı yalnızca bir numaralandırma kullanarak temsil etmek daha özlüdür: 
bir yapı içindeki bir numaralandırma yerine, verileri doğrudan her bir numaralandırma 
değişkenine koyabiliriz. <code>IpAddr</code> <code>enum</code>'un bu yeni tanımı, 
hem <code>V4</code> hem de <code>V6</code> varyantlarının ilişkili <code>String</code> değerlerine sahip olacağını söylüyor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p><code>enum</code>'un her türevine doğrudan veri ekliyoruz, bu nedenle ekstra bir yapıya gerek yok. 
Burada ayrıca numaralandırmaların nasıl çalıştığına dair başka bir ayrıntıyı görmek daha kolaydır:
tanımladığımız her bir numaralandırma değişkeninin adı aynı zamanda numaralandırmanın bir örneğini
oluşturan bir fonksiyon haline gelir. Diğer bir deyişle, <code>IpAddr::V4()</code>, 
bir <code>String</code> bağımsız değişkeni alan ve <code>IpAddr</code> türünün bir örneğini döndüren bir fonksiyon çağrısıdır.
<code>enum</code>'u tanımlamanın bir sonucu olarak bu yapıcı fonksiyonu otomatik olarak tanımlarız.</p>
<p>Bir yapı yerine bir numaralandırma kullanmanın başka bir avantajı daha vardır: her değişken, 
farklı türde ve miktarda ilişkili veriye sahip olabilir. V4 tip IP adresleri her zaman 
0 ile 255 arasında değerlere sahip dört sayısal bileşene sahip olacaktır:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>V4 ve V6 IP adreslerini depolamak için veri yapılarını tanımlamanın birkaç farklı yolunu gösterdik. 
Ancak, ortaya çıktığı gibi, IP adreslerini saklamak ve hangi tür olduklarını kodlamak istemek o kadar
yaygın ki, <a href="../std/net/enum.IpAddr.html">standart kütüphanenin kullanabileceğimiz bir tanımı var!</a><!-- ignore --> 
Standart kütüphanenin <code>IpAddr</code>'yi nasıl tanımladığına bakalım: tanımladığımız ve kullandığımız 
tam <code>enum</code> ve varyantlara sahiptir, ancak adres verilerini varyantların içine, 
her varyant için farklı tanımlanmış iki farklı yapı şeklinde gömer:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<p>Bu kod, herhangi bir türde veriyi bir numaralandırma değişkeninin içine koyabileceğinizi gösterir: 
örneğin dizgiler, sayısal türler veya yapılar. Hatta başka bir numaralandırma ekleyebilirsiniz! 
Ayrıca, standart kütüphane türleri genellikle bulabileceklerinizden çok daha karmaşık değildir.</p>
<p>Standart kütüphanenin <code>IpAddr</code> için bir tanım içermesine rağmen, standart kütüphanenin tanımını 
kapsamımıza almadığımız için kendi tanımımızı çakışmadan oluşturup kullanabileceğimize dikkat edin. 
Bölüm 7'de türleri kapsama almak hakkında daha fazla konuşacağız.</p>
<p>Liste 6-2'deki başka bir numaralandırma örneğine bakalım: bu, türevlerinde gömülü çok çeşitli türlere sahiptir.</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Liste 6-2: Varyantlarının her biri farklı miktar ve türde değerleri saklayan bir
<code>Message</code> numaralandırması</span></p>
<p>Bu numaralandırmanın farklı türlerde dört çeşidi vardır:</p>
<ul>
<li><code>Quit</code> onunla ilişkili hiçbir veriye sahip değil.</li>
<li><code>Move</code> bir yapının yaptığı gibi alanları adlandırmıştır.</li>
<li><code>Write</code> tek bir <code>String</code>'i dahil eder.</li>
<li><code>ChangeColor</code> üç tane <code>i32</code> değerini dahil eder.</li>
</ul>
<p>Liste 6-2'dekiler gibi değişkenlerle bir numaralandırma tanımlamak, 
farklı türde yapı tanımları tanımlamaya benzer, ancak numaralandırmanın <code>struct</code> anahtar sözcüğünü
kullanmaması ve tüm değişkenlerin <code>Message</code> türü altında gruplandırılması dışında. 
Aşağıdaki yapılar, önceki numaralandırma değişkenlerinin sahip olduğu aynı verileri tutabilir:</p>
<pre><pre class="playground"><code class="language-rust">struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Ancak, her biri kendi tipine sahip olan farklı yapıları kullanırsak, 
bu tür mesajların herhangi birini almak için, tek bir mesaj olan Liste 6-2'de 
tanımlanan <code>Message</code> <code>enum</code>'u ile yapabileceğimiz kadar kolay bir fonksiyon tanımlayamazdık.</p>
<p>Numaralandırmalar ve yapılar arasında bir benzerlik daha vardır: 
<code>impl</code> kullanarak yapılar üzerinde yöntemleri tanımlayabildiğimiz gibi, 
<code>enum</code>'lar üzerinde de yöntemler tanımlayabiliriz. İşte <code>Message</code> <code>enum</code>'umuzda 
tanımlayabileceğimiz <code>call</code> adında bir metod:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from(&quot;hello&quot;));
    m.call();
<span class="boring">}
</span></code></pre></pre>
<p>Metodun gövdesi, metodu çağırdığımız değeri almak için <code>self</code>'i kullanır.
Bu örnekte, <code>m</code> adında <code>Message::Write(String::from(&quot;hello&quot;))</code>'yu tutan bir değişken oluşturduk 
ve <code>m.call()</code> çalıştığında <code>self</code> <code>call</code> metodunun gövdesinde olacak.</p>
<p>Standart kütüphanedeki çok yaygın ve kullanışlı olan başka bir numaralandırmaya bakalım: 
<code>Option</code>.</p>
<h3 id="option-numaralandırması-ve-null-değerlerine-göre-avantajları"><a class="header" href="#option-numaralandırması-ve-null-değerlerine-göre-avantajları"><code>Option</code> Numaralandırması ve <code>Null</code> Değerlerine Göre Avantajları</a></h3>
<p>Bu bölüm, standart kütüphane tarafından tanımlanan başka bir numaralandırma olan 
<code>Option</code>'ın örnek olay incelemesini incelemektedir. <code>Option</code> türü, bir değerin 
bir şey olabileceği veya hiçbir şey olamayacağı çok yaygın senaryoyu kodlar.</p>
<p>Örneğin, öğeleri içeren bir listenin ilkini talep ederseniz, bir değer alırsınız. 
Boş bir listenin ilk maddesini talep ederseniz, hiçbir şey alamazsınız. Bu kavramı 
tür sistemi cinsinden ifade etmek, derleyicinin, ele almanız gereken tüm durumları ele alıp 
almadığınızı kontrol edebileceği anlamına gelir; bu işlevsellik, diğer programlama dillerinde 
son derece yaygın olan hataları önleyebilir.</p>
<p>Programlama dili tasarımı genellikle hangi özellikleri eklediğinize göre düşünülür, 
ancak hariç tuttuğunuz özellikler de önemlidir. Rust, diğer birçok dilde bulunan 
<em>null</em> özelliğine sahip değildir. <em>null</em>, hiçbir değer olmadığı anlamına gelen bir değerdir. 
<em>null</em> olan dillerde, değişkenler her zaman iki durumdan birinde olabilir: <em>null</em> veya <em>null</em> değil.</p>
<p><em>null</em>'un mucidi Tony Hoare, “Null References: The Billion Dollar Mistake,” adlı 2009 sunumunda şunları söylüyor:</p>
<blockquote>
<p>Ben buna milyar dolarlık hatam diyorum. O zaman, nesne yönelimli bir dilde 
referanslar için ilk kapsamlı tip sistemini tasarlıyordum. Amacım, derleyici tarafından 
otomatik olarak gerçekleştirilen kontrol ile referansların tüm kullanımının kesinlikle güvenli
olmasını sağlamaktı. Ancak, uygulanması çok kolay olduğu için boş bir referans koymanın 
cazibesine karşı koyamadım. Bu, son kırk yılda muhtemelen milyarlarca dolarlık acıya 
ve hasara neden olan sayısız hataya, güvenlik açığına ve sistem çökmesine neden oldu.</p>
</blockquote>
<p>Boş değerlerle ilgili sorun, boş olmayan bir değer olarak boş bir değer kullanmaya çalışırsanız, 
bir tür hata almanızdır. Bu boş veya boş olmayan özellik yaygın olduğundan, 
bu tür bir hatayı yapmak son derece kolaydır.</p>
<p>Bununla birlikte, <em>null</em>'un ifade etmeye çalıştığı kavram hala kullanışlıdır: 
<em>null</em>, şu anda geçersiz olan veya herhangi bir nedenle mevcut olmayan bir değerdir.</p>
<p>Sorun gerçekten konseptte değil, uygulanmasındadır. Bu nedenle, Rust'ın boş değerleri yoktur, 
ancak var olan veya olmayan bir değer kavramını kodlayabilen bir numaralandırmaya sahiptir. 
Bu numaralandırma <code>Option&lt;T&gt;</code>'dir ve <a href="../std/option/enum.Option.html">standart kütüphane tarafından</a><!-- ignore -->
aşağıdaki gibi tanımlanır:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Option&lt;T&gt;</code> <code>enum</code>'u o kadar kullanışlıdır ki, girişe bile dahil edilmiştir; 
Bunu açıkça kapsama sokmanız gerekmez. Varyantları da başlangıç bölümüne dahil edilmiştir: 
<code>Some</code> ve <code>None</code>'ı doğrudan <code>Option::</code> ön eki olmadan kullanabilirsiniz. <code>Option&lt;T&gt;</code> numaralandırma 
hala normal bir numaralandırmadır ve <code>Some(T)</code> ve <code>None</code> hala <code>Option&lt;T&gt;</code> türünün varyantlarıdır.</p>
<p><code>&lt;T&gt;</code> sözdizimi, Rust'ın henüz bahsetmediğimiz bir özelliğidir. 
Bu genel bir tür parametresidir ve yaygınları Bölüm 10'da daha ayrıntılı olarak ele alacağız. 
Şimdilik, bilmeniz gereken tek şey <code>&lt;T&gt;</code>'nin <code>Option</code> <code>enum</code>'unun <code>Some</code> varyantının herhangi bir 
türden tek bir veri parçasını tutabileceği anlamına geldiğidir. 
Sayı türlerini ve dize türlerini tutmak için <code>Option</code> değerlerini kullanmanın bazı örnekleri:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<p><code>some_number</code> türü <code>Option&lt;i32&gt;</code> şeklindedir. <code>some_char</code> türü, farklı bir tür olan 
<code>Option&lt;char&gt;</code>'dır. Rust, <code>Some</code> varyantı içinde bir değer belirttiğimiz için bu türlerin 
çıkarımını yapabilir. <code>absent_number</code> için Rust, genel <code>Otpion</code> türüne açıklama eklememizi gerektirir:
derleyici, yalnızca <code>None</code> değerine bakarak karşılık gelen <code>Some</code> varyantının tutacağı türü çıkaramaz.
Burada, <code>absent_number</code> için <code>Option&lt;i32&gt;</code> türünde olmasını kastettiğimizi Rust'a söylüyoruz.</p>
<p>Bir <code>Some</code> değerine sahip olduğumuzda, bir değerin mevcut olduğunu ve değerin <code>Some</code> içinde tutulduğunu
biliriz. <code>None</code> değerine sahip olduğumuzda, bir anlamda <em>null</em> ile aynı anlama gelir: 
geçerli bir değerimiz yoktur. Öyleyse neden <code>Option&lt;T&gt;</code> seçeneğine sahip olmak boş değere sahip 
olmaktan daha iyidir?</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}
</span></code></pre>
<p>Bu kodu çalıştırırsak şöyle bir hata mesajı alırız:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
</code></pre>
<p>Aslında bu hata mesajı, farklı türler oldukları için Rust'ın bir <code>i8</code> ve bir <code>Option&lt;i8&gt;</code> nasıl 
ekleneceğini anlamadığı anlamına gelir. Rust'ta <code>i8</code> gibi bir değerimiz olduğunda, 
derleyici her zaman geçerli bir değere sahip olmamızı sağlayacaktır. 
Bu değeri kullanmadan önce <em>null</em> değerini kontrol etmek zorunda kalmadan güvenle ilerleyebiliriz. 
Yalnızca bir <code>Option&lt;i8&gt;</code> olduğunda (veya hangi tür değerle çalışırsak çalışalım), 
muhtemelen bir değere sahip olmama konusunda endişelenmemiz gerekir ve derleyici, 
değeri kullanmadan önce bu durumu ele aldığımızdan emin olacaktır.</p>
<p>Başka bir deyişle, onunla <code>T</code> işlemleri gerçekleştirmeden önce <code>Option&lt;T&gt;</code> öğesini <code>T</code>'ye dönüştürmeniz
gerekir. Genellikle bu, <em>null</em> ile ilgili en yaygın sorunlardan birini yakalamaya yardımcı olur: 
bir şeyin gerçekte boş olmadığını varsaymak.</p>
<p>Yanlış bir şekilde boş olmayan bir değer varsayma riskini ortadan kaldırmak, 
kodunuza daha fazla güvenmenize yardımcı olur. Muhtemelen <em>null</em> olabilecek bir değere sahip olmak için, 
bu değerin türünü <code>Option&lt;T&gt;</code> yaparak açıkça seçmelisiniz. Ardından, bu değeri kullandığınızda, 
değer boş olduğunda durumu açıkça ele almanız gerekir. Bir değerin <code>Option&lt;T&gt;</code> olmayan bir türü 
olduğu her yerde, değerin boş olmadığını güvenle varsayabilirsiniz. 
Bu, Rust'ın <em>null</em>'ın yaygınlığını sınırlamak ve Rust kodunun güvenliğini artırmak için kasıtlı bir 
tasarım kararıydı.</p>
<p>Öyleyse, <code>Option&lt;T&gt;</code> türünde bir değeriniz olduğunda, bu değeri kullanabilmeniz için <code>Some</code> varyantından 
<code>T</code> değerini nasıl alırsınız? <code>Option&lt;T&gt;</code> <code>enum</code>'u, çeşitli durumlarda yararlı olan çok sayıda yönteme
sahiptir; <a href="../std/option/enum.Option.html">dokümantasyonundan</a><!-- ignore --> kontrol edebilirsiniz. <code>Option&lt;T&gt;</code> üzerindeki metodlara aşina olmak, 
Rust ile olan yolculuğunuzda son derece yararlı olacaktır.</p>
<p>Genel olarak, bir <code>Option&lt;T&gt;</code> değeri kullanmak için her bir değişkeni işleyecek bir koda sahip olmak
istersiniz. Yalnızca bir <code>Some(T)</code> değerine sahip olduğunuzda çalışacak bir kod istiyorsunuz 
ve bu kodun iç <code>T</code>'yi kullanmasına izin veriliyor. <code>None</code> değeriniz varsa ve bu kodda başka bir kodun
çalıştırılmasını istiyorsunuz. bir <code>T</code> değeri mevcuttur. <code>match</code> ifadesi, 
numaralandırmalarla kullanıldığında tam da bunu yapan bir kontrol akışı yapısıdır: 
sahip olduğu numaralandırmanın hangi türevine bağlı olarak farklı kod çalıştırır ve bu kod, 
eşleşen değerin içindeki verileri kullanabilir.</p>
<div style="break-before: page; page-break-before: always;"></div><p><a id="the-match-control-flow-operator"></a></p>
<h2 id="match-kontrol-akışı-yapısı"><a class="header" href="#match-kontrol-akışı-yapısı"><code>match</code> Kontrol Akışı Yapısı</a></h2>
<p>Rust, bir değeri bir dizi modelle karşılaştırmanıza ve ardından hangi modelin eşleştiğine göre kod yürütmenize olanak tanıyan, 
<code>match</code> adı verilen son derece güçlü bir kontrol akışı yapısına sahiptir. Modeller değişmez değerlerden, 
değişken adlarından, joker karakterlerden ve diğer birçok şeyden oluşabilir; 
Bölüm 18, tüm farklı kalıp türlerini ve ne yaptıklarını kapsar. 
<code>match</code>'in gücü, modellerin ifade gücünden ve derleyicinin tüm olası vakaların ele alındığını doğrulamasından gelir.</p>
<p>Bir <code>match</code> ifadesini madeni para ayırma makinesi gibi düşünün: madeni paralar, üzerinde çeşitli büyüklükte delikler 
bulunan bir raydan aşağı kayar ve her madeni para, karşılaştığı ilk delikten girer ve sığar. Aynı şekilde, 
değerler bir <code>match</code>'te her bir modelden geçer ve ilk modelde değer “uyar”, değer, yürütme sırasında kullanılacak ilgili kod bloğuna düşer.</p>
<p>Madeni paralardan bahsetmişken, onları <code>match</code>'i kullanırken örnek verebiliriz! 
Bir Birleşik Devletler madeni parasını alan ve sayma makinesine benzer bir şekilde, 
hangi madeni para olduğunu belirleyen ve burada Liste 6-3'te gösterildiği gibi değerini 
sent olarak döndüren bir fonksiyon yazabiliriz.</p>
<pre><pre class="playground"><code class="language-rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Liste 6-3: Bir <code>enum</code> ve bir <code>match</code> ifadesi, 
model olarak <code>enum</code> türüne sahip</span></p>
<p><code>value_in_cents</code> fonksiyonundaki <code>match</code>'i parçalayalım. 
İlk olarak, eşleşen anahtar kelimeyi ve ardından bu durumda jeton değeri olan bir ifadeyi listeleriz. 
Bu, <code>if</code> ile kullanılan bir ifadeye çok benziyor, ancak büyük bir fark var: 
<code>if</code> ile ifadenin bir Boole değeri döndürmesi gerekiyor, ancak burada herhangi bir tür döndürebilir. 
Bu örnekteki jeton türü, ilk satırda tanımladığımız <code>Coin</code>; <code>enum</code>'dur.</p>
<p>Sıradaki <code>match</code> kolları. Bu kolların iki parçası vardır: 
bir model ve bir miktar kod. Buradaki ilk kol <code>Coin::Penny</code> değerinde bir modele ve ardından model ile çalıştırılacak kodu ayıran 
<code>=&gt;</code> operatörüne sahiptir. Bu durumda kod sadece <code>1</code> değeridir. Her kol bir sonrakinden virgülle ayrılır.</p>
<p><code>match</code> ifadesi yürütüldüğünde, elde edilen değeri sırayla her bir kolun modeliyle karşılaştırır. 
Bir model değerle eşleşirse, o kalıpla ilişkili kod yürütülür. Bu model değerle eşleşmezse, 
yürütme bir madeni para sıralama makinesinde olduğu gibi bir sonraki kola devam eder. 
İhtiyacımız olduğu kadar çok kola sahip olabiliriz: Liste 6-3'te <code>match</code>'imizde dört kol var.</p>
<p>Her kolla ilişkili kod bir ifadedir ve eşleşen koldaki ifadenin sonuç değeri, 
tüm <code>match</code> ifadesi için döndürülen değerdir.</p>
<p>Her bir kolun yalnızca bir değer döndürdüğü Liste 6-3'te olduğu gibi, 
<code>match</code> kolu kodu kısaysa genellikle süslü parantezler kullanmayız. Bir <code>match</code> kolunda birden çok kod satırı 
çalıştırmak istiyorsanız, süslü parantezleri kullanmanız gerekir ve kolu takip eden virgül isteğe bağlıdır. 
Örneğin, aşağıdaki kod “Lucky penny!” yazdırır. Metod bir <code>Coin::Penny</code> ile her çağrıldığında, 
ancak bloğun son değeri olan <code>1</code>'i döndürür:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Lucky penny!&quot;);
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h3 id="değerlere-bağlanan-modeller"><a class="header" href="#değerlere-bağlanan-modeller">Değerlere Bağlanan Modeller</a></h3>
<p><code>match</code> kollarının bir başka kullanışlı özelliği de değerlerin modelle eşleşen kısımlarına bağlanabilmeleridir. 
<code>enum</code> değişkenlerinden değerleri bu şekilde çıkarabiliriz.</p>
<p>Örnek olarak, <code>enum</code> değişkenlerimizden birini veriyi içinde tutacak şekilde değiştirelim. 
1999'dan 2008'e kadar Amerika Birleşik Devletleri, bir taraftaki 50 eyaletin her biri için farklı tasarımlara sahip paralar bastı. 
Başka hiçbir madeni paranın bu tarz bir devlet tasarımı yoktur, bu nedenle yalnızca çeyrekler buna sahiptir. 
Bu bilgiyi, <code>Quarter</code> değişkenini, burada Liste 6-4'te yaptığımız, içinde saklanan bir <code>UsState</code> değerini içerecek şekilde değiştirerek 
<code>enum</code>'a ekleyebiliriz.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Liste 6-4: <code>Quarter</code> değişkeninin de bir <code>UsState</code> değerine sahip olduğu bir <code>Coin</code> <code>enum</code>'u</span></p>
<p>Bir arkadaşın 50 eyalet parasının tamamını toplamaya çalıştığını düşünelim. 
Bozuk paramızı madeni para türüne göre sıralarken, her üç aylık dönemle ilişkili eyaletin adını da söyleyeceğiz, böylece arkadaşımızın sahip olmadığı
bir şey varsa, koleksiyonlarına ekleyebilirler.</p>
<p>Bu kodun <code>match</code> ifadesinde, <code>Coin::Quarter</code> varyantının değerleriyle eşleşen modele <code>state</code> adlı bir değişken ekleriz. 
<code>Coin::Quarter</code> eşleştiğinde, <code>state</code> değişkeni o çeyreğin durumunun değerine bağlanır. 
Daha sonra bu kolun kodundaki <code>state</code>'i şu şekilde kullanabiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}
</span></code></pre></pre>
<p><code>value_in_cents(Coin::Quarter(UsState::Alaska))</code> olarak çağıracak olsaydık, 
<code>coin</code> <code>Coin::Quarter(UsState::Alaska)</code> olurdu. Bu değeri <code>match</code> kollarının her biri ile karşılaştırdığımızda, 
<code>Coin::Quarter(state)</code> değerine ulaşana kadar hiçbiri eşleşmez. 
Bu noktada, <code>state</code> için değer <code>UsState::Alaska</code> olacaktır. Daha sonra bu atamayı <code>println!</code>'de kullanabiliriz.</p>
<h3 id="optiontla-eşleştirme"><a class="header" href="#optiontla-eşleştirme"><code>Option&lt;T&gt;</code>'la Eşleştirme</a></h3>
<p>Önceki bölümde, <code>Option&lt;T&gt;</code> kullanırken <code>Some</code> durumundan iç <code>T</code> değerini almak istedik; 
<code>Option&lt;T&gt;</code> ile <code>Coin</code> <code>enum</code>'da yaptığımız gibi <code>match</code>'i kullanarak da işleyebiliriz! 
Madeni paraları karşılaştırmak yerine, <code>Option&lt;T&gt;</code>'nin türevlerini karşılaştıracağız, 
ancak <code>match</code> ifadesinin çalışma şekli aynı kalıyor.</p>
<p>Diyelim ki <code>Option&lt;i32&gt;</code> alan ve içinde bir değer varsa bu değere <code>1</code> ekleyen bir fonksiyon yazmak istiyoruz. 
İçinde bir değer yoksa, fonksiyon <code>None</code> değerini döndürmeli ve herhangi bir işlem yapmaya çalışmamalıdır.</p>
<p>Bu fonksiyonun yazılması, <code>match</code> sayesinde çok kolaydır ve Liste 6-5'e benzeyecektir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 6-5: <code>Option&lt;i32&gt;</code> için <code>match</code> ifadesi kullanan bir fonksiyon</span></p>
<p>Şimdi <code>plus_one</code>'ın ilk süreklemesini daha detaylı inceleyelim. 
<code>plus_one(five</code> dediğimizde, <code>plus_one</code> gövdesindeki <code>x</code> değişkeni <code>Some(5)</code> değerine sahip olacaktır. 
Daha sonra bunu her bir <code>match</code> koluyla karşılaştırırız.</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p><code>Some(5)</code> değeri <code>None</code> ile eşleşmediğinden dolayı sonraki kolla devam ediyoruz:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p><code>Some(5)</code> <code>Some(i)</code> ile eşleşiyor mu? Neden evet olduğuna bakalım! 
Aynı varyanta sahibiz. <code>i</code>'ye <code>Some</code> içindeki değer atanır, bu yüzden <code>5</code> değerini alır. 
<code>match</code> kolundaki kod daha sonra çalıştırılır, bu yüzden <code>i</code>'nin değerine <code>1</code> ekliyoruz ve içindeki 
toplam <code>6</code> ile yeni bir <code>Some</code> değeri oluşturuyoruz.</p>
<p>Şimdi, <code>x</code>'in <code>None</code> olduğu Liste 6-5'teki ikinci <code>plus_one</code> çağrısını ele alalım. 
<code>match</code>'e giriyoruz ve ilk kolla karşılaştırıyoruz.</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p>Eşleşiyor! Eklenecek bir değer yoktur, bu nedenle program durur ve <code>=&gt;</code> öğesinin sağ tarafındaki <code>None</code> değerini döndürür. 
İlk kol eşleştiği için diğer kollar karşılaştırılmaz.</p>
<p><code>match</code> ve <code>enum</code>'u birleştirmek çoğu durumda yararlıdır. 
Bu modeli birçok Rust kodunda göreceksiniz: <code>enum</code> eşleştirmek, içindeki verilere bir değişken bağlamak ve ardından buna dayalı olarak kod yürütmek. 
İlk başta biraz zor ama alıştıktan sonra tüm dillerde olmasını dileyeceksiniz. Rustseverlerin favorisidir.</p>
<h3 id="matchler-kapsamlıdır"><a class="header" href="#matchler-kapsamlıdır"><code>match</code>'ler Kapsamlıdır</a></h3>
<p><code>match</code>'in tartışmamız gereken başka bir yönü daha var: 
kollardaki modeller tüm olasılıkları kapsamalıdır. 
Bir hata içeren ve derlenmeyecek olan <code>plus_one</code> fonksiyonumuzun bu sürümünü düşünün:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p><code>None</code> durumunu ele almadık yani eğer <code>None</code> <code>match</code>'e argüman olarak verilirse bir sorun ortaya çıkacaktır.
Şansımıza ki, bu sorun Rust'ın nasıl çözeceğini bildiği bir sorundur. Eğer kodu çalıştırırsak, Rust bize bu hatayı
verecektir:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --&gt; src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
    = note: the matched value is of type `Option&lt;i32&gt;`

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
</code></pre>
<p>Rust, olası her durumu ele almadığımızı ve hatta hangi modeli unuttuğumuzu biliyor! 
Rust'taki <code>match</code>'ler <em>kapsamlıdır</em>: Kodun geçerli olması için son tüm olasılıkları ele almalıyız. 
Özellikle <code>Option&lt;T&gt;</code> durumunda; Rust, <code>None</code> durumunu açıkça ele almayı unutmamızı engellediğinde, 
<code>null</code>'a sahip olabileceğimiz bir değere sahip olduğumuzu varsaymaktan bizi korur, 
böylece daha önce tartışılan milyar dolarlık hatayı imkansız hale getirir.</p>
<h3 id="tümünü-yakalama-modelleri-ve-_-yer-tutucusu"><a class="header" href="#tümünü-yakalama-modelleri-ve-_-yer-tutucusu">Tümünü Yakalama Modelleri ve <code>_</code> Yer Tutucusu</a></h3>
<p><code>enum</code>'u kullanarak, belirli birkaç değer için özel eylemler de yapabiliriz, 
ancak diğer tüm değerler için bir varsayılan eylem gerçekleştirir. Bir zar atarken 3 atarsanız, 
oyuncunuzun hareket etmediği, bunun yerine yeni bir süslü şapka aldığı bir oyun uyguladığımızı hayal edin. 
7 atarsanız, oyuncunuz süslü bir şapka kaybeder. Diğer tüm değerler için, oyuncunuz oyun tahtasında bu sayıda 
yeri hareket ettirir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
<span class="boring">}
</span></code></pre></pre>
<p>İlk iki kol için modeller, 3 ve 7 değişmez değerleridir. Diğer tüm olası değerleri kapsayan son kol için, 
model, diğer olarak adlandırmayı seçtiğimiz değişkendir. Diğer kol için çalışan kod, 
değişkeni <code>move_player</code> fonksiyonuna geçirerek kullanır.</p>
<p>Bu kod, bir <code>u8</code>'in sahip olabileceği tüm olası değerleri listelememiş olsak bile derlenir, 
çünkü son model özel olarak listelenmemiş tüm değerlerle eşleşecektir. Bu tümünü yakalama modeli, 
<code>match</code>'in kapsamlı olması gerekliliğini karşılar. Modeller sırayla değerlendirildiği için tümünü yakalama kolunu 
en sona koymamız gerektiğini unutmayın. Her şeyi yakalama kolunu daha erken koyarsak, diğer kollar asla çalışmaz, 
bu yüzden hepsini yakalamadan sonra kolları eklersek Rust bizi uyarır!</p>
<p>Rust'ta ayrıca hepsini yakalamak istediğimizde ancak tümünü yakalama modelindeki değeri kullanmak istemediğimizde kullanabileceğimiz 
bir model vardır: <code>_</code> herhangi bir değerle eşleşen ve o değere bağlanmayan özel bir modeldir. 
Bu, Rust'a değeri kullanmayacağımızı söyler, bu nedenle Rust bizi kullanılmayan bir değişken hakkında uyarmaz.</p>
<p>Oyunun kurallarını değiştirelim: şimdi, 3 veya 7'den başka bir şey atarsanız, tekrar atmanız gerekir. 
Artık tümünü yakalama değerini kullanmamız gerekmiyor, bu nedenle kodumuzu <code>other</code> adlı değişken yerine <code>_</code> kullanacak şekilde 
değiştirebiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
<span class="boring">}
</span></code></pre></pre>
<p>Bu örnek ayrıca, son koldaki diğer tüm değerleri açıkça yok saydığımız için ayrıntılı olma gereksinimini de karşılamaktadır; 
hiçbir şeyi unutmadık.</p>
<p>Son olarak, oyunun kurallarını bir kez daha değiştireceğiz, böylece 3 veya 7'den başka bir şey atarsanız, 
başla bir şey ortaya çıkmaz. Bunu, <code>_</code> ile gelen kod olarak birim değeri kullanarak ifade edebiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
<span class="boring">}
</span></code></pre></pre>
<p>Burada, Rust'a açıkça daha önceki bir koldaki bir modelle eşleşmeyen başka bir değer kullanmayacağımızı ve 
bu durumda herhangi bir kod çalıştırmak istemediğimizi söylüyoruz.</p>
<p>Modeller ve eşleştirme hakkında <a href="ch18-00-patterns.html">Bölüm
18</a><!-- ignore -->'de ele alacağımız daha çok şey var. 
Şimdilik, <code>match</code> ifadesinin biraz kullanışsız olduğu durumlarda faydalı olabilecek <code>if let</code> söz dizimine geçeceğiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="if-let-ile-kontrol-akışı"><a class="header" href="#if-let-ile-kontrol-akışı"><code>if let</code> ile Kontrol Akışı</a></h2>
<p><code>if let</code> söz dizimi, <code>if</code> ve <code>let</code> sözcüklerini bir modelle eşleşen değerleri işlemek ve gerisini 
yok saymak için daha az ayrıntılı bir şekilde birleştirmenize olanak tanır. Liste 6-6'daki, <code>config_max</code> değişkenindeki bir <code>Option&lt;u8&gt;</code> değeriyle eşleşen, ancak yalnızca değer <code>Some</code> değişkeniyse kodu yürütmek isteyen programı düşünün.
ode if the value is the <code>Some</code> variant.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    match config_max {
        Some(max) =&gt; println!(&quot;The maximum is configured to be {}&quot;, max),
        _ =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 6-6: Değer yalnızca <code>Some</code> olduğunda kodu çalıştırmayı önemseyen bir <code>eşleşme</code></span></p>
<p>Eğer değer <code>Some</code> ise, değeri modeldeki <code>max</code> değişkenine atayarak <code>Some</code> varyantındaki değeri yazdırırız. 
<code>None</code> değeriyle hiçbir şey yapmak istemiyoruz. <code>match</code> ifadesi için, yalnızca bir değişkeni işledikten sonra <code>_ =&gt; ()</code> eklemeliyiz, 
bu da eklemesi can sıkıcı bir koddur.</p>
<p>Bunun yerine, <code>if let</code> yapısını kullanarak bunu daha kısa bir şekilde yazabiliriz. 
Aşağıdaki kod, Liste 6-6'daki <code>match</code> yapısıyla aynı şekilde davranır:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!(&quot;The maximum is configured to be {}&quot;, max);
    }
<span class="boring">}
</span></code></pre></pre>
<p><code>if let</code> söz dizimi, eşittir işaretiyle ayrılmış bir model ve ifade alır. 
İfadenin <code>match</code>'e verildiği ve modelin ilk kolu olduğu bir <code>match</code> ile aynı şekilde çalışır. 
Bu durumda, model <code>Some(max)</code> şeklindedir ve <code>max</code>, <code>Some</code> içindeki değere atanır. Daha sonra, <code>match</code> yapısında <code>max</code>'ı kullandığımız gibi, 
<code>if let</code> bloğunun gövdesinde de <code>max</code>ı kullanabiliriz. Değer modelle eşleşmezse <code>if let</code> bloğundaki kod çalışmaz.</p>
<p><code>if let</code> kullanmak, daha az yazma, daha az girinti ve daha az ilintili kod anlamına gelir.
Ancak, <code>match</code>'in zorunlu kıldığı kapsamlı denetimi kaybedersiniz. <code>match</code> ve <code>if let</code> arasında seçim yapmak, 
kendi özel durumunuzda ne yaptığınıza ve kısalık kazanmanın kapsamlı kontrolü kaybetmek için uygun bir değiş tokuş olup olmadığına bağlıdır.</p>
<p>Başka bir deyişle, <code>if let</code> ifadesini, değer bir model eşleştiğinde kodu çalıştıran ve ardından diğer tüm değerleri yok sayan bir <code>match</code> için 'sözdizimsel tatlılık' olarak düşünebilirsiniz.</p>
<p>Bir <code>if let</code>'e <code>else</code> ekleyebiliriz. <code>else</code> ile gelen kod bloğu, <code>if let</code> ve <code>else</code>'e eş değer olan <code>match</code> ifadesindeki <code>_</code> 
durumu ile kullanılacak kod bloğu ile aynıdır. <code>Quarter</code> varyantının da bir <code>UsState</code> değerine sahip olduğu Liste 6-4'teki 
<code>Coin</code> numralandırılmış yapı tanımını hatırlayın. Çeyreklerin durumunu açıklarken gördüğümüz tüm çeyrek olmayan paraları saymak istersek, 
bunu şöyle bir eşleşme ifadesi ile yapabilirdik:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),
        _ =&gt; count += 1,
    }
<span class="boring">}
</span></code></pre></pre>
<p>Veya şu şekildeki bir <code>if let</code> ve <code>else</code> ifadesini kullanabiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!(&quot;State quarter from {:?}!&quot;, state);
    } else {
        count += 1;
    }
<span class="boring">}
</span></code></pre></pre>
<p>Programınızın bir <code>match</code> kullanarak ifade edemeyecek kadar ayrıntılı bir mantığının olduğu bir durumunuz varsa, 
<code>if let</code>'in de Rust araç kutunuzda olduğunu unutmayın.</p>
<h2 id="Özet-3"><a class="header" href="#Özet-3">Özet</a></h2>
<p>Şimdi, bir dizi numaralandırılmış değerden biri olabilecek özel türler oluşturmak için 
numaralandırmaların nasıl kullanılacağını ele aldık. Standart kütüphanenin sunmuş olduğu <code>Option&lt;T&gt;</code> türünün, 
hataları önlemek için tür sistemini kullanmanıza nasıl yardımcı olduğunu gösterdik. 
Numaralandırılmış yapı değerlerinin içinde veriler olduğunda, 
kaç modeli ele almanız gerektiğine bağlı olarak bu değerleri çıkarmak ve kullanmak için <code>match</code> veya <code>if let</code> kullanabilirsiniz.</p>
<p>Rust programlarınız artık yapıları ve numaralandırmaları kullanarak etki alanınızdaki kavramları ifade edebilir. 
API'nizde kullanılacak özel türler oluşturmak, tür güvenliğini sağlar: derleyici, fonksiyonlarınızın yalnızca her işlevin beklediği türden değerleri almasını sağlar.</p>
<p>Kullanıcılarınıza iyi organize edilmiş, kullanımı kolay ve yalnızca kullanıcılarınızın ihtiyaç duyacaklarını tam olarak ortaya koyan bir API sağlamak için şimdi Rust'ın modüllerine dönelim.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="büyüyen-projeleri-paketler-kasalar-ve-modüllerle-yönetme"><a class="header" href="#büyüyen-projeleri-paketler-kasalar-ve-modüllerle-yönetme">Büyüyen Projeleri Paketler, Kasalar ve Modüllerle Yönetme</a></h1>
<p>Büyük programlar yazarken, kodunuzu düzenlemek giderek daha önemli hale gelecektir. 
İlgili fonksiyonları gruplandırarak ve kodu farklı özelliklerle ayırarak, belirli bir özelliği uygulayan kodu nerede bulacağınızı ve bir özelliğin nasıl çalıştığını değiştirmek için nereye gideceğinizi netleştireceksiniz.</p>
<p>Şimdiye kadar yazdığımız programlar tek bir dosyada tek bir modülde olmuştur. 
Bir proje büyüdükçe, kodu birden çok modüle ve ardından birden çok dosyaya bölerek düzenlemeniz gerekir.
Bir paket, birden çok ikili kasa ve isteğe bağlı olarak bir kütüphane kasası içerebilir. Bir paket büyüdükçe, 
parçaları dış bağımlılıklar haline gelen ayrı kasalara çıkarabilirsiniz. 
Bu bölüm tüm bu teknikleri kapsar. Birlikte gelişen birbiriyle ilişkili bir dizi paketten oluşan çok büyük projeler için Cargo, Bölüm 14'teki <a href="ch14-03-cargo-workspaces.html">“Cargo'nun Çalışma Alanları”</a><!-- ignore --> bölümünde ele alacağımız çalışma alanları sağlar.</p>
<p>Ayrıca, kodu daha yüksek bir düzeyde yeniden kullanmanıza olanak tanıyan kapsülleme uygulama ayrıntılarını da tartışacağız: Bir işlemi uyguladıktan sonra, diğer kod, uygulamanın nasıl çalıştığını bilmek zorunda kalmadan ortak arabirimi aracılığıyla kodunuzu arayabilir. Kodu yazma şekliniz, diğer kodun kullanması için hangi bölümlerin genel olduğunu ve hangi bölümlerin değiştirme hakkını saklı tuttuğunuz özel uygulama ayrıntıları olduğunu tanımlar. Bu, kafanızda tutmanız gereken ayrıntı miktarını sınırlamanın başka bir yoludur.</p>
<p>İlgili bir kavram kapsamdır: Kodun yazıldığı iç içe bağlam, “kapsam dahilinde” olarak tanımlanan bir dizi isme sahiptir. 
Kod okurken, yazarken ve derlerken, programcılar ve derleyiciler, belirli bir noktadaki belirli bir adın bir değişkene, fonksiyona, yapıya, numaralandırılmış yapıya, modüle, sabite veya başka bir öğeye atıfta bulunup bulunmadığını ve bu öğenin ne anlama geldiğini bilmelidir. 
Kapsamlar oluşturabilir ve hangi adların kapsam içinde veya dışında olduğunu değiştirebilirsiniz. Aynı kapsamda aynı ada sahip iki öğeniz olamaz; ad çakışmalarını çözmek için araçlar mevcuttur.</p>
<p>Rust, hangi ayrıntıların açığa çıktığı, hangi ayrıntıların özel olduğu ve programlarınızdaki her kapsamda hangi adların bulunduğu dahil olmak üzere kodunuzun organizasyonunu yönetmenize olanak tanıyan bir dizi özelliğe sahiptir. Bazen toplu olarak modül sistemi olarak adlandırılan bu özellikler şunları içerir:</p>
<ul>
<li><strong>Paketler</strong>: Kasaları oluşturmanıza, test etmenize ve paylaşmanıza olanak tanıyan bir Cargo özelliği</li>
<li><strong>Kasalar</strong>: Bir kütüphane ve yürütülebilir dosya oluşturan bir modül ağacı</li>
<li><strong>Modüller</strong>: Yolların organizasyonunu, kapsamını ve gizliliğini kontrol etmeye izin</li>
<li><strong>Yollar</strong>: Yapı, fonksiyon veya modül gibi bir öğeyi adlandırmanın bir yolu</li>
</ul>
<p>Bu bölümde, tüm bu özellikleri ele alacağız, nasıl etkileşime girdiklerini tartışacağız ve kapsamı yönetmek için bunların nasıl kullanılacağını açıklayacağız.</p>
<p>Bölüm sonu canavarını kestiğinizde, modül sistemi hakkında sağlam bir anlayışa sahip olmalısınız ve bir usta gibi kapsamlarla çalışabilmelisiniz!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="paketler-ve-kasalar"><a class="header" href="#paketler-ve-kasalar">Paketler ve Kasalar</a></h2>
<p>Modül sisteminin ele alacağımız ilk kısımları paketler ve kasalardır.</p>
<p><em>Kasa</em>, Rust derleyicisinin bir seferde dikkate aldığı en küçük kod miktarıdır. 
<code>cargo</code> yerine <code>rustc</code> çalıştırsanız ve tek bir kaynak kod dosyası iletseniz bile (1. Bölüm'ün “Bir Rust Programı Yazma ve Çalıştırma” bölümünde yaptığımız gibi), derleyici bu dosyayı bir kasa olarak kabul eder. Kasalar modüller içerebilir ve modüller, 
sonraki bölümlerde göreceğimiz gibi, kasa ile derlenen diğer dosyalarda tanımlanabilir.</p>
<p>Bir kasa iki biçimde olabilir: ikili kasa veya kütüphane kasası. İkili kasalar, bir komut satırı programı veya bir sunucu gibi 
çalıştırabileceğiniz bir yürütülebilir dosyaya derleyebileceğiniz programlardır. Her birinin, yürütülebilir dosya çalıştığında ne olacağını 
tanımlayan <code>main</code> adlı fonksiyonu olmalıdır. Şimdiye kadar yarattığımız tüm kasalar ikili kasalardı.</p>
<p><em>Kütüphane kasalarının</em> <code>main</code> fonksiyonu yoktur ve yürütülebilir bir dosyaya derlenmezler. Bunun yerine, birden çok projeyle paylaşılması amaçlanan
fonksiyonları tanımlarlar. Örneğin, Bölüm 2'de kullandığımız <code>rand</code> kasası, <em>sözde rastgele</em> sayılar üreten işlevsellik sağlar. 
Rustseverler çoğu zaman “kasa” derken, kütüphane kasası demek isterler ve “kasa” sözcüğünü genel programlama kavramı olan 
“kütüphane” ile birbirinin yerine kullanırlar.</p>
<p>Kasa kökü, Rust derleyicisinin başlattığı ve kasanızın kök modülünü oluşturan bir kaynak dosyadır 
(<a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">“Kapsam ve Gizliliği Kontrol Etmek için Modüller Tanımlamak”</a><!-- ignore --> bölümünde modülleri ayrıntılı olarak açıklayacağız).</p>
<p>Paket, bir dizi işlevsellik sağlayan bir veya daha fazla kasadan oluşan bir pakettir. 
Bir paket, bu kasaların nasıl oluşturulacağını açıklayan bir <em>Cargo.toml</em> dosyası içerir. Cargo aslında kodunuzu oluşturmak için kullandığınız 
komut satırı aracı için ikili kasayı içeren bir pakettir. Cargo paketi ayrıca ikili kasanın bağlı olduğu bir kütüphane kasası içerir. 
Diğer projeler, Cargo komut satırı aracının kullandığı mantığı kullanmak için Cargo kütüphane kasasını kullanabilir.</p>
<p>Bir paket, istediğiniz kadar ikili kasa içerebilir, ancak en fazla yalnızca bir kütüphane kasası olabilir. 
Bir paket, ister kitaplık ister ikili kasa olsun, en az bir kasa içermelidir.</p>
<p>Bir paket oluşturduğumuzda neler olduğunu gözden geçirelim. İlk olarak, <code>cargo new</code> komutunu giriyoruz:</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p><code>cargo new</code>'i çalıştırdıktan sonra, <code>cargo</code>'nun ne oluşturduğunu görmek için <code>ls</code> kullanırız. 
Proje dizininde bize bir paket veren bir <em>Cargo.toml</em> dosyası var. Ayrıca <em>main.rs</em>'i içeren bir <em>src</em> dizini vardır. 
Metin düzenleyicinizde <em>Cargo.toml</em>'yi açın ve burada <em>src/main.rs</em>'den bahsedilmediğini unutmayın. 
Cargo, <em>src/main.rs</em> öğesinin, paketle aynı ada sahip bir ikili kasanın kasa kökü olduğu kuralına uyar. 
Benzer şekilde, Cargo, paket dizini <em>src/lib.rs</em> içeriyorsa, paketin paketle aynı ada sahip bir kütüphane kasası içerdiğini ve 
<em>src/lib.rs</em>'nin bunun kasa kökü olduğunu bilir. Cargo, kütüphaneyi veya ikili dosyayı oluşturmak için 
sandık kök dosyalarını <code>rustc</code>'ye iletir.</p>
<p>Burada, yalnızca <em>src/main.rs</em> içeren bir paketimiz var, yani yalnızca <em>my-project</em> adında bir ikili sandık içeriyor. 
Bir paket <em>src/main.rs</em> ve <em>src/lib.rs</em> içeriyorsa, iki kasası vardır: ikisi de paketle aynı ada sahip ikili dosya ve kütüphane. 
Bir paket, dosyaları <em>src/bin</em> dizinine yerleştirerek birden çok ikili kasaya sahip olabilir: 
her dosya ayrı bir ikili kasa olacaktır.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kapsam-ve-gizliliği-kontrol-etmek-İçin-modüllerin-tanımlanması"><a class="header" href="#kapsam-ve-gizliliği-kontrol-etmek-İçin-modüllerin-tanımlanması">Kapsam ve Gizliliği Kontrol Etmek İçin Modüllerin Tanımlanması</a></h2>
<p>Bu bölümde, modüller ve modül sisteminin diğer bölümlerinden, yani öğeleri adlandırmanıza izin veren yollardan bahsedeceğiz; 
kapsam içine bir yol getiren <code>use</code> anahtar sözcüğü; ve öğeleri herkese açık hale getirmek için <code>pub</code> anahtar sözcüğü. 
Ayrıca <code>as</code> anahtar sözcüğünü, harici paketleri ve <code>glob</code> operatörünü tartışacağız.</p>
<p>İlk olarak, kodunuzu düzenlerken kolay referans için bir kurallar listesiyle başlayacağız. 
Ardından, kuralların her birini ayrıntılı olarak açıklayacağız.</p>
<h3 id="modüllerin-ana-hatları"><a class="header" href="#modüllerin-ana-hatları">Modüllerin Ana Hatları</a></h3>
<p>Burada modüllerin, yolların, <code>use</code> anahtar sözcüğünün ve <code>pub</code> anahtar sözcüğünün derleyicide nasıl çalıştığı ve 
çoğu geliştiricinin kodlarını nasıl düzenlediği hakkında hızlı bir referans sağlıyoruz. 
Bu bölüm boyunca bu kuralların her birinin örneklerini inceleyeceğiz, ancak şu an, 
modüllerin nasıl çalıştığını hatırlatmak için harika bir zamandır.</p>
<ul>
<li><strong>Sandık kökünden başlamak</strong>: Bir kasayı derlerken, derleyici ilk olarak kasa 
kök dosyasına bakar (genellikle bir kütüphane kasası için <em>src/lib.rs</em> veya bir ikili kasa için <em>src/main.rs</em>).</li>
<li><strong>Modüller tanımlamak</strong>: Sandık kök dosyasında yeni modüller tanımlayabilirsiniz;
diyelim ki <code>mod garden</code> ile bir “garden” modülü tanımladınız; Derleyici, modülün kodunu şu yerlerde arayacaktır:
<ul>
<li>Noktalı virgül yerine süslü parantez içinde <code>mod garden</code>'ı doğrudan takip eden satır içi</li>
<li><em>src/garden.rs</em> dosyasında</li>
<li><em>src/garden/mod.rs</em> dosyasında</li>
</ul>
</li>
<li><strong>Alt modül tanımlamak</strong>: Sandık kökü dışındaki herhangi bir dosyada alt modüller bildirebilirsiniz. 
Örneğin, <code>mod vegetables</code> tanımlayabilirsiniz; <em>src/garden.rs</em>'de olacak şekilde. Derleyici, aşağıdaki yerlerde ana modül 
için adlandırılan dizinde alt modülün kodunu arayacaktır:
<ul>
<li>Satır içi, noktalı virgül yerine süslü parantezler içinde; <code>mod vegetables</code>'ın hemen ardından</li>
<li><em>src/garden/vegetables.rs</em> dosyasında</li>
<li><em>src/garden/vegetables/mod.rs</em> dosyasında</li>
</ul>
</li>
<li><strong>Modüllerde kodlama yolları</strong>: Bir modül kasanızın bir parçası olduğunda, gizlilik kurallarının izin verdiği sürece, 
kodun yolunu kullanarak aynı kasadaki herhangi bir yerden o modüldeki koda başvurabilirsiniz. 
Örneğin, <em>vegetables</em> modülündeki bir <code>Asparagus</code> türü <code>crate::garden::vegetables::Asparagus</code>'ta bulunur.</li>
<li><strong>Özel vs genel</strong>: Bir modül içindeki kod, varsayılan olarak üst modüllerinden özeldir. 
Bir modülü herkese açık hale getirmek için <code>mod</code> yerine <code>pub mod</code> ile bildirin. 
Bir genel modül içindeki öğeleri de herkese açık hale getirmek için, bildirimlerinden önce <code>pub</code>'ı kullanın.</li>
<li><strong><code>use</code> anahtar sözcüğü</strong>: Bir kapsam içinde, <code>use</code> anahtar sözcüğü, uzun yolların tekrarını azaltmak için öğelere kısayollar oluşturur.
<code>crate::garden::vegetables::Asparagus</code> ile ilgili olabilecek herhangi bir kapsamda, <code>use crate::garden::vegetables::Asparagus</code> 
kullanarak bir kısayol oluşturabilirsiniz; ve o andan itibaren bu türden kapsamda faydalanmak için sadece <code>Asparagus</code> yazmanız yeterlidir.</li>
</ul>
<p>Burada, bu kuralları gösteren <code>backyard</code> adında bir ikili sandık oluşturuyoruz. Kasanın <code>backyard</code> olarak da adlandırılan dizini 
şu dosyaları ve dizinleri içerir:</p>
<pre><code class="language-text">backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
</code></pre>
<p>Bu durumda sandık kök dosyası <em>src/main.rs</em> şeklindedir ve şunları içerir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust noplayground ignore">use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!(&quot;I'm growing {:?}!&quot;, plant);
}
</code></pre>
<p><code>pub mod garden;</code> satırı, derleyiciye <em>src/garden.rs</em> içinde bulduğu kodu eklemesini söyler;</p>
<p><span class="filename">Dosya adı: src/garden.rs</span></p>
<pre><code class="language-rust noplayground ignore">pub mod vegetables;
</code></pre>
<p>Burada <code>pub mod vegetables</code>, <em>src/garden/vegetables.rs</em> içindeki kodun da dahil olduğu anlamına gelir. Bu kod:</p>
<pre><code class="language-rust noplayground ignore">#[derive(Debug)]
pub struct Asparagus {}
</code></pre>
<p>Şimdi bu kuralların ayrıntılarına girelim ve bunları uygulamada gösterelim!</p>
<h3 id="İlgili-kodu-modüllerde-gruplama"><a class="header" href="#İlgili-kodu-modüllerde-gruplama">İlgili Kodu Modüllerde Gruplama</a></h3>
<p><em>Modüller</em>, okunabilirlik ve kolay yeniden kullanım için kodu bir kasa içinde düzenlememize izin verir. 
Modüller ayrıca, bir modül içindeki kod varsayılan olarak özel olduğundan, <em>öğelerin gizliliğini</em> kontrol etmemizi sağlar. 
Özel öğeler, harici kullanım için mevcut olmayan dahili uygulama ayrıntılarıdır.
Modülleri ve içlerindeki öğeleri herkese açık hale getirmeyi seçebiliriz, 
bu da onları harici kodun kullanmasına ve bunlara bağımlı olmasına izin verecek şekilde ortaya çıkarır.</p>
<p>Örnek olarak bir restoranın fonksiyonelliğini sağlayan bir kütüphane kasası yazalım. 
Fonksiyonların imzalarını tanımlayacağız, ancak bir restoranın süreklenmesinden ziyade kodun organizasyonuna konsantre 
olmak için fonksiyon içlerini boş bırakacağız.</p>
<p>Restoran endüstrisinde, bir restoranın bazı bölümleri <em>evin önü</em>, diğerleri ise <em>evin arkası</em> olarak adlandırılır. 
Evin önü müşterilerin bulunduğu yerdir; bu, ev sahiplerinin müşterileri oturduğu, sunucuların siparişleri ve ödemeleri aldığı ve 
barmenlerin içecek verdiği yerleri kapsar. Evin arkası, mutfakta şeflerin ve aşçıların çalıştığı, 
bulaşık makinelerinin temizlik yaptığı ve yöneticilerin idari işleri yaptığı yerdir.</p>
<p>Kasamızı bu şekilde yapılandırmak için işlevlerini iç içe modüller halinde düzenleyebiliriz.
<code>cargo new --lib restaurant</code> komutunu kullanarak <code>restaurant</code> adında yeni kütüphane oluşturun, daha sonra bazı 
modülleri ve fonksiyon imzalarını tanımlamak için Liste 7-1'deki kodu <em>src/lib.rs</em> içine girin. İşte evin ön cephesi:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
</code></pre>
<p><span class="caption">Liste 7-1: Fonksiyonları içeren ve diğer modülleri içeren bir <code>front_of_house</code> 
modülü</span></p>
<p><code>mod</code> anahtar sözcüğünü ve ardından modülün adını (bu durumda, <code>front_of_house</code>) 
takip eden bir modül tanımlarız. Modülün gövdesi süslü parantezlerin içine girer. 
Modüllerin içine, diğer modülleri de yerleştirebiliriz, bu durumda modüllerin barındırılması ve 
sunulmasında olduğu gibi. Modüller ayrıca yapılar, numaralandırmalar, sabitler, özellikler ve -Liste 7-1'de olduğu gibi- 
fonksiyonlar gibi diğer öğeler için tanımları da içerebilir.</p>
<p>Modülleri kullanarak ilgili tanımları birlikte gruplayabilir ve neden ilişkili olduklarını adlandırabiliriz. 
Bu kodu kullanan programcılar, tüm tanımları okumak zorunda kalmadan gruplara göre kodda gezinebilir, 
bu da kendileriyle ilgili tanımları bulmayı kolaylaştırır. Bu koda yeni fonksiyonlar ekleyen programcılar, 
programı düzenli tutmak için kodu nereye yerleştireceklerini bilirler.</p>
<p>Daha önce, <em>src/main.rs</em> ve <em>src/lib.rs</em>'nin kasa kökleri olarak adlandırıldığından bahsetmiştik. 
Adlarının nedeni, bu iki dosyadan herhangi birinin içeriğinin, kasanın modül yapısının kökünde, 
modül ağacı olarak bilinen <code>crate</code> adlı bir modül oluşturmasıdır.</p>
<p>Liste 7-2, Liste 7-1'deki yapı için modül ağacını gösterir.</p>
<pre><code class="language-text">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p><span class="caption">Liste 7-2: Liste 7-1'deki kod için modül ağacı</span></p>
<p>Bu ağaç, bazı modüllerin birbirinin içine nasıl yuvalandığını gösterir; örneğin, <code>front_of_house</code> içinde <code>hosting</code>'i barındırır. 
Ağaç ayrıca bazı modüllerin birbiriyle kardeş olduğunu, yani aynı modülde tanımlandıklarını gösterir; 
<code>hosting</code> ve <code>serving</code>, <code>front_of_house</code> içinde tanımlanan kardeşlerdir. 
A modülü B modülünün içindeyse, A modülünün B modülünün <em>çocuğu</em> olduğunu ve B modülünün A modülünün <em>ebeveyni</em> olduğunu söyleriz. 
Tüm modül ağacının <code>crate</code> adlı örtük modül altında köklendiğine dikkat edin.</p>
<p>Modül ağacı size bilgisayarınızdaki dosya sisteminin dizin ağacını hatırlatabilir; 
bu çok uygun bir karşılaştırma! Tıpkı bir dosya sistemindeki dizinler gibi, kodunuzu düzenlemek için modülleri kullanırsınız. 
Ve tıpkı bir dizindeki dosyalar gibi, modüllerimizi bulmanın da kolay bir yoluna ihtiyacımız vardır.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="modül-ağacındaki-bir-Öğeye-başvuru-yolları"><a class="header" href="#modül-ağacındaki-bir-Öğeye-başvuru-yolları">Modül Ağacındaki Bir Öğeye Başvuru Yolları</a></h2>
<p>Bir modül ağacında bir öğeyi nerede bulacağını Rust'a göstermek için, bir dosya sisteminde gezinirken bir yol 
kullandığımız gibi bir yol kullanırız. Bir fonksiyonu çağırmak için yolunu bilmemiz gerekir.</p>
<p>Bir yol iki şekilde olabilir:</p>
<ul>
<li><em>Mutlak yol</em>, sandık kökünden başlayan tam yoldur; harici bir kasadan gelen kod için, 
mutlak yol kasa adıyla başlar ve mevcut kasadan gelen kod için değişmez kasayla başlar.</li>
<li><em>Göreli yol</em>, geçerli modülden başlar ve geçerli modülde <code>self</code>, <code>super</code> veya bir tanımlayıcı kullanır.</li>
</ul>
<p>Hem mutlak hem de göreli yolları, çift iki nokta (<code>::</code>) üst üste ile ayrılmış bir veya daha fazla tanımlayıcı izler.</p>
<p>Liste 7-1'e dönersek, <code>add_to_waitlist</code> fonksiyonunu çağırmak istediğimizi varsayalım. 
Bu, şunu sormakla aynıdır: <code>add_to_waitlist</code> fonksiyonunun yolu nedir? 
Liste 7-3, bazı modüller ve fonksiyonlar kaldırılmış olarak Liste 7-1'i içerir. 
Kasa kökünde tanımlanan yeni bir <code>eat_at_restaurant</code> fonksiyonundan sonra <code>add_to_waitlist</code> fonksiyonunu çağırmanın iki yolunu göstereceğiz.
<code>eat_at_restaurant</code> fonksiyonu, kütüphane kasamızın genel API'sinin bir parçasıdır, 
bu yüzden onu <code>pub</code> anahtar kelimesiyle işaretliyoruz. <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">“<code>pub</code> Anahtar Sözcüğüyle Yolları Gösterme”</a><!-- ignore
--> bölümünde, <code>pub</code> hakkında daha fazla ayrıntıya gireceğiz. Bu örneğin henüz derlenmeyeceğini unutmayın; 
nedenini birazdan açıklayacağız.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Liste 7-3: Mutlak ve göreli yolları kullanarak <code>add_to_waitlist</code>
fonksiyonunu çağırma</span></p>
<p><code>eat_at_restaurant</code>'ta <code>add_to_waitlist</code> fonksiyonunu ilk çağırdığımızda, mutlak bir yol kullanırız. 
<code>add_to_waitlist</code> fonksiyonu, <code>eat_at_restaurant</code> ile aynı kasada tanımlanır; bu, mutlak bir yol başlatmak için <code>crate</code> anahtar sözcüğünü
kullanabileceğimiz anlamına gelir. Ardından, <code>add_to_waitlist</code>'e gidene kadar ardışık modüllerin her birini dahil ederiz. 
Aynı yapıya sahip bir dosya sistemi hayal edebilirsiniz: <code>add_to_waitlist</code> programını çalıştırmak için 
<code>/front_of_house/hosting/add_to_waitlist</code> yolunu belirtirdik; kasa kökünden başlamak için <code>crate</code> adını kullanmak, 
kabuğunuzdaki dosya sistemi kökünden başlamak için <code>/</code> kullanmaya benzer.</p>
<p><code>eat_at_restaurant</code>'ta <code>add_to_waitlist</code>'i ikinci kez çağırdığımızda, göreceli bir yol kullanırız. 
Yol, modül ağacının <code>eat_at_restaurant</code> ile aynı düzeyinde tanımlanan modülün adı olan <code>front_of_house</code> ile başlar. 
Burada dosya sistemi eşdeğeri <code>front_of_house/hosting/add_to_waitlist</code> yolunu kullanıyor olacaktır. 
Bir modül adıyla başlamak, yolun göreceli olduğu anlamına gelir.</p>
<p>Göreceli mi yoksa mutlak yol mu kullanacağınızı seçmek, projenize göre vereceğiniz bir karardır ve 
öğe tanım kodunu öğeyi kullanan koddan ayrı mı yoksa onunla birlikte mi taşıma olasılığınızın daha yüksek olduğuna bağlıdır. 
Örneğin, <code>front_of_house</code> modülünü ve <code>eat_at_restaurant</code> fonksiyonunu <code>customer_experience</code> adlı bir modüle taşırsak, mutlak yolu 
<code>add_to_waitlist</code>'e güncellememiz gerekir, ancak göreli yol yine de geçerli olur. Ancak, <code>eat_at_restaurant</code> fonksiyonunu <code>dining</code> adlı bir 
modüle ayrı olarak taşırsak, <code>add_to_waitlist</code> çağrısının mutlak yolu aynı kalır, ancak göreli yolun güncellenmesi gerekir. 
Genel olarak tercihimiz mutlak yollar belirtmektir, çünkü kod tanımlarını ve öğe çağrılarını birbirinden bağımsız olarak taşımak 
isteyeceğimiz daha olasıdır.</p>
<p>Liste 7-3'ü derlemeye çalışalım ve neden henüz derlenmediğini öğrenelim! Aldığımız hata Liste 7-4'te gösterilmektedir.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^ private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^ private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
<p><span class="caption">Liste 7-4: Liste 7-3'te kodun oluşturulmasından kaynaklanan 
derleyici hataları</span></p>
<p>Hata mesajları, modül <code>hosting</code>'in gizli olduğunu söylüyor. Başka bir deyişle, 
<code>hosting</code> modülü ve <code>add_to_waitlist</code> fonksiyonu için doğru yollara sahibiz, ancak gizli bölümlere erişimi olmadığı 
için Rust bunları kullanmamıza izin vermiyor. Rust'ta tüm öğeler (fonksiyonlar, yöntemler, yapılar, numaralandırmalar, 
modüller ve sabitler) varsayılan olarak üst modüllere gizlidir. Bir fonksiyon veya yapı gibi bir öğeyi gizli yapmak istiyorsanız, 
onu bir modüle koyarsınız.</p>
<p>Bir üst modüldeki öğeler, alt modüllerdeki gizli öğeleri kullanamaz, ancak alt modüllerdeki öğeler, 
üst modüllerindeki öğeleri kullanabilir. Bunun nedeni, alt modüllerin uygulama ayrıntılarını sarması ve gizlemesidir, 
ancak alt modüller tanımlandıkları bağlamı görebilir. Metaforumuza devam etmek için, gizlilik kurallarını bir restoranın 
arka ofisi gibi düşünün: orada olup bitenler restoran müşterilerine özeldir, ancak ofis yöneticileri işlettikleri restoranda
her şeyi görebilir ve yapabilir.</p>
<p>Rust, modül sisteminin bu şekilde çalışmasını seçti, böylece dahili uygulama ayrıntılarını gizlemek varsayılandır. 
Bu şekilde, dış kodu bozmadan iç kodun hangi kısımlarını değiştirebileceğinizi bilirsiniz. Ancak Rust, bir öğeyi herkese açık 
hale getirmek için <code>pub</code> anahtar sözcüğünü kullanarak alt modüllerin kodunun iç kısımlarını dış üst modüllere gösterme seçeneği sunar.</p>
<h3 id="pub-anahtar-kelimesiyle-yolları-gösterme"><a class="header" href="#pub-anahtar-kelimesiyle-yolları-gösterme"><code>pub</code> Anahtar Kelimesiyle Yolları Gösterme</a></h3>
<p><code>hosting</code> modülünün gizli olduğunu söyleyen Liste 7-4'teki hataya dönelim. 
Ana modüldeki <code>eat_at_restaurant</code> fonksiyonunun alt modüldeki <code>add_to_waitlist</code> fonksiyonuna erişmesini istiyoruz, 
bu nedenle <code>hosting</code> modülünü Liste 7-5'te gösterildiği gibi <code>pub</code> anahtar sözcüğüyle işaretliyoruz.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Liste 7-5: <code>eat_at_restaurant</code>'tan kullanmak için <code>hosting</code> modülünü <code>pub</code> 
olarak bildirme</span></p>
<p>Ne yazık ki, Liste 7-5'teki kod, Liste 7-6'da gösterildiği gibi hala bir hatayla sonuçlanıyor.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
<p><span class="caption">Liste 7-6: Liste 7-5'te kodun oluşturulmasından kaynaklanan 
derleyici hataları</span></p>
<p>Ne oldu? <code>mod hosting</code>'in önüne <code>pub</code> anahtar sözcüğünü eklemek, modülü herkese açık hale getirir. 
Bu değişiklikle <code>front_of_house</code>'a erişebilirsek, <code>hosting</code>'e de erişebiliriz. Ancak <code>hosting</code> içeriği hala gizlidir; 
modülü herkese açık hale getirmek, içeriğini herkese açık hale getirmez. Bir modüldeki <code>pub</code> anahtar sözcüğü, iç koduna erişmesine değil, 
yalnızca ata modüllerindeki kodun ona başvurmasına izin verir. Modüller kapsayıcı olduğundan, yalnızca modülü herkese açık hale getirerek
yapabileceğimiz pek bir şey yoktur; daha ileri gitmemiz ve modül içindeki bir veya daha fazla öğeyi de herkese açık hale getirmeyi 
seçmemiz gerekiyor.</p>
<p>Liste 7-6'daki hatalar, <code>add_to_waitlist</code> fonksiyonunun gizli olduğunu söylüyor. 
Gizlilik kuralları yapılar, numaralandırmalar, fonksiyonlar ve yöntemler ile modüller için geçerlidir.</p>
<p>Ayrıca Liste 7-7'deki gibi tanımından önce <code>pub</code> anahtar sözcüğünü ekleyerek <code>add_to_waitlist</code> fonksiyonunu genel yapalım.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Liste 7-7: <code>mod hosting</code> ve <code>fn add_to_waitlist</code>'e <code>pub</code> eklemek, 
fonksiyonu <code>eat_at_restaurant</code>'tan çağırabilmemizi sağlar</span></p>
<p>Kod derlenecek! <code>pub</code> anahtar sözcüğünü eklemenin neden bu yolları <code>add_to_waitlist</code>'te gizlilik kurallarına göre kullanmamıza 
izin verdiğini görmek için mutlak ve göreli yollara bakalım.</p>
<p>Mutlak yolda, kasamızın modül ağacının kökü olan <code>crate</code> ile başlıyoruz. <code>front_of_house</code> modülü kasa kökünde tanımlanır. 
<code>front_of_house</code> herkese açık olmasa da, <code>eat_at_restaurant</code> fonksiyonu <code>front_of_house</code> ile aynı modülde tanımlandığından 
(yani, <code>eat_at_restaurant</code> ve <code>front_of_house</code> kardeştir), <code>eat_at_restaurant</code>'tan <code>front_of_house</code>'a başvurabiliriz. 
Sonraki, <code>pub</code> ile işaretlenmiş barındırma modülüdür. Barındırma ana modülüne erişebiliriz, 
böylece barındırmaya erişebiliriz. Son olarak, <code>add_to_waitlist</code> fonksiyonu <code>pub</code> ile işaretlenmiştir ve üst modülüne erişebiliriz, 
böylece bu fonksiyon çağrısı çalışır!</p>
<p>Göreceli yolda mantık, ilk adım dışında mutlak yolla aynıdır: <code>crate</code> kökünden başlamak yerine, yol <code>front_of_house</code>'dan başlar. 
<code>front_of_house</code> modülü, <code>eat_at_restaurant</code> ile aynı modül içinde tanımlanır, bu nedenle, <code>eat_at_restaurant</code>'ın tanımlandığı modülden 
başlayan göreli yol çalışır. Ardından, <code>hosting</code> ve <code>add_to_waitlist</code> <code>pub</code> ile işaretlendiğinden, yolun geri kalanı çalışır 
ve bu fonksiyon çağrısı da geçerlidir ve çalışır!</p>
<p>Diğer projelerin kodunuzu kullanabilmesi için kütüphane kasanızı paylaşmayı planlıyorsanız, 
genel API'niz, kasanızın kullanıcılarıyla, kodunuzla nasıl etkileşim kurabileceklerini belirleyen sözleşmenizdir. 
İnsanların kasanıza bağımlı olmasını kolaylaştırmak için genel API'nizde yapılan değişiklikleri yönetme konusunda birçok husus vardır. 
Bu düşünceler bu kitabın kapsamı dışındadır; Bu konuyla ilgileniyorsanız, bkz. <a href="https://rust-lang.github.io/api-guidelines/">Rust API Yönergeleri</a>.</p>
<blockquote>
<h4 id="İkili-program-ve-kitaplık-İçeren-paketler-için-en-İyi-uygulamalar"><a class="header" href="#İkili-program-ve-kitaplık-İçeren-paketler-için-en-İyi-uygulamalar">İkili Program ve Kitaplık İçeren Paketler için En İyi Uygulamalar</a></h4>
<p>Bir paketin hem bir <em>src/main.rs</em> ikili kasa kökü hem de bir <em>src/lib.rs</em> kütüphane kasa kökü içerebileceğinden ve 
her iki kasanın da varsayılan olarak paket adına sahip olacağından bahsetmiştik. Tipik olarak, 
hem kütüphane hem de ikili kasa içeren bu modele sahip paketler, ikili kasada kütüphane kasasıyla kod çağıran bir yürütülebilir 
dosyayı başlatmak için yeterli koda sahip olacaktır. Bu, kütüphane kasasının kodu paylaşılabildiğinden, diğer projelerin 
paketin sağladığı en fazla işlevsellikten faydalanmasını sağlar.
Modül ağacı <em>src/lib.rs</em> içinde tanımlanmalıdır. Ardından, paketin adıyla yolları başlatarak ikili sandıkta herhangi 
bir genel öğe kullanılabilir. İkili kasa, tıpkı tamamen harici bir kasanın kütüphane kasasını kullanması gibi kütüphane kasasının 
bir kullanıcısı olur: yalnızca genel API'yi kullanabilir. Bu, iyi bir API tasarlamanıza yardımcı olur; 
sadece yazar değil, aynı zamanda bir müşterisiniz!</p>
<p><a href="ch12-00-an-io-project.html">Bölüm 12</a><!-- ignore -->'de hem ikili kasa hem de kitaplık kasası içeren bir komut satırı programıyla bu organizasyonel uygulamayı
göstereceğiz.</p>
</blockquote>
<h3 id="göreli-yolları-super-ile-başlatma"><a class="header" href="#göreli-yolları-super-ile-başlatma">Göreli Yolları <code>super</code> ile Başlatma</a></h3>
<p>Yolun başlangıcında <code>super</code> kullanarak, geçerli modül veya kasa kökü yerine ana modülde başlayan göreli yollar oluşturabiliriz. 
Bu, <code>..</code> söz dizimi ile bir dosya sistemi yolunu başlatmak gibidir. Bu, üst modülde olduğunu bildiğimiz bir öğeye başvurmamızı sağlar; 
bu, modül üst öğeyle yakından ilişkili olduğunda modül ağacının yeniden düzenlenmesini kolaylaştırabilir, 
ancak üst öğe bir gün modül ağacında başka bir yere taşınabilir.</p>
<p>Bir şefin yanlış bir siparişi düzelttiği ve bunu müşteriye kişisel olarak sunduğu durumu modelleyen Liste 7-8'deki kodu göz önünde bulundurun. <code>back_of_house</code> modülünde tanımlanan <code>fix_incorrect_order</code> fonksiyonu, <code>super</code> ile başlayan <code>deliver_order</code> yolunu belirterek üst modülde 
tanımlanan <code>deliver_order</code> fonksiyonunu çağırır:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
</code></pre>
<p><span class="caption">Liste 7-8: <code>super</code> ile başlayan göreli bir yol kullanarak 
bir fonksiyonu çağırma</span></p>
<p><code>fix_incorrect_order</code> fonksiyonu <code>back_of_house</code> modülündedir, 
bu nedenle <code>super</code>'i <code>back_of_house</code>'un üst modülüne gitmek için kullanabiliriz, 
bu durumda kasa, köktür. Oradan <code>deliver_order</code> arar ve buluruz. Başarılı! Kasanın modül ağacını yeniden düzenlemeye karar vermemiz durumunda, 
<code>back_of_house</code> modülünün ve <code>deliver_order</code> fonksiyonunun birbiriyle aynı ilişkide kalacağını ve birlikte hareket edeceğini düşünüyoruz. 
Bu nedenle, gelecekte bu kod farklı bir modüle taşınırsa kodu güncellemek için daha az yerimiz olacağı için <code>super</code> kullandık.</p>
<h3 id="yapıları-ve-numaralandırmaları-herkese-açık-yapma"><a class="header" href="#yapıları-ve-numaralandırmaları-herkese-açık-yapma">Yapıları ve Numaralandırmaları Herkese Açık Yapma</a></h3>
<p>Yapıları ve numaralandırılmış yapıları <code>public</code> olarak atamak için <code>pub</code>'ı da kullanabiliriz, 
ancak <code>pub</code>'ın yapılar ve numaralandırmalarla kullanımına ilişkin birkaç ayrıntı daha vardır. 
Bir <code>struct</code> tanımından önce <code>pub</code> kullanırsak, <code>struct</code>'ı herkese açık yaparız, ancak <code>struct</code>'ın alanları yine gizli olur. 
Her bir alanı duruma göre kamuya açık hale getirebilir veya açıklamayabiliriz. Liste 7-9'da, genel bir <code>toast</code> üyesi, 
ancak özel bir <code>seasonal_fruit</code> üyesi olan bir genel <code>back_of_house::Breakfast</code> yapısı tanımladık. 
Bu, müşterinin yemekle birlikte gelen ekmeğin türünü seçebildiği, ancak şefin mevsime ve stokta bulunanlara göre yemeğe hangi meyvenin 
eşlik edeceğine karar verdiği bir restorandaki durumu modellemektedir. Mevcut meyve stoğu hızla değişir, 
bu nedenle müşteriler meyveyi seçemez ve hatta hangi meyveyi alacaklarını göremezler.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&quot;peaches&quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;);
    // Change our mind about what bread we'd like
    meal.toast = String::from(&quot;Wheat&quot;);
    println!(&quot;I'd like {} toast please&quot;, meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from(&quot;blueberries&quot;);
}
</code></pre>
<p><span class="caption">Liste 7-9: Bazı ortak üyeler ve bazı gizli üyeler içeren 
bir yapı</span></p>
<p><code>back_of_house::Breakfast</code> yapısındaki <code>toast</code> alanı genel olduğundan, 
<code>eat_at_restaurant</code>'ta nokta gösterimini kullanarak <code>toast</code> alanına yazabilir ve okuyabiliriz. 
<code>seasonal_fruit</code> gizli olduğu için <code>eat_at_restaurant</code>'ta <code>seasonal_fruit</code> üyesini kullanamadığımıza dikkat edin. 
Hangi hatayı aldığınızı görmek için <code>seasonal_fruit</code> üye değerini değiştirerek satırın yorumunu kaldırmayı deneyin!</p>
<p>Ayrıca, <code>back_of_house::Breakfast</code>'ın gizli bir alanı olduğundan, yapının bir <code>Breakfast</code> örneği oluşturan ortak bir 
ilişkili fonksiyon sağlaması gerektiğini unutmayın (buraya <code>summer</code> adını verdik). Eğer <code>Breakfast</code>'ın böyle bir fonksiyonu olmasaydı,
<code>eat_at_restaurant</code>'ta özel <code>seasonal_fruit</code> üyesinin değerini ayarlayamadığımız için, <code>eat_at_restaurant</code>'ta bir <code>Breakfast</code> örneği oluşturamazdık.</p>
<p>Buna karşılık, bir numaralandırmayı herkese açık yaparsak, tüm varyantları genel olur. Liste 7-10'da gösterildiği gibi, 
<code>pub</code>'a yalnızca <code>enum</code> anahtar sözcüğünden önce ihtiyacımız var.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
</code></pre>
<p><span class="caption">Liste 7-10: Bir numaralandırmanın genel olarak atanması, 
tüm türevlerini herkese açık hale getirir</span></p>
<p><code>Appetizer</code> <code>enum</code>'u <code>public</code> yaptığımız için, <code>eat_at_restaurant</code>'ta <code>Soup</code> ve <code>Salad</code> çeşitlerini kullanabiliriz.</p>
<p>Değişkenleri herkese açık olmadığı sürece, numaralandırmalar pek kullanışlı değildir; her durumda tüm numaralandırma değişkenlerine 
<code>pub</code> ile açıklama eklemek can sıkıcı olurdu, bu nedenle numaralandırma değişkenleri için varsayılan değer herkese açık olmaktır. 
Yapılar genellikle alanları herkese açık olmadan yararlıdır, bu nedenle yapı alanları, <code>pub</code> ile açıklama yapılmadığı sürece varsayılan olarak 
her şeyin gizli olduğu genel kuralını izler.</p>
<p><code>pub</code> ile ilgili ele almadığımız bir durum daha var ve bu bizim son modül sistemi özelliğimiz: <code>use</code> anahtar sözcüğü. 
İlk önce <code>use</code>'ı tek başına ele alacağız ve ardından <code>pub</code> ve <code>use</code>'ın nasıl birleştirileceğini göstereceğiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="bringing-paths-into-scope-with-the-use-keyword"><a class="header" href="#bringing-paths-into-scope-with-the-use-keyword">Bringing Paths into Scope with the <code>use</code> Keyword</a></h2>
<p>Having to write out the paths to call functions can feel inconvenient and
repetitive. In Listing 7-7, whether we chose the absolute or relative path to
the <code>add_to_waitlist</code> function, every time we wanted to call <code>add_to_waitlist</code>
we had to specify <code>front_of_house</code> and <code>hosting</code> too. Fortunately, there’s a
way to simplify this process: we can create a shortcut to a path with the <code>use</code>
keyword once, and then use the shorter name everywhere else in the scope.</p>
<p>In Listing 7-11, we bring the <code>crate::front_of_house::hosting</code> module into the
scope of the <code>eat_at_restaurant</code> function so we only have to specify
<code>hosting::add_to_waitlist</code> to call the <code>add_to_waitlist</code> function in
<code>eat_at_restaurant</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Listing 7-11: Bringing a module into scope with
<code>use</code></span></p>
<p>Adding <code>use</code> and a path in a scope is similar to creating a symbolic link in
the filesystem. By adding <code>use crate::front_of_house::hosting</code> in the crate
root, <code>hosting</code> is now a valid name in that scope, just as though the <code>hosting</code>
module had been defined in the crate root. Paths brought into scope with <code>use</code>
also check privacy, like any other paths.</p>
<p>Note that <code>use</code> only creates the shortcut for the particular scope in which the
<code>use</code> occurs. Listing 7-12 moves the <code>eat_at_restaurant</code> function into a new
child module named <code>customer</code>, which is then a different scope than the <code>use</code>
statement, so the function body won’t compile:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness does_not_compile ignore">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}
</code></pre>
<p><span class="caption">Listing 7-12: A <code>use</code> statement only applies in the scope
it’s in</span></p>
<p>The compiler error shows that the shortcut no longer applies within the
<code>customer</code> module:</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: failed to resolve: use of undeclared crate or module `hosting`
  --&gt; src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ use of undeclared crate or module `hosting`

warning: unused import: `crate::front_of_house::hosting`
 --&gt; src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` due to previous error; 1 warning emitted
</code></pre>
<p>Notice there’s also a warning that the <code>use</code> is no longer used in its scope! To
fix this problem, move the <code>use</code> within the <code>customer</code> module too, or reference
the shortcut in the parent module with <code>super::hosting</code> within the child
<code>customer</code> module.</p>
<h3 id="creating-idiomatic-use-paths"><a class="header" href="#creating-idiomatic-use-paths">Creating Idiomatic <code>use</code> Paths</a></h3>
<p>In Listing 7-11, you might have wondered why we specified <code>use crate::front_of_house::hosting</code> and then called <code>hosting::add_to_waitlist</code> in
<code>eat_at_restaurant</code> rather than specifying the <code>use</code> path all the way out to
the <code>add_to_waitlist</code> function to achieve the same result, as in Listing 7-13.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}
</code></pre>
<p><span class="caption">Listing 7-13: Bringing the <code>add_to_waitlist</code> function
into scope with <code>use</code>, which is unidiomatic</span></p>
<p>Although both Listing 7-11 and 7-13 accomplish the same task, Listing 7-11 is
the idiomatic way to bring a function into scope with <code>use</code>. Bringing the
function’s parent module into scope with <code>use</code> means we have to specify the
parent module when calling the function. Specifying the parent module when
calling the function makes it clear that the function isn’t locally defined
while still minimizing repetition of the full path. The code in Listing 7-13 is
unclear as to where <code>add_to_waitlist</code> is defined.</p>
<p>On the other hand, when bringing in structs, enums, and other items with <code>use</code>,
it’s idiomatic to specify the full path. Listing 7-14 shows the idiomatic way
to bring the standard library’s <code>HashMap</code> struct into the scope of a binary
crate.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre></pre>
<p><span class="caption">Listing 7-14: Bringing <code>HashMap</code> into scope in an
idiomatic way</span></p>
<p>There’s no strong reason behind this idiom: it’s just the convention that has
emerged, and folks have gotten used to reading and writing Rust code this way.</p>
<p>The exception to this idiom is if we’re bringing two items with the same name
into scope with <code>use</code> statements, because Rust doesn’t allow that. Listing 7-15
shows how to bring two <code>Result</code> types into scope that have the same name but
different parent modules and how to refer to them.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}
</code></pre>
<p><span class="caption">Listing 7-15: Bringing two types with the same name into
the same scope requires using their parent modules.</span></p>
<p>As you can see, using the parent modules distinguishes the two <code>Result</code> types.
If instead we specified <code>use std::fmt::Result</code> and <code>use std::io::Result</code>, we’d
have two <code>Result</code> types in the same scope and Rust wouldn’t know which one we
meant when we used <code>Result</code>.</p>
<h3 id="providing-new-names-with-the-as-keyword"><a class="header" href="#providing-new-names-with-the-as-keyword">Providing New Names with the <code>as</code> Keyword</a></h3>
<p>There’s another solution to the problem of bringing two types of the same name
into the same scope with <code>use</code>: after the path, we can specify <code>as</code> and a new
local name, or <em>alias</em>, for the type. Listing 7-16 shows another way to write
the code in Listing 7-15 by renaming one of the two <code>Result</code> types using <code>as</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}
</code></pre>
<p><span class="caption">Listing 7-16: Renaming a type when it’s brought into
scope with the <code>as</code> keyword</span></p>
<p>In the second <code>use</code> statement, we chose the new name <code>IoResult</code> for the
<code>std::io::Result</code> type, which won’t conflict with the <code>Result</code> from <code>std::fmt</code>
that we’ve also brought into scope. Listing 7-15 and Listing 7-16 are
considered idiomatic, so the choice is up to you!</p>
<h3 id="re-exporting-names-with-pub-use"><a class="header" href="#re-exporting-names-with-pub-use">Re-exporting Names with <code>pub use</code></a></h3>
<p>When we bring a name into scope with the <code>use</code> keyword, the name available in
the new scope is private. To enable the code that calls our code to refer to
that name as if it had been defined in that code’s scope, we can combine <code>pub</code>
and <code>use</code>. This technique is called <em>re-exporting</em> because we’re bringing
an item into scope but also making that item available for others to bring into
their scope.</p>
<p>Listing 7-17 shows the code in Listing 7-11 with <code>use</code> in the root module
changed to <code>pub use</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Listing 7-17: Making a name available for any code to use
from a new scope with <code>pub use</code></span></p>
<p>Before this change, external code would have to call the <code>add_to_waitlist</code>
function by using the path
<code>restaurant::front_of_house::hosting::add_to_waitlist()</code>. Now that this <code>pub use</code> has re-exported the <code>hosting</code> module from the root module, external code
can now use the path <code>restaurant::hosting::add_to_waitlist()</code> instead.</p>
<p>Re-exporting is useful when the internal structure of your code is different
from how programmers calling your code would think about the domain. For
example, in this restaurant metaphor, the people running the restaurant think
about “front of house” and “back of house.” But customers visiting a restaurant
probably won’t think about the parts of the restaurant in those terms. With
<code>pub use</code>, we can write our code with one structure but expose a different
structure. Doing so makes our library well organized for programmers working on
the library and programmers calling the library. We’ll look at another example
of <code>pub use</code> and how it affects your crate’s documentation in the <a href="ch14-02-publishing-to-crates-io.html#exporting-a-convenient-public-api-with-pub-use">“Exporting a
Convenient Public API with <code>pub use</code>”</a><!-- ignore --> section of
Chapter 14.</p>
<h3 id="using-external-packages"><a class="header" href="#using-external-packages">Using External Packages</a></h3>
<p>In Chapter 2, we programmed a guessing game project that used an external
package called <code>rand</code> to get random numbers. To use <code>rand</code> in our project, we
added this line to <em>Cargo.toml</em>:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">rand = &quot;0.8.3&quot;
</code></pre>
<p>Adding <code>rand</code> as a dependency in <em>Cargo.toml</em> tells Cargo to download the
<code>rand</code> package and any dependencies from <a href="https://crates.io/">crates.io</a> and
make <code>rand</code> available to our project.</p>
<p>Then, to bring <code>rand</code> definitions into the scope of our package, we added a
<code>use</code> line starting with the name of the crate, <code>rand</code>, and listed the items
we wanted to bring into scope. Recall that in the <a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">“Generating a Random
Number”</a><!-- ignore --> section in Chapter 2, we brought the <code>Rng</code> trait
into scope and called the <code>rand::thread_rng</code> function:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1..=100);
<span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span>}
</code></pre>
<p>Members of the Rust community have made many packages available at
<a href="https://crates.io/">crates.io</a>, and pulling any of them into your package
involves these same steps: listing them in your package’s <em>Cargo.toml</em> file and
using <code>use</code> to bring items from their crates into scope.</p>
<p>Note that the standard <code>std</code> library is also a crate that’s external to our
package. Because the standard library is shipped with the Rust language, we
don’t need to change <em>Cargo.toml</em> to include <code>std</code>. But we do need to refer to
it with <code>use</code> to bring items from there into our package’s scope. For example,
with <code>HashMap</code> we would use this line:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}
</span></code></pre></pre>
<p>This is an absolute path starting with <code>std</code>, the name of the standard library
crate.</p>
<h3 id="using-nested-paths-to-clean-up-large-use-lists"><a class="header" href="#using-nested-paths-to-clean-up-large-use-lists">Using Nested Paths to Clean Up Large <code>use</code> Lists</a></h3>
<p>If we’re using multiple items defined in the same crate or same module,
listing each item on its own line can take up a lot of vertical space in our
files. For example, these two <code>use</code> statements we had in the Guessing Game in
Listing 2-4 bring items from <code>std</code> into scope:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Instead, we can use nested paths to bring the same items into scope in one
line. We do this by specifying the common part of the path, followed by two
colons, and then curly brackets around a list of the parts of the paths that
differ, as shown in Listing 7-18.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::{cmp::Ordering, io};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 7-18: Specifying a nested path to bring multiple
items with the same prefix into scope</span></p>
<p>In bigger programs, bringing many items into scope from the same crate or
module using nested paths can reduce the number of separate <code>use</code> statements
needed by a lot!</p>
<p>We can use a nested path at any level in a path, which is useful when combining
two <code>use</code> statements that share a subpath. For example, Listing 7-19 shows two
<code>use</code> statements: one that brings <code>std::io</code> into scope and one that brings
<code>std::io::Write</code> into scope.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::io;
use std::io::Write;
</code></pre>
<p><span class="caption">Listing 7-19: Two <code>use</code> statements where one is a subpath
of the other</span></p>
<p>The common part of these two paths is <code>std::io</code>, and that’s the complete first
path. To merge these two paths into one <code>use</code> statement, we can use <code>self</code> in
the nested path, as shown in Listing 7-20.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::io::{self, Write};
</code></pre>
<p><span class="caption">Listing 7-20: Combining the paths in Listing 7-19 into
one <code>use</code> statement</span></p>
<p>This line brings <code>std::io</code> and <code>std::io::Write</code> into scope.</p>
<h3 id="the-glob-operator"><a class="header" href="#the-glob-operator">The Glob Operator</a></h3>
<p>If we want to bring <em>all</em> public items defined in a path into scope, we can
specify that path followed by the <code>*</code> glob operator:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}
</span></code></pre></pre>
<p>This <code>use</code> statement brings all public items defined in <code>std::collections</code> into
the current scope. Be careful when using the glob operator! Glob can make it
harder to tell what names are in scope and where a name used in your program
was defined.</p>
<p>The glob operator is often used when testing to bring everything under test
into the <code>tests</code> module; we’ll talk about that in the <a href="ch11-01-writing-tests.html#how-to-write-tests">“How to Write
Tests”</a><!-- ignore --> section in Chapter 11. The glob operator
is also sometimes used as part of the prelude pattern: see <a href="../std/prelude/index.html#other-preludes">the standard
library documentation</a><!-- ignore -->
for more information on that pattern.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="modülleri-farklı-dosyalara-ayırma"><a class="header" href="#modülleri-farklı-dosyalara-ayırma">Modülleri Farklı Dosyalara Ayırma</a></h2>
<p>Şimdiye kadar, bu bölümdeki tüm örnekler tek bir dosyada birden fazla modül tanımladı. 
Modüller büyüdüğünde, kodda gezinmeyi kolaylaştırmak için tanımlarını ayrı bir dosyaya taşımak isteyebilirsiniz.</p>
<p>Örneğin, birden fazla restoran modülüne sahip olan Liste 7-17'deki koddan başlayalım. Tüm modülleri kasa kök dosyasında tanımlamak yerine, 
modülleri dosyalara çıkaracağız. Bu durumda, kasa kök dosyası <em>src/lib.rs</em>'dir, ancak bu prosedür, 
kasa kök dosyası <em>src/main.rs</em> olan ikili kasalarla da çalışır.</p>
<p>Öncelikle <code>front_of_house</code> modülünü kendi dosyasına çıkaracağız. Yalnızca <code>mod front_of_house</code>'u bırakarak <code>front_of_house</code> modülü için 
süslü parantezlerin içindeki kodu kaldırın; böylece <em>src/lib.rs</em> Liste 7-21'de gösterilen kodu içerir. Liste 7-22'de 
<em>src/front_of_house.rs</em> dosyasını oluşturana kadar bunun derlenmeyeceğini unutmayın.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Liste 7-21: Gövdesi <em>src/front_of_house.rs</em> içinde olacak bir <code>front_of_house</code> 
modülünün tanımlanması</span></p>
<p>Ardından, köşeli parantez içindeki kodu Liste 7-22'de gösterildiği gibi <em>src/front_of_house.rs</em> adlı yeni bir dosyaya yerleştirin. 
Derleyici bu dosyaya bakması gerektiğini bilir çünkü kasa kökündeki modül bildirimi <code>front_of_house</code> adıyla karşılaştı.</p>
<p><span class="filename">Dosya adı: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting {
    pub fn add_to_waitlist() {}
}
</code></pre>
<p><span class="caption">Liste 7-22: <em>src/front_of_house.rs</em>'deki <code>front_of_house</code> modülünün içindeki tanımlar</span></p>
<p>Modül ağacınızda yalnızca bir <code>mod</code> bildirimi kullanarak bir dosya yüklemeniz gerektiğini unutmayın. 
Derleyici dosyanın projenin bir parçası olduğunu öğrendiğinde (ve <code>mod</code> deyimini nereye koyduğunuzdan dolayı kodun modül ağacında 
nerede olduğunu bildiğinde), projenizdeki diğer dosyalar bir yol kullanarak yüklenen dosyanın koduna başvurmalıdır. 
“Modül Ağacındaki Bir Öğeye Başvuru Yolları”]<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">paths</a><!-- ignore --> bölümünde anlatıldığı gibi, beyan edildiği yerde. 
Başka bir deyişle <code>mod</code>, diğer programlama dillerinde görmüş olabileceğiniz bir “include” işlemi <em>değildir</em>.</p>
<p>Ardından, <code>hosting</code> modülünü kendi dosyasına çıkaracağız. <code>hosting</code>, kök modülün değil, <code>front_of_house</code>'ın bir alt modülü olduğundan, 
süreç biraz farklı olacaktır. <code>hosting</code> dosyasını modül ağacındaki ataları için adlandırılacak yeni bir dizine yerleştireceğiz, 
bu durumda <em>src/front_of_house/</em> olacaktır.</p>
<p><code>hosting</code>'i taşımak için, <em>src/front_of_house.rs</em> dosyasını yalnızca <code>hosting</code> modülünün bildirimini içerecek şekilde değiştiriyoruz:</p>
<p><span class="filename">Dosya adı: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting;
</code></pre>
<p>Ardından bir <em>src/front_of_house</em> dizini ve <code>hosting</code> modülünde yapılan tanımları içerecek bir <em>hosting.rs</em> dosyası oluşturuyoruz:</p>
<p><span class="filename">Dosya adı: src/front_of_house/hosting.rs</span></p>
<pre><code class="language-rust ignore">pub fn add_to_waitlist() {}
</code></pre>
<p>Bunun yerine <em>src</em> dizinine <em>hosting.rs</em>'i koyarsak, derleyici <em>hosting.rs</em> kodunun kasa kökünde bildirilen bir <code>hosting</code> modülünde olmasını 
ve <code>front_of_house</code> modülünün alt öğesi olarak bildirilmemesini bekler. Derleyicinin hangi dosyaların hangi modüllerin kodunu kontrol edeceğine 
ilişkin kuralları, dizinlerin ve dosyaların modül ağacıyla daha yakından eşleştiği anlamına gelir.</p>
<blockquote>
<h3 id="alternatif-dosya-yolları"><a class="header" href="#alternatif-dosya-yolları">Alternatif Dosya Yolları</a></h3>
<p>Şimdiye kadar Rust derleyicisinin kullandığı en deyimsel dosya yollarını ele aldık, 
ancak Rust ayrıca daha eski bir dosya yolu stilini de destekliyor. 
Kasa kökünde bildirilen <code>front_of_house</code> adlı bir modül için, derleyici modülün kodunu şurada arayacaktır:</p>
<ul>
<li><em>src/front_of_house.rs</em> (şu ana kadar ele aldığımız yol)</li>
<li><em>src/front_of_house/mod.rs</em> (eski stil, hala desteklenen yol)</li>
</ul>
<p><code>front_of_house</code> alt modülü olan <code>hosting</code> adlı bir modül için, derleyici modülün kodunu şurada arayacaktır:</p>
<ul>
<li><em>src/front_of_house/hosting.rs</em> (şu ana kadar ele aldığımız yol)</li>
<li><em>src/front_of_house/hosting/mod.rs</em> (eski stil, hala desteklenen yol),</li>
</ul>
<p>Aynı modül için her iki stili de kullanırsanız derleyici hatası alırsınız.
Aynı projede farklı modüller için her iki stili de kullanmaya izin verilir, 
ancak projenizde gezinen kişiler için kafa karıştırıcı olabilir.</p>
<p><em>mod.rs</em> adlı dosyaları kullanan stilin ana dezavantajı, projenizin <em>mod.rs</em> adlı birçok dosyayla sonuçlanabilmesidir; 
bu, onları aynı anda kod editörünüzde açtığınızda kafa karıştırıcı olmaya sebebiyet verebilir.</p>
</blockquote>
<p>Her modülün kodunu ayrı bir dosyaya taşıdık ve modül ağacı aynı kaldı. <code>eat_at_restaurant</code> içindeki fonksiyon çağrıları, 
tanımlar farklı dosyalarda bulunsa bile herhangi bir değişiklik yapılmadan çalışacaktır. 
Bu teknik, modülleri boyut olarak büyüdükçe yeni dosyalara taşımanıza olanak tanır.</p>
<p><em>src/lib.rs</em> içindeki <code>pub use crate::front_of_house::hosting</code> ifade yapısının da değişmediğini ve kullanımın kasanın parçası 
olarak hangi dosyaların derlendiği üzerinde herhangi bir etkisi olmadığını unutmayın. <code>mod</code> anahtar sözcüğü, modülleri bildirir ve Rust, 
o modüle giren kod için modülle aynı ada sahip bir dosyaya bakar.</p>
<h2 id="Özet-4"><a class="header" href="#Özet-4">Özet</a></h2>
<p>Rust, bir paketi birden çok kasaya ve bir kasayı modüllere ayırmanıza olanak tanır, 
böylece bir modülde tanımlanan öğelere başka bir modülden başvurabilirsiniz. 
Bunu, mutlak veya göreli yollar belirterek yapabilirsiniz. Bu yollar, bir <code>use</code> ifade yapısı ile kapsama alınabilir, 
böylece o kapsamdaki öğenin birden çok kullanımı için daha kısa bir yol kullanabilirsiniz. 
Modül kodu varsayılan olarak gizlidir, ancak <code>pub</code> anahtar sözcüğünü ekleyerek tanımları herkese açık hale getirebilirsiniz.</p>
<p>Bir sonraki bölümde, düzenli bir şekilde organize edilmiş kodunuzda kullanabileceğiniz standart kütüphanedeki bazı koleksiyon 
veri yapılarına bakacağız.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yaygın-koleksiyonlar"><a class="header" href="#yaygın-koleksiyonlar">Yaygın Koleksiyonlar</a></h1>
<p>Rust'ın standart kütüphanesi, <em>koleksiyon</em> adı verilen bir dizi çok kullanışlı veri yapısını içerir. 
Diğer veri türlerinin çoğu belirli bir değeri temsil eder, ancak koleksiyonlar birden çok değer içerebilir. 
Yerleşik dizi ve tanımlama grubu türlerinin aksine, bu koleksiyonların işaret ettiği veriler öbek üzerinde depolanır; bu, veri miktarının derleme zamanında bilinmesine gerek olmadığı ve program çalışırken büyüyüp küçülebileceği anlamına gelir. 
Her toplama türünün farklı yetenekleri ve maliyetleri vardır ve mevcut durumunuza uygun olanı seçmek zamanla geliştireceğiniz bir beceridir. Bu bölümde, Rust programlarında çok sık kullanılan üç koleksiyonu tartışacağız:</p>
<ul>
<li>Bir <em>vektör</em> değişken sayıda aynı tür değerleri yan yana saklamanıza izin verir.</li>
<li>Bir <em>dizgi</em> karakter <em>koleksiyonudur</em>. <code>String</code> türünden önceden de bahsetmiştik ama artık daha derine ineceğiz.</li>
<li>Bir <em>kilit koleksiyonu</em> bir değeri belirli bir anahtarla ilişkilendirmenizi sağlar. <em>map</em> diye tanımlanan veri yapısının
daha özel bir süreklemesidir (uygulamasıdır).</li>
</ul>
<p>Standart kütüphane tarafından sunulan diğer tür koleksiyonlar hakkında bilgi almak için <a href="../std/collections/index.html">dokümantasyona</a>
göz atabilirsiniz.</p>
<p>Vektörlerin, dizgilerin ve kilit koleksiyonlarının nasıl oluşturulacağını ve 
güncelleneceğini ve ayrıca her birini neyin özel kıldığını tartışacağız.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="vektörlerle-değer-listelerini-saklama"><a class="header" href="#vektörlerle-değer-listelerini-saklama">Vektörlerle Değer Listelerini Saklama</a></h2>
<p>Bakacağımız ilk koleksiyon türü, vektör olarak da bilinen <code>Vec&lt;T&gt;</code>'dir. Vektörler, tüm değerleri bellekte 
yan yana koyan tek bir veri yapısında birden fazla değeri saklamanıza izin verir. Vektörler yalnızca aynı türdeki 
değerleri saklayabilir. Bir dosyadaki metin satırları veya bir alış veriş sepetindeki ürünlerin fiyatları gibi bir 
öğe listeniz olduğunda kullanışlıdırlar.</p>
<h3 id="yeni-bir-vektör-oluşturma"><a class="header" href="#yeni-bir-vektör-oluşturma">Yeni bir Vektör Oluşturma</a></h3>
<p>Yeni bir boş vektör oluşturmak için Liste 8-1'de gösterildiği gibi 
<code>Vec::new</code> fonksiyonunu çağırıyoruz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-1: <code>i32</code> türündeki değerleri tutmak için yeni, 
boş bir vektör oluşturma</span></p>
<p>Buraya bir tür ek açıklaması eklediğimize dikkat edin. Bu vektöre herhangi bir değer eklemediğimiz için, 
Rust ne tür öğeler depolamak istediğimizi bilmiyor. Bu önemli bir noktadır. Vektörler yaygınlar kullanılarak uygulanır; 
Bölüm 10'da yaygınları kendi türlerinizle nasıl kullanacağınızı ele alacağız. Şimdilik, standart kütüphane tarafından sağlanan 
<code>Vec&lt;T&gt;</code> türünün herhangi bir türü tutabileceğini bilin. Belirli bir türü tutmak için bir vektör oluşturduğumuzda, 
türü köşeli parantezler içinde belirtebiliriz. Liste 8-1'de, Rust'a <code>v</code> içindeki <code>Vec&lt;T&gt;</code>'nin <code>i32</code> tipinde elemanlar tutacağını söyledik.</p>
<p>Daha sık olarak, ilk değerlerle bir <code>Vec&lt;T&gt;</code> oluşturursunuz ve Rust saklamak istediğiniz değerin türünü çıkarır, 
bu nedenle bu tür ek açıklamasını yapmanız nadiren gerekir. Rust, verdiğiniz değerleri tutan yeni bir vektör oluşturacak olan 
<code>vec!</code> makrosunu uygun bir şekilde sağlar. Liste 8-2, <code>1</code>, <code>2</code> ve <code>3</code> değerlerini tutan yeni bir <code>Vec&lt;i32&gt;</code> oluşturur. Tam sayı 
türü <code>i32</code>'dir çünkü bu, Bölüm 3'ün <a href="ch03-02-data-types.html#data-types">“Veri Türleri”</a><!-- ignore -->  bölümünde tartıştığımız gibi varsayılan tam sayı türüdür.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-2: Değerler içeren yeni bir vektör oluşturma</span></p>
<p><code>i32</code> değerlerini verdiğimiz için, Rust <code>v</code> türünün <code>Vec&lt;i32&gt;</code> olduğu sonucunu çıkarabilir ve tür ek açıklamasına gerek kalmaz. 
Sonraki başlıkta bir vektörün nasıl değiştirileceğine bakacağız.</p>
<h3 id="bir-vektörü-güncelleme"><a class="header" href="#bir-vektörü-güncelleme">Bir Vektörü Güncelleme</a></h3>
<p>Bir vektör oluşturmak ve daha sonra ona eleman eklemek için <code>push</code> metodunu kullanabiliriz,
Liste 8-3'te gösterildiği gibi.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-3: Using the <code>push</code> method to add values to a
vector</span></p>
<p>Herhangi bir değişkende olduğu gibi, değerini değiştirebilmek istiyorsak, şunu yapmamız gerekir:
Bölüm 3'te tartışıldığı gibi <code>mut</code> anahtar sözcüğünü kullanarak değiştirilebilir hale getirmelisiniz. </p>
<p>Sayılar içine yerleştirdiğimiz tüm öğeler <code>i32</code> türündedir ve Rust bunu verilerden çıkarır, yani
<code>Vec&lt;i32&gt;</code> ek açıklamasına ihtiyacımız yoktur.</p>
<h3 id="vektörlerin-elemanlarını-okuma"><a class="header" href="#vektörlerin-elemanlarını-okuma">Vektörlerin Elemanlarını Okuma</a></h3>
<p>Bir vektörde saklanan bir değere başvurmanın iki yolu vardır: indeksleme veya
<code>get</code> metodunu kullanma. Aşağıdaki örneklerde, daha fazla netlik için bu fonksiyonlardan 
döndürülen değerlerin türlerini açıkladık.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!(&quot;The third element is {}&quot;, third);

    let third: Option&lt;&amp;i32&gt; = v.get(2);
    match third  {
        Some(third) =&gt; println!(&quot;The third element is {}&quot;, third),
        None =&gt; println!(&quot;There is no third element.&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-4: Bir vektördeki bir öğeye erişmek için indekslemeyi veya 
<code>get</code> metodunu kullanma</span></p>
<p>Burada birkaç ayrıntıya dikkat edin. Üçüncü elemanı elde etmek için <code>2</code> indeks değerini kullanırız çünkü vektörler sıfırdan 
başlayarak sayıya göre indekslenir ve <code>[]</code> kullanmak bize indeks değerindeki elemana bir referans verir. <code>get</code> metodunu argüman 
olarak geçirilen indeksle kullandığımızda, <code>match</code> ile kullanabileceğimiz bir <code>Option&lt;&amp;T&gt;</code> elde ederiz.</p>
<p>Rust'ın bir öğeye başvurmak için bu iki yolu sağlamasının nedeni, mevcut öğelerin aralığı dışında bir 
indeks değeri kullanmaya çalıştığınızda programın nasıl davranacağını seçebilmenizdir. 
Örnek olarak, beş elemanlı bir vektörümüz olduğunda ve ardından Liste 8-5'te gösterildiği gibi her bir teknikle 
<code>100</code> indeksindeki bir elemana erişmeye çalıştığımızda ne olacağını görelim.</p>
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &amp;v[100];
    let does_not_exist = v.get(100);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-5: Beş element içeren bir vektörde indeks 
<code>100</code>'deki elemana erişmeye çalışmak</span></p>
<p>Bu kodu çalıştırdığımızda ilk <code>[]</code> metodu var olmayan bir elemente referans verdiği için programın paniğe kapılmasına neden olacaktır. 
Bu yöntem en iyi şekilde, vektörün sonundaki bir öğeye erişme girişimi olduğunda programınızın çökmesini istediğinizde kullanılır.</p>
<p><code>get</code> metodu vektörün dışında bir indeks iletildiğinde panik yapmadan <code>None</code> döndürür. 
Normal koşullar altında, vektör aralığının dışındaki bir öğeye erişim ara sıra gerçekleşebiliyorsa, 
bu metodu kullanırsınız. Kodunuz, Bölüm 6'da tartışıldığı gibi, <code>Some(&amp;element)</code> veya <code>None</code>'a sahip olmayı işlemek için bir mantığa sahip 
olacaktır. Örneğin, dizin bir sayı giren bir kişiden geliyor olabilir. Yanlışlıkla çok büyük bir sayı girerlerse ve program <code>None</code> değeri alırsa,
kullanıcıya geçerli vektörde kaç öğe olduğunu söyleyebilir ve onlara geçerli bir değer girmeleri için bir şans daha verebilirsiniz. 
Bu, bir yazım hatası nedeniyle programı çökertmekten daha kullanıcı dostu olurdu!</p>
<p>Programın geçerli bir referansı olduğunda, ödünç alma denetleyicisi, bu referansın ve vektörün içeriğine yönelik diğer referansların geçerli 
kalmasını sağlamak için mülkiyet ve ödünç alma kurallarını (Bölüm 4'te ele alınmıştır) uygular. Aynı kapsamda değiştirilebilir ve değişmez 
referanslara sahip olamayacağınızı belirten kuralı hatırlayın. Bu kural, bir vektördeki ilk öğeye değişmez bir referans tuttuğumuz ve 
sona bir öğe eklemeye çalıştığımız Liste 8-6'da geçerlidir. Fonksiyonda daha sonra bu öğeye başvurmaya çalışırsak, bu program çalışmayacaktır:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0];

    v.push(6);

    println!(&quot;The first element is: {}&quot;, first);
<span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 8-6: Bir öğeye referans tutarken bir vektöre öğe eklemeye çalışmak</span></p>
<p>Bu kodu derlemek şu hataya neden olur:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 | 
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;The first element is: {}&quot;, first);
  |                                          ----- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` due to previous error
</code></pre>
<p>Liste 8-6'daki kod çalışması gerekiyormuş gibi görünebilir: ilk elemana yapılan bir referans vektörün sonundaki değişiklikleri neden önemsesin? 
Bu hata vektörlerin çalışma şeklinden kaynaklanmaktadır: vektörler değerleri bellekte yan yana koyduğu için, vektörün sonuna yeni bir 
eleman eklemek, vektörün şu anda depolandığı yerde tüm elemanları yan yana koymak için yeterli yer yoksa, yeni bellek ayırmayı ve eski 
elemanları yeni alana kopyalamayı gerektirebilir. Bu durumda, ilk elemanın referansı ayrılmış belleğe işaret ediyor olacaktır. 
Ödünç alma kuralları programların bu duruma düşmesini engeller.</p>
<blockquote>
<p>Not: <code>Vec&lt;T&gt;</code> türünün sürekleme ayrıntıları hakkında daha fazla bilgi için bkz. <a href="../nomicon/vec/vec.html">“The Rustonomicon”</a>.</p>
</blockquote>
<h3 id="bir-vektördeki-değerler-Üzerinde-yineleme"><a class="header" href="#bir-vektördeki-değerler-Üzerinde-yineleme">Bir Vektördeki Değerler Üzerinde Yineleme</a></h3>
<p>Bir vektördeki her bir öğeye sırayla erişmek için, her seferinde bir öğeye erişmek üzere indisleri kullanmak yerine 
tüm öğeler arasında yineleme yaparız. Liste 8-7, <code>i32</code> değerlerinden oluşan bir vektördeki her bir öğeye 
değişmez referanslar almak ve bunları yazdırmak için bir <code>for</code> döngüsünün nasıl kullanılacağını gösterir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!(&quot;{}&quot;, i);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-7: Bir <code>for</code> döngüsü kullanarak öğeler üzerinde yineleme yaparak bir vektördeki her bir öğeyi yazdırma</span></p>
<p>Ayrıca, tüm öğelerde değişiklik yapmak için değişebilir bir vektördeki her bir öğeye yönelik değişebilir referanslar 
üzerinde yineleme yapabiliriz. Liste 8-8'deki <code>for</code> döngüsü her öğeye <code>50</code> ekleyecektir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-8: Bir vektördeki öğelere yönelik değiştirilebilir referanslar üzerinde yineleme</span></p>
<p>Değiştirilebilir referansın ifade ettiği değeri değiştirmek için, <code>+=</code> operatörünü kullanmadan önce <code>i</code> içindeki değere ulaşmak için 
<code>*</code> referansı alma operatörünü kullanmamız gerekir. Referansı alma operatörü hakkında daha fazla bilgiyi Bölüm 15'teki  <a href="ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator">“Referansı Alma Operatörü ile Değere Bakan İşaretçiyi Takip Etme”</a><!-- ignore --> kısmında bulacağız.</p>
<p>İster değişmez ister değişebilir olsun, bir vektör üzerinde yineleme yapmak, ödünç denetleyicisinin kuralları nedeniyle güvenlidir. 
Liste 8-7 ve Liste 8-8'deki <code>for</code> döngüsü gövdelerine öğe eklemeye veya çıkarmaya çalışırsak, 
Liste 8-6'daki kodla aldığımıza benzer bir derleyici hatası alırız. <code>for</code> döngüsünün tuttuğu vektör referansı tüm vektörün aynı anda 
değiştirilmesini engeller.</p>
<h3 id="birden-fazla-türü-saklamak-için-enum-kullanma"><a class="header" href="#birden-fazla-türü-saklamak-için-enum-kullanma">Birden Fazla Türü Saklamak için <code>enum</code> Kullanma</a></h3>
<p>Vektörler yalnızca aynı türden değerleri depolayabilir. Bu elverişsiz olabilir; farklı türlerdeki öğelerin bir 
listesini saklamaya ihtiyaç duyan kullanım durumları kesinlikle vardır. Neyse ki, bir <code>enum</code>'un varyantları aynı <code>enum</code> tipi altında tanımlanır, 
bu nedenle farklı tiplerdeki öğeleri temsil etmek için tek bir tipe ihtiyaç duyduğumuzda, bir <code>enum</code> tanımlayabilir ve kullanabiliriz!</p>
<p>Örneğin, satırdaki sütunlardan bazılarının tam sayılar, bazılarının kayan noktalı sayılar ve bazılarının da dizgiler içerdiği bir elektronik 
tablodaki bir satırdan değerler almak istediğimizi varsayalım. Varyantları farklı değer türlerini tutacak bir <code>enum</code> tanımlayabiliriz ve 
tüm <code>enum</code> varyantları aynı tür olarak kabul edilir. Daha sonra bu <code>enum</code>'u tutmak için bir vektör oluşturabiliriz ve 
böylece sonuçta farklı türleri tutabiliriz. Bunu Liste 8-9'da gösterdik.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
        SpreadsheetCell::Float(10.12),
    ];
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-9: Farklı türlerdeki değerleri tek bir vektörde saklamak için <code>enum</code> tanımlama</span></p>
<p>Rust'ın derleme zamanında vektörde hangi türlerin olacağını bilmesi gerekir, böylece her bir öğeyi depolamak için 
yığın üzerinde tam olarak ne kadar bellek gerekeceğini bilir. Ayrıca bu vektörde hangi türlere izin verildiği konusunda 
da açık olmalıyız. Rust bir vektörün herhangi bir türü tutmasına izin verseydi, 
türlerden birinin veya daha fazlasının vektörün elemanları üzerinde gerçekleştirilen işlemlerde hatalara neden olma ihtimali olurdu. 
Bir <code>enum</code> ve bir <code>match</code> ifadesi kullanmak, Bölüm 6'da tartışıldığı gibi, Rust'ın derleme zamanında olası her durumun 
ele alınmasını sağlayacağı anlamına gelir.</p>
<p>Bir programın çalışma zamanında bir vektörde depolamak için alacağı kapsamlı tür kümesini bilmiyorsanız, 
<code>enum</code> işe yaramayacaktır. Bunun yerine, Bölüm 17'de ele alacağımız bir <code>trait</code> tanımını kullanabilirsiniz.</p>
<p>Vektörleri kullanmanın en yaygın yollarından bazılarını tartıştığımıza göre, standart kütüphane tarafından <code>Vec&lt;T&gt;</code> üzerinde tanımlanan 
birçok yararlı yöntem için <a href="../std/vec/struct.Vec.html">API dokümantasyonunu</a><!-- ignore --> gözden geçirdiğinizden emin olun. 
Örneğin, <code>push</code>'a ek olarak, <code>pop</code> yöntemi son elemanı kaldırır 
ve döndürür.</p>
<h3 id="bir-vektörü-düşürmek-elemanlarını-düşürür"><a class="header" href="#bir-vektörü-düşürmek-elemanlarını-düşürür">Bir Vektörü Düşürmek Elemanlarını Düşürür</a></h3>
<p><code>struct</code>'lar gibi, bir vektör de kapsam dışına çıktığında, Liste 8-10'da açıklandığı gibi serbest bırakılır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v
    } // &lt;- v goes out of scope and is freed here
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-10: Vektörün ve elemanlarının nereye bırakıldığını gösterme</span></p>
<p>Vektör bırakıldığında, tüm içeriği de bırakılır, yani tuttuğu tam sayılar temizlenir. Ödünç alma denetleyicisi, 
bir vektörün içeriğine yapılan referansların yalnızca vektörün kendisi geçerli olduğu sürece kullanılmasını sağlar.</p>
<p>Bir sonraki koleksiyon türüne geçelim: <code>String</code>!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="utf-8-kodlu-metni-dizgilerde-saklama"><a class="header" href="#utf-8-kodlu-metni-dizgilerde-saklama">UTF-8 Kodlu Metni Dizgilerde Saklama</a></h2>
<p>Dizgilerden Bölüm 4'te bahsetmiştik, ancak şimdi onlara daha derinlemesine bakacağız. 
Yeni Rustseverler genellikle üç nedenden dolayı dizgilere takılırlar: Rust'ın olası hataları açığa çıkarma eğilimi, 
dizgilerin birçok programcının düşündüğünden daha karmaşık bir veri yapısı olması ve UTF-8. 
Bu faktörler, diğer programlama dillerinden geldiğinizde zor görünebilecek bir şekilde birleşir.</p>
<p>Dizgileri koleksiyonlar bağlamında ele alıyoruz çünkü dizgiler bir bayt koleksiyonu ve bu baytlar metin olarak yorumlandığında yararlı 
işlevler sağlayan bazı metodlar olarak uygulanmaktadır. Bu bölümde, <code>String</code> üzerinde her koleksiyon türünün sahip olduğu oluşturma, 
güncelleme ve okuma gibi işlemlerden bahsedeceğiz. Ayrıca, <code>String</code>'in diğer koleksiyonlardan farklı olduğu yönleri, yani bir 
<code>String</code>'de indekslemenin, insanların ve bilgisayarların <code>String</code> verilerini yorumlama biçimleri arasındaki farklar nedeniyle nasıl karmaşıklaştığını tartışacağız.</p>
<h3 id="dizgi-nedir"><a class="header" href="#dizgi-nedir">Dizgi Nedir?</a></h3>
<p>İlk olarak <em>dizgi</em> terimi ile ne kastettiğimizi tanımlayacağız. Rust'ın çekirdek dilinde yalnızca bir dizgi tipi vardır, 
bu da genellikle ödünç alınmış <code>&amp;str</code> biçiminde görülen dizgi dilimi <code>str</code>'dir. Bölüm 4'te, başka bir yerde saklanan bazı UTF-8 kodlu dizgi 
verilerine referans olan dizgi dilimlerinden bahsetmiştik. Örneğin dizgi değişmezleri, programın ikili dosyasında saklanır ve bu 
nedenle dizgi dilimleridir.</p>
<p>Çekirdek dile kodlanmak yerine Rust'ın standart kütüphanesi tarafından sağlanan <code>String</code> türü, büyütülebilir, değiştirilebilir, 
sahipli, UTF-8 kodlu bir dize türüdür. Rustseverler Rust'ta “dizgilerden” bahsettiklerinde, <code>String</code> ya da dizgi dilimi <code>&amp;str</code> tiplerinden 
birine atıfta bulunuyor olabilirler, sadece bu tiplerden birine değil. Bu bölüm büyük ölçüde <code>String</code> hakkında olsa da, 
her iki tür de Rust'ın standart kütüphanesinde yoğun olarak kullanılır ve hem <code>String</code> hem de string dilimleri UTF-8 kodludur.</p>
<h3 id="yeni-bir-string-oluşturma"><a class="header" href="#yeni-bir-string-oluşturma">Yeni Bir <code>String</code> Oluşturma</a></h3>
<p><code>Vec&lt;T&gt;</code> ile kullanılabilen işlemlerin çoğu <code>String</code> ile de kullanılabilir, çünkü <code>String</code> aslında bazı ekstra garantilere, 
kısıtlamalara ve yeteneklere sahip bir bayt vektörü etrafında bir sarmalayıcı olarak uygulanmaktadır. <code>Vec&lt;T&gt;</code> ve <code>String</code> ile 
aynı şekilde çalışan bir fonksiyon örneği, Liste 8-11'de gösterilen bir örnek oluşturmak için <code>new</code> fonksiyonudur.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-11: Yeni, boş bir <code>String</code> oluşturma</span></p>
<p>Bu satır, daha sonra içine veri yükleyebileceğimiz <code>s</code> adında yeni bir boş dizgi oluşturur. 
Genellikle, dizgiyi başlatmak istediğimiz bazı başlangıç verilerimiz olacaktır. Bunun için, dizgi değişmezlerinin yaptığı 
gibi <code>Display</code> tanımını sürekleyen herhangi bir türde kullanılabilen <code>to_string</code> metodunu kullanırız.</p>
<p>Liste 8-12'de iki örnek gösterilmektedir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let data = &quot;initial contents&quot;;

    let s = data.to_string();

    // the method also works on a literal directly:
    let s = &quot;initial contents&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-12: Bir dize değişmezinden bir <code>String</code> oluşturmak için <code>to_string</code> metodunu 
kullanma</span></p>
<p><code>String::from</code> fonksiyonunu bir dizgi değişmezinden <code>String</code> oluşturmak için de kullanabiliriz. 
Liste 8-13'teki kod, Liste 8-12'deki <code>to_string</code> kullanan koda eş değerdir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;initial contents&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-13: Bir dizgi değişmezinden <code>String</code> oluşturmak için <code>String::from</code> fonksiyonunu 
kullanma</span></p>
<p>Dizgiler pek çok şey için kullanıldığından, dizgiler için pek çok farklı genel API kullanabiliriz ve bu da bize pek çok seçenek sunar. 
Bazıları gereksiz görünebilir, ancak hepsinin önemli amacı vardır! Bu durumda, <code>String::from</code> ve <code>to_string</code> aynı şeyi yapar, 
bu nedenle hangisini seçeceğiniz bir stil ve okunabilirlik meselesidir.</p>
<p>Dizgilerin UTF-8 kodlu olduğunu unutmayın, bu nedenle Liste 8-14'te gösterildiği gibi uygun şekilde kodlanmış herhangi bir 
veriyi bunlara dahil edebiliriz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let hello = String::from(&quot;السلام عليكم&quot;);
    let hello = String::from(&quot;Dobrý den&quot;);
    let hello = String::from(&quot;Hello&quot;);
    let hello = String::from(&quot;שָׁלוֹם&quot;);
    let hello = String::from(&quot;नमस्ते&quot;);
    let hello = String::from(&quot;こんにちは&quot;);
    let hello = String::from(&quot;안녕하세요&quot;);
    let hello = String::from(&quot;你好&quot;);
    let hello = String::from(&quot;Olá&quot;);
    let hello = String::from(&quot;Здравствуйте&quot;);
    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-14: Farklı dillerdeki selamlamaları dizgilerde saklama</span></p>
<p>Bunların tamamı geçerli <code>String</code> değerleridir. </p>
<h3 id="stringi-güncelleme"><a class="header" href="#stringi-güncelleme"><code>String</code>'i Güncelleme</a></h3>
<p>Bir <code>String</code>'in boyutu büyüyebilir ve içine daha fazla veri koyarsanız, tıpkı bir <code>Vec&lt;T&gt;</code>'nin içeriği gibi içeriği değişebilir. 
Ayrıca, <code>String</code> değerlerini birleştirmek için <code>+</code> operatörünü veya <code>format!</code> makrosunu rahatlıkla kullanabilirsiniz.</p>
<h4 id="push_str-ve-push-ile-stringe-ekleme-yapmak"><a class="header" href="#push_str-ve-push-ile-stringe-ekleme-yapmak"><code>push_str</code> ve <code>push</code> ile <code>String</code>'e ekleme yapmak</a></h4>
<p>Liste 8-15'te gösterildiği gibi, bir dizgi dilimi eklemek için <code>push_str</code> 
metodunu kullanarak bir <code>String</code>'i büyütebiliriz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;foo&quot;);
    s.push_str(&quot;bar&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-15: <code>push_str</code> metodunu kullanarak bir <code>String</code>'e bir dizgi 
dilimi ekleme</span></p>
<p>Bu iki satırdan sonra, <code>s</code> <code>foobar</code>'ı içerecektir. <code>push_str</code> metodu bir dizgi dilimi alır çünkü parametrenin sahipliğini 
almak zorunda değilizdir. Örneğin, Liste 8-16'daki kodda, içeriğini <code>s1</code>'e ekledikten sonra <code>s2</code>'yi kullanabilmek istiyoruz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s1 = String::from(&quot;foo&quot;);
    let s2 = &quot;bar&quot;;
    s1.push_str(s2);
    println!(&quot;s2 is {}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-16: İçeriğini bir <code>String</code>'e ekledikten sonra dizgi dilimini 
kullanma</span></p>
<p>Eğer <code>push_str</code> metodu <code>s2</code>'nin sahipliğini alsaydı, değerini son satıra yazdıramazdık. 
Ancak, bu kod beklediğimiz gibi çalışıyor!</p>
<p><code>push</code> metodu parametre olarak tek bir karakter alır ve onu <code>String</code>'e ekler. Liste 8-17, <code>push</code> metodunu kullanarak bir 
<code>String</code>'e “l” harfini ekler.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;lo&quot;);
    s.push('l');
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-17: <code>push</code> kullanarak <code>String</code>'e 
karakter ekleme</span></p>
<p>Sonuç olarak, <code>s</code>, <em><code>lol</code></em> içerecektir.</p>
<h4 id="-operatörü-veya-format-makrosu-ile-birleştirme"><a class="header" href="#-operatörü-veya-format-makrosu-ile-birleştirme"><code>+</code> Operatörü veya <code>format!</code> Makrosu ile birleştirme</a></h4>
<p>Çoğu zaman, mevcut iki dizgiyi birleştirmek isteyeceksiniz. Bunu yapmanın bir yolu, Liste 8-18'de gösterildiği gibi 
<code>+</code> operatörünü kullanmaktır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;Hello, &quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-18: İki <code>String</code> değerini yeni bir <code>String</code> değeriyle birleştirmek 
için <code>+</code> operatörünü kullanmak</span></p>
<p><code>s3</code> dizgisi <code>Hello, world!</code> içerecektir. Ekleme işleminden sonra <code>s1</code>'in artık geçerli olmamasının ve 
<code>s2</code>'ye bir referans kullanmamızın nedeni, <code>+</code> operatörünü kullandığımızda çağrılan metodun imzasıyla ilgilidir. 
Imzası aşağıdaki gibi görünen <code>add</code> metodunu kullanır:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>Standart kütüphanede, yaygınlar ve ilişkili türler kullanılarak tanımlanmış eklentiler görürsünüz. 
Burada, bu metodu <code>String</code> değerleriyle çağırdığımızda olan şey olan somut türlerle değiştirdik. 
Yaygınları Bölüm 10'da tartışacağız. Bu imza bize <code>+</code> operatörünün zor kısımlarını anlamamız için gereken ipuçlarını verir.</p>
<p>İlk olarak, <code>s2</code> bir <code>&amp;</code> içerir, yani ilk dizgiye ikinci dizginin bir referansını ekliyoruz. Bunun nedeni <code>add</code> fonksiyonundaki 
<code>s</code> parametresidir: bir <code>String</code>'e yalnızca bir <code>&amp;str</code> ekleyebiliriz; iki <code>String</code> değerini birbirine ekleyemeyiz. 
Ama bekleyin - <code>&amp;s2</code>'nin türü, <code>add</code> fonksiyonunun ikinci parametresinde belirtildiği gibi <code>&amp;str</code> değil, <code>&amp;String</code>'dir. </p>
<p>Öyleyse Liste 8-18 neden derleniyor?</p>
<p><code>add</code> çağrısında <code>&amp;s2</code>'yi kullanabilmemizin nedeni, derleyicinin <code>&amp;String</code> argümanını <code>&amp;str</code>'e zorlayabilmesidir. 
<code>add</code> metodunu çağırdığımızda, Rust burada <code>&amp;s2</code>'yi <code>&amp;s2[..]</code>'ye dönüştüren bir <em><code>deref</code> zorlaması</em> kullanır. 
<em><code>deref</code> zorlamasını</em> Bölüm 15'te daha derinlemesine tartışacağız. <code>add</code>, <code>s</code> parametresinin sahipliğini almadığından, 
<code>s2</code> bu işlemden sonra hala geçerli bir <code>String</code> olacaktır.</p>
<p>İkinci olarak, imzada <code>add</code>'in <code>self</code>'in sahipliğini aldığını görebiliriz, çünkü <code>self</code>'in <code>&amp;'</code>si yoktur. 
Bu, Liste 8-18'deki <code>s1</code>'in <code>add</code> çağrısına taşınacağı ve bundan sonra artık geçerli olmayacağı anlamına gelir. 
Dolayısıyla, <code>let s3 = s1 + &amp;s2;</code> ifade yapısı her iki dizgiyi de kopyalayıp yeni bir tane oluşturacak gibi görünse de, 
bu ifade yapısı aslında <code>s1</code>'in sahipliğini alır, <code>s2</code>'nin içeriğinin bir kopyasını ekler ve ardından sonucun sahipliğini döndürür. 
Başka bir deyişle, çok sayıda kopya oluşturuyormuş gibi görünür ancak oluşturmaz; uygulama kopyalamadan daha verimlidir.</p>
<p>Birden fazla dizgiyi birleştirmemiz gerekirse, <code>+</code> operatörünün davranışı hantal hale gelir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}
</span></code></pre></pre>
<p>Bu noktada, <code>s</code> <code>tic-tac-toe</code> olacak. Tüm <code>+</code> ve <code>&quot;</code> karakterleri ile neler olup bittiğini görmek zordur. 
Daha karmaşık dizgi birleştirmeleri için <code>format!</code> makrosunu kullanabiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
<span class="boring">}
</span></code></pre></pre>
<p>Bu kod da aynı şekilde <code>s</code>'yi <code>tic-tac-toe</code> olarak ayarlar. <code>format!</code> makrosu <code>println!</code> gibi çalışır, 
ancak çıktıyı ekrana yazdırmak yerine, içeriği içeren bir <code>String</code> döndürür. Kodun <code>format!</code> kullanan versiyonunun okunması 
çok daha kolaydır ve <code>format!</code> makrosu tarafından oluşturulan kod referanslar kullanır, böylece bu çağrı parametrelerinden 
herhangi birinin sahipliğini almaz.</p>
<h3 id="dizgilerde-İndeksleme"><a class="header" href="#dizgilerde-İndeksleme">Dizgilerde İndeksleme</a></h3>
<p>Diğer birçok programlama dilinde, bir dizedeki karakterlere indeksle referans vererek tek tek erişmek geçerli ve yaygın bir işlemdir. 
Ancak, Rust'ta indeksleme söz dizimini kullanarak bir <code>String</code>'in parçalarına erişmeye çalışırsanız, 
bir hata alırsınız. Liste 8-19'daki geçersiz kodu düşünün.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let h = s1[0];
<span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 8-19: İndeksleme söz dizimini <code>String</code> ile kullanmaya çalışmak</span></p>
<p>Bu kod aşağıdaki hataya sebebiyet verecektir:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `String` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index&lt;{integer}&gt;` is not implemented for `String`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` due to previous error
</code></pre>
<p>Hata ve not hikayeyi anlatıyor: Rust dizgileri indekslemeyi desteklemez. Ama neden desteklemiyor? 
Bu soruyu yanıtlamak için, Rust'ın dizgileri bellekte nasıl sakladığını tartışmamız gerekir.</p>
<h4 id="dahili-temsil"><a class="header" href="#dahili-temsil">Dahili Temsil</a></h4>
<p><code>String</code>, <code>Vec&lt;u8&gt;</code> kullanan bir sarmalayıcıdır. Liste 8-14'teki düzgün kodlanmış UTF-8 örnek dizgilerimizden bazılarına bakalım. </p>
<p>İlk olarak, buna bakalım:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;السلام عليكم&quot;);
</span><span class="boring">    let hello = String::from(&quot;Dobrý den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;שָׁלוֹם&quot;);
</span><span class="boring">    let hello = String::from(&quot;नमस्ते&quot;);
</span><span class="boring">    let hello = String::from(&quot;こんにちは&quot;);
</span><span class="boring">    let hello = String::from(&quot;안녕하세요&quot;);
</span><span class="boring">    let hello = String::from(&quot;你好&quot;);
</span><span class="boring">    let hello = String::from(&quot;Olá&quot;);
</span><span class="boring">    let hello = String::from(&quot;Здравствуйте&quot;);
</span>    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Bu durumda, <code>len</code> <code>4</code> olacaktır, bu da “Hola” dizgisini depolayan vektörün 4 bayt uzunluğunda olduğu anlamına gelir. 
UTF-8'de kodlandığında bu harflerin her biri 1 bayt alır. Ancak aşağıdaki satır sizi şaşırtabilir. 
(Bu dizenin Arapça 3 rakamı ile değil, büyük Kiril harfi Ze ile başladığına dikkat edin).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;السلام عليكم&quot;);
</span><span class="boring">    let hello = String::from(&quot;Dobrý den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;שָׁלוֹם&quot;);
</span><span class="boring">    let hello = String::from(&quot;नमस्ते&quot;);
</span><span class="boring">    let hello = String::from(&quot;こんにちは&quot;);
</span><span class="boring">    let hello = String::from(&quot;안녕하세요&quot;);
</span><span class="boring">    let hello = String::from(&quot;你好&quot;);
</span><span class="boring">    let hello = String::from(&quot;Olá&quot;);
</span>    let hello = String::from(&quot;Здравствуйте&quot;);
<span class="boring">    let hello = String::from(&quot;Hola&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>Dizginin ne kadar uzunlukta olduğu sorulduğunda 12 diyebilirsiniz. 
Aslında Rust'ın cevabı 24'tür: UTF-8'de “Здравствуйте” yi kodlamak için gereken bayt sayısı budur, 
çünkü bu dizgideki her Unicode skaler değeri 2 bayt depolama alanı alır. Bu nedenle, dizginin baytlarındaki bir 
indeks her zaman geçerli bir Unicode skaler değeriyle ilişkili olmayacaktır. </p>
<p>Kanıt için bu geçersiz Rust kodunu düşünün:</p>
<pre><code class="language-rust ignore does_not_compile">let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];
</code></pre>
<p><code>answer</code>'ın ilk harf olan <code>З</code> olmayacağını zaten biliyorsunuz. UTF-8'de kodlandığında, <code>З</code>'nin ilk baytı <code>208</code> ve ikincisi <code>151</code>'dir, 
bu nedenle cevabın aslında <code>208</code> olması gerekir, ancak <code>208</code> tek başına geçerli bir karakter değildir. 
Bu dizginin ilk harfini soran bir kullanıcı muhtemelen <code>208</code> sonucunu almak istemeyecektir; 
ancak Rust'ın <code>0</code> bayt indeksinde sahip olduğu tek veri budur. Kullanıcılar, dizgi yalnızca Latin harfleri içerse bile 
genellikle bayt değerinin döndürülmesini istemezler: <code>&amp;&quot;hello&quot;[0]</code> bayt değerini döndüren geçerli bir kod olsaydı, <code>h</code> değil <code>104</code> döndürürdü.</p>
<p>O halde cevap, beklenmedik bir değer döndürmekten ve hemen keşfedilemeyecek hatalara neden olmaktan kaçınmak için Rust'ın 
bu kodu hiç derlememesi ve geliştirme sürecinin başlarında yanlış anlamaları önlemesidir.</p>
<h3 id="baytlar-ve-skaler-değerler-ve-grapheme-kümeleri-amanın"><a class="header" href="#baytlar-ve-skaler-değerler-ve-grapheme-kümeleri-amanın">Baytlar ve Skaler Değerler ve Grapheme Kümeleri! Amanın!</a></h3>
<p>UTF-8 ile ilgili bir başka nokta da, Rust'ın bakış açısından dizgilere bakmanın aslında üç ilgili yolu olduğudur: 
baytlar, skaler değerler ve grapheme kümeleri (<em>harf</em> olarak adlandırdığımız şeye en yakın şey).</p>
<p>Devanagari alfabesiyle yazılmış Hintçe “नमस्ते” kelimesine bakarsak, bu kelime aşağıdaki gibi görünen 
<code>u8</code> değerlerinden oluşan bir vektör olarak saklanır:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Bu 18 bayttır ve bilgisayarlar bu verileri nihai olarak bu şekilde depolar. 
Bunlara Unicode skaler değerleri olarak bakarsak, ki Rust'ın <code>char</code> türü budur, bu baytlar şöyle görünür:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>Burada altı <code>char</code> değeri vardır, ancak dördüncü ve altıncı harfler harf değildir: 
bunlar kendi başlarına bir anlam ifade etmeyen aksan işaretleridir. 
Son olarak, bunlara grapheme kümeleri olarak bakarsak, bir kişinin Hintçe kelimeyi oluşturan 
dört harf olarak adlandıracağı şeyi elde ederiz:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Rust, bilgisayarların depoladığı ham dizgi verilerini yorumlamak için farklı yollar sağlar, 
böylece veriler hangi insan dilinde olursa olsun her program ihtiyaç duyduğu yorumu seçebilir.</p>
<p>Rust'ın bir karakteri elde etmek için bir String içinde indeksleme yapmamıza izin vermemesinin son bir nedeni, 
indeksleme işlemlerinin her zaman sabit zaman (O(1)) almasının beklenmesidir. Ancak bir <code>String</code> ile bu performansı garanti 
etmek mümkün değildir, çünkü Rust'ın kaç tane geçerli karakter olduğunu belirlemek için başlangıçtan indekse kadar içerik boyunca 
yürümesi gerekir.</p>
<h3 id="stringi-dilimleme"><a class="header" href="#stringi-dilimleme"><code>String</code>'i Dilimleme</a></h3>
<p>Bir dizeye indeksleme yapmak genellikle kötü bir fikirdir çünkü dizeye indeksleme işleminin dönüş türünün ne olması gerektiği 
açık değildir: bayt değeri, karakter, grapheme kümesi veya dizgi dilimi. Bu nedenle, dizgi dilimleri oluşturmak için 
gerçekten indis kullanmanız gerekiyorsa, Rust sizden daha spesifik olmanızı bekler.</p>
<p>Tek bir sayı ile <code>[]</code> kullanarak indeksleme yapmak yerine, belirli baytları içeren bir dizgi dilimi oluşturmak 
için <code>[]</code> ile bir aralığı kullanabilirsiniz:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
<span class="boring">}
</span></code></pre></pre>
<p>Burada <code>s</code>, dizginin ilk 4 baytını içeren bir <code>&amp;str</code> olacaktır. Daha önce, bu karakterlerin her birinin 
2 bayt olduğundan bahsetmiştik, bu da <code>s</code>'nin <code>Зд</code> olacağı anlamına gelir.</p>
<p>Eğer bir karakterin baytlarının sadece bir kısmını <code>&amp;hello[0..1]</code> gibi bir şeyle dilimlemeye çalışsaydık, 
Rust çalışma zamanında bir vektörde geçersiz bir indekse erişildiğinde olduğu gibi paniğe kapılırdı:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/main.rs:4:14
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Dizgi dilimleri oluşturmak için aralıkları dikkatli kullanmalısınız, çünkü yanlış kullanım programınızı çökertebilir.</p>
<h3 id="string-Üzerinde-yineleme-yöntemleri"><a class="header" href="#string-Üzerinde-yineleme-yöntemleri"><code>String</code> Üzerinde Yineleme Yöntemleri</a></h3>
<p>Dizgi parçaları üzerinde işlem yapmanın en iyi yolu, karakter mi yoksa bayt mı istediğinizi açıkça belirtmektir. 
Tek tek Unicode skaler değerleri için <code>chars</code> metodunu kullanabilirsiniz. “Зд” üzerinde <code>chars</code> metodu çağrıldığında <code>char</code> türünde 
iki değer ayrılır ve döndürülür; her bir öğeye erişmek için sonuç üzerinde yineleme yapabilirsiniz:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;Зд&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
<span class="boring">}
</span></code></pre></pre>
<p>Bu kod aşağıdakileri yazdıracaktır:</p>
<pre><code class="language-text">З
д
</code></pre>
<p>Alternatif olarak, <code>bytes</code> yöntemi, kullanımınız için uygun olabilecek her ham baytı döndürür:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;Зд&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
<span class="boring">}
</span></code></pre></pre>
<p>Bu kod, bu dizgiyi oluşturan dört baytı yazdıracaktır:</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>Ancak geçerli Unicode skaler değerlerinin 1 bayttan fazla olabileceğini unutmayın.</p>
<p>Devanagari alfabesinde olduğu gibi dizelerden grapheme kümeleri elde etmek karmaşıktır, 
bu nedenle bu fonksiyon direkt standart kütüphane tarafından sağlanmamaktadır. </p>
<p>İhtiyacınız olan işlevsellik buysa <a href="https://crates.io/">crates.io</a><!-- ignore -->'da işe yarayabilecek 
kasalar mevcuttur.</p>
<h3 id="stringler-o-kadar-da-basit-değildir"><a class="header" href="#stringler-o-kadar-da-basit-değildir"><code>String</code>'ler O Kadar da Basit Değildir</a></h3>
<p>Özetlemek gerekirse, dizgiler karmaşıktır. Farklı programlama dilleri, bu karmaşıklığın programcıya nasıl sunulacağı 
konusunda farklı seçimler yapar. Rust, <code>String</code> verilerinin doğru işlenmesini tüm Rust programları için varsayılan 
davranış haline getirmeyi seçmiştir, bu da programcıların UTF-8 verilerini önceden ele almak için daha fazla düşünmesi gerektiği 
anlamına gelir. Bu değiş tokuş, dizelerin karmaşıklığını diğer programlama dillerinde göründüğünden daha fazla ortaya çıkarır, 
ancak geliştirme yaşam döngünüzün ilerleyen aşamalarında <em>ASCII</em> olmayan karakterleri içeren hataları ele almak zorunda kalmanızı önler.</p>
<p>İyi haber şu ki, standart kütüphane bu karmaşık durumların doğru şekilde ele alınmasına yardımcı olmak için <code>String</code> ve 
<code>&amp;str</code> türlerinden oluşturulmuş çok sayıda işlevsellik sunar. Bir dizgi içinde arama yapmak için <code>contains</code> ve bir dizginin 
parçalarını başka bir dizgiyle değiştirmek için <code>replace</code> gibi yararlı metodlara ulaşmak için ilgili dokümantasyonlara
göz attığınızdan emin olun.</p>
<p>Daha az karışık bir şeye geçelim: <em>anahtar-kilit koleksiyonları</em>!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="anahtar-kilit-koleksiyonlarında-İlişkili-değerlerle-anahtarları-saklama"><a class="header" href="#anahtar-kilit-koleksiyonlarında-İlişkili-değerlerle-anahtarları-saklama">Anahtar-Kilit Koleksiyonlarında İlişkili Değerlerle Anahtarları Saklama</a></h2>
<p>Ortak koleksiyonlarımızın sonuncusu <em>anahtar-kilit koleksiyonudur</em>. <code>HashMap&lt;K, V&gt;</code> türü, 
bu anahtarları ve değerleri belleğe nasıl yerleştireceğini belirleyen bir karma fonksiyonu kullanarak K türündeki anahtarların 
V türündeki değerlerle eşlenmesini depolar. Birçok programlama dili bu tür bir veri yapısını destekler, 
ancak genellikle hash, map, object, hash table, dictionary veya associative array gibi farklı isimler kullanırlar.</p>
<p>Anahtar-kilit koleksiyonları, vektörlerde olduğu gibi bir indeks kullanarak değil, herhangi bir türde olabilen bir anahtar 
kullanarak verileri aramak istediğinizde kullanışlıdır. Örneğin, bir oyunda, her anahtarın bir takımın adı ve 
değerlerin her takımın puanı olduğu bir anahtar-kilit koleksiyonunda her takımın puanını takip edebilirsiniz. 
Bir takım adı verildiğinde, skorunu alabilirsiniz.</p>
<p>Bu bölümün devamında a-k.k diyerek bahsedeceğimiz şey anahtar-kilit koleksiyonu olacaktır.</p>
<p>Bu bölümde a-k.k'nin temel API'sinin üzerinden geçeceğiz, ancak standart kütüphane tarafından <code>HashMap&lt;K, V&gt;</code> üzerinde tanımlanan 
fonksiyonlarda çok daha fazla güzellik gizlidir. Her zaman olduğu gibi, daha fazla bilgi için standart kütüphane dokümantasyonunu 
kontrol edin.</p>
<h2 id="yeni-bir-a-kk-oluşturma"><a class="header" href="#yeni-bir-a-kk-oluşturma">Yeni Bir A-K.K Oluşturma</a></h2>
<p>Boş bir a-k.k oluşturmanın bir yolu <code>new</code> kullanmak ve <code>insert</code> ile eleman eklemektir. Liste 8-20'de, isimleri 
<em>Blue</em> ve <em>Yellow</em> olan iki takımın skorlarını takip ediyoruz. <em>Blue</em> takım 10 puanla başlar ve <em>Yellow</em> takım 50 puanla başlar.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-20: Yeni bir a-k.k oluşturma ve bazı anahtar ve değerleri ekleme</span></p>
<p>Öncelikle standart kütüphanenin koleksiyonlar bölümündeki <code>HashMap</code>'i kullanmamız gerektiğini unutmayın. 
Üç yaygın koleksiyonumuz arasında bu en az kullanılanıdır, bu nedenle başlangıçta otomatik olarak kapsama alınan 
özelliklere dahil edilmemiştir. <code>HashMap</code> standart kütüphaneden de daha az destek alır; örneğin bunları oluşturmak için 
yerleşik bir makro yoktur.</p>
<p>Tıpkı vektörler gibi, a-k.k da verilerini yığın üzerinde saklar. Bu <code>HashMap</code>'in <code>String</code> türünde anahtarları ve <code>i32</code> türünde değerleri 
vardır. Vektörler gibi, a-k.k da homojendir: tüm anahtarlar birbiriyle aynı türde olmalıdır ve tüm değerler aynı türde olmalıdır.</p>
<h3 id="ak-kda-değerlere-erişme"><a class="header" href="#ak-kda-değerlere-erişme">A.K-K'da Değerlere Erişme</a></h3>
<p>Liste 8-21'de gösterildiği gibi, <code>get</code> metoduna anahtarı sağlayarak a.k-k'dan dönüş değerini alabiliriz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    let team_name = String::from(&quot;Blue&quot;);
    let score = scores.get(&amp;team_name);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-21: A-k.k'da saklanan <em>Blue</em> takımının 
skoruna erişim</span></p>
<p>Burada, skor <em>Blue</em> takımla ilişkilendirilen değere sahip olacak ve sonuç <code>10</code> olacaktır. <code>get</code> metodu <code>Option&lt;&amp;V&gt;</code> döndürür; 
a-k.k'da o anahtar için değer yoksa <code>get</code>, <code>None</code> döndürür. Bu program, skorlarda anahtar için bir giriş yoksa skoru sıfıra ayarlamak 
için <code>unwrap_or</code> öğesini çağırarak <code>Option</code>'ı işler.</p>
<p>Bir a-k.k'daki her bir anahtar/değer çifti üzerinde, vektörlerde yaptığımıza benzer şekilde, bir <code>for</code> döngüsü kullanarak yineleme yapabiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    for (key, value) in &amp;scores {
        println!(&quot;{}: {}&quot;, key, value);
    }
<span class="boring">}
</span></code></pre></pre>
<p>Bu kod, her bir çifti rastgele bir sırayla yazdıracaktır:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<h3 id="a-kklar-ve-sahiplik"><a class="header" href="#a-kklar-ve-sahiplik">A-K.K'lar ve Sahiplik</a></h3>
<p><code>Copy</code> tanımını uygulayan <code>i32</code> gibi türler için değerler a-k.k'a kopyalanır. <code>String</code> gibi sahip olunan değerler için, 
değerler taşınır ve a-k.k, Liste 8-22'de gösterildiği gibi bu değerlerin sahibi olur.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let field_name = String::from(&quot;Favorite color&quot;);
    let field_value = String::from(&quot;Blue&quot;);

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name and field_value are invalid at this point, try using them and
    // see what compiler error you get!
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-22: Eklendikten sonra anahtarların ve değerlerin a-k.k'a 
ait olduğunu gösterme</span></p>
<p><code>field_name</code> ve <code>field_value</code> değişkenlerini, <code>insert</code> çağrısı ile a-k.k'a taşındıktan sonra kullanamıyoruz.</p>
<p>Değerlere yapılan referansları a-k.k'a eklersek, değerler hash haritasına taşınmaz. 
Referansların işaret ettiği değerler en azından a-k.k geçerli olduğu sürece geçerli olmalıdır. 
Bölüm 10'daki <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“Referansları Yaşam Süreleriyle Doğrulama”</a><!-- ignore --> bölümünde 
bu konular hakkında daha fazla konuşacağız.</p>
<h3 id="a-kkunu-güncelleme"><a class="header" href="#a-kkunu-güncelleme">A-K.K'unu Güncelleme</a></h3>
<p>Anahtar ve değer çiftlerinin sayısı artırılabilir olsa da, her benzersiz anahtar aynı anda kendisiyle 
ilişkilendirilmiş yalnızca bir değere sahip olabilir (ancak bunun tersi geçerli değildir: örneğin, hem <em>Blue</em> takım hem de <em>Yellow</em> 
takım skorlar a-k.k'da depolanan 10 değerine sahip olabilir).</p>
<p>Bir anahtar-kilit eşlemedeki verileri değiştirmek istediğinizde, bir anahtarın zaten atanmış bir değere sahip olduğu 
durumu nasıl ele alacağınıza karar vermeniz gerekir. Eski değeri tamamen göz ardı ederek eski değeri yeni değerle değiştirebilirsiniz. 
Eski değeri tutup yeni değeri <em>yok sayabilir</em>, yalnızca anahtarın zaten bir değeri yoksa yeni değeri ekleyebilirsiniz. 
Ya da eski değer ile yeni değeri birleştirebilirsiniz. Şimdi bunların her birinin nasıl yapılacağına bakalım!</p>
<h4 id="bir-değerin-Üzerine-yazma"><a class="header" href="#bir-değerin-Üzerine-yazma">Bir Değerin Üzerine Yazma</a></h4>
<p>Bir a-k.k'a bir anahtar ve bir değer eklersek ve daha sonra aynı anahtarı farklı bir değerle eklersek, 
bu anahtarla ilişkili değer değiştirilecektir. Liste 8-23'teki kod iki kez <code>insert</code> çağrısı yapsa da, 
<em>Blue</em> takımın anahtarının değerini iki kez eklediğimiz için a-k.k yalnızca bir anahtar/değer çifti içerecektir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Blue&quot;), 25);

    println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-23: Belirli bir anahtarla saklanan bir değeri değiştirme</span></p>
<p>Bu kod <code>{&quot;Blue&quot;: 25}</code> yazdıracaktır. <code>10</code>'un orijinal değerinin üzerine yazılmıştır.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="only-inserting-a-value-if-the-key-has-no-value"></a></p>
<h4 id="yalnızca-bir-anahtar-mevcut-değilse-anahtar-ve-değer-ekleme"><a class="header" href="#yalnızca-bir-anahtar-mevcut-değilse-anahtar-ve-değer-ekleme">Yalnızca Bir Anahtar Mevcut Değilse Anahtar ve Değer Ekleme</a></h4>
<p>Belirli bir anahtarın a-k.k'da bir değerle zaten var olup olmadığını kontrol etmek ve ardından aşağıdaki eylemleri 
gerçekleştirmek yaygındır: anahtar a-k.k'da varsa, mevcut değer olduğu gibi kalmalıdır. 
Anahtar mevcut değilse, onu ve değerini eklersiniz.</p>
<p>A-k.k'ları bunun için kontrol etmek istediğiniz anahtarı parametre olarak alan <code>entry</code> adında özel bir API'ye sahiptir. 
<code>entry</code> metodunun geri dönüş değeri, var olabilecek veya olmayabilecek bir değeri temsil eden <code>Entry</code> adlı bir <code>enum</code>'dur. 
Diyelim ki <em>Yellow</em> takımın anahtarının kendisiyle ilişkili bir değeri olup olmadığını kontrol etmek istiyoruz. 
Eğer yoksa, <code>50</code> değerini eklemek istiyoruz ve aynı şeyi <em>Blue</em> takım için de yapmak istiyoruz. 
<code>entry</code> API'sini kullanarak yazacağımız kod Liste 8-24'e benzeyecektir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from(&quot;Blue&quot;), 10);

    scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
    scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

    println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-24: Yalnızca anahtarın halihazırda bir değeri yoksa eklemek 
için <code>entry</code> metodunu kullanma</span></p>
<p><code>Entry</code> üzerindeki <code>or_insert</code> metodu, ilgili <code>Entry</code> anahtarı mevcutsa bu anahtarın değerine 
değiştirilebilir bir referans döndürmek için tanımlanmıştır; mevcut değilse, parametreyi bu anahtarın yeni 
değeri olarak ekler ve yeni değere değiştirilebilir bir referans döndürür. 
Bu teknik, mantığı kendimiz yazmaktan çok daha temizdir ve ayrıca ödünç denetleyicisi ile daha iyi çalışır.</p>
<p>Liste 8-24'teki kod çalıştırıldığında <code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code> çıktısını verecektir. 
<code>entry</code>'e yapılan ilk çağrı <em>Yellow</em> takımın anahtarına <code>50</code> değerini ekleyecektir çünkü <em>Yellow</em> takımın zaten bir değeri yoktur. 
İkinci <code>entry</code> çağrısı a-k.k'unu değiştirmeyecektir çünkü <em>Blue</em> takım zaten <code>10</code> değerine sahiptir.</p>
<h4 id="eski-değere-dayalı-olarak-bir-değeri-güncelleme"><a class="header" href="#eski-değere-dayalı-olarak-bir-değeri-güncelleme">Eski Değere Dayalı Olarak Bir Değeri Güncelleme</a></h4>
<p>A-K.K'lar için bir başka yaygın kullanım durumu da bir anahtarın değerini aramak ve ardından eski değere göre güncellemektir. 
Örneğin, Liste 8-25, bir metinde her bir kelimenin kaç kez geçtiğini sayan kodu göstermektedir. 
Kelimeleri anahtar olarak içeren bir a-k.k kullanırız ve o kelimeyi kaç kez gördüğümüzü takip etmek için değeri artırırız. 
Eğer bir kelimeyi ilk kez görüyorsak, önce 0 değerini ekleriz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let text = &quot;hello world wonderful world&quot;;

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!(&quot;{:?}&quot;, map);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-25: Kelimeleri ve sayıları saklayan bir a-k.k kullanarak 
kelimelerin oluşumlarını sayma</span></p>
<p>This code will print <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>. You might see
the same key/value pairs printed in a different order: recall from the
section that
iterating over a hash map happens in an arbitrary order.</p>
<p>Bu kod <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code> yazdıracaktır. Aynı anahtar/değer çiftlerinin farklı bir sırada yazdırıldığını 
görebilirsiniz: <a href="ch08-03-hash-maps.html#accessing-values-in-a-hash-map">“A-K.K'daki Değerlere Erişim”</a><!-- ignore --> bölümünden bir a-k.k üzerinde yinelemenin 
rastgele bir sırada gerçekleştiğini hatırlayın.</p>
<p><code>split_whitespace</code> metodu, metin içindeki değerin boşluklarla ayrılmış alt dilimleri üzerinde bir yineleyici döndürür. 
<code>or_insert</code> metodu, belirtilen anahtar için değere değiştirilebilir bir referans (<code>&amp;mut V</code>) döndürür. 
Burada bu değişebilir referansı <code>count</code> değişkeninde saklarız, bu nedenle bu değere atama yapmak için önce yıldız işaretini (<code>*</code>) 
kullanarak <code>count</code> referansını kaldırmamız gerekir. Değiştirilebilir referans <code>for</code> döngüsünün sonunda kapsam dışına çıkar, 
bu nedenle tüm bu değişiklikler güvenlidir ve ödünç alma kuralları tarafından izin verilir.</p>
<h3 id="Şifreleme-fonksiyonları"><a class="header" href="#Şifreleme-fonksiyonları">Şifreleme Fonksiyonları</a></h3>
<p>Varsayılan olarak <code>HashMap</code>, anahtar-kilit tablolarını içeren Hizmet Reddi (DoS) saldırılarına karşı direnç 
sağlayabilen <em>SipHash</em> adlı bir şifreleme fonksiyonu kullanır<sup class="footnote-reference"><a href="#siphash">1</a></sup><!-- ignore -->. Bu, mevcut en hızlı şifreleme algoritması değildir, 
ancak performanstaki düşüşle birlikte gelen daha iyi güvenlik için yapılan takas buna değecektir. 
Kodunuzun profilini çıkarırsanız ve varsayılan şifreleme fonksiyonunun amaçlarınız için çok yavaş olduğunu fark ederseniz, 
farklı bir şifreleyici belirterek başka bir fonksiyona geçebilirsiniz. Bir şifreleyici, <code>BuildHasher</code> tanımını uygulayan bir türdür. 
Özellikler ve bunların nasıl uygulanacağı hakkında Bölüm 10'da konuşacağız. Kendi şifreleyicinizi sıfırdan yazmak zorunda değilsiniz; 
<a href="https://crates.io/">crates.io</a><!-- ignore -->, birçok yaygın hashing algoritmasını uygulayan şifreleyiciler sağlayan, diğer Rust kullanıcıları 
tarafından paylaşılan kütüphanelere sahiptir.</p>
<h3 id="Özet-5"><a class="header" href="#Özet-5">Özet</a></h3>
<p>Vektörler, dizgiler ve anahtar-kilit koleksiyonları, verileri depolamanız, erişmeniz ve değiştirmeniz gerektiğinde programlarda 
gerekli olan büyük miktarda işlevsellik sağlayacaktır. </p>
<p>İşte şimdi çözmeniz gereken bazı alıştırmalar:</p>
<ul>
<li>Bir tam sayı listesi verildiğinde, bir vektör kullanın ve listenin medyanını (sıralandığında orta konumdaki değer) ve modunu 
(en sık ortaya çıkan değer; bir a-k.k burada yardımcı olacaktır) döndürün.</li>
<li>Dizgileri Domuz Latincesine dönüştürün. Her kelimenin ilk ünsüzü kelimenin sonuna taşınır ve “ay” eklenir, 
böylece “first” “irst-fay olur. Sesli harfle başlayan kelimelerin sonuna “hay” eklenir (“apple”, “apple-hay” olur). 
UTF-8 kodlamasıyla ilgili ayrıntıları aklınızda bulundurun!</li>
<li>Bir a-k.k ve vektör kullanarak, bir kullanıcının bir şirketteki bir departmana çalışan isimleri eklemesine olanak tanıyan bir metin 
arayüzü oluşturun. Örneğin, “Sally'i Mühendisliğe Ekle” veya “Amir'i Satış Danışmanlığına Ekle”. 
Ardından kullanıcının bir departmandaki tüm kişilerin veya şirketteki tüm kişilerin alfabetik olarak 
sıralanmış bir listesini almasına izin verin.</li>
</ul>
<p>Standart kütüphane API dokümantasyonları vektörlerin, dizgilerin ve a-k.k'ların bu alıştırmalar için yararlı olacak 
metodlarını açıklamaktadır!</p>
<p>İşlemlerin başarısız olabileceği daha karmaşık programlara giriyoruz, bu nedenle hata işlemeyi tartışmak için mükemmel bir zaman. 
Bunu daha sonra yapacağız!</p>
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hata-yönetimi"><a class="header" href="#hata-yönetimi">Hata Yönetimi</a></h1>
<p>Hatalar, yazılımlar için hayatın bir gerçeğidir, 
bu nedenle Rust, bir şeylerin yanlış gittiği durumları ele almak için bir dizi özelliğe sahiptir. 
Çoğu durumda, Rust, bir hata olasılığını kabul etmenizi ve kodunuz derlenmeden önce bazı işlemler yapmanızı gerektirir. 
Bu gereksinim, kodunuzu üretime dağıtmadan önce hataları keşfetmenizi ve bunları uygun şekilde işlemenizi sağlayarak programınızı daha sağlam hale getirir!</p>
<p>Rust, hataları iki ana kategoriye ayırır: <em>kurtarılabilir</em> ve <em>kurtarılamaz</em> hatalar. <em>Dosya bulunamadı</em> hatası gibi 
kurtarılabilir bir hata için, büyük olasılıkla sorunu kullanıcıya bildirmek ve işlemi yeniden denemek istiyoruz. 
Kurtarılamaz hatalar her zaman bir dizinin sonunun ötesindeki bir konuma erişmeye çalışmak gibi hataların belirtileridir ve bu nedenle programı hemen durdurmak istiyoruz.</p>
<p>Çoğu dil, bu iki tür hatayı ayırt etmez ve istisnalar gibi mekanizmalar kullanarak her ikisini de aynı şekilde ele alır. Rust'ın istisnaları yoktur. Bunun yerine, kurtarılabilir hatalar ve panik durumu için <code>Result&lt;T, E&gt;</code> türüne sahiptir! Program kurtarılamaz bir hatayla karşılaştığında yürütmeyi durduran şey burada <code>panic!</code> makrosudur. Bu bölüm öncelikle <code>panic!</code>'i çağırmayı kapsar ve sonrasında <code>Result&lt;T, E&gt;</code> değerlerini döndürmekten bahseder. Ek olarak, bir hatadan kurtulmaya veya yürütmeyi durdurmaya karar verirken göz önünde bulundurulması gereken noktaları keşfedeceğiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="panic-İle-kurtarılamayan-hatalar"><a class="header" href="#panic-İle-kurtarılamayan-hatalar"><code>panic!</code> İle Kurtarılamayan Hatalar</a></h2>
<p>Bazen kodunuzda kötü şeyler olur ve bu konuda yapabileceğiniz hiçbir şey yoktur. 
Bu durumlarda Rust'ta <code>panic!</code> makrosu kullanılır. Pratikte paniğe yol açmanın iki yolu vardır: 
kodumuzun paniklemesine neden olan bir eylemde bulunmak (sondan sonraki bir diziye erişmek gibi) veya açıkça <code>panic!</code> makrosunu
çağırmaktır. 
Her iki durumda da programımızda paniğe neden oluyoruz. Varsayılan olarak, bu panikler bir hata mesajı yazdırır, 
yığıtı temizler ve çıkar. Bir ortam değişkeni aracılığıyla, panik meydana geldiğinde panik kaynağını bulmayı kolaylaştırmak için 
Rust'ın çağrı yığınını görüntülemesini de sağlayabilirsiniz.</p>
<blockquote>
<h3 id="paniğe-tepki-olarak-yığıtı-Çözme-veya-durdurma"><a class="header" href="#paniğe-tepki-olarak-yığıtı-Çözme-veya-durdurma">Paniğe Tepki Olarak Yığıtı Çözme veya Durdurma</a></h3>
<p>Varsayılan olarak, bir panik meydana geldiğinde program çözülmeye başlar, bu da Rust'ın yığıtı geri aldığı ve karşılaştığı 
her fonksiyondan gelen verileri temizlediği anlamına gelir. Ancak, bu geri dönüş ve temizlik çok iştir. 
Bu nedenle Rust, programı temizlemeden sonlandıran hemen iptal etme alternatifini seçmenize izin verir.</p>
<p>Programın kullandığı belleğin işletim sistemi tarafından temizlenmesi gerekecektir. Projenizde elde edilen ikili dosyayı mümkün 
olduğu kadar küçük yapmanız gerekiyorsa, <em>Cargo.toml</em> dosyanızdaki uygun <code>[profile]</code> bölümlerine <code>panic = 'abort'</code> ekleyerek gevşemeden 
panik durumunda iptal etmeye geçebilirsiniz. Örneğin, yayın modund paniği iptal etmek istiyorsanız şunu ekleyin:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>Basit bir programda <code>panic!</code>'i çağırmaya çalışalım:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre></pre>
<p>Programı çalıştırdığınızda, şöyle bir şey göreceksiniz:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p><code>panic!</code> çağrısı, son iki satırda bulunan hata mesajına neden olur. İlk satır panik mesajımızı ve kaynak kodumuzda paniğin 
meydana geldiği yeri gösterir: src/main.rs:2:5 src/main.rs dosyamızın ikinci satırı, beşinci karakteri olduğunu gösterir.</p>
<p>Bu durumda belirtilen satır kodumuzun bir parçasıdır ve o satıra gidersek <code>panic!</code> makro çağrısını görürüz. 
Diğer durumlarda, <code>panic!</code> çağrısı, kodumuzun çağırdığı kodda olabilir ve hata mesajı tarafından bildirilen dosya adı ve 
satır numarası, <code>panic!</code> makrosunun çağrıldığı yeri gösterecektir. 
Kodumuzun soruna neden olan kısmını bulmak için <code>panic!</code> çağrısının geldiği fonksiyonların geri izini kullanabiliriz. 
Geri izlemeleri ileride daha ayrıntılı olarak tartışacağız.</p>
<h3 id="panic-geri-İzlemesini-kullanma"><a class="header" href="#panic-geri-İzlemesini-kullanma"><code>panic!</code> Geri İzlemesini Kullanma</a></h3>
<p>Kodumuzun doğrudan makroyu çağırması yerine kodumuzdaki bir hata nedeniyle bir kütüphaneden bir <code>panic!</code> çağrısı geldiğinde 
nasıl bir şey olduğunu görmek için başka bir örneğe bakalım. Liste 9-1, geçerli dizin aralığının ötesinde bir vektördeki bir 
dizine erişmeye çalışan bazı kodlara sahiptir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<p><span class="caption">Liste 9-1: Bir vektörün büyüklüğünden fazla bir indekse erişmeye çalışmak, <code>panic!</code> 
çağrısına neden olacaktır.</span></p>
<p>Burada, vektörümüzün 100. elemanına erişmeye çalışıyoruz (bu, indeksleme sıfırdan başladığı için indeks 99'dadır), 
ancak vektörün sadece 3 elemanı vardır. Bu durumda Rust <em>paniğe kapılır</em>. <code>[]</code> öğesinin kullanılması bir öğe döndürmesi gerekir, 
ancak geçersiz bir dizini iletirseniz, Rust'ın buraya döndürebileceği hiçbir öğe yoktur, bu da olması gerekendir.</p>
<p>C'de, bir veri yapısının sonunun ötesini okumaya çalışmak tanımsız davranıştır. Bellek o yapıya ait olmasa bile, 
veri yapısındaki o öğeye karşılık gelen bellekteki konumda ne varsa alabilirsiniz. Buna arabellek aşırı okuma denir 
ve bir saldırgan dizini, veri yapısından sonra depolanmasına izin verilmemesi gereken verileri okuyacak şekilde değiştirebiliyorsa, g
üvenlik açıklarına yol açabilir.</p>
<p>Programınızı bu tür bir güvenlik açığından korumak için, var olmayan bir dizindeki bir öğeyi okumaya çalışırsanız, 
Rust yürütmeyi durdurur ve devam etmeyi reddeder. Deneyelim ve görelim:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Bu hata, dizin 99'a erişmeye çalıştığımız <code>main.rs</code>'in 4. satırına işaret ediyor. 
Sonraki not satırı bize, <code>RUST_BACKTRACE</code> ortam değişkenini, hataya neden olan şeyin tam olarak geri izini almak için ayarlayabileceğimizi 
söylüyor. Geri izleme, bu noktaya gelmek için çağrılan tüm fonksiyonların bir listesidir. Rust'ta geriye dönük izlemeler, 
diğer dillerde olduğu gibi çalışır: Geri izlemeyi okumanın anahtarı, en baştan başlamak ve yazdığınız dosyaları görene kadar okumaktır. 
Sorunun ortaya çıktığı yer orasıdır. Bu noktanın üzerindeki satırlar, kodunuzun çağırdığı koddur; Aşağıdaki satırlar, kodunuzu çağıran koddur. 
Bu öncesi ve sonrası satırları, temel Rust kodunu, standart kütüphane kodunu veya kullandığınız kasaları içerebilir. 
<code>RUST_BACKTRACE</code> ortam değişkenini 0 dışında herhangi bir değere ayarlayarak geri izlemeye almayı deneyelim. 
Liste 9-2, göreceğinize benzer bir çıktı gösteriyor.</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-->
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/std/src/panicking.rs:483
   1: core::panicking::panic_fmt
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/panicking.rs:85
   2: core::panicking::panic_bounds_check
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/panicking.rs:62
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/slice/index.rs:255
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/slice/index.rs:15
   5: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/alloc/src/vec.rs:1982
   6: panic::main
             at ./src/main.rs:4
   7: core::ops::function::FnOnce::call_once
             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/ops/function.rs:227
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p><span class="caption">Liste 9-2: <code>RUST_BACKTRACE</code> ortam değişkeni ayarlandığında görüntülenen 
<code>panic!</code> çağrısı tarafından oluşturulan geri izleme</span></p>
<p>Çok fazla çıktı var! Gördüğünüz tam çıktı, işletim sisteminize ve Rust sürümünüze bağlı olarak farklı olabilir. 
Bu bilgilerle geriye dönük izler almak için hata ayıklama sembollerinin etkinleştirilmesi gerekir. 
Hata ayıklama sembolleri, burada olduğu gibi <code>--release</code> bayrağı olmadan <code>cargo build</code> veya <code>cargo run</code> kullanılırken varsayılan 
olarak etkindir.</p>
<p>Liste 9-2'deki çıktıda, geri izlemenin 6. satırı, projemizde soruna neden olan satırı işaret ediyor: <em>src/main.rs</em> dosyasının 4. satırı. 
Eğer programımızın paniğe kapılmasını istemiyorsak, ilk satırın gösterdiği ve yazdığımız bir dosyadan bahseden yerden araştırmamıza başlamalıyız.
Kasten panik yaratacak kod yazdığımız Liste 9-1'de, paniği düzeltmenin yolu, vektör indekslerinin aralığının ötesinde bir öğe talep etmemektir. 
Kodunuz paniklediğinde, paniğe neden olmak için kodun hangi değerlerle hangi eylemi gerçekleştirdiğini ve bunun yerine kodun ne 
yapması gerektiğini bulmanız gerekir.</p>
<p><code>panic!</code>'e geri döneceğiz ve hataları yönetmek için <code>panic!</code>'i ne zaman kullanıp kullanmamamız gerektiğini 
<a href="ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">“<code>panic!</code>'lemek ya da <code>panic!</code>'lememek”</a><!-- ignore --> bölümünde daha sonra anlatacağız.
Sonraki bölümde, <code>Result</code> tanımını kullanarak nasıl hatadan dönülebileceğine bakacağız.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="result-İle-kurtarılabilir-hatalar"><a class="header" href="#result-İle-kurtarılabilir-hatalar"><code>Result</code> İle Kurtarılabilir Hatalar</a></h2>
<p>Çoğu hata, programın tamamen durdurulmasını gerektirecek kadar ciddi değildir. Bazen, bir fonksiyon başarısız olduğunda, 
kolayca yorumlayabileceğiniz ve yanıt verebileceğiniz bir nedenden dolayı başarısız olur. Örneğin, bir dosyayı açmaya çalışırsanız 
ve dosya mevcut olmadığı için bu işlem başarısız olursa, işlemi sonlandırmak yerine dosyayı oluşturmak isteyebilirsiniz.</p>
<p>Bölüm 2'deki <a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">“<code>Result</code> Türü ile Potansiyel Başarısızlığı Ele Alma”</a><!-- ignore --> kısmından, 
<code>Result</code> <code>enum</code>'unun aşağıdaki gibi <code>Ok</code> ve <code>Err</code> olmak üzere iki değişken olarak tanımlandığını hatırlayın:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p><code>T</code> ve <code>E</code> yaygın tür parametreleridir: yaygın türleri Bölüm 10'da daha ayrıntılı olarak tartışacağız. 
Şu anda bilmeniz gereken şey, <code>T</code>'nin <code>Ok</code> değişkeni içinde bir başarı durumunda döndürülecek değerin türünü temsil ettiği ve <code>E</code>'nin Err 
değişkeni içinde bir başarısızlık durumunda döndürülecek hatanın türünü temsil ettiğidir. <code>Result</code> bu yaygın tür parametrelerine 
sahip olduğu için, döndürmek istediğimiz başarılı değer ile hata değerinin farklı olabileceği birçok farklı durumda <code>Result</code> türünü ve 
üzerinde tanımlı fonksiyonları kullanabiliriz.</p>
<p>Fonksiyon başarısız olabileceği için <code>Result</code> değeri döndüren bir fonksiyon çağıralım. Liste 9-3'te bir dosya açmaya çalışıyoruz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">Liste 9-3: Dosya açmak</span></p>
<p><code>File::open</code> öğesinin dönüş türü <code>Result&lt;T, E&gt;</code>'dir. Yaygın parametre <code>T</code>, <code>File::open</code> tarafından başarı değerinin türü olan 
<code>std::fs::File</code> ile tanımlanmıştır, bu da bir dosya tanıtıcısıdır. Hata değerinde kullanılan <code>E</code>'nin türü <code>std::io::Error</code>'dır. 
Bu dönüş türü, <code>File::open</code> çağrısının başarılı olabileceği ve okuyabileceğimiz veya yazabileceğimiz bir dosya tanıtıcısı döndürebileceği 
anlamına gelir. Fonksiyon çağrısı başarısız da olabilir: örneğin, dosya mevcut olmayabilir veya dosyaya erişim iznimiz olmayabilir. 
<code>File::open</code> fonksiyonunun bize başarılı ya da başarısız olduğunu söyleyecek ve aynı zamanda bize dosya tanıtıcısı ya da hata 
bilgisi verecek bir yolu olmalıdır. Bu bilgi tam olarak <code>Result</code> <code>enum</code>'unun anlattığı şeydir.</p>
<p><code>File::open</code> fonksiyonunun başarılı olduğu durumda, <code>greeting_file_result</code> değişkenindeki değer, 
bir dosya tanıtıcısı içeren <code>Ok</code> tanımı olacaktır. Başarısız olduğu durumda, <code>greeting_file_result</code> değişkenindeki değer, 
meydana gelen hata türü hakkında daha fazla bilgi içeren <code>Err</code> tanımı olacaktır.</p>
<p><code>File::open</code>'ın döndürdüğü değere bağlı olarak farklı eylemler gerçekleştirmek için Liste 9-3'teki koda ekleme yapmamız gerekir. 
Liste 9-4, Bölüm 6'da tartıştığımız temel bir araç olan <code>match</code> ifadesini kullanarak <code>Result</code>'u ele almanın bir yolunu göstermektedir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&quot;Problem opening the file: {:?}&quot;, error),
    };
}
</code></pre></pre>
<p><span class="caption">Liste 9-4: Döndürülebilecek <code>Result</code> değişkenlerini işlemek için <code>match</code> 
ifadesi kullanma</span></p>
<p><code>Option</code> <code>enum</code>'u gibi <code>Result</code> <code>enum</code>'u ve varyantlarının da <code>prelude</code> tarafından kapsama alındığına dikkat edin, 
bu nedenle <code>match</code> kollarında <code>Ok</code> ve <code>Err</code> varyantlarından önce <code>Result::</code> belirtmemize gerek yoktur.</p>
<p><code>Result</code>, <code>Ok</code> olduğunda, bu kod <code>Ok</code> değişkeninden iç dosya değerini döndürür ve daha sonra bu dosya tanıtıcısı 
değerini <code>greeting_file</code> değişkenine atar. <code>match</code>'ten sonra, dosya tanıtıcısını okuma veya yazma için kullanabiliriz.</p>
<p><code>match</code>'in diğer kolu, <code>File::open</code>'dan <code>Err</code> değeri aldığımız durumu ele alır. Bu örnekte, <code>panic!</code> makrosunu çağırmayı seçtik. 
Geçerli dizinimizde <code>hello.txt</code> adında bir dosya yoksa ve bu kodu çalıştırırsak, <code>panic!</code> makrosundan aşağıdaki çıktıyı görürüz:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Her zamanki gibi, bu çıktı bize tam olarak neyin yanlış gittiğini söyler.</p>
<h3 id="farklı-hatalarda-eşleştirme"><a class="header" href="#farklı-hatalarda-eşleştirme">Farklı Hatalarda Eşleştirme</a></h3>
<p>Liste 9-4'teki kod, <code>File::open</code>'ın neden başarısız olduğuna bakmadan <code>panic!</code> yapacaktır. 
Ancak, farklı başarısızlık nedenleri için farklı eylemler gerçekleştirmek istiyoruz: <code>File::open</code> dosya mevcut 
olmadığı için başarısız olduysa, dosyayı oluşturmak ve yeni dosyanın tanıtıcısını döndürmek istiyoruz. 
<code>File::open</code> başka bir nedenle başarısız olduysa - örneğin, dosyayı açma iznimiz olmadığı için - kodun yine de Liste 9-4'te 
olduğu gibi <code>panic!</code> yapmasını istiyoruz. Bunun için Liste 9-5'te gösterilen bir iç <code>match</code> ifadesi ekleriz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Problem creating the file: {:?}&quot;, e),
            }
            other_error =&gt; {
                panic!(&quot;Problem opening the file: {:?}&quot;, other_error);
            }
        }
    };
}
</code></pre>
<p><span class="caption">Liste 9-5: Farklı türdeki hataları farklı şekillerde ele alma</span></p>
<p><code>File::open</code>'ın <code>Err</code> değişkeni içinde döndürdüğü değerin türü, standart kütüphane tarafından sağlanan bir yapı olan 
<code>io::Error</code>'dır. Bu <code>struct</code>, bir <code>io::ErrorKind</code> değeri elde etmek için çağırabileceğimiz bir <code>kind</code> metoduna sahiptir. 
<code>io::ErrorKind</code> <code>enum</code>'u standart kütüphane tarafından sağlanır ve bir <code>io</code> işleminden kaynaklanabilecek farklı hata türlerini temsil 
eden varyantlara sahiptir. Kullanmak istediğimiz değişken, açmaya çalıştığımız dosyanın henüz mevcut olmadığını gösteren <code>ErrorKind::NotFound</code>'dur. 
Bu yüzden <code>greeting_file_result</code> ile eşleşiyoruz, ancak <code>error.kind()</code> ile de bir iç <code>match</code>'imiz var.</p>
<p>İç <code>match</code>'te kontrol etmek istediğimiz koşul, <code>error.kind()</code> tarafından döndürülen değerin <code>ErrorKind</code> <code>enum</code>'unun <code>NotFound</code> varyantı 
olup olmadığıdır. Eğer varsa, dosyayı <code>File::create</code> ile oluşturmaya çalışırız. Ancak, <code>File::create</code> de başarısız olabileceğinden, 
iç <code>match</code> ifadesinde ikinci bir kola ihtiyacımız var. Dosya oluşturulamadığında, farklı bir hata mesajı yazdırılır. 
Dış <code>match</code>'in ikinci kolu aynı kalır, böylece program eksik dosya hatası dışındaki herhangi bir hatada panik yapar.</p>
<blockquote>
<h3 id="resultt-e-ile-match-kullanmanın-alternatifleri"><a class="header" href="#resultt-e-ile-match-kullanmanın-alternatifleri"><code>Result&lt;T, E&gt;</code> ile <code>match</code> Kullanmanın Alternatifleri</a></h3>
<p>Çok fazla <code>match</code> var! <code>match</code> ifadesi çok kullanışlıdır ancak aynı zamanda çok ilkeldir. 
Bölüm 13'te, <code>Result&lt;T, E&gt;</code> üzerinde tanımlanan birçok metodla birlikte kullanılan kapanış ifadeleri hakkında bilgi 
edineceksiniz. Bu metodlar, kodunuzdaki <code>Result&lt;T, E&gt;</code> değerlerini işlerken <code>match</code> kullanmaktan daha özlü olabilir.</p>
<p>Örneğin, Liste 9-5'te gösterilen aynı mantığı bu kez kapanış ifadelerini ve <code>unwrap_or_else</code> metodunu kullanarak 
yazmanın başka bir yolunu aşağıda bulabilirsiniz:</p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| {
                panic!(&quot;Problem creating the file: {:?}&quot;, error);
            })
        } else {
            panic!(&quot;Problem opening the file: {:?}&quot;, error);
        }
    });
}
</code></pre>
<p>Bu kod Liste 9-5 ile aynı davranışa sahip olsa da, herhangi bir <code>match</code> ifadesi içermez ve okunması daha temizdir. 
Bölüm 13'ü okuduktan sonra bu örneğe geri dönün ve standart kütüphane dokümantasyonundan <code>unwrap_or_else</code> metoduna bakın. 
Bu metodlardan çok daha fazlası, hatalarla uğraşırken iç içe geçmiş büyük <code>match</code> ifadelerini temizleyebilir.</p>
</blockquote>
<h3 id="panik-hatası-kısayolları-unwrap-ve-expect"><a class="header" href="#panik-hatası-kısayolları-unwrap-ve-expect">Panik Hatası Kısayolları: <code>unwrap</code> ve <code>expect</code></a></h3>
<p><code>match</code> kullanmak yeterince işe yarar, ancak biraz ayrıntılı olabilir ve amacı her zaman iyi iletmez. 
<code>Result&lt;T, E&gt;</code> türü, çeşitli ve daha spesifik görevleri yerine getirmek için üzerinde tanımlanmış birçok yardımcı metoda sahiptir. 
<code>unwrap</code> metodu, tıpkı Liste 9-4'te yazdığımız <code>match</code> ifadesi gibi uygulanan bir kısayol yöntemidir. 
<code>Result</code> değeri <code>Ok</code> varyantı ise unwrap, <code>Ok</code> içindeki değeri döndürür. <code>Result</code> değeri <code>Err</code> değişkeniyse, 
<code>unwrap</code> bizim için <code>panic!</code> makrosunu çağırır. İşte <code>unwrap</code>'in iş başında olduğu bir örnek:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<p>Bu kodu <em>hello.txt</em> dosyası olmadan çalıştırırsak, <code>unwrap</code> yönteminin yaptığı <code>panic!</code> çağrısından
bir hata mesajı görürüz:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<p>Benzer şekilde, <code>expect</code> metodu da <code>panic!</code> hata mesajını seçmemizi sağlar. <code>unwrap</code> yerine <code>expect</code> kullanmak ve 
iyi hata mesajları sağlamak, amacınızı iletebilir ve paniğin kaynağını bulmayı kolaylaştırabilir. 
<code>expect</code>'in söz dizimi şu şekildedir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;)
        .expect(&quot;hello.txt should be included in this project&quot;);
}
</code></pre></pre>
<p><code>expect</code>'i <code>unwrap</code> ile aynı şekilde kullanırız: dosya tanıtıcısını döndürmek veya <code>panic!</code> makrosunu çağırmak için. 
<code>expect</code> tarafından <code>panic!</code> çağrısında kullanılan hata mesajı, <code>unwrap</code>'ın kullandığı varsayılan <code>panic!</code> mesajı yerine 
<code>expect</code>'e aktardığımız parametre olacaktır. İşte böyle görünüyor:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at 'hello.txt should be included in this project: Error
{ repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<p>Üretim kalitesindeki kodlarda, çoğu Rustsever <code>unwrap</code> yerine <code>expect</code>'i seçer ve işlemin neden her zaman 
başarılı olmasının beklendiği hakkında daha fazla bağlam verir. Bu şekilde, varsayımlarınızın yanlış olduğu kanıtlanırsa, 
hata ayıklamada kullanabileceğiniz daha fazla bilgiye sahip olursunuz.</p>
<h3 id="hataların-yayılması"><a class="header" href="#hataların-yayılması">Hataların Yayılması</a></h3>
<p>Bir fonksiyonun süreklemesi başarısız olabilecek bir şeyi çağırdığında, hatayı fonksiyonun kendi içinde ele almak yerine, 
hatayı çağıran koda döndürebilirsiniz, böylece işlev ne yapacağına karar verebilir. 
Bu, hatanın yayılması olarak bilinir ve hatanın nasıl ele alınması gerektiğini belirleyen daha fazla bilgi veya 
mantığın kodunuzun bağlamında mevcut olandan daha fazla olabileceği çağıran koda daha fazla kontrol sağlar.</p>
<p>Örneğin, Liste 9-6'da bir dosyadan kullanıcı adı okuyan bir fonksiyon gösterilmektedir. 
Dosya mevcut değilse veya okunamıyorsa, bu fonksiyon; hataları, fonksiyonu çağıran koda döndürür.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open(&quot;hello.txt&quot;);

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 9-6: <code>match</code> kullanarak arama koduna hata 
döndüren bir fonksiyon</span></p>
<p>Bu fonksiyon çok daha kısa bir şekilde yazılabilir, ancak hata işlemeyi keşfetmek için çoğunu manuel olarak yaparak başlayacağız; 
sonunda daha kısa yolu göstereceğiz. Önce fonksiyonun dönüş tipine bakalım: <code>Result&lt;String, io::Error&gt;</code>. 
Bu, fonksiyonun <code>Result&lt;T, E&gt;</code> türünde bir değer döndürdüğü anlamına gelir; burada yaygın parametre <code>T</code>, somut <code>String</code> türüyle 
ve yaygın tür <code>E</code>, somut <code>io::Error</code> tipiyle doldurulmuştur.</p>
<p>Bu fonksiyon sorunsuz bir şekilde başarılı olursa, bu fonksiyonu çağıran kod, bu fonksiyonun dosyadan okuduğu kullanıcı 
adı olan bir <code>String</code> içeren bir <code>Ok</code> değeri alacaktır. Bu fonksiyon herhangi bir sorunla karşılaşırsa, çağıran kod, 
sorunların ne olduğu hakkında daha fazla bilgi içeren <code>io::Error</code> tanımını tutan bir <code>Err</code> değeri alır. 
Bu fonksiyonun geri dönüş türü olarak <code>io::Error</code>'ı seçtik çünkü bu fonksiyonun gövdesinde çağırdığımız ve başarısız olabilecek 
her iki işlemden (<code>File::open</code> fonksiyonu ve <code>read_to_string</code> metodu) dönen hata değerinin türü budur.</p>
<p>Fonksiyonun gövdesi <code>File::open</code> fonksiyonunu çağırarak başlar. Ardından <code>Result</code> değerini Liste 9-4'teki <code>match</code>'e benzer 
bir <code>match</code> ile ele alıyoruz. <code>File::open</code> başarılı olursa, <code>file</code> kalıp değişkenindeki dosya tanıtıcısı <code>username_file</code> değişkenindeki 
değer olur ve fonksiyon devam eder. <code>Err</code> durumunda, <code>panic!</code> çağrısı yapmak yerine, <code>return</code> anahtar sözcüğünü kullanarak 
fonksiyondan erken döneriz ve <code>File::open</code>'dan gelen hata değerini, şimdi <code>e</code> kalıp değişkeninde, bu fonksiyonun hata değeri olarak
çağıran koda geri aktarırız.</p>
<p>Dolayısıyla, <code>username_file</code> içinde bir dosya tanıtıcımız varsa, fonksiyon <code>username</code> değişkeninde yeni bir <code>String</code> oluşturur ve 
dosyanın içeriğini <code>username</code> içine okumak için <code>username_file</code> içindeki dosya tanıtıcısında <code>read_to_string</code> metodunu çağırır. 
<code>read_to_string</code> metodu da <code>Result</code> döndürür, çünkü <code>File::open</code> başarılı olsa bile başarısız olabilir. 
Bu nedenle, <code>Result</code>'u işlemek için başka bir <code>match</code>'e ihtiyacımız var: <code>read_to_string</code> başarılı olursa, fonksiyonumuz başarılı olmuştur ve 
şimdi bir <code>Ok</code>'a sarılmış <code>username</code>'de bulunan dosyadan kullanıcı adını döndürürüz. <code>read_to_string</code> başarısız olursa, 
<code>File::open</code>'ın dönüş değerini işleyen <code>match</code>'te hata değerini döndürdüğümüz şekilde hata değerini döndürürüz. Ancak, 
bu fonksiyondaki son ifade olduğu için açıkça <code>return</code> dememize gerek yoktur.</p>
<p>Bu kodu çağıran kod daha sonra kullanıcı adı içeren bir <code>Ok</code> değeri ya da <code>io::Error</code> içeren bir <code>Err</code> değeri almayı işleyecektir. 
Bu değerlerle ne yapılacağına çağıran kod karar verir. Çağıran kod bir <code>Err</code> değeri alırsa, <code>panic!</code> çağrısı yapabilir ve programı 
çökertebilir, varsayılan bir kullanıcı adı kullanabilir veya örneğin kullanıcı adını bir dosyadan başka bir yerden arayabilir. 
Çağıran kodun gerçekte ne yapmaya çalıştığı hakkında yeterli bilgiye sahip değiliz, bu nedenle uygun şekilde işlemesi için 
tüm başarı veya hata bilgilerini yukarı doğru yayıyoruz.</p>
<p>Bu hata yayma eğilimi Rust'ta o kadar yaygındır ki, Rust bunu kolaylaştırmak için <code>?</code> soru işareti operatörünü sağlar.</p>
<h4 id="hataları-yaymak-İçin-bir-kısayol--operatörü"><a class="header" href="#hataları-yaymak-İçin-bir-kısayol--operatörü">Hataları Yaymak İçin Bir Kısayol: <code>?</code> Operatörü</a></h4>
<p>Liste 9-7, Liste 9-6'dakiyle aynı fonksiyona sahip bir <code>read_username_from_file</code> süreklemesini göstermektedir, 
ancak bu sürekleme <code>?</code> işlecini kullanmaktadır.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open(&quot;hello.txt&quot;)?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 9-7: <code>?</code> operatörünü kullanarak arama koduna hata döndüren bir
fonksiyon</span></p>
<p>Bir <code>Result</code> değerinden sonra yerleştirilen <code>?</code> işareti, Liste 9-6'da <code>Result</code> değerlerini işlemek için tanımladığımız 
<code>match</code> ifadeleriyle hemen hemen aynı şekilde çalışacak şekilde tanımlanmıştır. <code>Result</code>'un değeri bir <code>Ok</code> ise, <code>Ok</code>'un içindeki 
değer bu ifadeden döndürülür ve program devam eder. Değer <code>Err</code> ise, <code>return</code> anahtar sözcüğünü kullanmışız gibi tüm fonksiyondan <code>Err</code> 
döndürülür, böylece hata değeri çağıran koda yayılır.</p>
<p>Liste 9-6'daki <code>match</code> ifadesinin yaptığı ile <code>?</code> operatörünün yaptığı arasında bir fark vardır: <code>?</code> operatörünün çağrıldığı 
hata değerleri, standart kütüphanedeki <code>From</code> tanımında tanımlanan ve değerleri bir türden diğerine dönüştürmek için kullanılan <code>from</code> 
fonksiyonundan geçer. <code>?</code> işleci <code>from</code> fonksiyonunu çağırdığında, alınan hata türü geçerli fonksiyonun dönüş türünde tanımlanan 
hata türüne dönüştürülür. Bu, bir fonksiyonun birçok farklı nedenden dolayı başarısız olsa bile, bir fonksiyonun başarısız 
olabileceği tüm yolları temsil etmek için tek bir hata türü döndürdüğünde kullanışlıdır.</p>
<p>Örneğin, Liste 9-7'deki <code>read_username_from_file</code> fonksiyonunu <code>OurError</code> adında tanımladığımız özel bir hata türünü döndürecek şekilde
değiştirebiliriz. Bir <code>io::Error</code>'dan bir <code>OurError</code> tanımı oluşturmak için <code>impl From&lt;io::Error&gt; for OurError</code> olarak tanımlarsak,
<code>read_username_from_file</code>'ın gövdesindeki <code>?</code> operatör çağrıları, fonksiyona daha fazla kod eklemeye gerek kalmadan <code>from</code>'u çağıracak ve 
hata türlerini dönüştürecektir.</p>
<p>Liste 9-7 bağlamında, <code>File::open</code> çağrısının sonundaki <code>?</code>, <code>Ok</code> içindeki değeri <code>username_file</code> değişkenine döndürecektir. 
Bir hata oluşursa, <code>?</code> işleci tüm fonksiyonlardan erken dönecek ve çağıran koda herhangi bir <code>Err</code> değeri verecektir. 
Aynı şey <code>read_to_string</code> çağrısının sonundaki <code>?</code> için de geçerlidir.</p>
<p><code>?</code> işleci, çok sayıda kopyala-yapıştır kodu ortadan kaldırır ve bu fonksiyonun süreklenmesini de daha basit hale getirir. 
Hatta Liste 9-8'de gösterildiği gibi, <code>?</code>'den hemen sonra metod çağrılarını zincirleyerek bu kodu daha da kısaltabiliriz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 9-8: <code>?</code> operatöründen sonra zincirleme yöntemi çağrıları</span></p>
<p><code>username</code>'de yeni <code>String</code>'in oluşturulmasını fonksiyonun başına taşıdık; sıkıntısız çalışacaktır. 
Bir <code>username_file</code> değişkeni oluşturmak yerine <code>read_to_string</code> çağrısını doğrudan <code>File::open(&quot;hello.txt&quot;)?</code> sonucunun üzerine zincirledik. 
Hala bir <code>?</code> <code>read_to_string</code> çağrısının sonunda ve hata döndürmek yerine hem <code>File::open</code> hem de <code>read_to_string</code> başarılı olduğunda 
<code>username</code>'i içeren <code>Ok</code> değerini döndürürüz. İşlevsellik yine Liste 9-6 ve Liste 9-7'deki ile aynıdır; bu sadece yazmanın farklı, 
daha ergonomik bir yolu.</p>
<p>Liste 9-9, <code>fs::read_to_string</code> kullanarak bunu daha da kısaltmanın bir yolunu gösterir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 9-9: Dosyayı açıp okumak yerine <code>fs::read_to_string</code> kullanma</span></p>
<p>Bir dosyayı bir <code>String</code>'e okumak oldukça yaygın bir işlemdir, bu nedenle standart kütüphane dosyayı açan, 
yeni bir <code>String</code> oluşturan, dosyanın içeriğini okuyan, içeriği bu <code>String</code>'e atayan ve geri döndüren kullanışlı <code>fs::read_to_string</code> 
fonksiyonunu sağlar. Elbette, <code>fs::read_to_string</code> kullanmak bize tüm hata işlemlerini açıklama fırsatı vermez, bu yüzden önce uzun yoldan yaptık.</p>
<h4 id="-operatörünün-kullanılabileceği-yerler"><a class="header" href="#-operatörünün-kullanılabileceği-yerler"><code>?</code> Operatörünün Kullanılabileceği Yerler</a></h4>
<p><code>?</code> işleci yalnızca dönüş türü <code>?</code> işlecinin kullanıldığı değerle uyumlu olan fonksiyonlarda kullanılabilir. 
Bunun nedeni, <code>?</code> işlecinin, Liste 9-6'da tanımladığımız <code>match</code> ifadesiyle aynı şekilde, bir değerin fonksiyondan erken dönüşünü 
gerçekleştirmek üzere tanımlanmış olmasıdır. Liste 9-6'da, <code>match</code> <code>Result</code> değeri kullanıyordu ve erken dönüş kolu <code>Err(e)</code> 
değeri döndürüyordu. Bu dönüşle uyumlu olması için fonksiyonun dönüş tipi bir <code>Result</code> olmalıdır.</p>
<p>Liste 9-10'da, <code>?</code> operatörünü <code>?</code> kullandığımız değerin türüyle uyumsuz bir geri dönüş türüne sahip <code>main</code> 
fonksiyonunda kullanırsak alacağımız hataya bakalım:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<p><span class="caption">Liste 9-10: <code>()</code> döndüren <code>main</code> fonksiyonunda <code>?</code> kullanmaya çalışırsak derlenmeyecektir</span></p>
<p>Bu kod, başarısız olabilecek bir dosya açar. <code>?</code> işleci <code>File::open</code> tarafından döndürülen <code>Result</code> değerini takip eder, 
ancak bu <code>main</code> fonksiyonunun dönüş türü <code>Result</code> değil <code>()</code>'dir. Bu kodu derlediğimizde aşağıdaki hata mesajını alırız:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:36
  |
3 | / fn main() {
4 | |     let f = File::open(&quot;hello.txt&quot;)?;
  | |                                    ^ cannot use the `?` operator in a function that returns `()`
5 | | }
  | |_- this function should return `Result` or `Option` to accept `?`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` due to previous error
</code></pre>
<p>Bu hata, <code>?</code> operatörünü yalnızca <code>Result</code>, <code>Option</code> veya <code>FromResidual</code>'ı sürekleyen başka bir tür döndüren bir 
fonksiyonda kullanabileceğimize işaret eder.</p>
<p>Hatayı düzeltmek için iki seçeneğiniz vardır. Seçeneklerden biri, bunu engelleyen herhangi bir kısıtlama olmadığı sürece fonksiyonunuzun dönüş 
türünü <code>?</code> operatörünü kullandığınız değerle uyumlu olacak şekilde değiştirmektir. Diğer teknik ise, <code>Result&lt;T, E&gt;</code>'yi uygun olan şekilde 
işlemek için <code>match</code> veya <code>Result&lt;T, E&gt;</code> yöntemlerinden birini kullanmaktır.</p>
<p>Hata mesajında ayrıca <code>?</code> operatörünün <code>Option&lt;T&gt;</code> değerleriyle de kullanılabileceği belirtilmiştir. <code>Result</code> üzerinde <code>?</code> kullanımında olduğu 
gibi, <code>Option</code> üzerinde <code>?</code> kullanımını da yalnızca <code>Option</code> döndüren bir fonksiyonda kullanabilirsiniz. 
Bir <code>Option&lt;T&gt;</code> üzerinde çağrıldığında <code>?</code> operatörünün davranışı, bir <code>Result&lt;T, E&gt;</code> üzerinde çağrıldığında gösterdiği davranışa benzer: 
değer <code>None</code> ise, <code>None</code> o noktada fonksiyondan erken döndürülür. Değer <code>Some</code> ise, <code>Some</code> içindeki değer ifadenin sonuç değeridir ve 
fonksiyon devam eder. Liste 9-11'de, verilen metindeki ilk satırın son karakterini bulan bir fonksiyon örneği vardır:</p>
<pre><pre class="playground"><code class="language-rust">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line(&quot;Hello, world\nHow are you today?&quot;),
</span><span class="boring">        Some('d')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(&quot;&quot;), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line(&quot;\nhi&quot;), None);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 9-11: Bir <code>Option&lt;T&gt;</code> değerinde <code>?</code> 
operatörünü kullanma</span></p>
<p>Bu fonksiyon <code>Option&lt;char&gt;</code> döndürür, çünkü orada bir karakter olması mümkündür, ancak olmaması da mümkündür. 
Bu kod, metin dizgisi dilim argümanını alır ve dizedeki satırlar üzerinde bir yineleyici döndüren <code>lines</code> metodunu çağırır. 
Bu fonksiyon ilk satırı incelemek istediğinden, yineleyiciden ilk değeri almak için yineleyicide <code>next</code> öğesini çağırır. 
Eğer <code>text</code> boş dizgiyse, <code>next</code>'e yapılan bu çağrı <code>None</code> değerini döndürür, bu durumda durdurmak için <code>?</code> kullanırız ve 
<code>last_char_of_first_line</code>'dan <code>None</code> değerini döndürürüz. <code>text</code> boş değilse, <code>next</code> çağrısı metindeki ilk satırın dizgi dilimini içeren 
<code>Some</code> değerini döndürür.</p>
<p><code>?</code> dizgi dilimini çıkarır ve karakterlerinin bir yineleyicisini almak için bu dizgi dilimi üzerinde <code>chars</code>'ı çağırabiliriz. 
Bu ilk satırdaki son karakterle ilgilendiğimizden, yineleyicideki son öğeyi döndürmek için <code>last</code> öğesini çağırırız. 
Bu bir <code>Option</code>'dur çünkü ilk satırın boş bir dizgi olması mümkündür, örneğin metin boş bir satırla başlıyorsa ancak <code>&quot;\nhi&quot;</code> gibi diğer 
satırlarda karakterler varsa. Ancak, ilk satırda bir son karakter varsa, <code>Some</code> değişkeninde döndürülür. Ortadaki <code>?</code> operatörü bize 
bu mantığı ifade etmek için kısa bir yol sunar ve fonksiyonu tek bir satırda yazmamıza olanak tanır. 
<code>Option</code> üzerinde <code>?</code> operatörünü kullanamasaydık, bu mantığı daha fazla metod çağrısı veya bir <code>match</code> ifadesi kullanarak uygulamamız gerekirdi.
Kısaca Rust bu ameleliği sizin üzerinizden alır.</p>
<p><code>Result</code> döndüren bir fonksiyonda bir <code>Result</code> üzerinde <code>?</code> operatörünü kullanabileceğinizi ve <code>Option</code> döndüren bir 
fonksiyonda bir <code>Option</code> üzerinde <code>?</code> operatörünü kullanabileceğinizi, ancak karıştırıp eşleştiremeyeceğinizi unutmayın. 
<code>?</code> işleci bir <code>Result</code>'u otomatik olarak <code>Option</code>'a dönüştürmez veya tam tersini yapmaz; bu gibi durumlarda, dönüştürmeyi 
açıkça yapmak için <code>Result</code> üzerinde <code>Ok</code> metodu veya <code>Option</code> üzerinde <code>ok_or</code> metodu gibi metodları kullanabilirsiniz.</p>
<p>Şimdiye kadar kullandığımız tüm <code>main</code> fonksiyonlar <code>()</code> döndürüyordu. <code>main</code> fonksiyonu özeldir, çünkü çalıştırılabilir 
programların giriş ve çıkış noktasıdır ve programların beklendiği gibi davranması için dönüş türünün ne olabileceği 
konusunda kısıtlamalar vardır.</p>
<p>Neyse ki <code>main</code> aynı zamanda bir <code>Result&lt;(), E&gt;</code> de döndürebilir. Liste 9-12, Liste 9-10'daki kodu içerir, 
ancak <code>main</code>'in dönüş türünü <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> olarak değiştirdik ve sonuna bir dönüş değeri 
<code>Ok(())</code> ekledik. Bu kod şimdi derlenecektir:</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open(&quot;hello.txt&quot;)?;

    Ok(())
}
</code></pre>
<p><span class="caption">Liste 9-12: <code>main</code>'i <code>Result&lt;(), E&gt;</code> döndürecek şekilde değiştirmek, <code>Result</code> değerlerinde 
<code>?</code> operatörünün kullanılmasına izin verir</span></p>
<p><code>Box&lt;dyn Error&gt;</code> türü bir <em>tanım nesnesidir</em> ve 17. Bölümdeki 
<a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Farklı Türlerde Değerlere İzin Veren Tanım Nesnelerini Kullanma”</a><!-- ignore --> kısmında bundan bahsedeceğiz. 
Şimdilik, <code>Box&lt;dyn Error&gt;</code> türünü “hatanın her türlüsü” olarak okuyabilirsiniz. Hata türü <code>Box&lt;dyn Error&gt;</code> olan bir <code>main</code>'de, 
<code>Result</code> değeri üzerinde <code>?</code> kullanılmasına izin verilir, çünkü herhangi bir <code>Err</code> değerinin erken döndürülmesine izin verir. 
Bu <code>main</code>'in gövdesi yalnızca <code>std::io::Error</code> türünde hatalar döndürecek olsa da, <code>Box&lt;dyn Error&gt;</code> belirtilerek, 
<code>main</code> gövdesine başka hatalar döndüren başka kodlar eklense bile bu imza doğru olmaya devam edecektir.</p>
<p><code>main</code>, <code>Result&lt;(), E&gt;</code> döndürdüğünde, <code>main</code> <code>Ok(())</code> döndürürse yürütülebilir dosya <code>0</code> değeriyle çıkar ve <code>main</code> <code>Err</code> değeri döndürürse 
<em>sıfır olmayan</em> bir değerle çıkar. C'de yazılmış çalıştırılabilir dosyalar çıktıklarında tam sayı döndürür: 
başarıyla çıkan programlar <code>0</code> döndürür ve hata veren programlar 0 dışında bir tam sayı döndürür. 
Rust da bu kuralla uyumlu olmak için çalıştırılabilir dosyadan tam sayı döndürür.</p>
<p><code>main</code> fonksiyonu, <code>ExitCode</code> döndüren bir fonksiyon raporu içeren <code>std::process::Termination</code> tanımını sürekleyen herhangi bir türü 
döndürebilir. Kendi türleriniz için <code>Termination</code> tanımını sürekleme hakkında daha fazla bilgi için standart kütüphane 
dokümantasyonuna bakın.</p>
<p><code>panic!</code> çağrısı yapmanın veya <code>Result</code> döndürmenin ayrıntılarını tartıştığımıza göre, 
hangi durumlarda hangisinin kullanılmasının uygun olacağına nasıl karar verileceği konusuna geri dönelim.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="paniclemek-mi-paniclememek-mi"><a class="header" href="#paniclemek-mi-paniclememek-mi"><code>panic!</code>'lemek mi, <code>panic!</code>'lememek mi?</a></h2>
<p>Peki ne zaman panik yapacağınıza ve ne zaman <code>Result</code>'a geri döneceğinize nasıl karar vereceksiniz? 
Kod panik yaptığında, kurtarmanın bir yolu yoktur. Kurtarmanın olası bir yolu olsun ya da olmasın, herhangi bir hata durumu için 
<code>panic!</code> çağrısı yapabilirsiniz, ancak o zaman çağıran kod adına bir durumun kurtarılamaz olduğuna karar vermiş olursunuz. 
Bir <code>Result</code> değeri döndürmeyi seçtiğinizde, çağıran koda seçenekler sunarsınız. Çağıran kod, kendi durumuna uygun bir şekilde kurtarma 
girişiminde bulunmayı seçebilir veya bu durumda bir <code>Err</code> değerinin kurtarılamaz olduğuna karar verebilir, böylece <code>panic!</code> çağrısı yapabilir 
ve kurtarılabilir hatanızı kurtarılamaz bir hataya dönüştürebilir. Bu nedenle, başarısız olabilecek bir fonksiyon tanımlarken <code>Result</code> döndürmek 
iyi bir varsayılan seçimdir.</p>
<p>Örnekler, prototip kodu ve testler gibi durumlarda, <code>Result</code> döndürmek yerine panikleyen kod yazmak daha uygundur. 
Nedenini inceleyelim, ardından derleyicinin başarısızlığın imkansız olduğunu söyleyemediği, ancak insan olarak sizin söyleyebildiğiniz 
durumları tartışalım. Bölüm, kütüphane kodunda panik yapıp yapmamaya nasıl karar verileceğine ilişkin bazı genel yönergelerle sona erecektir.</p>
<h3 id="Örnekler-prototip-kod-ve-testler"><a class="header" href="#Örnekler-prototip-kod-ve-testler">Örnekler, Prototip Kod ve Testler</a></h3>
<p>Bir kavramı açıklamak için bir örnek yazarken, sağlam hata işleme kodu da eklemek örneği daha az anlaşılır hale getirebilir. 
Örneklerde, <code>unwrap</code> gibi panik yaratabilecek bir metoda yapılan çağrının, uygulamanızın hataları nasıl ele almasını istediğinize yönelik 
bir yer tutucu olduğu anlaşılır; bu da kodunuzun geri kalanının ne yaptığına bağlı olarak farklılık gösterebilir.</p>
<p>Benzer şekilde, <code>unwrap</code> ve <code>expect</code> metodları, hataları nasıl ele alacağınıza karar vermeye hazır olmadan önce prototip 
oluştururken çok kullanışlıdır. Programınızı daha sağlam hale getirmeye hazır olduğunuzda kodunuzda net işaretler bırakırlar.</p>
<p>Bir testte bir metod çağrısı başarısız olursa, bu yöntem test edilen fonksiyon olmasa bile tüm testin başarısız olmasını istersiniz. 
<code>panic!</code> bir testin başarısız olarak işaretlenme şekli olduğundan, <code>unwrap</code> veya <code>expect</code> çağrısı tam olarak olması gereken şeydir.</p>
<h3 id="derleyiciden-daha-fazla-bilgiye-sahip-olduğunuz-durumlar"><a class="header" href="#derleyiciden-daha-fazla-bilgiye-sahip-olduğunuz-durumlar">Derleyiciden Daha Fazla Bilgiye Sahip Olduğunuz Durumlar</a></h3>
<p>Ayrıca, <code>Result</code>'un <code>Ok</code> değerine sahip olmasını sağlayan başka bir mantığınız olduğunda <code>unwrap</code> veya <code>expect</code> çağrısı 
yapmak da uygun olacaktır, ancak bu mantık derleyicinin anlayabileceği bir şey değildir. Hala işlemeniz gereken bir <code>Result</code> değeriniz olacaktır:
çağırdığınız işlem, sizin özel durumunuzda mantıksal olarak imkansız olsa bile, genel olarak başarısız olma olasılığına sahiptir. 
Kodu manuel olarak inceleyerek hiçbir zaman bir <code>Err</code> varyantına sahip olmayacağınızdan emin olabiliyorsanız, 
<code>unwrap</code>'i çağırmak tamamen kabul edilebilir ve hatta <code>expect</code> metninde hiçbir zaman bir <code>Err</code> varyantına sahip olmayacağınızı düşünmenizin 
nedenini belgelemek daha iyidir. İşte bir örnek:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = &quot;127.0.0.1&quot;
        .parse()
        .expect(&quot;Hardcoded IP address should be valid&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Kodlanmış bir dizeyi ayrıştırarak bir <code>IpAddr</code> örneği oluşturuyoruz. <code>127.0.0.1</code>'in geçerli bir IP adresi olduğunu görebiliyoruz, 
bu nedenle burada <code>expect</code> kullanmak kabul edilebilir. Ancak, sabit kodlu, geçerli bir dizeye sahip olmak, <code>parse</code> metodunun dönüş türünü 
değiştirmez: hala bir <code>Result</code> değeri alırız ve derleyici, bu dizginin her zaman geçerli bir IP adresi olduğunu görecek kadar akıllı olmadığından, 
<code>Err</code> varyantı bir olasılıkmış gibi <code>Result</code>'u işlememizi sağlar. IP adresi dizgisi programa kodlanmak yerine bir kullanıcıdan gelseydi ve 
bu nedenle hata olasılığı olsaydı, bunun yerine <code>Result</code>'u kesinlikle daha sağlam bir şekilde ele almak isterdik. 
Bu IP adresinin sabit kodlu olduğu varsayımından bahsetmek, gelecekte IP adresini başka bir kaynaktan almamız gerekirse, 
daha iyi hata işleme kodu beklentisini değiştirmemizi sağlayacaktır.</p>
<h3 id="hata-İşleme-yönergeleri"><a class="header" href="#hata-İşleme-yönergeleri">Hata İşleme Yönergeleri</a></h3>
<p>Kodunuzun kötü bir duruma düşme olasılığı olduğunda kodunuzun paniğe kapılması tavsiye edilir. Bu bağlamda kötü durum, geçersiz değerler, 
çelişkili değerler veya eksik değerlerin kodunuza aktarılması gibi bazı varsayımların, garantilerin, sözleşmelerin veya değişmezlerin 
ihlal edilmesi ve ayrıca aşağıdakilerden bir veya daha fazlasının gerçekleşmesi durumudur:</p>
<ul>
<li>
<p>Kötü durum, kullanıcının yanlış formatta veri girmesi gibi ara sıra meydana gelebilecek bir durumun aksine beklenmedik bir durumdur.
Bu noktadan sonra kodunuzun her adımda sorunu kontrol etmek yerine bu kötü durumda olmamaya güvenmesi gerekir.
Kullandığınız türlerde bu bilgiyi kodlamanın iyi bir yolu yoktur. Bölüm 17'deki 
<a href="ch17-03-oo-design-patterns.html#encoding-states-and-behavior-as-types">“Durumları ve Davranışları Türler Olarak Kodlama”</a><!-- ignore --> kısmında ne demek istediğimizi bir örnekle açıklayacağız.</p>
</li>
<li>
<p>Birisi kodunuzu çağırır ve mantıklı olmayan değerler girerse, yapabiliyorsanız bir hata döndürmek en iyisidir, 
böylece kütüphane kullanıcısı bu durumda ne yapmak istediğine karar verebilir. Ancak, devam etmenin güvensiz veya zararlı olabileceği durumlarda, 
en iyi seçim <code>panic!</code> çağrısı yapmak ve kütüphanenizi kullanan kişiyi kodlarındaki hata konusunda uyarmak olabilir, böylece geliştirme 
sırasında düzeltebilirler. Benzer şekilde, kontrolünüz dışında olan harici bir kodu çağırıyorsanız ve bu kod düzeltme imkanınızın olmadığı geçersiz 
bir durum döndürüyorsa <code>panic!</code> çağrısı yapılmalıdır.</p>
</li>
<li>
<p>Başarısızlık beklendiğinde, <code>panic!</code> çağrısı yapmaktansa bir <code>Result</code> döndürmek daha uygundur. Örnekler arasında, hatalı biçimlendirilmiş
verilerin verildiği bir ayrıştırıcı veya bir hız sınırına ulaştığınızı gösteren bir durum döndüren bir HTTP isteği yer alır. 
Bu durumlarda, <code>Result</code> döndürmek, başarısızlığın, çağıran kodun nasıl ele alacağına karar vermesi gereken beklenen bir olasılık olduğunu gösterir.</p>
</li>
</ul>
<p>Kodunuz, geçersiz değerler kullanılarak çağrıldığında kullanıcıyı riske atabilecek bir işlem gerçekleştirdiğinde, 
kodunuz önce değerlerin geçerli olduğunu doğrulamalı ve değerler geçerli değilse paniklemelidir. 
Bu çoğunlukla güvenlik nedenleriyle yapılır: geçersiz veriler üzerinde işlem yapmaya çalışmak kodunuzu güvenlik açıklarına maruz bırakabilir. 
Sınır dışı bir bellek erişimi denediğinizde standart kütüphanenin <code>panic!</code> çağrısı yapmasının ana nedeni budur: mevcut veri yapısına ait 
olmayan belleğe erişmeye çalışmak yaygın bir güvenlik sorunudur. Fonksiyonların genellikle sözleşmeleri vardır: 
davranışları yalnızca girdilerin belirli gereksinimleri karşılaması durumunda garanti edilir. Sözleşme ihlal edildiğinde paniklemek 
mantıklıdır çünkü bir sözleşme ihlali her zaman çağıran tarafında bir hata olduğunu gösterir ve çağıran kodun açıkça ele almasını istediğiniz bir 
hata türü değildir. Aslında, çağıran kodun hatayı telafi etmesinin makul bir yolu yoktur; çağıran programcıların kodu düzeltmesi gerekir. 
Bir fonksiyon için sözleşmeler, özellikle de bir ihlal paniğe neden olacaksa, işlevin API belgelerinde açıklanmalıdır.</p>
<p>Ancak, tüm fonksiyonlarınızda çok sayıda hata kontrolü olması ayrıntılı ve can sıkıcı olacaktır. Neyse ki, Rust'ın tür sistemini 
(ve dolayısıyla derleyici tarafından yapılan tür kontrolünü) kontrollerin çoğunu sizin için yapmak için kullanabilirsiniz. Fonksiyonunuz parametre 
olarak belirli bir türe sahipse, derleyicinin zaten geçerli bir değere sahip olduğunuzdan emin olduğunu bilerek kodunuzun mantığına devam 
edebilirsiniz. Örneğin, bir <code>Option</code> yerine bir türünüz varsa, programınız hiçbir şey yerine bir şey olmasını bekler. 
Bu durumda kodunuz <code>Some</code> ve <code>None</code> varyantları için iki durumla uğraşmak zorunda kalmaz: kesinlikle bir değere sahip olmak için 
yalnızca bir durum olacaktır. Fonksiyonunuza hiçbir şey iletmemeye çalışan kod derlenmez bile, bu nedenle fonksiyonunuzun çalışma zamanında bu 
durumu kontrol etmesi gerekmez. Başka bir örnek de <code>u32</code> gibi işaretsiz bir tam sayı türü kullanmaktır, bu da parametrenin asla negatif 
olmamasını sağlar.</p>
<h3 id="doğrulama-için-Özel-tipler-oluşturma"><a class="header" href="#doğrulama-için-Özel-tipler-oluşturma">Doğrulama için Özel Tipler Oluşturma</a></h3>
<p>Geçerli bir değere sahip olduğumuzdan emin olmak için Rust'ın tür sistemini kullanma fikrini bir adım daha ileri götürelim 
ve doğrulama için özel bir tür oluşturmaya bakalım. Bölüm 2'de kodumuzun kullanıcıdan 1 ile 100 arasında bir sayı tahmin etmesini 
istediği tahmin oyununu hatırlayın. Gizli sayımızla karşılaştırmadan önce kullanıcının tahmininin bu sayılar arasında olduğunu 
doğrulamadık; yalnızca tahminin pozitif olduğunu doğruladık. Bu durumda, sonuçlar çok vahim değildi: “Too high” veya &quot;Too low&quot; 
çıktılarımız yine de doğru olacaktı. Ancak, kullanıcıyı geçerli tahminlere yönlendirmek ve bir kullanıcı aralık dışında bir sayı tahmin 
ettiğinde, bunun yerine örneğin harfler yazdığında farklı bir davranışa sahip olmak yararlı bir geliştirme olacaktır.</p>
<p>Bunu yapmanın bir yolu, potansiyel olarak negatif sayılara izin vermek için tahmini yalnızca bir <code>u32</code> yerine bir <code>i32</code> olarak ayrıştırmak ve 
ardından sayının aralıkta olup olmadığına dair bir kontrol eklemek olabilir:</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    loop {
        // --snip--

<span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!(&quot;The secret number will be between 1 and 100.&quot;);
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --snip--
<span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}
</span></code></pre>
<p><code>if</code> ifadesi, değerimizin aralık dışında olup olmadığını kontrol eder, kullanıcıya sorun hakkında bilgi verir ve döngünün 
bir sonraki yinelemesini başlatmak ve başka bir tahmin istemek için <code>continue</code> çağrısı yapar. <code>if</code> ifadesinden sonra, 
tahminin <code>1</code> ile <code>100</code> arasında olduğunu bilerek tahmin ile gizli sayı arasındaki karşılaştırmalara devam edebiliriz.</p>
<p>Ancak, bu ideal bir çözüm değildir: programın yalnızca <code>1</code> ile <code>100</code> arasındaki değerler üzerinde çalışması kesinlikle kritikse ve 
bu gereksinime sahip birçok fonksiyonu varsa, her işlevde bunun gibi bir kontrol yapmak sıkıcı olacaktır (ve performansı etkileyebilir).</p>
<p>Bunun yerine, yeni bir tür oluşturabilir ve doğrulamaları her yerde tekrarlamak yerine türün bir örneğini oluşturmak için doğrulamaları 
bir fonksiyona koyabiliriz. Bu şekilde, fonksiyonların imzalarında yeni türü kullanmaları ve aldıkları değerleri güvenle kullanmaları 
güvenli olur. Liste 9-13, yalnızca yeni fonksiyon <code>1</code> ile <code>100</code> arasında bir değer alırsa <code>Guess</code>'in bir örneğini oluşturacak bir 
<code>Guess</code> türü tanımlamanın bir yolunu göstermektedir.</p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 9-13: Yalnızca <code>1</code> ile <code>100</code> arasındaki değerlerle devam edecek bir <code>Guess</code> 
türü</span></p>
<p>İlk olarak, bir <code>i32</code> tutan <code>value</code> adlı bir üyeye sahip <code>Guess</code> adlı bir yapı tanımlarız. Burası sayının saklanacağı yerdir.</p>
<p>Ardından, <code>Guess</code> değerlerinin örneklerini oluşturan <code>Guess</code> üzerinde new adında ilişkili bir fonksiyon uyguluyoruz. 
<code>new</code> fonksiyonu, <code>i32</code> türünde <code>value</code> adında bir parametreye sahip olacak ve bir <code>Guess</code> değeri döndürecek şekilde tanımlanır. 
<code>new</code> fonksiyonunun gövdesindeki kod, <code>1</code> ile <code>100</code> arasında olduğundan emin olmak için değeri test eder. Eğer <code>value</code> bu testi geçemezse, 
çağıran kodu yazan programcıyı düzeltmesi gereken bir hata olduğu konusunda uyaracak bir <code>panic!</code> çağrısı yaparız, 
çünkü bu aralığın dışında bir değere sahip bir <code>Guess</code> oluşturmak <code>Guess::new</code>'in dayandığı sözleşmeyi ihlal edecektir. 
<code>Guess::new</code>'in paniğe kapılabileceği koşullar kamuya açık API dokümantasyonunda tartışılmalıdır; 
Bölüm 14'te oluşturacağınız API dokümantasyonunda <code>panic</code> olasılığını belirten dokümantasyon kurallarını ele alacağız. 
Eğer <code>value</code> testi geçerse, value alanı value parametresine ayarlanmış yeni bir <code>Guess</code> yaratırız ve <code>Guess</code>'i döndürürüz.</p>
<p>Ardından, <code>self</code> öğesini ödünç alan, başka parametresi olmayan ve bir <code>i32</code> döndüren <code>value</code> adlı bir metod yazarız. 
Bu tür yöntemlere bazen <em>getter</em> adı verilir, çünkü amacı alanlarından bazı verileri almak ve döndürmektir. 
<code>Guess</code> yapısının <code>value</code> üyesi gizli olduğu için burada yaygın metod gereklidir. Değer üyesinin gizli olması önemlidir, 
böylece <code>Guess</code> yapısını kullanan kodun değeri doğrudan ayarlamasına izin verilmez: modül dışındaki kod, bir <code>Guess</code> tanımı oluşturmak 
için <code>Guess::new</code> fonksiyonunu kullanmalıdır, böylece <code>Guess</code>'in <code>Guess::new</code> fonksiyonundaki koşullar tarafından kontrol edilmemiş 
bir değere sahip olmasının hiçbir yolu yoktur.</p>
<p>Parametresi olan veya yalnızca <code>1</code> ile <code>100</code> arasındaki sayıları döndüren bir fonksiyon, imzasında bir <code>i32</code> yerine bir <code>Guess</code> aldığını 
veya döndürdüğünü bildirebilir ve gövdesinde herhangi bir ek kontrol yapması gerekmez.</p>
<h2 id="Özet-6"><a class="header" href="#Özet-6">Özet</a></h2>
<p>Rust'ın hata işleme özellikleri, daha sağlam kod yazmanıza yardımcı olmak için tasarlanmıştır. 
<code>panic!</code> makrosu, programınızın üstesinden gelemeyeceği bir durumda olduğunu bildirir ve geçersiz veya yanlış değerlerle devam 
etmeye çalışmak yerine sürece durmasını söylemenizi sağlar. <code>Result</code> <code>enum</code>'u, işlemlerin kodunuzun kurtarabileceği bir şekilde başarısız 
olabileceğini belirtmek için Rust'ın tür sistemini kullanır. <code>Result</code>'u, kodunuzu çağıran koda olası başarı veya başarısızlığı da 
ele alması gerektiğini söylemek için kullanabilirsiniz. <code>panic!</code> ve <code>Result</code>'u uygun durumlarda kullanmak, kaçınılmaz sorunlar karşısında 
kodunuzu daha güvenilir hale getirecektir.</p>
<p>Standart kütüphanenin <code>Option</code> ve <code>Result</code> <code>enum</code>'ları ile yaygınları nasıl kullandığını gördüğünüze göre, 
yaygınların nasıl çalıştığından ve bunları kodunuzda nasıl kullanabileceğinizden bahsedeceğiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yaygın-türler-tanımlar-ve-Ömürler"><a class="header" href="#yaygın-türler-tanımlar-ve-Ömürler">Yaygın Türler, Tanımlar ve Ömürler</a></h1>
<p>Her programlama dili, kavramların tekrarını etkin bir şekilde ele almak için araçlara sahiptir. 
Rust'ta bu araç <em>yaygınlardır</em>. 
Kodu derlerken ve çalıştırırken yerlerinde ne olacağını bilmeden yaygınların davranışını veya diğer yaygınlarla 
nasıl ilişkili olduklarını ifade edebiliriz.</p>
<p>Fonksiyonlar, <code>i32</code> veya <code>String</code> gibi somut bir tür yerine bazı yaygın türdeki parametreleri alabilir; 
aynı şekilde, bir işlevin aynı kodu birden çok somut değerde çalıştırmak için bilinmeyen değerlere sahip 
parametreleri alması gibi. Aslında, Bölüm 6'da <code>Option&lt;T&gt;</code>, Bölüm 8'de <code>Vec&lt;T&gt;</code> ve <code>HashMap&lt;K, V&gt;</code> ve 
Bölüm 9'da <code>Result&lt;T, E&gt;</code> ile yaygınları zaten kullandık. 
Bu bölümde, yaygınları kullanarak kendi türlerinizi, 
fonksiyonlarınızı ve metodlarınızı nasıl tanımlayacabileceğinizi keşfedeceksiniz!</p>
<p>İlk olarak, kod tekrarını azaltmak için bir fonksiyonun nasıl çıkarılacağını inceleyeceğiz. 
Daha sonra, yalnızca parametrelerinin türlerinde farklılık gösteren iki fonksiyondan yaygın bir 
fonksiyon yapmak için aynı tekniği kullanacağız. 
Ayrıca <code>struct</code> ve <code>enum</code> tanımlarında yaygın türlerin nasıl kullanılacağını açıklayacağız.</p>
<p>Ardından, davranışı yaygın bir şekilde tanımlamak için <em>tanımları</em> nasıl kullanacağınızı öğreneceksiniz. 
Yaygın bir türü, herhangi bir türün aksine, yalnızca belirli bir davranışı olan türleri kabul edecek şekilde sınırlamak için tanımları genel türlerle birleştirebilirsiniz.</p>
<p>Son olarak, derleyiciye referansların birbirleriyle nasıl ilişkili olduğu hakkında bilgi veren çeşitli yaygın türleri olan <em>yaşam sürelerini</em> tartışacağız. Ömürler, derleyiciye ödünç alınan değerler hakkında yeterli bilgi vermemize izin verir, 
böylece referansların bizim yardımımız olmadan yapabileceğinden daha fazla durumda geçerli olmasını sağlayabilir.</p>
<h2 id="bir-fonksiyonu-ayıklayarak-fazlalığı-atmak"><a class="header" href="#bir-fonksiyonu-ayıklayarak-fazlalığı-atmak">Bir Fonksiyonu Ayıklayarak Fazlalığı Atmak</a></h2>
<p>Yaygınlar, kod çoğaltmasını kaldırmak için belirli türleri birden çok türü temsil eden bir yer tutucuyla 
değiştirmemize olanak tanır. Yaygınların söz dizimine dalmadan önce, 
belirli değerleri birden çok değeri temsil eden bir yer tutucuyla değiştiren bir fonksiyonu çıkararak, 
yaygın türleri içermeyen bir şekilde çoğaltmanın nasıl ayıklanabileceğine bakalım. 
Ardından, yaygın bir fonksiyonu ayıklamak için aynı tekniği uygulayacağız! 
Bir fonksiyondan çıkarabileceğiniz fazlalık kodu nasıl tanıyacağınıza bakarak, 
yaygınları kullanabilen fazlalık kodu tanımaya başlayacaksınız.</p>
<p>Liste 10-1'deki listedeki en büyük sayıyı bulan kısa programla başlıyoruz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
<span class="boring">    assert_eq!(largest, 100);
</span>}
</code></pre></pre>
<p><span class="caption">Liste 10-1: Sayı listesindeki en büyük sayıyı bulma</span></p>
<p><code>number_list</code> değişkeninde bir tam sayı listesi saklarız ve listedeki ilk sayıyı 
<code>largest</code> adlı bir değişkene atarız. Daha sonra listedeki tüm sayılar arasında yineleniriz ve 
mevcut sayı <code>largest</code>'ta saklanan sayıdan büyükse, o değişkendeki sayıyı değiştiririz. 
Ancak, mevcut sayı o ana kadar görülen en büyük sayıdan küçük veya ona eşitse, 
değişken değişmez ve kod listedeki bir sonraki sayıya geçer. 
Listedeki tüm sayıları göz önünde bulundurduktan sonra, <code>largest</code>, bu durumda 100 olan en büyük sayıyı tutmalıdır.</p>
<p>Şimdi iki farklı sayı listesindeki en büyük sayıyı bulmakla görevlendirildiğimize göre, 
bunu yapmak için Liste 10-1'deki kodu çoğaltmayı seçebilir ve Liste 10-2'de gösterildiği gibi programdaki
iki farklı yerde aynı mantığı kullanabiliriz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre></pre>
<p><span class="caption">Liste 10-2: <em>İki</em> sayı listesindeki en büyük sayıyı bulmak için kullanılabilecek kod</span></p>
<p>Bu kod çalışsa da, kodu kopyalamak sıkıcı ve hataya açık. 
Ayrıca kodu değiştirmek istediğimizde birden çok yeri de güncellemeyi unutmamalıyız.</p>
<p>Bu tekrarı ortadan kaldırmak için, bir parametrede geçirilen herhangi bir tam sayı listesinde çalışan bir fonksiyon tanımlayarak bir soyutlama oluşturacağız. Bu çözüm, kodumuzu daha net hale getirir ve bir listedeki en büyük sayıyı bulma kavramını soyut olarak ifade etmemizi sağlar.</p>
<p>Liste 10-3'te, en büyük sayıyı bulan kodu <code>largest</code> adlı bir fonksiyona çıkarıyoruz. 
Ardından, Liste 10-2'deki iki listedeki en büyük sayıyı bulmak için bu fonksiyonu çağırırız. 
Bu fonksiyonu, gelecekte diğer <code>i32</code> değerleri listesinde de kullanabiliriz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">    assert_eq!(result, 100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">    assert_eq!(result, 6000);
</span>}
</code></pre></pre>
<p><span class="caption">Liste 10-3: İki listedeki en büyük sayıyı bulmak için kullanılabilecek soyut kod</span></p>
<p><code>largest</code> fonksiyonunun, fonksiyona aktarabileceğimiz herhangi bir somut <code>i32</code> değer
dilimini temsil eden <code>list</code> adında bir parametresi vardır. Sonuç olarak, fonksiyonu çağırdığımızda kod, 
ilettiğimiz belirli değerler üzerinde çalışır. Şimdilik <code>for</code> döngüsünün söz dizimini dert etmeyin. 
Burada bir <code>i32</code> referansına herhangi bir atıfta bulunmuyoruz; <code>for</code> döngüsünün aldığı her <code>&amp;i32</code>'yi 
modelle eşleştiriyor ve yok ediyoruz, böylece <code>item</code> döngü gövdesi içinde olduğu sürece türü <code>i32</code> olacaktır. 
Model eşleştirmeyi <a href="ch18-00-patterns.html">Bölüm 18</a><!-- ignore -->'de daha ayrıntılı olarak ele alacağız.</p>
<p>Özetle, kodu Liste 10-2'den Liste 10-3'e değiştirmek için attığımız adımlar şunlardır:</p>
<ol>
<li>Yinelenen kodu tanımlamak.</li>
<li>Yinelenen kodu fonksiyonun gövdesine çıkarmak 
ve bu kodun girdilerini ve dönüş değerlerini fonksiyon tanımında belirtmek.</li>
<li>Fonksiyonu çağırmak için yinelenen kodun iki örneğini de güncellemek.</li>
</ol>
<p>Daha sonra, kod tekrarını azaltmak için aynı adımları yaygınlarla birlikte kullanacağız. </p>
<p>Fonksiyon gövdesinin belirli değerler yerine soyut bir liste üzerinde çalışabilmesi gibi, 
yaygınlar da kodun soyut türler üzerinde çalışmasına izin verir.</p>
<p>Örneğin, iki fonksiyonumuz olduğunu varsayalım: 
biri <code>i32</code> değerleri dilimindeki en büyük öğeyi bulan ve diğeri bir <code>char</code> değerleri dilimindeki en büyük öğeyi bulan. 
Bu tekrarı nasıl ortadan kaldıracağız? </p>
<p>Hadi bulalım!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="yaygın-veri-türleri"><a class="header" href="#yaygın-veri-türleri">Yaygın Veri Türleri</a></h2>
<p>Fonksiyon imzaları veya yapılar gibi öğeler için tanımlar oluşturmak için yaygınları kullanırız ve bunları daha sonra birçok farklı 
somut veri türüyle kullanabiliriz. İlk olarak yaygınları kullanarak fonksiyonları, yapıları, <code>enum</code>'ları ve metodları nasıl tanımlayacağımıza 
bakalım. Daha sonra yaygınların kod performansını nasıl etkilediğini tartışacağız.</p>
<h3 id="fonksiyon-tanımlarında"><a class="header" href="#fonksiyon-tanımlarında">Fonksiyon Tanımlarında</a></h3>
<p>Yaygın kullanan bir fonksiyon tanımlarken, yaygınları fonksiyonun imzasına, genellikle parametrelerin ve dönüş değerinin 
veri tiplerini belirttiğimiz yere yerleştiririz. Bunu yapmak kodumuzu daha esnek hale getirir ve kod tekrarını önlerken 
fonksiyonumuzu çağıranlara daha fazla işlevsellik sağlar.</p>
<p><code>largest</code> fonksiyonumuzla devam edersek, Liste 10-4'te her ikisi de bir dilimdeki en büyük değeri bulan iki fonksiyon gösterilmektedir. 
Daha sonra bunları yaygın kullanan tek bir fonksiyonda birleştireceğiz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">    assert_eq!(result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
<span class="boring">    assert_eq!(result, 'y');
</span>}
</code></pre></pre>
<p><span class="caption">Liste 10-4: Yalnızca adlarında ve imzalarındaki türlerde 
farklılık gösteren iki fonksiyon</span></p>
<p><code>largest_i32</code> fonksiyonu, bir dilimdeki en büyük <code>i32</code>'yi bulan Liste 10-3'te çıkardığımız fonksiyondur. 
<code>largest_char</code> fonksiyonu bir dilimdeki en büyük <code>char</code> değerini bulur. Fonksiyon gövdeleri aynı koda sahiptir, 
bu nedenle tek bir fonksiyona yaygın tür parametresi ekleyerek yinelemeyi ortadan kaldıralım.</p>
<p>Yeni bir tek fonksiyonda türleri parametrelendirmek için, tıpkı bir fonksiyonun değer parametreleri için yaptığımız gibi tür 
parametresini adlandırmamız gerekir. Tür parametresi adı olarak herhangi bir tanımlayıcı kullanabilirsiniz. 
Ancak biz <code>T</code> kullanacağız çünkü Rust'ta parametre adları genellikle sadece bir harf olmak üzere kısadır ve Rust'ın tür adlandırma kuralı 
<code>CamelCase</code>'dir. “tür, type” kelimesinin kısaltması olan <code>T</code>, çoğu Rust programcısının varsayılan tercihidir.</p>
<p>Fonksiyonun gövdesinde bir parametre kullandığımızda, parametre adını imzada bildirmemiz gerekir, böylece derleyici bu adın ne anlama geldiğini 
bilir. Benzer şekilde, bir fonksiyon imzasında bir tür parametre adı kullandığımızda, kullanmadan önce tür parametre adını bildirmemiz gerekir. 
Yaygın <code>largest</code> fonksiyonunu tanımlamak için, tür adı bildirimlerini fonksiyonun adı ile parametre listesi arasına köşeli parantezler 
(<code>&lt;&gt;</code>) içinde yerleştirin, aşağıdaki gibi:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>Bu tanımı şu şekilde okuyabiliriz: <code>largest</code> fonksiyonu bazı <code>T</code> türleri üzerinde yaygındır. Bu fonksiyonun <code>list</code> adında bir 
parametresi vardır ve bu parametre <code>T</code> türünde bir değer dilimidir. <code>largest</code> fonksiyonu aynı <code>T</code> türünde bir değer döndürecektir.</p>
<p>Liste 10-5, imzasında yaygın veri tipini kullanan birleşik <code>largest</code> fonksiyon tanımını gösterir. 
Liste ayrıca, fonksiyonu <code>i32</code> değerlerinden oluşan bir dilim ya da <code>char</code> değerleriyle nasıl çağırabileceğimizi de gösterir. 
Bu kodun henüz derlenmeyeceğini unutmayın, ancak bu bölümün ilerleyen kısımlarında bunu düzelteceğiz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Liste 10-5: Yaygın tür parametreleri kullanan <code>largest</code> fonksiyonu; 
bu henüz derlenmiyor</span></p>
<p>Kodu şimdi derlemeye çalışırsak, şu hatayı alırız:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Notta bir tanım olan <code>std::cmp::PartialOrd</code>'dan bahsedilmektedir. Tanımlar hakkında bir sonraki bölümde konuşacağız. 
Şimdilik, bu hatanın <code>largest</code>'in gövdesinin <code>T</code>'nin olabileceği tüm olası türler için çalışmayacağını belirttiğini bilin. 
Gövdede <code>T</code> türündeki değerleri karşılaştırmak istediğimiz için, yalnızca değerleri sıralanabilen türleri kullanabiliriz. 
Karşılaştırmaları etkinleştirmek için, standart kütüphanede türler üzerinde uygulayabileceğiniz <code>std::cmp::PartialOrd</code> tanımı vardır 
(bu tanım hakkında daha fazla bilgi için Ekleme C'ye bakın). Yaygın bir türün belirli bir tanıma sahip olduğunu nasıl belirteceğinizi 
<a href="ch10-02-traits.html#traits-as-parameters">“Parametre Olarak Tanımlar”</a><!-- ignore --> bölümünde öğreneceksiniz. 
Bu kodu düzeltmeden önce (<a href="ch10-02-traits.html#fixing-the-largest-function-with-trait-bounds">“Tanım Sınırları ile Fonksiyonu Düzeltme”</a><!-- ignore --> bölümünde), yaygın tür parametrelerini 
kullanmanın diğer yollarını inceleyelim.</p>
<h3 id="struct-tanımlarında"><a class="header" href="#struct-tanımlarında">Struct Tanımlarında</a></h3>
<p>Ayrıca, <code>&lt;&gt;</code> söz dizimini kullanarak bir veya daha fazla alanda yaygın tür parametresi kullanmak için 
<code>struct</code>'ları tanımlayabiliriz. Liste 10-6, herhangi bir türdeki <code>x</code> ve <code>y</code> koordinat değerlerini tutmak için bir 
<code>Point&lt;T&gt;</code> <code>struct</code>'ı tanımlar.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Liste 10-6: <code>T</code> türünde <code>x</code> ve <code>y</code> değerlerini tutan bir <code>Point&lt;T</code> 
yapısı</span></p>
<p>Yapı tanımlarında yaygın türlerin kullanımı için söz dizimi, fonksiyon tanımlarında kullanılan söz dizimine benzer. 
İlk olarak, <code>struct</code> adından hemen sonra köşeli parantezler içinde tür parametresinin adını bildiririz. 
Ardından, <code>struct</code> tanımında somut veri türlerini belirteceğimiz yerde yaygın türü kullanırız.</p>
<p><code>Point&lt;T&gt;</code>'yi tanımlamak için yalnızca bir yaygın tür kullandığımızdan, bu tanımın <code>Point&lt;T&gt;</code> yapısının bazı <code>T</code> türleri üzerinde 
yaygın olduğunu ve <code>x</code> ve <code>y</code> üyelerinin her ikisinin de, bu tür ne olursa olsun, aynı tür olduğunu söylediğine dikkat edin. 
Liste 10-7'de olduğu gibi, farklı türlerde değerlere sahip bir <code>Point&lt;T&gt;</code> tanımı oluşturursak, kodumuz derlenmeyecektir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre>
<p><span class="caption">Liste 10-7: Her ikisi de aynı genel veri türü <code>T</code>'ye sahip olduğundan, 
<code>x</code> ve <code>y</code> üyeleri aynı türde olmalıdır.</span></p>
<p>Bu örnekte, <code>x</code>'e <code>5</code> tam sayı değerini atadığımızda, derleyiciye <code>T</code> yaygın türünün bu <code>Point&lt;T&gt;</code> tanımı için bir tam sayı olacağını bildiririz. 
Daha sonra, <code>x</code> ile aynı türe sahip olacak şekilde tanımladığımız <code>y</code> için <code>4.0</code> değerini belirttiğimizde, aşağıdaki gibi tür 
uyuşmazlığı hatası alırız:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p><code>x</code> ve <code>y</code>'nin her ikisinin de yaygın olduğu ancak farklı türlere sahip olabileceği bir <code>Point</code> yapısını tanımlamak için birden fazla 
yaygın tür parametresi kullanabiliriz. Örneğin, Liste 10-8'de, <code>Point</code> tanımını <code>T</code> ve <code>U</code> türleri üzerinde yaygın olacak şekilde 
değiştiririz; burada <code>x</code> <code>T</code> tipinde ve <code>y</code> <code>U</code> tipindedir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Liste 10-8: İki tür üzerinde yaygın bir <code>Point&lt;T, U&gt;</code>, böylece <code>x</code> ve <code>y</code> farklı türlerin 
değerleri olabilir</span></p>
<p>Artık gösterilen tüm <code>Point</code> tanımlarına izin verilmektedir! Bir tanımda istediğiniz kadar yaygın tür parametresi kullanabilirsiniz, 
ancak birkaç taneden fazla kullanmak kodunuzun okunmasını zorlaştırır. Kodunuzda çok sayıda yaygın türe ihtiyaç duyuyorsanız, 
bu kodunuzun daha küçük parçalar halinde yeniden yapılandırılması gerektiğini gösterebilir.</p>
<h3 id="enum-tanımlarında"><a class="header" href="#enum-tanımlarında"><code>enum</code> Tanımlarında</a></h3>
<p>Yapılarda yaptığımız gibi, yaygın veri türlerini varyantlarında tutmak için <code>enum</code>'ları tanımlayabiliriz. 
Standart kütüphanenin sağladığı ve Bölüm 6'da kullandığımız <code>Option&lt;T&gt;</code> <code>enum</code>'una bir kez daha göz atalım:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>Bu tanım şimdi size daha anlamlı gelecektir. Gördüğünüz gibi <code>Option&lt;T&gt;</code> <code>enum</code>'u <code>T</code> türü üzerinde yaygındır ve iki çeşidi vardır: 
<code>T</code> türünde bir değer tutan <code>Some</code> ve herhangi bir değer tutmayan <code>None</code> varyantı. <code>Option&lt;T&gt;</code> <code>enum</code>'unu kullanarak, 
isteğe bağlı bir değerin soyut kavramını ifade edebiliriz ve <code>Option&lt;T&gt;</code> yaygın olduğu için, isteğe bağlı değerin türü ne olursa 
olsun bu soyutlamayı kullanabiliriz.</p>
<p><code>enum</code>'lar birden fazla yaygın tür de kullanabilir. Bölüm 9'da kullandığımız <code>Result</code> <code>enum</code> tanımı buna bir örnektir:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Result</code> <code>enum</code>'u, <code>T</code> ve <code>E</code> olmak üzere iki tür üzerinde yaygındır ve iki çeşidi vardır: <code>T</code> türünde bir değer tutan <code>Ok</code> ve 
<code>E</code> türünde bir değer tutan <code>Err</code>. Bu tanım, başarılı (<code>T</code> türünde bir değer döndüren) veya başarısız (<code>E</code> türünde bir hata döndüren) 
olabilecek bir işlemimiz olan her yerde <code>Result</code> <code>enum</code>'unu kullanmayı kolaylaştırır. Aslında, Liste 9-3'te bir dosyayı açmak 
için kullandığımız şey buydu; dosya başarıyla açıldığında <code>T</code>, <code>std::fs::File</code> türüyle atandı ve dosyanın açılmasında sorun olduğunda 
<code>E</code>, <code>std::io::Error</code> türüyle atandı.</p>
<p>Kodunuzda, yalnızca tuttukları değerlerin türlerinde farklılık gösteren birden fazla <code>struct</code> veya <code>enum</code> tanımının bulunduğu 
durumları fark ettiğinizde, bunun yerine yaygın türleri kullanarak yinelemeyi önleyebilirsiniz.</p>
<h3 id="metod-tanımlarında"><a class="header" href="#metod-tanımlarında">Metod Tanımlarında</a></h3>
<p>Yapılar ve <code>enum</code>'lar üzerinde metodlar uygulayabilir (Bölüm 5'te yaptığımız gibi) ve tanımlarında yaygın türleri kullanabiliriz. 
Liste 10-9, Liste 10-6'da tanımladığımız <code>Point&lt;T&gt;</code> yapısını ve üzerinde uygulanan <code>x</code> adlı bir metodu göstermektedir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p><span class="caption">Liste 10-9: <code>T</code> türündeki <code>x</code> üyesine bir başvuru döndürecek olan <code>Point&lt;T&gt;</code> yapısında 
<code>x</code> adlı metodun süreklenmesi</span></p>
<p>Burada, <code>x</code> üyesindeki verilere bir referans döndüren <code>Point&lt;T&gt;</code> üzerinde <code>x</code> adında bir metod tanımladık.</p>
<p><code>T</code>'yi <code>impl</code>'den hemen sonra bildirmemiz gerektiğine dikkat edin, böylece <code>T</code>'yi <code>Point&lt;T&gt;</code> türünde metodlar tanımladığımızı belirtmek için
kullanabiliriz. <code>T</code>'yi <code>impl</code>'den sonra yaygın bir tür olarak bildirerek, Rust, <code>Point</code>'teki köşeli parantez içindeki türün somut bir tür 
yerine yaygın bir tür olduğunu belirleyebilir. Bu yaygın parametre için <code>struct</code> tanımında bildirilen yaygın parametreden farklı bir 
isim seçebilirdik, ancak aynı ismi kullanmak gelenekseldir. Yaygın türü bildiren bir <code>impl</code> içinde yazılan metodlar, 
yaygın türün yerine hangi somut tür geçerse geçsin, türün herhangi bir tanımı üzerinde tanımlanacaktır.</p>
<p>Tür üzerinde metod tanımlarken yaygın türler üzerinde kısıtlamalar da belirtebiliriz. 
Örneğin, herhangi bir yaygın türe sahip <code>Point&lt;T&gt;</code> tanımları yerine yalnızca <code>Point&lt;f32&gt;</code> tanımları üzerinde metodlar uygulayabiliriz. 
Liste 10-10'da somut <code>f32</code> türünü kullanıyoruz, yani <code>impl</code>'den sonra herhangi bir tür bildirmiyoruz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!(&quot;p.x = {}&quot;, p.x());
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 10-10: Yaygın tür parametresi <code>T</code> için yalnızca belirli bir somut türe sahip bir 
yapıya tanımlanan bir <code>impl</code> bloğu</span></p>
<p>Bu kod, <code>Point&lt;f32&gt;</code> türünün bir <code>distance_from_origin</code> metoduna sahip olacağı anlamına gelir; 
<code>T</code>'nin <code>f32</code> türünde olmadığı diğer <code>Point&lt;T&gt;</code> örneklerinde bu metod tanımlı olmayacaktır. Metod, noktamızın <code>(0.0, 0.0)</code> 
koordinatlarındaki noktadan ne kadar uzakta olduğunu ölçer ve yalnızca kayan nokta türleri için kullanılabilen matematiksel işlemleri kullanır.</p>
<p>Bir <code>struct</code> tanımındaki yaygın tür parametreleri her zaman aynı <code>struct</code>'ın metod imzalarında kullandıklarınızla aynı değildir. 
Liste 10-11, örneği daha açık hale getirmek için <code>Point</code> <code>struct</code>'ı için <code>X1</code> ve <code>Y1</code> yaygın türlerini ve <code>mixup</code> metod imzası için <code>X2</code> <code>Y2</code>'yi
kullanır. Metod, kendi <code>Point</code>'inden (<code>X1</code> türünde) alınan <code>x</code> değeri ve aktarılan <code>Point</code>'ten (<code>Y2</code> türünde) alınan <code>y</code> değeriyle yeni bir 
<code>Point</code> tanımı oluşturur.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c' };

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p><span class="caption">Liste 10-11: Yapısının tanımından farklı yaygın türleri 
kullanan bir metod</span></p>
<p><code>main</code>'de, <code>x</code> için bir <code>i32</code> (değeri <code>5</code>) ve <code>y</code> için bir <code>f64</code> (değeri <code>10,4</code>) olan bir <code>Point</code> tanımladık. <code>p2</code> değişkeni, 
<code>x</code> için bir dizgi dilimine (<code>&quot;Hello&quot;</code> değeriyle) ve <code>y</code> için bir <code>char</code> değerine (<code>c</code> değeriyle) sahip bir <code>Point</code> <code>struct</code>'tır. 
<code>p1</code> üzerinde <code>p2</code> argümanıyla <code>mixup</code> çağrıldığında, <code>x</code> <code>p1</code>'den geldiği için <code>x</code> için bir <code>i32</code>'ye sahip olan <code>p3</code> elde edilir. 
<code>p3</code> değişkeninde <code>y</code> için bir <code>char</code> olacaktır, çünkü <code>y</code> <code>p2</code>'den gelmiştir. <code>println!</code> makro çağrısı <code>p3.x = 5, p3.y = c</code> yazdıracaktır.</p>
<p>Bu örneğin amacı, bazı yaygın parametrelerin <code>impl</code> ile bildirildiği ve bazılarının metod tanımıyla bildirildiği bir durumu göstermektir. 
Burada, <code>X1</code> ve <code>Y1</code> yaygın parametreleri <code>impl</code>'den sonra bildirilir, çünkü bunlar <code>struct</code> tanımıyla birlikte tanımlanmıştır. 
<code>X2</code> ve <code>Y2</code> yaygın parametreleri <code>fn mixup</code>'tan sonra bildirilir, çünkü bunlar yalnızca metodla ilgilidir.</p>
<h3 id="yaygınları-kullanan-kodun-performansı"><a class="header" href="#yaygınları-kullanan-kodun-performansı">Yaygınları Kullanan Kodun Performansı</a></h3>
<p>Yaygın tür parametrelerini kullanırken bir çalışma zamanı maliyeti olup olmadığını merak ediyor olabilirsiniz. 
İyi haber şu ki, yaygın türleri kullanmak çalışmanızı somut tiplere göre daha yavaş hale getirmeyecektir.</p>
<p>Rust bunu, derleme zamanında yaygınları kullanarak kodun <em>monomorfizasyonunu</em> gerçekleştirerek başarır. 
<em>Monomorfizasyon</em>, derlendiğinde kullanılan somut tiplerin içini doldurarak genel kodu belirli bir koda dönüştürme işlemidir. 
Bu süreçte derleyici, Liste 10-5'teki yaygın fonksiyonu oluşturmak için kullandığımız adımların tersini yapar: 
derleyici, genel kodun çağrıldığı tüm yerlere bakar ve genel kodun çağrıldığı somut türler için kod oluşturur.</p>
<p>Standart kütüphanenin yaygın <code>Option&lt;T&gt;</code> <code>enum</code>'unu kullanarak bunun nasıl çalıştığına bakalım:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}
</span></code></pre></pre>
<p>Rust bu kodu derlediğinde, <em>monomorflaştırma</em> gerçekleştirir. Bu işlem sırasında, derleyici <code>Option&lt;T&gt;</code> tanımlarında kullanılan değerleri 
okur ve iki tür <code>Option&lt;T&gt;</code> tanımlar: biri <code>i32</code> ve diğeri <code>f64</code>. Bu nedenle, <code>Option&lt;T&gt;</code>'nin yaygın tanımını <code>Option_i32</code> ve 
<code>Option_f64</code> olarak genişletir, böylece genel tanımı özel olanlarla değiştirir.</p>
<p>Kodun monomorfize edilmiş versiyonu aşağıdaki gibi görünür:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>Yaygın <code>Option&lt;T&gt;</code>, derleyici tarafından oluşturulan özel tanımlarla değiştirilir. 
Rust, yaygın kodu her örnekte türü belirten koda derlediğinden, yaygınları kullanmak için çalışma zamanı maliyeti ödemeyiz. 
Kod çalıştığında, her bir tanımı elle çoğaltmış olsaydık nasıl çalışacaksa öyle çalışır. Monomorfizasyon süreci, 
Rust'ın yaygınlarını çalışma zamanında son derece verimli hale getirir.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tanımlar-paylaşılan-davranışı-tanımlama"><a class="header" href="#tanımlar-paylaşılan-davranışı-tanımlama">Tanımlar: Paylaşılan Davranışı Tanımlama</a></h2>
<p>Bir <em>tanım</em>, belirli bir türün sahip olduğu ve diğer türlerle paylaşabileceği işlevselliği tanımlar. 
Paylaşılan davranışı soyut bir şekilde tanımlamak için tanımları kullanabiliriz. Genel bir türün belirli davranışlara sahip herhangi 
bir tür olabileceğini belirtmek için tanım sınırlarını kullanabiliriz.</p>
<blockquote>
<p>Not: Tanımlar, bazı farklılıklara rağmen diğer dillerde genellikle <em>arayüz</em> olarak adlandırılan 
bir özelliğe benzer.</p>
</blockquote>
<h3 id="tanım-tanımlama"><a class="header" href="#tanım-tanımlama"><em>Tanım</em> Tanımlama</a></h3>
<p>Bir türün davranışı, o tür üzerinde çağırabileceğimiz metodlardan oluşur. 
Tüm türler üzerinde aynı metodları çağırabiliyorsak, farklı tipler aynı davranışı paylaşır. 
Tanım tanımları, bir amacı gerçekleştirmek için gerekli olan bir dizi davranışı tanımlamak üzere metod imzalarını 
bir araya getirmenin bir yoludur.</p>
<p>Örneğin, çeşitli tür ve miktarlarda metin tutan birden fazla yapımız olduğunu varsayalım: 
belirli bir konumda dosyalanmış bir haberi tutan bir NewsArticle yapısı ve yeni bir tweet mi, retweet mi yoksa başka bir tweet'e yanıt mı olduğunu gösteren meta verilerle birlikte en fazla 280 karaktere sahip olabilen bir Tweet.</p>
<p>Bir <code>NewsArticle</code> veya <code>Tweet</code> örneğinde saklanabilecek verilerin özetlerini görüntüleyebilen <code>aggregator</code> adlı bir 
medya toplayıcı kütüphane kasası yapmak istiyoruz. Bunu yapmak için, her türden bir özete ihtiyacımız var ve bir 
örnek üzerinde bir summarize yöntemi çağırarak bu özeti talep edeceğiz. Liste 10-12, bu davranışı ifade eden bir genel
<code>Summary</code> tanımının tanımlanmasını göstermektedir.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
</code></pre>
<p><span class="caption">Liste 10-12: <code>summarize</code> metoduyla sağlanan davranıştan oluşan bir <code>Summary</code> tanımı</span></p>
<p>Burada, <code>trait</code> anahtar sözcüğünü ve ardından bu durumda <code>Summary</code> olan <code>trait</code>'in adını kullanarak bir <code>trait</code> bildiriyoruz. 
Ayrıca, birkaç örnekte göreceğimiz gibi, bu kasaya bağlı kasaların da bu tanımı kullanabilmesi için tanımı <code>pub</code> olarak bildirdik. 
Süslü parantezlerin içinde, bu tanımı uygulayan türlerin davranışlarını tanımlayan metod imzalarını bildiriyoruz; 
bu durumda <code>fn summarize(&amp;self) -&gt; String</code> olacaktır.</p>
<p>Metod imzasından sonra, süslü parantezler içinde bir sürekleme sağlamak yerine noktalı virgül kullanırız. 
Bu tanımı uygulayan her tür, metodun gövdesi için kendi özel davranışını sağlamalıdır. Derleyici, <code>Summary</code> tanımına sahip 
herhangi bir türün <code>summarize</code> metodunun tam olarak bu imza ile tanımlanmasını zorunlu kılacaktır.</p>
<p>Bir tanımın gövdesinde birden fazla metod olabilir: metod imzaları her satırda bir tane listelenir ve her satır noktalı virgülle biter.</p>
<h3 id="tür-Üzerinde-tanım-uygulama"><a class="header" href="#tür-Üzerinde-tanım-uygulama">Tür Üzerinde Tanım Uygulama</a></h3>
<p><code>Summary</code> tanımının metodlarının istenen imzalarını tanımladığımıza göre, bunu medya toplayıcımızdaki türlere uygulayabiliriz. 
Liste 10-13, <code>Summary</code> tanımının <code>NewsArticle</code> yapısı üzerinde, <code>summarize</code>'ın dönüş değerini oluşturmak için başlığı, 
yazarı ve konumu kullanan bir süreklemesini göstermektedir. Tweet yapısı için, tweet içeriğinin zaten 280 karakterle sınırlı olduğunu 
varsayarak, <code>summarize</code> özelliğini kullanıcı adı ve ardından tweet metninin tamamı olarak tanımlarız.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
</code></pre>
<p><span class="caption">Liste 10-13: <code>NewsArticle</code> ve <code>Tweet</code> türlerine <code>Summary</code> tanımının süreklenmesi</span></p>
<p>Bir tür üzerinde bir tanım süreklemek, normal metodları süreklemeye benzer. Aradaki fark, <code>impl</code>'den sonra süreklemek istediğimiz 
özellik adını koymamız, ardından <code>for</code> anahtar sözcüğünü kullanmamız ve ardından tanımı uygulamak istediğimiz türün adını belirtmemizdir. 
<code>impl</code> bloğunun içine, <em>tanım</em> tanımının <strong>tanımladığı</strong> metod imzalarını koyarız. Her imzadan sonra noktalı virgül eklemek yerine, 
süslü parantezler kullanırız ve metod gövdesini, tanımın metodlarının belirli bir tür için sahip olmasını istediğimiz belirli 
davranışla doldururuz.</p>
<p>Artık kütüphane <code>NewsArticle</code> ve <code>Tweet</code> üzerinde <code>Summary</code> tanımını süreklediğine göre, kasa kullanıcıları <code>NewsArticle</code> ve 
<code>Tweet</code> örnekleri üzerindeki tanım metodlarını normal metodları çağırdığımız şekilde çağırabilir. Tek fark, kullanıcının türlerin 
yanı sıra tanımı da kapsam içine alması gerektiğidir. İşte ikili bir kasanın <code>aggregator</code> kütüphane kasamızı nasıl kullanabileceğine dair 
bir örnek:</p>
<pre><code class="language-rust ignore">use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
}
</code></pre>
<p>Bu kod <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code> yazdırır.</p>
<p><code>aggregator</code> kasamıza bağımlı olan diğer kasalar da <code>Summary</code> tanımını kendi türlerinde süreklemek için kapsam içine alabilir. 
Unutulmaması gereken bir kısıtlama, bir özelliği bir tür üzerinde yalnızca tanım veya türden en az birinin kasamız için yerel olması 
durumunda uygulayabileceğimizdir. Örneğin, <code>Tweet</code> türü <code>aggregator</code> kasamız için yerel olduğundan, <code>Display</code> gibi standart kütüphane 
özelliklerini <code>Tweet</code> gibi gizli bir tür üzerinde kasa işlevselliğimizin bir parçası olarak sürekleyebiliriz. 
Ayrıca <code>Summary</code> tanımını <code>Vec&lt;T&gt;</code> üzerinde de sürekleyebiliriz, çünkü <code>Summary</code> tanımı kasamız için yereldir.</p>
<p>Ancak harici tanımları harici türler üzerinde uygulayamayız. Örneğin, <code>Display</code> tanımını <code>Vec&lt;T&gt;</code> üzerinde; kasamızda sürekleyemeyiz, 
çünkü <code>Display</code> ve <code>Vec&lt;T&gt;</code> standart kütüphanede tanımlanmıştır ve kasamız için yerel değildir. Bu kısıtlama, <em>tutarlılık</em> adı verilen bir 
özelliğin ve daha spesifik olarak, ana tür mevcut olmadığı için bu şekilde adlandırılan <em>yetim kuralının</em> bir parçasıdır. 
Bu kural, başkalarının kodunun sizin kodunuzu bozamamasını ve bunun tersinin de geçerli olmamasını sağlar. 
Bu kural olmasaydı, iki kasa aynı tür için aynı tanımı sürekleyebilirdi ve Rust hangi süreklemeyi kullanacağını bilemezdi.</p>
<h3 id="varsayılan-süreklemeler"><a class="header" href="#varsayılan-süreklemeler">Varsayılan Süreklemeler</a></h3>
<p>Bazen, her türdeki tüm metodlar için sürekleme gerektirmek yerine, bir tanımdaki metodlardan bazıları veya 
tümü için varsayılan davranışa sahip olmak yararlıdır. Daha sonra, tanımı belirli bir tür üzerinde süreklerken, 
her bir metodun varsayılan davranışını koruyabilir veya geçersiz kılabiliriz.</p>
<p>Liste 10-14'te, Liste 10-12'de yaptığımız gibi yalnızca metod imzasını tanımlamak yerine <code>Summary</code> tanımının <code>summarize</code> metodu için 
varsayılan bir dizgi belirtiyoruz.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 10-14: <code>Summarize</code> metodunun varsayılan süreklemesiyle bir <code>Summary</code> tanımının yazılması</span></p>
<p><code>NewsArticle</code> örneklerini özetlemek üzere varsayılan bir sürekleme kullanmak istediğimiz için, 
<code>impl Summary for NewsArticle {}</code> ile boş bir <code>impl</code> bloğu belirtiriz.</p>
<p>Artık <code>NewsArticle</code> üzerinde <code>summarize</code> metodunu doğrudan tanımlamıyor olsak da, 
varsayılan bir sürekleme sağladık ve <code>NewsArticle</code>'ın <code>Summary</code> tanımını süreklediğini belirttik. 
Sonuç olarak, bir <code>NewsArticle</code> örneği üzerinde <code>summarize</code> metodunu aşağıdaki gibi çağırabiliriz:</p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
        location: String::from(&quot;Pittsburgh, PA, USA&quot;),
        author: String::from(&quot;Iceburgh&quot;),
        content: String::from(
            &quot;The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.&quot;,
        ),
    };

    println!(&quot;New article available! {}&quot;, article.summarize());
<span class="boring">}
</span></code></pre>
<p>Bu kod <code>New article available! (Read more...)</code> çıktısını verir.</p>
<p>Varsayılan bir sürekleme oluşturmak, Liste 10-13'teki <code>Tweet</code>'deki <code>Summary</code> süreklemesinde herhangi bir değişiklik yapmamızı 
gerektirmez. Bunun nedeni, varsayılan bir süreklemeyi geçersiz kılma söz diziminin, varsayılan bir süreklemeye sahip olmayan 
bir tanım metodunu sürekleme söz dizimiyle aynı olmasıdır.</p>
<p>Varsayılan süreklemeler, diğer metodların varsayılan bir süreklemesi olmasa bile aynı tanımdaki diğer metodları çağırabilir. 
Bu şekilde, bir özellik çok sayıda yararlı işlevsellik sağlayabilir ve uygulayıcıların bunun yalnızca küçük bir bölümünü 
belirtmesini gerektirebilir. Örneğin, <code>Summary</code> tanımını, süreklenmesi gerekli olan bir <code>summarize_author</code> metoduna sahip olacak 
şekilde tanımlayabilir ve ardından <code>summarize_author</code> metodunu çağıran varsayılan bir süreklemeye sahip bir <code>summarize</code> metodu tanımlayabiliriz:</p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;@{}&quot;, self.username)
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><code>Summary</code>'in bu sürümünü kullanmak için, özelliği bir türe süreklediğimizde yalnızca <code>summary_author</code>'u tanımlamamız gerekir:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
</code></pre>
<p><code>summarize_author</code>'ı tanımladıktan sonra, <code>Tweet</code> yapısının örnekleri üzerinde <code>summarize</code>'ı çağırabiliriz ve 
<code>summarize</code>'ın varsayılan süreklemesi, sağladığımız <code>summarize_author</code> tanımını çağıracaktır. 
<code>summarize_author</code> tanımını süreklediğimiz için, <code>Summary</code> tanımı bize daha fazla kod yazmamızı gerektirmeden 
<code>summarize</code> metodunun davranışını vermiştir.</p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre>
<p>Bu kod <code>1 new tweet: (Read more from @horse_ebooks...)</code> çıktısını verecektir.</p>
<p>Aynı metodun geçersiz kılınan bir süreklemesinden varsayılan süreklemeyi çağırmanın mümkün olmadığını unutmayın.</p>
<h3 id="parametre-olarak-tanımlar"><a class="header" href="#parametre-olarak-tanımlar">Parametre olarak Tanımlar</a></h3>
<p>Artık tanımları nasıl tanımlayacağınızı ve sürekleyeceğinizi bildiğinize göre, 
birçok farklı türü kabul eden fonksiyonları tanımlamak için tanımları nasıl kullanacağımızı keşfedebiliriz. 
Liste 10-13'te <code>NewsArticle</code> ve <code>Tweet</code> türleri üzerinde süreklediğimiz <code>Summary</code> tanımını, <code>Summary</code> tanımını sürekleyen bir 
türden olan <code>item</code> parametresi üzerinde <code>summarize</code> metodunu çağıran <code>notify</code> fonksiyonunu tanımlamak için kullanacağız. 
Bunu yapmak için, aşağıdaki gibi <code>impl Trait</code> söz dizimini kullanırız:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<p>Öğe parametresi için somut bir tür yerine, 
<code>impl</code> anahtar sözcüğünü ve tanım adını belirtiriz. Bu parametre, belirtilen tanımı uygulayan herhangi bir 
türü kabul eder. <code>notify</code>'ın gövdesinde, <code>item</code> üzerinde <code>Summary</code> tanımından gelen <code>summarize</code> gibi herhangi bir metodu çağırabiliriz. 
<code>notify</code>'ı çağırabilir ve <code>NewsArticle</code> veya <code>Tweet</code>'in herhangi bir örneğini aktarabiliriz. Fonksiyonu <code>String</code> veya 
<code>i32</code> gibi başka bir türle çağıran kod derlenmez çünkü bu türler <code>Summary</code> tanımını uygulamaz.</p>
<h4 id="tanıma-bağlılık-söz-dizimi"><a class="header" href="#tanıma-bağlılık-söz-dizimi">Tanıma Bağlılık Söz Dizimi</a></h4>
<p><code>impl Trait</code> söz dizimi basit durumlar için çalışır, ancak aslında <em>tanıma bağlılık</em> olarak bilinen daha uzun bir form için 
<em>söz dizimi tatlılığıdır</em>; şöyle görünür:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<p>Bu uzun form önceki bölümdeki örneğe eş değerdir ancak daha ayrıntılıdır. Tanıma bağlılık, iki nokta üst üste 
işaretinden sonra ve köşeli parantezler içinde yaygın tür parametresinin bildirimiyle birlikte yerleştiririz.</p>
<p><code>impl Trait</code> söz dizimi kullanışlıdır ve basit durumlarda daha özlü bir kod sağlarken, tanıma bağlılık söz dizimi 
karmaşık durumlarda daha farklı bir şekilde kendini ifade edebilir. Örneğin, <code>Summary</code> öğesini uygulayan iki parametreye sahip olabiliriz. 
Bunu <code>impl Trait</code> sö zdizimi ile yapmak şu şekilde görünür:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {
</code></pre>
<p>Bu fonksiyonun <code>item1</code> ve <code>item2</code>'nin farklı türlere sahip olmasına izin vermesini istiyorsak 
(her iki tür de <code>Summary</code>'yi süreklediği sürece) <code>impl Trait</code> kullanmak uygundur. 
Ancak her iki parametrenin de aynı türde olmasını istiyorsak, aşağıdaki gibi, tanıma bağlılığı kullanmalıyız:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {
</code></pre>
<p><code>item1</code> ve <code>item2</code> parametrelerinin türü olarak belirtilen <code>T</code> yaygın türü; fonksiyonu, <code>item1</code> ve <code>item2</code> için argüman olarak 
aktarılan değerin somut türünün aynı olması gerektiği şekilde kısıtlar.</p>
<h4 id="-söz-dizimi-ile-birden-fazla-tanıma-bağlılığın-belirtilmesi"><a class="header" href="#-söz-dizimi-ile-birden-fazla-tanıma-bağlılığın-belirtilmesi"><code>+</code> Söz Dizimi ile Birden Fazla Tanıma Bağlılığın Belirtilmesi</a></h4>
<p>Birden fazla tanıma bağlılığı da belirleyebiliriz. Diyelim ki <code>notify</code>'ın öğe üzerinde özetlemenin yanı sıra görüntüleme 
biçimlendirmesini de kullanmasını istedik: <code>notify</code> tanımında öğenin hem <code>Display</code> hem de <code>Summary</code>'i süreklemesi gerektiğini belirtiriz. 
Bunu <code>+</code> söz dizimini kullanarak da yapabiliriz:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {
</code></pre>
<p><code>+</code> söz dizimi, yaygın türlerdeki tanıma bağlılıkta da geçerlidir:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {
</code></pre>
<p>Belirtilen iki tanıma bağlılık ile, <code>notify</code> öğesinin gövdesi <code>summarize</code>'ı çağırabilir ve <code>item</code>'ı 
biçimlendirmek için <code>{}</code> kullanabilir.</p>
<h4 id="where-ile-daha-net-tanıma-bağlılık"><a class="header" href="#where-ile-daha-net-tanıma-bağlılık"><code>where</code> ile Daha Net Tanıma Bağlılık</a></h4>
<p>Çok fazla tanıma bağlılık kullanmanın dezavantajları vardır. Her yaygın kendine özgü tanıma bağlılığa sahiptir, 
bu nedenle birden fazla yaygın tür parametresi olan fonksiyonlar, fonksiyonun adı ve parametre listesi arasında 
çok sayıda tanıma bağlılık bilgisi içerebilir ve bu da fonksiyon imzasının okunmasını zorlaştırır. 
Bu nedenle Rust, fonksiyon imzasından sonra <code>where</code> içinde tanıma bağlılığı belirtmek için alternatif bir söz dizime sahiptir. </p>
<p>Yani bunu yazmak yerine:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre>
<p><code>where</code> kullanabiliriz:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>Bu fonksiyonun imzası daha az karmaşıktır: fonksiyon adı, parametre listesi ve dönüş türü birbirine yakındır, 
çok sayıda tamıma bağlılığı olmayan bir fonksiyona benzer.</p>
<h3 id="tanımları-sürekleyen-dönüş-türleri"><a class="header" href="#tanımları-sürekleyen-dönüş-türleri">Tanımları Sürekleyen Dönüş Türleri</a></h3>
<p>Burada gösterildiği gibi, bir tanımı sürekleyen bir türden bir değer döndürmek için <code>return</code> konumunda
<code>impl Trait</code> söz dizimini de kullanabiliriz:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    }
}
</code></pre>
<p>Dönüş türü için <code>impl Summary</code> kullanarak, <code>returns_summarizable</code> fonksiyonunun somut türü belirtmeden <code>Summary</code> 
tanımını sürekleyen bir türü döndürdüğünü belirtiyoruz. Bu durumda, <code>returns_summarizable</code> <code>Tweet</code> döndürür, 
ancak bu fonksiyonu çağıran kodun bunu bilmesine gerek yoktur.</p>
<p>Bir geri dönüş türünü yalnızca uyguladığı özelliğe göre belirtme yeteneği, özellikle Bölüm 13'te ele aldığımız kapanış ifadeleri ve 
yineleyiciler bağlamında kullanışlıdır. Kapanış ifadeleri ve yineleyiciler yalnızca derleyicinin bildiği türler veya 
belirtilmesi çok uzun olan türler oluşturur. <code>impl Trait</code> söz dizimi, çok uzun bir tür yazmanıza gerek kalmadan bir fonksiyonun 
<code>Iterator</code> tanımını sürekleyen bir tür döndürdüğünü kısaca belirtmenizi sağlar.</p>
<p>Ancak, <code>impl Trait</code>'i yalnızca tek bir tür döndürüyorsanız kullanabilirsiniz. Örneğin, dönüş türü <code>impl Summary</code> olarak belirtilen 
bir <code>NewsArticle</code> veya <code>Tweet</code> döndüren bu kod çalışmaz:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &quot;Penguins win the Stanley Cup Championship!&quot;,
            ),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(
                &quot;The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.&quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(
                &quot;of course, as you probably already know, people&quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}
</code></pre>
<p>Derleyicide <code>impl Trait</code> söz diziminin nasıl süreklendiğine ilişkin kısıtlamalar nedeniyle <code>NewsArticle</code> veya <code>Tweet</code> döndürülmesine 
izin verilmez. Bu davranışa sahip bir fonksiyonun nasıl yazılacağını Bölüm 17'deki 
<a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Farklı Türlerde Değerlere İzin Veren Tanım Nesnelerini Kullanma”</a><!-- ignore --> 
kısmında ele alacağız.</p>
<h3 id="tanıma-bağlılık-ile-largest-fonksiyonunu-düzeltme"><a class="header" href="#tanıma-bağlılık-ile-largest-fonksiyonunu-düzeltme">Tanıma Bağlılık ile <code>largest</code> Fonksiyonunu Düzeltme</a></h3>
<p>Artık yaygın tür parametresinin bağlılıklarını kullanarak istediğiniz davranışı nasıl belirleyeceğinizi bildiğinize göre, 
yaygın tür parametresi kullanan <code>largest</code> fonksiyonunun tanımını düzeltmek için Liste 10-5'e dönelim! Bu kodu en son çalıştırmayı 
denediğimizde bu hatayı almıştık:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p><code>largest</code>'in gövdesinde, daha büyük (<code>&gt;</code>) operatörünü kullanarak <code>T</code> türündeki iki değeri karşılaştırmak istedik. 
Bu operatör standart kütüphane özelliği <code>std::cmp::PartialOrd</code> üzerinde varsayılan bir metod olarak tanımlandığından, 
<code>T</code>'ye tanıma bağlılıktan dolayı <code>PartialOrd</code>'u süreklememiz gerekir, böylece <code>largest</code> fonksiyonu karşılaştırabileceğimiz 
herhangi bir türden dilimler üzerinde çalışabilir. <code>PartialOrd</code>'u kapsam içine almamıza gerek yok çünkü o zaten kapsama otomatik
olarak dahildir... Yani, <code>largest</code>'in imzasını aşağıdaki gibi değiştirin:</p>
<pre><code class="language-rust ignore">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
<span class="boring">    let mut largest = list[0];
</span><span class="boring">
</span><span class="boring">    for &amp;item in list {
</span><span class="boring">        if item &gt; largest {
</span><span class="boring">            largest = item;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    largest
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let number_list = vec![34, 50, 25, 100, 65];
</span><span class="boring">
</span><span class="boring">    let result = largest(&amp;number_list);
</span><span class="boring">    println!(&quot;The largest number is {}&quot;, result);
</span><span class="boring">
</span><span class="boring">    let char_list = vec!['y', 'm', 'a', 'q'];
</span><span class="boring">
</span><span class="boring">    let result = largest(&amp;char_list);
</span><span class="boring">    println!(&quot;The largest char is {}&quot;, result);
</span><span class="boring">}
</span></code></pre>
<p>Bu sefer kodu derlediğimizde farklı hatalar alıyoruz:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&amp;list[0]`

error[E0507]: cannot move out of a shared reference
 --&gt; src/main.rs:4:18
  |
4 |     for &amp;item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&amp;`: `item`

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10` due to 2 previous errors
</code></pre>
<p>Buranın en önemli noktası, <code>kopyalanmamış bir dilim olan [T] türünün dışına çıkamaz</code> (<code>cannot move out of type [T], a non-copy slice</code>) hatasıdır. 
<code>largest</code> fonksiyonunun yaygın olmayan versiyonlarında, yalnızca en büyük <code>i32</code> veya <code>char</code>'ı bulmaya çalışıyorduk. 
Bkz. <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">“Sadece Yığıt Kullanan Veriler: Kopyalama”</a><!-- ignore --> konusuna bakın, <code>i32</code> ve <code>char</code> gibi bilinen bir 
boyuta sahip türler yığıtta saklanabilir, böylece <code>Copy</code> tanımı süreklenebilir. Ancak, <code>largest</code> fonksiyonunu genelleştirdiğimizde, 
<code>list</code> parametresinin içinde <code>Copy</code> tanımını süreklemeyen türler olması mümkün hale geldi. Sonuç olarak, 
değeri <code>list[0]</code>'ten <code>largest</code> değişkenine taşıyamayız, bu da bu hataya neden olur.</p>
<p>Bu kodu yalnızca <code>Copy</code> tanımını sürekleyen türlerle birlikte çağırmak için, <code>T</code>'nin tanıma bağlılık listesine <code>Copy</code>'i ekleyebiliriz! 
Liste 10-15, fonksiyona aktardığımız dilimdeki değerlerin türleri <code>i32</code> ve <code>char</code> gibi <code>PartialOrd</code> <em>ve</em> <code>Copy</code> tanımlarını süreklediği sürece 
derlenecek yaygın <code>largest</code> fonksiyonunun tam kodunu gösterir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Liste 10-15: <code>PartialOrd</code> ve <code>Copy</code> tanımlarını sürekleyen herhangi bir yaygın tür 
üzerinde çalışan <code>largest</code> fonksiyonunun düzgün çalışan versiyonu</span></p>
<p><code>largest</code> fonksiyonunu <code>Copy</code> tanımını sürekleyen türlerle sınırlamak istemiyorsak, 
<code>T</code>'nin <code>Copy</code> yerine <code>Clone</code> tanımına sahip olduğunu belirtebiliriz. Böylece, <code>largest</code> fonksiyonunun sahibi olmasını istediğimizde 
dilimdeki her değeri klonlayabiliriz. <code>Clone</code> fonksiyonunu kullanmak, <code>String</code> gibi yığın verisine sahip türler söz konusu olduğunda 
potansiyel olarak daha fazla yığın tahsisi yapacağımız anlamına gelir ve büyük miktarda veriyle çalışıyorsak yığın tahsisleri yavaş olabilir.</p>
<p>Ayrıca, fonksiyonun dilimdeki bir <code>T</code> değerine bir referans döndürmesini sağlayarak <code>largest</code>'ı sürekleyebiliriz. 
Dönüş türünü <code>T</code> yerine <code>&amp;T</code> olarak değiştirirsek, böylece fonksiyonun gövdesini bir referans döndürecek şekilde değiştirirsek, 
<code>Clone</code> veya <code>Copy</code> tanıma bağlılıklarına ihtiyacımız olmaz ve yığın tahsisatlarından kaçınabiliriz. 
Bu alternatif çözümleri kendi başınıza yazmayı deneyin! Yaşam süreleri ile ilgili hatalara takılırsanız, 
okumaya devam edin: “Yaşam Süreleri ile Referansları Doğrulama” bölümü durumu açıklayacaktır, 
ancak bu meydan okumaları çözmek için yaşam süreleri gerekli değildir.</p>
<h3 id="metodları-koşullu-olarak-süreklemek-için-tanıma-bağlılığı-kullanma"><a class="header" href="#metodları-koşullu-olarak-süreklemek-için-tanıma-bağlılığı-kullanma">Metodları Koşullu Olarak Süreklemek için Tanıma Bağlılığı Kullanma</a></h3>
<p>Yaygın tür parametreleri kullanan bir <code>impl bloğu</code> ile bağlı bir tanım kullanarak, 
belirtilen tanımları sürekleyen türler için metodları koşullu olarak sürekleyebiliriz. Örneğin, Liste 10-16'daki <code>Pair&lt;T&gt;</code> türü her 
zaman yeni bir <code>Pair&lt;T&gt;</code> örneği döndürmek için <code>new</code> fonksiyonunu çağırır (Bölüm 5'teki <a href="ch05-03-method-syntax.html#defining-methods">“Metodları Tanımlama”</a><!-- ignore --> 
bölümünden <code>Self</code>'in <code>impl</code> bloğunun türü için bir tür takma ad olduğunu hatırlayın, bu durumda <code>Pair&lt;T&gt;</code>'dir). 
Ancak bir sonraki <code>impl</code> bloğunda, <code>Pair&lt;T&gt;</code> yalnızca iç tipi <code>T</code>, karşılaştırmayı sağlayan <code>PartialOrd</code> tanımını ve 
yazdırmayı sağlayan <code>Display</code> tanımını süreklerse <code>cmp_display</code> metodunu sürekleyebilir.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
</code></pre>
<p><span class="caption">Liste 10-16: <em>Tanıma bağlılığa</em> bağlı olarak metodları yaygın bir tür üzerinde koşullu ,
olarak süreklemek</span></p>
<p>Ayrıca, başka bir tanımı sürekleyen herhangi bir tür için bir tanımı koşullu olarak sürekleyebiliriz. 
Bir tanımın, tanıma bağlılığı karşılayan herhangi bir tür üzerindeki süreklemelerine 
<em>kapsamlı sürekleme</em> denir ve Rust standart kütüphanesinde yaygın olarak kullanılır. 
Örneğin, standart kütüphane <code>Display</code> tanımını sürekleyen herhangi bir tür üzerinde <code>ToString</code> tanımını sürekler. 
Standart kütüphanedeki <code>impl</code> bloğu bu koda benzer:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>Standart kütüphane bu <em>kapsamlı süreklemeye</em> sahip olduğundan, <code>Display</code> tanımını sürekleyen herhangi bir tür üzerinde 
<code>ToString</code> tanımı tarafından tanımlanan <code>to_string</code> metodunu çağırabiliriz. Örneğin, tam sayılar <code>Display</code> tanımını 
süreklediği için tam sayıları karşılık gelen <code>String</code> değerlerine dönüştürebiliriz:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<p><em>Kapsamlı süreklemeler</em>, tanımın dokümantasyonunun “Implementors” bölümünde görünür.</p>
<p>Tanımlar ve tanıma bağlılık, yinelemeyi azaltmak için yaygın tür parametrelerini kullanan kod yazmamıza ve 
aynı zamanda derleyiciye yaygın türün belirli bir davranışa sahip olmasını istediğimizi belirtmemize olanak tanır. 
Derleyici daha sonra kodumuzla birlikte kullanılan tüm somut tiplerin doğru davranışı sağlayıp sağlamadığını kontrol etmek için 
tanıma bağlılık bilgisini kullanabilir. Dinamik olarak yazılan dillerde, metodu tanımlamayan bir tür üzerinde bir metod çağırırsak 
çalışma zamanında bir hata alırız. Ancak Rust bu hataları derleme zamanına taşır, böylece kodumuz daha çalışmadan önce sorunları 
düzeltmek zorunda kalırız. Ayrıca, derleme zamanında zaten kontrol ettiğimiz için çalışma zamanında davranışı kontrol eden kod yazmak 
zorunda kalmayız. Bunu yapmak, yaygınların esnekliğinden vazgeçmek zorunda kalmadan performansı artırır.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="validating-references-with-lifetimes"><a class="header" href="#validating-references-with-lifetimes">Validating References with Lifetimes</a></h2>
<p>Lifetimes are another kind of generic that we’ve already been using. Rather
than ensuring that a type has the behavior we want, lifetimes ensure that
references are valid as long as we need them to be.</p>
<p>One detail we didn’t discuss in the <a href="ch04-02-references-and-borrowing.html#references-and-borrowing">“References and
Borrowing”</a><!-- ignore --> section in Chapter 4 is
that every reference in Rust has a <em>lifetime</em>, which is the scope for which
that reference is valid. Most of the time, lifetimes are implicit and inferred,
just like most of the time, types are inferred. We only must annotate types
when multiple types are possible. In a similar way, we must annotate lifetimes
when the lifetimes of references could be related in a few different ways. Rust
requires us to annotate the relationships using generic lifetime parameters to
ensure the actual references used at runtime will definitely be valid.</p>
<p>Annotating lifetimes is not even a concept most other programming languages
have, so this is going to feel unfamiliar. Although we won’t cover lifetimes in
their entirety in this chapter, we’ll discuss common ways you might encounter
lifetime syntax so you can get comfortable with the concept.</p>
<h3 id="preventing-dangling-references-with-lifetimes"><a class="header" href="#preventing-dangling-references-with-lifetimes">Preventing Dangling References with Lifetimes</a></h3>
<p>The main aim of lifetimes is to prevent <em>dangling references</em>, which cause a
program to reference data other than the data it’s intended to reference.
Consider the program in Listing 10-17, which has an outer scope and an inner
scope.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    {
        let r;

        {
            let x = 5;
            r = &amp;x;
        }

        println!(&quot;r: {}&quot;, r);
    }
<span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 10-17: An attempt to use a reference whose value
has gone out of scope</span></p>
<blockquote>
<p>Note: The examples in Listings 10-17, 10-18, and 10-24 declare variables
without giving them an initial value, so the variable name exists in the
outer scope. At first glance, this might appear to be in conflict with Rust’s
having no null values. However, if we try to use a variable before giving it
a value, we’ll get a compile-time error, which shows that Rust indeed does
not allow null values.</p>
</blockquote>
<p>The outer scope declares a variable named <code>r</code> with no initial value, and the
inner scope declares a variable named <code>x</code> with the initial value of 5. Inside
the inner scope, we attempt to set the value of <code>r</code> as a reference to <code>x</code>. Then
the inner scope ends, and we attempt to print the value in <code>r</code>. This code won’t
compile because the value <code>r</code> is referring to has gone out of scope before we
try to use it. Here is the error message:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:7:17
   |
7  |             r = &amp;x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  | 
10 |         println!(&quot;r: {}&quot;, r);
   |                           - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>The variable <code>x</code> doesn’t “live long enough.” The reason is that <code>x</code> will be out
of scope when the inner scope ends on line 7. But <code>r</code> is still valid for the
outer scope; because its scope is larger, we say that it “lives longer.” If
Rust allowed this code to work, <code>r</code> would be referencing memory that was
deallocated when <code>x</code> went out of scope, and anything we tried to do with <code>r</code>
wouldn’t work correctly. So how does Rust determine that this code is invalid?
It uses a borrow checker.</p>
<h3 id="the-borrow-checker"><a class="header" href="#the-borrow-checker">The Borrow Checker</a></h3>
<p>The Rust compiler has a <em>borrow checker</em> that compares scopes to determine
whether all borrows are valid. Listing 10-18 shows the same code as Listing
10-17 but with annotations showing the lifetimes of the variables.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &amp;x;           //  |       |
        }                     // -+       |
                              //          |
        println!(&quot;r: {}&quot;, r); //          |
    }                         // ---------+
<span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 10-18: Annotations of the lifetimes of <code>r</code> and
<code>x</code>, named <code>'a</code> and <code>'b</code>, respectively</span></p>
<p>Here, we’ve annotated the lifetime of <code>r</code> with <code>'a</code> and the lifetime of <code>x</code>
with <code>'b</code>. As you can see, the inner <code>'b</code> block is much smaller than the outer
<code>'a</code> lifetime block. At compile time, Rust compares the size of the two
lifetimes and sees that <code>r</code> has a lifetime of <code>'a</code> but that it refers to memory
with a lifetime of <code>'b</code>. The program is rejected because <code>'b</code> is shorter than
<code>'a</code>: the subject of the reference doesn’t live as long as the reference.</p>
<p>Listing 10-19 fixes the code so it doesn’t have a dangling reference and
compiles without any errors.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &amp;x;           // --+-- 'a  |
                              //   |       |
        println!(&quot;r: {}&quot;, r); //   |       |
                              // --+       |
    }                         // ----------+
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-19: A valid reference because the data has a
longer lifetime than the reference</span></p>
<p>Here, <code>x</code> has the lifetime <code>'b</code>, which in this case is larger than <code>'a</code>. This
means <code>r</code> can reference <code>x</code> because Rust knows that the reference in <code>r</code> will
always be valid while <code>x</code> is valid.</p>
<p>Now that you know where the lifetimes of references are and how Rust analyzes
lifetimes to ensure references will always be valid, let’s explore generic
lifetimes of parameters and return values in the context of functions.</p>
<h3 id="generic-lifetimes-in-functions"><a class="header" href="#generic-lifetimes-in-functions">Generic Lifetimes in Functions</a></h3>
<p>We’ll write a function that returns the longer of two string slices. This
function will take two string slices and return a single string slice. After
we’ve implemented the <code>longest</code> function, the code in Listing 10-20 should
print <code>The longest string is abcd</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Listing 10-20: A <code>main</code> function that calls the <code>longest</code>
function to find the longer of two string slices</span></p>
<p>Note that we want the function to take string slices, which are references,
rather than strings, because we don’t want the <code>longest</code> function to take
ownership of its parameters. Refer to the <a href="ch04-03-slices.html#string-slices-as-parameters">“String Slices as
Parameters”</a><!-- ignore --> section in Chapter 4
for more discussion about why the parameters we use in Listing 10-20 are the
ones we want.</p>
<p>If we try to implement the <code>longest</code> function as shown in Listing 10-21, it
won’t compile.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<p><span class="caption">Listing 10-21: An implementation of the <code>longest</code>
function that returns the longer of two string slices but does not yet
compile</span></p>
<p>Instead, we get the following error that talks about lifetimes:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>The help text reveals that the return type needs a generic lifetime parameter
on it because Rust can’t tell whether the reference being returned refers to
<code>x</code> or <code>y</code>. Actually, we don’t know either, because the <code>if</code> block in the body
of this function returns a reference to <code>x</code> and the <code>else</code> block returns a
reference to <code>y</code>!</p>
<p>When we’re defining this function, we don’t know the concrete values that will
be passed into this function, so we don’t know whether the <code>if</code> case or the
<code>else</code> case will execute. We also don’t know the concrete lifetimes of the
references that will be passed in, so we can’t look at the scopes as we did in
Listings 10-18 and 10-19 to determine whether the reference we return will
always be valid. The borrow checker can’t determine this either, because it
doesn’t know how the lifetimes of <code>x</code> and <code>y</code> relate to the lifetime of the
return value. To fix this error, we’ll add generic lifetime parameters that
define the relationship between the references so the borrow checker can
perform its analysis.</p>
<h3 id="lifetime-annotation-syntax"><a class="header" href="#lifetime-annotation-syntax">Lifetime Annotation Syntax</a></h3>
<p>Lifetime annotations don’t change how long any of the references live. Rather,
they describe the relationships of the lifetimes of multiple references to each
other without affecting the lifetimes. Just as functions can accept any type
when the signature specifies a generic type parameter, functions can accept
references with any lifetime by specifying a generic lifetime parameter.</p>
<p>Lifetime annotations have a slightly unusual syntax: the names of lifetime
parameters must start with an apostrophe (<code>'</code>) and are usually all lowercase
and very short, like generic types. Most people use the name <code>'a</code> for the first
lifetime annotation. We place lifetime parameter annotations after the <code>&amp;</code> of a
reference, using a space to separate the annotation from the reference’s type.</p>
<p>Here are some examples: a reference to an <code>i32</code> without a lifetime parameter, a
reference to an <code>i32</code> that has a lifetime parameter named <code>'a</code>, and a mutable
reference to an <code>i32</code> that also has the lifetime <code>'a</code>.</p>
<pre><code class="language-rust ignore">&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime
</code></pre>
<p>One lifetime annotation by itself doesn’t have much meaning, because the
annotations are meant to tell Rust how generic lifetime parameters of multiple
references relate to each other. For example, let’s say we have a function with
the parameter <code>first</code> that is a reference to an <code>i32</code> with lifetime <code>'a</code>. The
function also has another parameter named <code>second</code> that is another reference to
an <code>i32</code> that also has the lifetime <code>'a</code>. The lifetime annotations indicate
that the references <code>first</code> and <code>second</code> must both live as long as that generic
lifetime.</p>
<h3 id="lifetime-annotations-in-function-signatures"><a class="header" href="#lifetime-annotations-in-function-signatures">Lifetime Annotations in Function Signatures</a></h3>
<p>Now let’s examine lifetime annotations in the context of the <code>longest</code>
function. As with generic type parameters, we need to declare generic lifetime
parameters inside angle brackets between the function name and the parameter
list. We want the signature to express the following constraint: the returned
reference will be valid as long as both the parameters are valid. This is the
relationship between lifetimes of the parameters and the return value. We’ll
name the lifetime <code>'a</code> and then add it to each reference, as shown in Listing
10-22.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p><span class="caption">Listing 10-22: The <code>longest</code> function definition
specifying that all the references in the signature must have the same lifetime
<code>'a</code></span></p>
<p>This code should compile and produce the result we want when we use it with the
<code>main</code> function in Listing 10-20.</p>
<p>The function signature now tells Rust that for some lifetime <code>'a</code>, the function
takes two parameters, both of which are string slices that live at least as
long as lifetime <code>'a</code>. The function signature also tells Rust that the string
slice returned from the function will live at least as long as lifetime <code>'a</code>.
In practice, it means that the lifetime of the reference returned by the
<code>longest</code> function is the same as the smaller of the lifetimes of the
references passed in. These relationships are what we want Rust to use when
analyzing this code.</p>
<p>Remember, when we specify the lifetime parameters in this function signature,
we’re not changing the lifetimes of any values passed in or returned. Rather,
we’re specifying that the borrow checker should reject any values that don’t
adhere to these constraints. Note that the <code>longest</code> function doesn’t need to
know exactly how long <code>x</code> and <code>y</code> will live, only that some scope can be
substituted for <code>'a</code> that will satisfy this signature.</p>
<p>When annotating lifetimes in functions, the annotations go in the function
signature, not in the function body. The lifetime annotations become part of
the contract of the function, much like the types in the signature. Having
function signatures contain the lifetime contract means the analysis the Rust
compiler does can be simpler. If there’s a problem with the way a function is
annotated or the way it is called, the compiler errors can point to the part of
our code and the constraints more precisely. If, instead, the Rust compiler
made more inferences about what we intended the relationships of the lifetimes
to be, the compiler might only be able to point to a use of our code many steps
away from the cause of the problem.</p>
<p>When we pass concrete references to <code>longest</code>, the concrete lifetime that is
substituted for <code>'a</code> is the part of the scope of <code>x</code> that overlaps with the
scope of <code>y</code>. In other words, the generic lifetime <code>'a</code> will get the concrete
lifetime that is equal to the smaller of the lifetimes of <code>x</code> and <code>y</code>. Because
we’ve annotated the returned reference with the same lifetime parameter <code>'a</code>,
the returned reference will also be valid for the length of the smaller of the
lifetimes of <code>x</code> and <code>y</code>.</p>
<p>Let’s look at how the lifetime annotations restrict the <code>longest</code> function by
passing in references that have different concrete lifetimes. Listing 10-23 is
a straightforward example.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;The longest string is {}&quot;, result);
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-23: Using the <code>longest</code> function with
references to <code>String</code> values that have different concrete lifetimes</span></p>
<p>In this example, <code>string1</code> is valid until the end of the outer scope, <code>string2</code>
is valid until the end of the inner scope, and <code>result</code> references something
that is valid until the end of the inner scope. Run this code, and you’ll see
that the borrow checker approves; it will compile and print <code>The longest string is long string is long</code>.</p>
<p>Next, let’s try an example that shows that the lifetime of the reference in
<code>result</code> must be the smaller lifetime of the two arguments. We’ll move the
declaration of the <code>result</code> variable outside the inner scope but leave the
assignment of the value to the <code>result</code> variable inside the scope with
<code>string2</code>. Then we’ll move the <code>println!</code> that uses <code>result</code> to outside the
inner scope, after the inner scope has ended. The code in Listing 10-24 will
not compile.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 10-24: Attempting to use <code>result</code> after <code>string2</code>
has gone out of scope</span></p>
<p>When we try to compile this code, we get this error:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^^^^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;The longest string is {}&quot;, result);
  |                                          ------ borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>The error shows that for <code>result</code> to be valid for the <code>println!</code> statement,
<code>string2</code> would need to be valid until the end of the outer scope. Rust knows
this because we annotated the lifetimes of the function parameters and return
values using the same lifetime parameter <code>'a</code>.</p>
<p>As humans, we can look at this code and see that <code>string1</code> is longer than
<code>string2</code> and therefore <code>result</code> will contain a reference to <code>string1</code>.
Because <code>string1</code> has not gone out of scope yet, a reference to <code>string1</code> will
still be valid for the <code>println!</code> statement. However, the compiler can’t see
that the reference is valid in this case. We’ve told Rust that the lifetime of
the reference returned by the <code>longest</code> function is the same as the smaller of
the lifetimes of the references passed in. Therefore, the borrow checker
disallows the code in Listing 10-24 as possibly having an invalid reference.</p>
<p>Try designing more experiments that vary the values and lifetimes of the
references passed in to the <code>longest</code> function and how the returned reference
is used. Make hypotheses about whether or not your experiments will pass the
borrow checker before you compile; then check to see if you’re right!</p>
<h3 id="thinking-in-terms-of-lifetimes"><a class="header" href="#thinking-in-terms-of-lifetimes">Thinking in Terms of Lifetimes</a></h3>
<p>The way in which you need to specify lifetime parameters depends on what your
function is doing. For example, if we changed the implementation of the
<code>longest</code> function to always return the first parameter rather than the longest
string slice, we wouldn’t need to specify a lifetime on the <code>y</code> parameter. The
following code will compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;efghijklmnopqrstuvwxyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
</code></pre></pre>
<p>We’ve specified a lifetime parameter <code>'a</code> for the parameter <code>x</code> and the return
type, but not for the parameter <code>y</code>, because the lifetime of <code>y</code> does not have
any relationship with the lifetime of <code>x</code> or the return value.</p>
<p>When returning a reference from a function, the lifetime parameter for the
return type needs to match the lifetime parameter for one of the parameters. If
the reference returned does <em>not</em> refer to one of the parameters, it must refer
to a value created within this function. However, this would be a dangling
reference because the value will go out of scope at the end of the function.
Consider this attempted implementation of the <code>longest</code> function that won’t
compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}
</code></pre>
<p>Here, even though we’ve specified a lifetime parameter <code>'a</code> for the return
type, this implementation will fail to compile because the return value
lifetime is not related to the lifetime of the parameters at all. Here is the
error message we get:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return reference to local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the current function

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>The problem is that <code>result</code> goes out of scope and gets cleaned up at the end
of the <code>longest</code> function. We’re also trying to return a reference to <code>result</code>
from the function. There is no way we can specify lifetime parameters that
would change the dangling reference, and Rust won’t let us create a dangling
reference. In this case, the best fix would be to return an owned data type
rather than a reference so the calling function is then responsible for
cleaning up the value.</p>
<p>Ultimately, lifetime syntax is about connecting the lifetimes of various
parameters and return values of functions. Once they’re connected, Rust has
enough information to allow memory-safe operations and disallow operations that
would create dangling pointers or otherwise violate memory safety.</p>
<h3 id="lifetime-annotations-in-struct-definitions"><a class="header" href="#lifetime-annotations-in-struct-definitions">Lifetime Annotations in Struct Definitions</a></h3>
<p>So far, the structs we've defined all hold owned types. We can define structs
to hold references, but in that case we would need to add a lifetime annotation
on every reference in the struct’s definition. Listing 10-25 has a struct named
<code>ImportantExcerpt</code> that holds a string slice.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
</code></pre></pre>
<p><span class="caption">Listing 10-25: A struct that holds a reference, so its
definition needs a lifetime annotation</span></p>
<p>This struct has one field, <code>part</code>, that holds a string slice, which is a
reference. As with generic data types, we declare the name of the generic
lifetime parameter inside angle brackets after the name of the struct so we can
use the lifetime parameter in the body of the struct definition. This
annotation means an instance of <code>ImportantExcerpt</code> can’t outlive the reference
it holds in its <code>part</code> field.</p>
<p>The <code>main</code> function here creates an instance of the <code>ImportantExcerpt</code> struct
that holds a reference to the first sentence of the <code>String</code> owned by the
variable <code>novel</code>. The data in <code>novel</code> exists before the <code>ImportantExcerpt</code>
instance is created. In addition, <code>novel</code> doesn’t go out of scope until after
the <code>ImportantExcerpt</code> goes out of scope, so the reference in the
<code>ImportantExcerpt</code> instance is valid.</p>
<h3 id="lifetime-elision"><a class="header" href="#lifetime-elision">Lifetime Elision</a></h3>
<p>You’ve learned that every reference has a lifetime and that you need to specify
lifetime parameters for functions or structs that use references. However, in
Chapter 4 we had a function in Listing 4-9, shown again in Listing 10-26, that
compiled without lifetime annotations.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-26: A function we defined in Listing 4-9 that
compiled without lifetime annotations, even though the parameter and return
type are references</span></p>
<p>The reason this function compiles without lifetime annotations is historical:
in early versions (pre-1.0) of Rust, this code wouldn’t have compiled because
every reference needed an explicit lifetime. At that time, the function
signature would have been written like this:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>After writing a lot of Rust code, the Rust team found that Rust programmers
were entering the same lifetime annotations over and over in particular
situations. These situations were predictable and followed a few deterministic
patterns. The developers programmed these patterns into the compiler’s code so
the borrow checker could infer the lifetimes in these situations and wouldn’t
need explicit annotations.</p>
<p>This piece of Rust history is relevant because it’s possible that more
deterministic patterns will emerge and be added to the compiler. In the future,
even fewer lifetime annotations might be required.</p>
<p>The patterns programmed into Rust’s analysis of references are called the
<em>lifetime elision rules</em>. These aren’t rules for programmers to follow; they’re
a set of particular cases that the compiler will consider, and if your code
fits these cases, you don’t need to write the lifetimes explicitly.</p>
<p>The elision rules don’t provide full inference. If Rust deterministically
applies the rules but there is still ambiguity as to what lifetimes the
references have, the compiler won’t guess what the lifetime of the remaining
references should be. Instead of guessing, the compiler will give you an error
that you can resolve by adding the lifetime annotations.</p>
<p>Lifetimes on function or method parameters are called <em>input lifetimes</em>, and
lifetimes on return values are called <em>output lifetimes</em>.</p>
<p>The compiler uses three rules to figure out the lifetimes of the references
when there aren’t explicit annotations. The first rule applies to input
lifetimes, and the second and third rules apply to output lifetimes. If the
compiler gets to the end of the three rules and there are still references for
which it can’t figure out lifetimes, the compiler will stop with an error.
These rules apply to <code>fn</code> definitions as well as <code>impl</code> blocks.</p>
<p>The first rule is that the compiler assigns a lifetime parameter to each
parameter that’s a reference. In other words, a function with one parameter
gets one lifetime parameter: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>; a function with two
parameters gets two separate lifetime parameters: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>; and so on.</p>
<p>The second rule is that, if there is exactly one input lifetime parameter, that
lifetime is assigned to all output lifetime parameters: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<p>The third rule is that, if there are multiple input lifetime parameters, but
one of them is <code>&amp;self</code> or <code>&amp;mut self</code> because this is a method, the lifetime of
<code>self</code> is assigned to all output lifetime parameters. This third rule makes
methods much nicer to read and write because fewer symbols are necessary.</p>
<p>Let’s pretend we’re the compiler. We’ll apply these rules to figure out the
lifetimes of the references in the signature of the <code>first_word</code> function in
Listing 10-26. The signature starts without any lifetimes associated with the
references:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Then the compiler applies the first rule, which specifies that each parameter
gets its own lifetime. We’ll call it <code>'a</code> as usual, so now the signature is
this:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<p>The second rule applies because there is exactly one input lifetime. The second
rule specifies that the lifetime of the one input parameter gets assigned to
the output lifetime, so the signature is now this:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Now all the references in this function signature have lifetimes, and the
compiler can continue its analysis without needing the programmer to annotate
the lifetimes in this function signature.</p>
<p>Let’s look at another example, this time using the <code>longest</code> function that had
no lifetime parameters when we started working with it in Listing 10-21:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Let’s apply the first rule: each parameter gets its own lifetime. This time we
have two parameters instead of one, so we have two lifetimes:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<p>You can see that the second rule doesn’t apply because there is more than one
input lifetime. The third rule doesn’t apply either, because <code>longest</code> is a
function rather than a method, so none of the parameters are <code>self</code>. After
working through all three rules, we still haven’t figured out what the return
type’s lifetime is. This is why we got an error trying to compile the code in
Listing 10-21: the compiler worked through the lifetime elision rules but still
couldn’t figure out all the lifetimes of the references in the signature.</p>
<p>Because the third rule really only applies in method signatures, we’ll look at
lifetimes in that context next to see why the third rule means we don’t have to
annotate lifetimes in method signatures very often.</p>
<h3 id="lifetime-annotations-in-method-definitions"><a class="header" href="#lifetime-annotations-in-method-definitions">Lifetime Annotations in Method Definitions</a></h3>
<p>When we implement methods on a struct with lifetimes, we use the same syntax as
that of generic type parameters shown in Listing 10-11. Where we declare and
use the lifetime parameters depends on whether they’re related to the struct
fields or the method parameters and return values.</p>
<p>Lifetime names for struct fields always need to be declared after the <code>impl</code>
keyword and then used after the struct’s name, because those lifetimes are part
of the struct’s type.</p>
<p>In method signatures inside the <code>impl</code> block, references might be tied to the
lifetime of references in the struct’s fields, or they might be independent. In
addition, the lifetime elision rules often make it so that lifetime annotations
aren’t necessary in method signatures. Let’s look at some examples using the
struct named <code>ImportantExcerpt</code> that we defined in Listing 10-25.</p>
<p>First, we’ll use a method named <code>level</code> whose only parameter is a reference to
<code>self</code> and whose return value is an <code>i32</code>, which is not a reference to anything:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!(&quot;Attention please: {}&quot;, announcement);
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<p>The lifetime parameter declaration after <code>impl</code> and its use after the type name
are required, but we’re not required to annotate the lifetime of the reference
to <code>self</code> because of the first elision rule.</p>
<p>Here is an example where the third lifetime elision rule applies:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<p>There are two input lifetimes, so Rust applies the first lifetime elision rule
and gives both <code>&amp;self</code> and <code>announcement</code> their own lifetimes. Then, because
one of the parameters is <code>&amp;self</code>, the return type gets the lifetime of <code>&amp;self</code>,
and all lifetimes have been accounted for.</p>
<h3 id="the-static-lifetime"><a class="header" href="#the-static-lifetime">The Static Lifetime</a></h3>
<p>One special lifetime we need to discuss is <code>'static</code>, which denotes that the
affected reference <em>can</em> live for the entire duration of the program. All
string literals have the <code>'static</code> lifetime, which we can annotate as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>The text of this string is stored directly in the program’s binary, which
is always available. Therefore, the lifetime of all string literals is
<code>'static</code>.</p>
<p>You might see suggestions to use the <code>'static</code> lifetime in error messages. But
before specifying <code>'static</code> as the lifetime for a reference, think about
whether the reference you have actually lives the entire lifetime of your
program or not, and whether you want it to. Most of the time, an error message
suggesting the <code>'static</code> lifetime results from attempting to create a dangling
reference or a mismatch of the available lifetimes. In such cases, the solution
is fixing those problems, not specifying the <code>'static</code> lifetime.</p>
<h2 id="generic-type-parameters-trait-bounds-and-lifetimes-together"><a class="header" href="#generic-type-parameters-trait-bounds-and-lifetimes-together">Generic Type Parameters, Trait Bounds, and Lifetimes Together</a></h2>
<p>Let’s briefly look at the syntax of specifying generic type parameters, trait
bounds, and lifetimes all in one function!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        &quot;Today is someone's birthday!&quot;,
</span><span class="boring">    );
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p>This is the <code>longest</code> function from Listing 10-22 that returns the longer of
two string slices. But now it has an extra parameter named <code>ann</code> of the generic
type <code>T</code>, which can be filled in by any type that implements the <code>Display</code>
trait as specified by the <code>where</code> clause. This extra parameter will be printed
using <code>{}</code>, which is why the <code>Display</code> trait bound is necessary. Because
lifetimes are a type of generic, the declarations of the lifetime parameter
<code>'a</code> and the generic type parameter <code>T</code> go in the same list inside the angle
brackets after the function name.</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>We covered a lot in this chapter! Now that you know about generic type
parameters, traits and trait bounds, and generic lifetime parameters, you’re
ready to write code without repetition that works in many different situations.
Generic type parameters let you apply the code to different types. Traits and
trait bounds ensure that even though the types are generic, they’ll have the
behavior the code needs. You learned how to use lifetime annotations to ensure
that this flexible code won’t have any dangling references. And all of this
analysis happens at compile time, which doesn’t affect runtime performance!</p>
<p>Believe it or not, there is much more to learn on the topics we discussed in
this chapter: Chapter 17 discusses trait objects, which are another way to use
traits. There are also more complex scenarios involving lifetime annotations
that you will only need in very advanced scenarios; for those, you should read
the <a href="../reference/index.html">Rust Reference</a>. But next, you’ll learn how to write tests in
Rust so you can make sure your code is working the way it should.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="otomatize-testler-yazma"><a class="header" href="#otomatize-testler-yazma">Otomatize Testler Yazma</a></h1>
<p>Edsger W. Dijkstra'nın 1972 tarihli “The Humble Programmer” adlı makalesinde, 
“Program testi, hataların varlığını göstermek için çok etkili bir yol olabilir, ancak onların yokluğunu göstermek için umutsuzca yetersizdir” dedi. Bu, elimizden geldiğince test etmeye çalışmamamız gerektiği anlamına gelmez!</p>
<p>Programlarımızdaki doğruluk, kodumuzun yapmayı amaçladığımız şeyi ne ölçüde yaptığıdır. Rust, programların doğruluğu konusunda yüksek derecede endişe ile tasarlanmıştır, ancak doğruluğu karmaşıktır ve kanıtlanması kolay değildir. Rust'ın tür sistemi bu yükün büyük bir kısmını omuzlar, ancak bu tür sistemi her şeyi yakalayamaz. Bu nedenle Rust, otomatize yazılım testlerini yazma desteğini
dahili olarak içermektedir.</p>
<p>Kendisine iletilen sayıya 2 ekleyen bir <code>add_two</code> fonksiyonu yazdığımızı varsayalım. 
Bu fonksiyonun yapısı, parametre olarak bir tam sayı kabul eder ve sonuç olarak bir tam sayı döndürür. 
Bu fonksiyonu süreklediğimizde ve derlediğimizde; Rust, örneğin, bu fonksiyona bir <code>String</code> değeri veya geçersiz bir referans geçirmediğimizden emin olmak için şimdiye kadar öğrendiğiniz tüm tür kontrollerini ve ödünç alma kontrollerini yapar. 
Ancak Rust, bu fonksiyonun tam olarak neyi amaçladığımızı anlayamaz ve bunu <em>kontrol edemez</em>; 
bu, örneğin parametre artı 10 veya parametre eksi 50 yerine parametre artı 2'yi döndürür! 
Testlerin gerektiği yer burasıdır.</p>
<p>Örneğin, <code>add_two</code> fonksiyonuna <code>3</code>'ü ilettiğimizde, döndürülen değerin <code>5</code> olduğunu iddia eden testler yazabiliriz.</p>
<p>Testler oluşturmak karmaşık bir beceridir: iyi testlerin nasıl yazılacağına dair her ayrıntıyı bir bölümde ele alamasak da, Rust'ın test tesislerinin mekaniğini tartışacağız. Testlerinizi yazarken kullanabileceğiniz ek açıklamalar ve makrolar, testlerinizi çalıştırmak için sağlanan varsayılan davranış ve seçenekler ve testlerin birim testleri ve entegrasyon testleri halinde nasıl organize edilebileceği hakkında konuşacağız.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="how-to-write-tests"><a class="header" href="#how-to-write-tests">How to Write Tests</a></h2>
<p>Tests are Rust functions that verify that the non-test code is functioning in
the expected manner. The bodies of test functions typically perform these three
actions:</p>
<ol>
<li>Set up any needed data or state.</li>
<li>Run the code you want to test.</li>
<li>Assert the results are what you expect.</li>
</ol>
<p>Let’s look at the features Rust provides specifically for writing tests that
take these actions, which include the <code>test</code> attribute, a few macros, and the
<code>should_panic</code> attribute.</p>
<h3 id="the-anatomy-of-a-test-function"><a class="header" href="#the-anatomy-of-a-test-function">The Anatomy of a Test Function</a></h3>
<p>At its simplest, a test in Rust is a function that’s annotated with the <code>test</code>
attribute. Attributes are metadata about pieces of Rust code; one example is
the <code>derive</code> attribute we used with structs in Chapter 5. To change a function
into a test function, add <code>#[test]</code> on the line before <code>fn</code>. When you run your
tests with the <code>cargo test</code> command, Rust builds a test runner binary that runs
the annotated functions and reports on whether each
test function passes or fails.</p>
<p>Whenever we make a new library project with Cargo, a test module with a test
function in it is automatically generated for us. This module gives you a
template for writing your tests so you don’t have to look up the exact
structure and syntax every time you start a new project. You can add as many
additional test functions and as many test modules as you want!</p>
<p>We’ll explore some aspects of how tests work by experimenting with the template
test before we actually test any code. Then we’ll write some real-world tests
that call some code that we’ve written and assert that its behavior is correct.</p>
<p>Let’s create a new library project called <code>adder</code> that will add two numbers:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>The contents of the <em>src/lib.rs</em> file in your <code>adder</code> library should look like
Listing 11-1.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new --lib listing-11-01 --name adder
cd listing-11-01
cargo test
git co output.txt
cd ../../..
-->
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
</code></pre>
<p><span class="caption">Listing 11-1: The test module and function generated
automatically by <code>cargo new</code></span></p>
<p>For now, let’s ignore the top two lines and focus on the function. Note the
<code>#[test]</code> annotation: this attribute indicates this is a test function, so the
test runner knows to treat this function as a test. We might also have non-test
functions in the <code>tests</code> module to help set up common scenarios or perform
common operations, so we always need to indicate which functions are tests.</p>
<p>The example function body uses the <code>assert_eq!</code> macro to assert that <code>result</code>,
which contains the result of adding 2 and 2, equals 4. This assertion serves as
an example of the format for a typical test. Let’s run it to see that this test
passes.</p>
<p>The <code>cargo test</code> command runs all tests in our project, as shown in Listing
11-2.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p><span class="caption">Listing 11-2: The output from running the automatically
generated test</span></p>
<p>Cargo compiled and ran the test. We see the line <code>running 1 test</code>. The next
line shows the name of the generated test function, called <code>it_works</code>, and that
the result of running that test is <code>ok</code>. The overall summary <code>test result: ok.</code>
means that all the tests passed, and the portion that reads <code>1 passed; 0 failed</code> totals the number of tests that passed or failed.</p>
<p>It's possible to mark a test as ignored so it doesn't run in a particular
instance; we'll cover that in the <a href="ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested">“Ignoring Some Tests Unless Specifically
Requested”</a><!-- ignore --> section later in this chapter. Because we
haven't done that here, the summary shows <code>0 ignored</code>. We can also pass an
argument to the <code>cargo test</code> command to run only tests whose name matches a
string; this is called filtering and we'll cover that in the <a href="ch11-02-running-tests.html#running-a-subset-of-tests-by-name">“Running a Subset
of Tests by Name”</a><!-- ignore --> section. We also haven’t filtered the
tests being run, so the end of the summary shows <code>0 filtered out</code>.</p>
<p>The <code>0 measured</code> statistic is for benchmark tests that measure performance.
Benchmark tests are, as of this writing, only available in nightly Rust. See
<a href="../unstable-book/library-features/test.html">the documentation about benchmark tests</a> to learn more.</p>
<p>The next part of the test output starting at <code>Doc-tests adder</code> is for the
results of any documentation tests. We don’t have any documentation tests yet,
but Rust can compile any code examples that appear in our API documentation.
This feature helps keep your docs and your code in sync! We’ll discuss how to
write documentation tests in the <a href="ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">“Documentation Comments as
Tests”</a><!-- ignore --> section of Chapter 14. For now, we’ll
ignore the <code>Doc-tests</code> output.</p>
<p>Let’s start to customize the test to our own needs. First change the name of
the <code>it_works</code> function to a different name, such as <code>exploration</code>, like so:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<p>Then run <code>cargo test</code> again. The output now shows <code>exploration</code> instead of
<code>it_works</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Now we'll add another test, but this time we’ll make a test that fails! Tests
fail when something in the test function panics. Each test is run in a new
thread, and when the main thread sees that a test thread has died, the test is
marked as failed. In Chapter 9, we talked about how the simplest way to panic
is to call the <code>panic!</code> macro. Enter the new test as a function named
<code>another</code>, so your <em>src/lib.rs</em> file looks like Listing 11-3.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!(&quot;Make this test fail&quot;);
    }
}
</code></pre>
<p><span class="caption">Listing 11-3: Adding a second test that will fail because
we call the <code>panic!</code> macro</span></p>
<p>Run the tests again using <code>cargo test</code>. The output should look like Listing
11-4, which shows that our <code>exploration</code> test passed and <code>another</code> failed.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'main' panicked at 'Make this test fail', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p><span class="caption">Listing 11-4: Test results when one test passes and one
test fails</span></p>
<p>Instead of <code>ok</code>, the line <code>test tests::another</code> shows <code>FAILED</code>. Two new
sections appear between the individual results and the summary: the first
displays the detailed reason for each test failure. In this case, we get the
details that <code>another</code> failed because it <code>panicked at 'Make this test fail'</code> on
line 10 in the <em>src/lib.rs</em> file. The next section lists just the names of all
the failing tests, which is useful when there are lots of tests and lots of
detailed failing test output. We can use the name of a failing test to run just
that test to more easily debug it; we’ll talk more about ways to run tests in
the <a href="ch11-02-running-tests.html#controlling-how-tests-are-run">“Controlling How Tests Are Run”</a><!-- ignore
--> section.</p>
<p>The summary line displays at the end: overall, our test result is <code>FAILED</code>. We
had one test pass and one test fail.</p>
<p>Now that you’ve seen what the test results look like in different scenarios,
let’s look at some macros other than <code>panic!</code> that are useful in tests.</p>
<h3 id="checking-results-with-the-assert-macro"><a class="header" href="#checking-results-with-the-assert-macro">Checking Results with the <code>assert!</code> Macro</a></h3>
<p>The <code>assert!</code> macro, provided by the standard library, is useful when you want
to ensure that some condition in a test evaluates to <code>true</code>. We give the
<code>assert!</code> macro an argument that evaluates to a Boolean. If the value is
<code>true</code>, nothing happens and the test passes. If the value is <code>false</code>, the
<code>assert!</code> macro calls <code>panic!</code> to cause the test to fail. Using the <code>assert!</code>
macro helps us check that our code is functioning in the way we intend.</p>
<p>In Chapter 5, Listing 5-15, we used a <code>Rectangle</code> struct and a <code>can_hold</code>
method, which are repeated here in Listing 11-5. Let’s put this code in the
<em>src/lib.rs</em> file, then write some tests for it using the <code>assert!</code> macro.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
</code></pre>
<p><span class="caption">Listing 11-5: Using the <code>Rectangle</code> struct and its
<code>can_hold</code> method from Chapter 5</span></p>
<p>The <code>can_hold</code> method returns a Boolean, which means it’s a perfect use case
for the <code>assert!</code> macro. In Listing 11-6, we write a test that exercises the
<code>can_hold</code> method by creating a <code>Rectangle</code> instance that has a width of 8 and
a height of 7 and asserting that it can hold another <code>Rectangle</code> instance that
has a width of 5 and a height of 1.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}
</code></pre>
<p><span class="caption">Listing 11-6: A test for <code>can_hold</code> that checks whether a
larger rectangle can indeed hold a smaller rectangle</span></p>
<p>Note that we’ve added a new line inside the <code>tests</code> module: <code>use super::*;</code>.
The <code>tests</code> module is a regular module that follows the usual visibility rules
we covered in Chapter 7 in the <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for Referring to an Item in the Module
Tree”</a><!-- ignore -->
section. Because the <code>tests</code> module is an inner module, we need to bring the
code under test in the outer module into the scope of the inner module. We use
a glob here so anything we define in the outer module is available to this
<code>tests</code> module.</p>
<p>We’ve named our test <code>larger_can_hold_smaller</code>, and we’ve created the two
<code>Rectangle</code> instances that we need. Then we called the <code>assert!</code> macro and
passed it the result of calling <code>larger.can_hold(&amp;smaller)</code>. This expression is
supposed to return <code>true</code>, so our test should pass. Let’s find out!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>It does pass! Let’s add another test, this time asserting that a smaller
rectangle cannot hold a larger rectangle:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
</code></pre>
<p>Because the correct result of the <code>can_hold</code> function in this case is <code>false</code>,
we need to negate that result before we pass it to the <code>assert!</code> macro. As a
result, our test will pass if <code>can_hold</code> returns <code>false</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Two tests that pass! Now let’s see what happens to our test results when we
introduce a bug in our code. We’ll change the implementation of the <code>can_hold</code>
method by replacing the greater-than sign with a less-than sign when it
compares the widths:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Running the tests now produces the following:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'main' panicked at 'assertion failed: larger.can_hold(&amp;smaller)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Our tests caught the bug! Because <code>larger.width</code> is 8 and <code>smaller.width</code> is
5, the comparison of the widths in <code>can_hold</code> now returns <code>false</code>: 8 is not
less than 5.</p>
<h3 id="testing-equality-with-the-assert_eq-and-assert_ne-macros"><a class="header" href="#testing-equality-with-the-assert_eq-and-assert_ne-macros">Testing Equality with the <code>assert_eq!</code> and <code>assert_ne!</code> Macros</a></h3>
<p>A common way to verify functionality is to test for equality between the result
of the code under test and the value you expect the code to return. You could
do this using the <code>assert!</code> macro and passing it an expression using the <code>==</code>
operator. However, this is such a common test that the standard library
provides a pair of macros—<code>assert_eq!</code> and <code>assert_ne!</code>—to perform this test
more conveniently. These macros compare two arguments for equality or
inequality, respectively. They’ll also print the two values if the assertion
fails, which makes it easier to see <em>why</em> the test failed; conversely, the
<code>assert!</code> macro only indicates that it got a <code>false</code> value for the <code>==</code>
expression, without printing the values that led to the <code>false</code> value.</p>
<p>In Listing 11-7, we write a function named <code>add_two</code> that adds <code>2</code> to its
parameter, then we test this function using the <code>assert_eq!</code> macro.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p><span class="caption">Listing 11-7: Testing the function <code>add_two</code> using the
<code>assert_eq!</code> macro</span></p>
<p>Let’s check that it passes!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>We pass <code>4</code> as the argument to <code>assert_eq!</code>, which is equal to the result of
calling <code>add_two(2)</code>. The line for this test is <code>test tests::it_adds_two ... ok</code>, and the <code>ok</code> text indicates that our test passed!</p>
<p>Let’s introduce a bug into our code to see what <code>assert_eq!</code> looks like when it
fails. Change the implementation of the <code>add_two</code> function to instead add <code>3</code>:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        assert_eq!(4, add_two(2));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Run the tests again:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Our test caught the bug! The <code>it_adds_two</code> test failed, and the message tells
us that the assertion that fails was <code>assertion failed: `(left == right)`</code>
and what the <code>left</code> and <code>right</code> values are. This message helps us start
debugging: the <code>left</code> argument was <code>4</code> but the <code>right</code> argument, where we had
<code>add_two(2)</code>, was <code>5</code>. You can imagine that this would be especially helpful
when we have a lot of tests going on.</p>
<p>Note that in some languages and test frameworks, the parameters to equality
assertion functions are called <code>expected</code> and <code>actual</code>, and the order in which
we specify the arguments matters. However, in Rust, they’re called <code>left</code> and
<code>right</code>, and the order in which we specify the value we expect and the value
the code produces doesn’t matter. We could write the assertion in this test as
<code>assert_eq!(add_two(2), 4)</code>, which would result in the same failure message
that displays <code>assertion failed: `(left == right)`</code>.</p>
<p>The <code>assert_ne!</code> macro will pass if the two values we give it are not equal and
fail if they’re equal. This macro is most useful for cases when we’re not sure
what a value <em>will</em> be, but we know what the value definitely <em>shouldn’t</em> be.
For example, if we’re testing a function that is guaranteed to change its input
in some way, but the way in which the input is changed depends on the day of
the week that we run our tests, the best thing to assert might be that the
output of the function is not equal to the input.</p>
<p>Under the surface, the <code>assert_eq!</code> and <code>assert_ne!</code> macros use the operators
<code>==</code> and <code>!=</code>, respectively. When the assertions fail, these macros print their
arguments using debug formatting, which means the values being compared must
implement the <code>PartialEq</code> and <code>Debug</code> traits. All primitive types and most of
the standard library types implement these traits. For structs and enums that
you define yourself, you’ll need to implement <code>PartialEq</code> to assert equality of
those types. You’ll also need to implement <code>Debug</code> to print the values when the
assertion fails. Because both traits are derivable traits, as mentioned in
Listing 5-12 in Chapter 5, this is usually as straightforward as adding the
<code>#[derive(PartialEq, Debug)]</code> annotation to your struct or enum definition. See
Appendix C, <a href="appendix-03-derivable-traits.html">“Derivable Traits,”</a><!-- ignore --> for more
details about these and other derivable traits.</p>
<h3 id="adding-custom-failure-messages"><a class="header" href="#adding-custom-failure-messages">Adding Custom Failure Messages</a></h3>
<p>You can also add a custom message to be printed with the failure message as
optional arguments to the <code>assert!</code>, <code>assert_eq!</code>, and <code>assert_ne!</code> macros. Any
arguments specified after the required arguments are passed along to the
<code>format!</code> macro (discussed in Chapter 8 in the <a href="ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro">“Concatenation with the <code>+</code>
Operator or the <code>format!</code>
Macro”</a><!-- ignore -->
section), so you can pass a format string that contains <code>{}</code> placeholders and
values to go in those placeholders. Custom messages are useful for documenting
what an assertion means; when a test fails, you’ll have a better idea of what
the problem is with the code.</p>
<p>For example, let’s say we have a function that greets people by name and we
want to test that the name we pass into the function appears in the output:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}
</code></pre>
<p>The requirements for this program haven’t been agreed upon yet, and we’re
pretty sure the <code>Hello</code> text at the beginning of the greeting will change. We
decided we don’t want to have to update the test when the requirements change,
so instead of checking for exact equality to the value returned from the
<code>greeting</code> function, we’ll just assert that the output contains the text of the
input parameter.</p>
<p>Now let’s introduce a bug into this code by changing <code>greeting</code> to exclude
<code>name</code> to see what the default test failure looks like:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting(&quot;Carol&quot;);
</span><span class="boring">        assert!(result.contains(&quot;Carol&quot;));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Running this test produces the following:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'assertion failed: result.contains(\&quot;Carol\&quot;)', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>This result just indicates that the assertion failed and which line the
assertion is on. A more useful failure message would print the value from the
<code>greeting</code> function. Let’s add a custom failure message composed of a format
string with a placeholder filled in with the actual value we got from the
<code>greeting</code> function:</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from(&quot;Hello!&quot;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(
            result.contains(&quot;Carol&quot;),
            &quot;Greeting did not contain name, value was `{}`&quot;,
            result
        );
    }
<span class="boring">}
</span></code></pre>
<p>Now when we run the test, we’ll get a more informative error message:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'Greeting did not contain name, value was `Hello!`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>We can see the value we actually got in the test output, which would help us
debug what happened instead of what we were expecting to happen.</p>
<h3 id="checking-for-panics-with-should_panic"><a class="header" href="#checking-for-panics-with-should_panic">Checking for Panics with <code>should_panic</code></a></h3>
<p>In addition to checking return values, it’s important to check that our code
handles error conditions as we expect. For example, consider the <code>Guess</code> type
that we created in Chapter 9, Listing 9-13. Other code that uses <code>Guess</code>
depends on the guarantee that <code>Guess</code> instances will contain only values
between 1 and 100. We can write a test that ensures that attempting to create a
<code>Guess</code> instance with a value outside that range panics.</p>
<p>We do this by adding the attribute <code>should_panic</code> to our test function. The
test passes if the code inside the function panics; the test fails if the code
inside the function doesn’t panic.</p>
<p>Listing 11-8 shows a test that checks that the error conditions of <code>Guess::new</code>
happen when we expect them to.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
</code></pre>
<p><span class="caption">Listing 11-8: Testing that a condition will cause a
<code>panic!</code></span></p>
<p>We place the <code>#[should_panic]</code> attribute after the <code>#[test]</code> attribute and
before the test function it applies to. Let’s look at the result when this test
passes:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Looks good! Now let’s introduce a bug in our code by removing the condition
that the <code>new</code> function will panic if the value is greater than 100:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>When we run the test in Listing 11-8, it will fail:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>We don’t get a very helpful message in this case, but when we look at the test
function, we see that it’s annotated with <code>#[should_panic]</code>. The failure we got
means that the code in the test function did not cause a panic.</p>
<p>Tests that use <code>should_panic</code> can be imprecise. A <code>should_panic</code> test would
pass even if the test panics for a different reason from the one we were
expecting. To make <code>should_panic</code> tests more precise, we can add an optional
<code>expected</code> parameter to the <code>should_panic</code> attribute. The test harness will
make sure that the failure message contains the provided text. For example,
consider the modified code for <code>Guess</code> in Listing 11-9 where the <code>new</code> function
panics with different messages depending on whether the value is too small or
too large.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                &quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                value
            );
        } else if value &gt; 100 {
            panic!(
                &quot;Guess value must be less than or equal to 100, got {}.&quot;,
                value
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
</code></pre>
<p><span class="caption">Listing 11-9: Testing for a <code>panic!</code> with a particular
panic message</span></p>
<p>This test will pass because the value we put in the <code>should_panic</code> attribute’s
<code>expected</code> parameter is a substring of the message that the <code>Guess::new</code>
function panics with. We could have specified the entire panic message that we
expect, which in this case would be <code>Guess value must be less than or equal to 100, got 200.</code> What you choose to specify depends on how much of the panic
message is unique or dynamic and how precise you want your test to be. In this
case, a substring of the panic message is enough to ensure that the code in the
test function executes the <code>else if value &gt; 100</code> case.</p>
<p>To see what happens when a <code>should_panic</code> test with an <code>expected</code> message
fails, let’s again introduce a bug into our code by swapping the bodies of the
<code>if value &lt; 1</code> and the <code>else if value &gt; 100</code> blocks:</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                &quot;Guess value must be less than or equal to 100, got {}.&quot;,
                value
            );
        } else if value &gt; 100 {
            panic!(
                &quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                value
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>This time when we run the <code>should_panic</code> test, it will fail:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'main' panicked at 'Guess value must be greater than or equal to 1, got 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `&quot;Guess value must be greater than or equal to 1, got 200.&quot;`,
 expected substring: `&quot;Guess value must be less than or equal to 100&quot;`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>The failure message indicates that this test did indeed panic as we expected,
but the panic message did not include the expected string <code>'Guess value must be less than or equal to 100'</code>. The panic message that we did get in this case was
<code>Guess value must be greater than or equal to 1, got 200.</code> Now we can start
figuring out where our bug is!</p>
<h3 id="using-resultt-e-in-tests"><a class="header" href="#using-resultt-e-in-tests">Using <code>Result&lt;T, E&gt;</code> in Tests</a></h3>
<p>Our tests so far all panic when they fail. We can also write tests that use
<code>Result&lt;T, E&gt;</code>! Here’s the test from Listing 11-1, rewritten to use <code>Result&lt;T, E&gt;</code> and return an <code>Err</code> instead of panicking:</p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;two plus two does not equal four&quot;))
        }
    }
}
</code></pre>
<p>The <code>it_works</code> function now has the <code>Result&lt;(), String&gt;</code> return type. In the
body of the function, rather than calling the <code>assert_eq!</code> macro, we return
<code>Ok(())</code> when the test passes and an <code>Err</code> with a <code>String</code> inside when the test
fails.</p>
<p>Writing tests so they return a <code>Result&lt;T, E&gt;</code> enables you to use the question
mark operator in the body of tests, which can be a convenient way to write
tests that should fail if any operation within them returns an <code>Err</code> variant.</p>
<p>You can’t use the <code>#[should_panic]</code> annotation on tests that use <code>Result&lt;T, E&gt;</code>. To assert that an operation returns an <code>Err</code> variant, <em>don’t</em> use the
question mark operator on the <code>Result&lt;T, E&gt;</code> value. Instead, use
<code>assert!(value.is_err())</code>.</p>
<p>Now that you know several ways to write tests, let’s look at what is happening
when we run our tests and explore the different options we can use with <code>cargo test</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="testlerin-nasıl-Çalıştırıldığını-kontrol-etme"><a class="header" href="#testlerin-nasıl-Çalıştırıldığını-kontrol-etme">Testlerin Nasıl Çalıştırıldığını Kontrol Etme</a></h2>
<p>Tıpkı <code>cargo run</code>'un kodunuzu derlemesi ve ardından ortaya çıkan ikili dosyayı çalıştırması gibi, 
<code>cargo test</code> de kodunuzu test modunda derler ve ortaya çıkan test ikili dosyasını çalıştırır. 
<code>cargo test</code> tarafından üretilen ikilinin varsayılan davranışı, tüm testleri paralel olarak çalıştırmak ve test çalıştırmaları 
sırasında üretilen çıktıyı yakalamak, çıktının görüntülenmesini önlemek ve test sonuçlarıyla ilgili çıktıyı okumayı kolaylaştırmaktır. 
Bununla birlikte, bu varsayılan davranışı değiştirmek için komut satırı seçenekleri belirleyebilirsiniz.</p>
<p>Bazı komut satırı seçenekleri <code>cargo test</code>'e, bazıları ise elde edilen test ikilisine gider. 
Bu iki tür argümanı ayırmak için, <code>cargo test</code>'e giden argümanları ve ardından ayırıcıyı <code>--</code> ve ardından test ikilisine gidenleri 
listelersiniz. <code>cargo test --help</code> komutunu çalıştırdığınızda <code>cargo test</code> ile kullanabileceğiniz seçenekler görüntülenir 
ve <code>cargo test -- --help</code> komutunu çalıştırdığınızda ayırıcıdan sonra kullanabileceğiniz seçenekler görüntülenir.</p>
<h3 id="testleri-paralel-veya-ardışık-olarak-Çalıştırma"><a class="header" href="#testleri-paralel-veya-ardışık-olarak-Çalıştırma">Testleri Paralel veya Ardışık Olarak Çalıştırma</a></h3>
<p>Birden fazla test çalıştırdığınızda, varsayılan olarak iş parçacıkları kullanılarak paralel olarak çalışırlar, 
yani daha hızlı çalışırlar ve daha hızlı geri bildirim alırsınız. Testler aynı anda çalıştığından, 
testlerinizin birbirlerine veya geçerli çalışma dizini veya ortam değişkenleri gibi paylaşılan bir ortam da dahil 
olmak üzere herhangi bir paylaşılan duruma bağlı olmadığından emin olmalısınız.</p>
<p>Örneğin, testlerinizin her birinin diskte <em>test-output.txt</em> adında bir dosya oluşturan ve bu dosyaya bazı veriler yazan bir 
kod çalıştırdığını varsayalım. Ardından her test bu dosyadaki verileri okur ve dosyanın her testte farklı olan belirli bir değer 
içerdiğini iddia eder. Testler aynı anda çalıştığından, bir testin dosyayı yazması ve okuması arasında geçen sürede bir test dosyanın 
üzerine yazabilir. Bu durumda ikinci test, kod hatalı olduğu için değil, testler paralel olarak çalışırken birbirine karıştığı 
için başarısız olacaktır. Bir çözüm, her testin farklı bir dosyaya yazdığından emin olmaktır; başka bir çözüm ise testleri teker teker çalıştırmaktır.</p>
<p>Testleri paralel olarak çalıştırmak istemiyorsanız veya kullanılan iş parçacığı sayısı üzerinde daha ayrıntılı kontrol istiyorsanız, 
<code>--test-threads</code> bayrağını ve kullanmak istediğiniz iş parçacığı sayısını test ikilisine gönderebilirsiniz. </p>
<p>Aşağıdaki örneğe bir göz atın:</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>Test iş parçacığı sayısını <code>1</code> olarak ayarladık ve programa herhangi bir paralellik kullanmamasını söyledik. 
Testleri tek bir iş parçacığı kullanarak çalıştırmak, paralel olarak çalıştırmaktan daha uzun sürecektir, 
ancak testler durumu paylaşırlarsa birbirlerini etkilemeyeceklerdir.</p>
<h3 id="fonksiyon-Çıktısını-gösterme"><a class="header" href="#fonksiyon-Çıktısını-gösterme">Fonksiyon Çıktısını Gösterme</a></h3>
<p>Varsayılan olarak, bir test geçerse, Rust'ın test kütüphanesi standart çıktıya yazdırılan her şeyi yakalar. 
Örneğin, bir testte <code>println!</code> komutunu çağırırsak ve test geçerse, uçbirimde <code>println!</code> çıktısını görmeyiz; yalnızca testin 
geçtiğini gösteren satırı görürüz. Bir test başarısız olursa, <em>başarısız</em> mesajının geri kalanıyla birlikte 
standart çıktıya ne yazdırıldıysa onu görürüz.</p>
<p>Örnek olarak, Liste 11-10'da parametresinin değerini yazdıran ve <code>10</code> döndüren saçma bir fonksiyonun yanı sıra başarılı 
olan bir test ve başarısız olan bir test vardır.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!(&quot;I got the value {}&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
</code></pre>
<p><span class="caption">Liste 11-10: <code>println!</code> çağrısı yapan bir fonksiyon için testler</span></p>
<p>Bu testleri <code>cargo test</code> ile çalıştırdığımızda aşağıdaki çıktıyı göreceğiz:</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Bu çıktının hiçbir yerinde <code>I got the value 4</code> ifadesini görmediğimize dikkat edin; 
bu, geçen test çalıştırıldığında yazdırılan değerdir. Bu çıktı yakalanmıştır. Başarısız olan testin çıktısı, 
<code>I got the value 8</code>, test özeti çıktısının test başarısızlığının nedenini de gösteren bölümünde görünür.</p>
<p>Geçen testler için de yazdırılan değerleri görmek istiyorsak, Rust'a <code>--show-output</code> ile başarılı testlerin 
çıktısını da en sonunda göstermesini söyleyebiliriz.</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>Liste 11-10'daki testleri <code>--show-output</code> bayrağı ile tekrar çalıştırdığımızda aşağıdaki çıktıyı görüyoruz:</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
I got the value 4


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<h3 id="bir-test-alt-kümesini-ada-göre-Çalıştırma"><a class="header" href="#bir-test-alt-kümesini-ada-göre-Çalıştırma">Bir Test Alt Kümesini Ada Göre Çalıştırma</a></h3>
<p>Bazen tam bir test paketi çalıştırmak uzun zaman alabilir. Belirli bir alandaki kod üzerinde çalışıyorsanız, 
yalnızca o kodla ilgili testleri çalıştırmak isteyebilirsiniz. Çalıştırmak istediğiniz test(ler)in adını veya adlarını 
<code>cargo test</code>'e argüman olarak ileterek hangi testlerin çalıştırılacağını seçebilirsiniz.</p>
<p>Testlerin bir alt kümesinin nasıl çalıştırılacağını göstermek için, önce Liste 11-11'de gösterildiği gibi <code>add_two</code> 
fonksiyonumuz için üç test oluşturacağız ve hangilerinin çalıştırılacağını seçeceğiz.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
</code></pre>
<p><span class="caption">Liste 11-11: Üç farklı isimle üç test</span></p>
<p>Testleri daha önce gördüğümüz gibi herhangi bir argüman geçmeden çalıştırırsak, tüm testler paralel olarak çalışacaktır:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<h4 id="tekdüze-testleri-Çalıştırma"><a class="header" href="#tekdüze-testleri-Çalıştırma">Tekdüze Testleri Çalıştırma</a></h4>
<p>Yalnızca bu testi çalıştırmak için herhangi bir test fonksiyonunun adını <code>cargo test</code>'e geçirebiliriz:</p>
<pre><code class="language-console">$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s

</code></pre>
<p>Sadece <code>one_hundred</code> isimli test çalıştı; diğer iki test bu isimle eşleşmedi. 
Test çıktısı, sonunda filtrelenen <code>2</code>'yi görüntüleyerek çalışmayan daha fazla testimiz olduğunu bilmemizi sağlar.</p>
<p>Bu şekilde birden fazla testin adını belirtemeyiz; yalnızca <code>cargo test</code>'e verilen ilk değer kullanılır. 
Ancak birden fazla test çalıştırmanın bir yolu var.</p>
<h4 id="birden-fazla-test-Çalıştırmak-için-filtreleme"><a class="header" href="#birden-fazla-test-Çalıştırmak-için-filtreleme">Birden Fazla Test Çalıştırmak için Filtreleme</a></h4>
<p>Bir test adının bir kısmını belirtebiliriz ve adı bu değerle eşleşen herhangi bir test çalıştırılır. 
Örneğin,testlerimizden ikisinin adı <code>add</code> içerdiğinden, bu ikisini <code>cargo test add</code> komutuyla çalıştırabiliriz:</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

</code></pre>
<p>Bu komut, adında add olan tüm testleri çalıştırır ve <code>one_hundred</code> adlı testi filtreler. 
Ayrıca, bir testin göründüğü modülün testin adının bir parçası haline geldiğini unutmayın, 
bu nedenle modülün adına göre filtreleme yaparak bir modüldeki tüm testleri çalıştırabiliriz.</p>
<h3 id="Özel-olarak-İstenmedikçe-bazı-testleri-yok-sayma"><a class="header" href="#Özel-olarak-İstenmedikçe-bazı-testleri-yok-sayma">Özel Olarak İstenmedikçe Bazı Testleri Yok Sayma</a></h3>
<p>Bazen belirli birkaç testin yürütülmesi çok zaman alıcı olabilir, bu nedenle <code>cargo test</code>'in çoğu çalıştırması 
sırasında bunları hariç tutmak isteyebilirsiniz. Çalıştırmak istediğiniz tüm testleri argüman olarak listelemek yerine, 
zaman alan testleri burada gösterildiği gibi dışlamak için <code>ignore</code> niteliğini kullanarak açıklama ekleyebilirsiniz:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
</code></pre>
<p><code>#[test]</code>'ten sonra, hariç tutmak istediğimiz teste <code>#[ignore]</code> satırını ekliyoruz. 
Testlerimizi çalıştırdığımızda <code>it_works</code> çalışıyor, ancak <code>expensive_test</code> çalışmıyor:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p><code>expensive_test</code> fonksiyonu <code>ignored</code> olarak listeleniyor. Yalnızca göz ardı edilen testleri çalıştırmak istiyorsak, 
<code>cargo test -- --ignored</code>'u kullanabiliriz:</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Hangi testlerin çalışacağını kontrol ederek, <code>cargo test</code> sonuçlarınızın hızlı olmasını sağlayabilirsiniz. 
Yok sayılan testlerin sonuçlarını kontrol etmenin mantıklı olduğu bir noktaya geldiğinizde ve sonuçları beklemek için zamanınız 
olduğunda, bunun yerine <code>cargo test -- --ignored</code> komutunu çalıştırabilirsiniz. 
Yok sayılsın ya da sayılmasın tüm testleri çalıştırmak istiyorsanız, <code>cargo test -- --include-ignored</code> komutunu çalıştırabilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="test-organizasyonu"><a class="header" href="#test-organizasyonu">Test Organizasyonu</a></h2>
<p>Bölümün başında da belirtildiği gibi, test karmaşık bir disiplindir ve farklı kişiler farklı terminoloji ve organizasyon kullanmaktadır. 
Rust topluluğu testleri iki ana kategoride ele alır: birim testleri ve entegrasyon testleri. Birim testleri küçük ve daha odaklıdır, 
her seferinde tek bir modülü izole olarak test eder ve özel arayüzleri test edebilir. Entegrasyon testleri kütüphanenizin tamamen dışındadır 
ve kodunuzu diğer harici kodlarla aynı şekilde kullanır, yalnızca genel arayüzü kullanır ve potansiyel olarak test başına birden fazla modülü test eder.</p>
<p>Her iki tür testin de yazılması, kütüphanenizin parçalarının ayrı ayrı ve birlikte beklediğiniz şeyi yaptığından emin olmak için önemlidir.</p>
<h3 id="birim-testleri"><a class="header" href="#birim-testleri">Birim Testleri</a></h3>
<p>Birim testlerinin amacı, kodun nerede beklendiği gibi çalışıp çalışmadığını hızlı bir şekilde belirlemek için her bir kod birimini 
kodun geri kalanından ayrı olarak test etmektir. Birim testlerini, test ettikleri kodun bulunduğu her dosyanın <em>src</em> dizinine koyarsınız. 
Alışılagelmiş yöntem, her dosyada test işlevlerini içerecek <code>tests</code> adında bir modül oluşturmak ve modüle <code>cfg(test)</code> ile açıklama eklemektir.</p>
<h4 id="testler-modülü-ve-cfgtest"><a class="header" href="#testler-modülü-ve-cfgtest">Testler Modülü ve <code>#[cfg(test)]</code></a></h4>
<p><code>tests</code> modülündeki <code>#[cfg(test)]</code> ek açıklaması, Rust'a test kodunu yalnızca <code>cargo test</code>'i çalıştırdığınızda derlemesini ve 
çalıştırmasını söyler, <code>cargo build</code>'i çalıştırdığınızda değil. Bu, yalnızca kütüphaneyi derlemek istediğinizde derleme süresinden 
tasarruf sağlar ve testler dahil edilmediği için sonuçta derlenen yapıda yer tasarrufu sağlar. Entegrasyon testleri farklı bir dizine 
gittiği için <code>#[cfg(test)]</code> ek açıklamasına ihtiyaç duymadıklarını göreceksiniz. Ancak, birim testleri kodla aynı dosyalara girdiği için, 
derlenen sonuca dahil edilmemeleri gerektiğini belirtmek için <code>#[cfg(test)]</code> kullanacaksınız.</p>
<p>Bu bölümün ilk kısmında yeni <code>adder</code> projesini oluşturduğumuzda, Cargo'nun bu kodu bizim için oluşturduğunu hatırlayın:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
</code></pre>
<p>Bu kod otomatik olarak oluşturulan test modülüdür. <code>cfg</code> niteliği <em>yapılandırma</em> anlamına gelir ve 
Rust'a aşağıdaki öğenin yalnızca belirli bir yapılandırma seçeneği verildiğinde dahil edilmesi gerektiğini söyler. 
Bu durumda, <em>yapılandırma</em> seçeneği, testlerin derlenmesi ve çalıştırılması için Rust tarafından sağlanan <code>test</code>'tir. 
<code>cfg</code> niteliğini kullanarak, <code>cargo test</code> kodumuzu yalnızca testleri <code>cargo test</code> ile aktif olarak çalıştırırsak derler. 
Bu, <code>#[test]</code> ile açıklanan fonksiyonlara ek olarak, bu modül içinde olabilecek tüm yardımcı fonksiyonları içerir.</p>
<h4 id="Özel-fonksiyonları-test-etme"><a class="header" href="#Özel-fonksiyonları-test-etme">Özel Fonksiyonları Test Etme</a></h4>
<p>Test topluluğu içinde gizli fonksiyonların doğrudan test edilip edilmemesi gerektiği konusunda tartışmalar vardır ve 
diğer diller gizli fonksiyonları test etmeyi zorlaştırır veya imkansız hale getirir. Hangi test ideolojisine bağlı olursanız olun, 
Rust'ın gizlilik kuralları gizli fonksiyonları test etmenize izin verir. Liste 11-12'deki kodu gizli fonksiyon <code>internal_adder</code> ile 
birlikte düşünün.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
</code></pre>
<p><span class="caption">Liste 11-12: Özel bir fonksiyonu test etme</span></p>
<p><code>internal_adder</code> fonksiyonunun <code>pub</code> olarak işaretlenmediğine dikkat edin. Testler sadece Rust kodudur ve <code>test</code> modülü sadece başka bir modüldür. 
<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Modül Ağacında Bir Öğeye Başvurma Yolları”</a><!-- ignore --> bölümünde tartıştığımız gibi, alt modüllerdeki öğeler ata 
modüllerindeki öğeleri kullanabilir. Bu testte, <code>test</code> modülünün ebeveyninin tüm öğelerini <code>use super::*</code> ile kapsama alırız ve 
ardından test <code>internal_adder</code>'ı çağırabilir. Gizli fonksiyonların test edilmemesi gerektiğini düşünüyorsanız, 
Rust'ta sizi bunu yapmaya zorlayacak hiçbir şey yoktur.</p>
<h3 id="entegrasyon-testleri"><a class="header" href="#entegrasyon-testleri">Entegrasyon Testleri</a></h3>
<p>Rust'ta entegrasyon testleri kütüphanenizin tamamen dışındadır. Kütüphanenizi diğer kodlarla aynı şekilde kullanırlar, 
yani yalnızca kütüphanenizin genel API'sinin bir parçası olan fonksiyonları çağırabilirler. Amaçları, kütüphanenizin birçok parçasının 
birlikte doğru çalışıp çalışmadığını test etmektir. Kendi başlarına doğru çalışan kod birimleri entegre edildiğinde sorun yaşayabilir, 
bu nedenle entegre kodun test kapsamı da önemlidir. Entegrasyon testleri oluşturmak için öncelikle bir test dizinine ihtiyacınız vardır.</p>
<h4 id="tests-dizini"><a class="header" href="#tests-dizini"><em>tests</em> Dizini</a></h4>
<p><em>tests</em> dizinindeki her dosya ayrı bir kasadır, bu nedenle kütüphanemizi her test kasasının kapsamına getirmemiz gerekir. 
Bu nedenle, birim testlerinde ihtiyaç duymadığımız <code>use adder</code>'ı kodun en üstüne ekliyoruz.</p>
<p><em>tests/integration_test.rs</em> içindeki herhangi bir koda <code>#[cfg(test)]</code> ile açıklama eklememize gerek yok.
Cargo, <em>tests</em> dizinini özel olarak ele alır ve bu dizindeki dosyaları yalnızca <code>cargo test</code>'i çalıştırdığımızda derler.
Şimdi <code>cargo test</code>'i çalıştırın:</p>
<p><span class="filename">Dosya adı: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p><span class="caption">Liste 11-13: <code>adder</code> kasasındaki bir fonksiyonun 
entegrasyon testi</span></p>
<p>Çıktının üç bölümü birim testlerini, entegrasyon testini ve dokümantasyon testlerini içerir. 
Birim testleri için ilk bölüm gördüğümüzle aynıdır: her birim testi için bir satır (Liste 11-12'de eklediğimiz <code>internal</code> adlı bir satır) 
ve ardından birim testleri için bir özet satırı.</p>
<p>Entegrasyon testleri bölümü <code>Running tests/integration_test.rs</code> satırıyla başlar. Ardından, bu entegrasyon testindeki her bir test 
fonksiyonu için bir satır ve <code>Doc-tests adder</code> bölümü başlamadan hemen önce entegrasyon testinin sonuçları için bir özet satırı vardır.</p>
<p>Her entegrasyon testi dosyasının kendi bölümü vardır, bu nedenle <em>tests</em> dizinine daha fazla dosya eklersek, 
daha fazla entegrasyon testi bölümü olacaktır.</p>
<p>Test fonksiyonunun adını <code>cargo test</code>'e argüman olarak belirterek belirli bir entegrasyon testi fonksiyonunu çalıştırabiliriz. 
Belirli bir entegrasyon testi dosyasındaki tüm testleri çalıştırmak için, <code>cargo test</code>'in <code>--test</code> argümanını ve ardından dosyanın adını kullanın:</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Bu komut yalnızca <em>tests/integration_test.rs</em> dosyasındaki testleri çalıştırır.</p>
<h4 id="entegrasyon-testlerinde-alt-modüller"><a class="header" href="#entegrasyon-testlerinde-alt-modüller">Entegrasyon Testlerinde Alt Modüller</a></h4>
<p>Daha fazla entegrasyon testi ekledikçe, bunları düzenlemeye yardımcı olmak için <em>tests</em> dizininde daha fazla dosya oluşturmak isteyebilirsiniz; 
örneğin, test fonksiyonlarını test ettikleri işlevselliğe göre gruplayabilirsiniz. Daha önce de belirtildiği gibi, 
<em>tests</em> dizinindeki her dosya kendi içinde ayrı kasa olarak derlenir, bu da son kullanıcıların kasanızı kullanma şeklini daha yakından 
taklit etmek için ayrı kapsamlar oluşturmak için kullanışlıdır. Ancak bu, Bölüm 7'de kodu modüllere ve dosyalara nasıl ayıracağınızı 
öğrendiğiniz gibi, <em>tests</em> dizinindeki dosyaların <em>src</em>'deki dosyalarla aynı davranışı paylaşmadığı anlamına gelir.</p>
<p><em>tests</em> dizini dosyalarının farklı davranışı en çok, birden fazla entegrasyon test dosyasında kullanılacak bir dizi yardımcı 
fonksiyonunuz olduğunda ve bunları ortak bir modüle çıkarmak için 
Bölüm 7'deki <a href="ch07-05-separating-modules-into-different-files.html">“Modülleri Farklı Dosyalara Ayırma”</a><!-- ignore --> bölümündeki adımları izlemeye 
çalıştığınızda fark edilir. Örneğin, <em>tests/common.rs</em> dosyasını oluşturur ve içine <code>setup</code> adında bir fonksiyon yerleştirirsek, 
<code>setup</code> dosyasına test dosyalarındaki test fonksiyonlarından çağırmak istediğimiz bazı kodlar ekleyebiliriz:</p>
<p><span class="filename">Dosya adı: tests/common.rs</span></p>
<pre><code class="language-rust noplayground">pub fn setup() {
    // setup code specific to your library's tests would go here
}
</code></pre>
<p>Testleri tekrar çalıştırdığımızda, <em>common.rs</em> dosyası için test çıktısında yeni bir bölüm göreceğiz, 
ancak bu dosya herhangi bir test fonksiyonu içermiyor ve <code>setup</code> fonksiyonunu herhangi bir yerden çağırmadık:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Test sonuçlarında yaygın olarak <code>running 0 tests</code>'in görüntülenmesi istediğimiz şey değildi. 
Sadece bazı kodları diğer entegrasyon test dosyalarıyla paylaşmak istedik.</p>
<p><code>common</code>'ın test çıktısında görünmesini önlemek için <em>tests/common.rs</em> oluşturmak yerine <em>tests/common/mod.rs</em> oluşturacağız. 
Bu, Rust'ın da anladığı alternatif bir adlandırma kuralıdır. Dosyayı bu şekilde adlandırmak, Rust'a <code>common</code> modülünü bir entegrasyon test 
dosyası olarak ele almamasını söyler. <code>setup</code> fonksiyonu kodunu <em>tests/common/mod.rs</em> dosyasına taşıdığımızda ve <em>tests/common.rs</em> dosyasını sildiğimizde, test çıktısındaki bölüm artık görünmeyecektir. <em>tests</em> dizininin alt dizinlerinde yer alan dosyalar ayrı kasalar olarak derlenmez 
veya test çıktısında bölümlere sahip olmaz.</p>
<p><em>tests/common/mod.rs</em> dosyasını oluşturduktan sonra, bunu entegrasyon test dosyalarından herhangi birinde modül olarak kullanabiliriz. 
Aşağıda, <em>tests/integration_test.rs</em> dosyasındaki <code>it_adds_two</code> testinden <code>setup</code> fonksiyonunun çağrılmasına bir örnek verilmiştir:</p>
<p><span class="filename">Dosya adı: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p><code>mod common;</code> bildiriminin Liste 7-21'de gösterdiğimiz modül bildirimiyle aynı olduğuna dikkat edin. 
Daha sonra test fonksiyonunda <code>common::setup()</code> fonksiyonunu çağırabiliriz.</p>
<h4 id="İkili-kasalar-için-entegrasyon-testleri"><a class="header" href="#İkili-kasalar-için-entegrasyon-testleri">İkili Kasalar için Entegrasyon Testleri</a></h4>
<p>Projemiz yalnızca bir <em>src/main.rs</em> dosyası içeren ve bir <em>src/lib.rs</em> dosyasına sahip olmayan ikili bir kasaysa, 
<em>tests</em> dizininde entegrasyon testleri oluşturamaz ve <em>src/main.rs</em> dosyasında tanımlanan fonksiyonları bir <code>use</code> ifade yapısı ile kapsama alamayız. 
Yalnızca kütüphane kasaları diğer kasaların kullanabileceği fonksiyonları açığa çıkarır; ikili kasalar kendi başlarına çalıştırılmak üzere tasarlanmıştır.</p>
<p>Bu, bir ikili dosya sağlayan Rust projelerinin <em>src/lib.rs</em> dosyasında bulunan mantığı çağıran basit bir 
<em>src/main.rs</em> dosyasına sahip olmasının nedenlerinden biridir. Bu yapıyı kullanarak entegrasyon testleri, 
önemli fonksiyonları kullanılabilir hale getirmek için kütüphane kasasını kullanarak test edebilir. 
Önemli işlevsellik çalışırsa, <em>src/main.rs</em> dosyasındaki az miktarda kod da çalışacaktır ve bu az miktarda kodun test edilmesi gerekmez.</p>
<h2 id="Özet-7"><a class="header" href="#Özet-7">Özet</a></h2>
<p>Rust'ın test özellikleri, siz değişiklik yapsanız bile kodun beklediğiniz gibi çalışmaya devam etmesini sağlamak 
için kodun nasıl çalışması gerektiğini belirtmenin bir yolunu sunar. Birim testleri, bir kütüphanenin farklı bölümlerini 
ayrı ayrı çalıştırır ve özel uygulama ayrıntılarını test edebilir. Entegrasyon testleri, kütüphanenin birçok parçasının 
birlikte doğru çalışıp çalışmadığını kontrol eder ve kodu harici kodun kullanacağı şekilde test etmek için kütüphanenin 
genel API'sini kullanır. Rust'ın tür sistemi ve sahiplik kuralları bazı hata türlerini önlemeye yardımcı olsa da,
kodunuzun nasıl davranması beklendiğiyle ilgili mantık hatalarını azaltmak için testler hala önemlidir.</p>
<p>Bu bölümde ve önceki bölümlerde öğrendiğiniz bilgileri bir proje üzerinde çalışmak için birleştirelim!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bir-gÇ-projesi-bir-komut-satırı-programı-yazmak"><a class="header" href="#bir-gÇ-projesi-bir-komut-satırı-programı-yazmak">Bir G/Ç Projesi: Bir Komut Satırı Programı Yazmak</a></h1>
<p>Bu bölüm, şimdiye kadar öğrendiğiniz birçok becerinin bir özeti ve birkaç standart 
kütüphane özelliğinin daha keşfidir. Şu anda sahip olduğunuz bazı Rust 
konseptlerini süreklemek için dosya ve komut satırı giriş/çıkış ile etkileşime giren 
bir komut satırı aracı oluşturacağız.</p>
<p>Rust'ın hızı, güvenliği, tek ikili yürütülebilir çıktısı ve platformlar arası desteği, 
onu komut satırı araçları oluşturmak için ideal bir dil haline getiriyor, bu nedenle projemiz için 
klasik komut satırı arama aracı <code>grep</code>'in (<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint) kendi sürümümüzü yapacağız. En basit kullanım durumunda, <code>grep</code>, belirtilen bir dize için belirtilen bir dosyayı arar. 
Bunu yapmak için <code>grep</code>, argümanları olarak bir dosya adı ve bir dizgi alır. Sonra dosyayı okur, 
o dosyada dizgi argümanını içeren satırları bulur ve bu satırları yazdırır.</p>
<p>Bu arada, komut satırı aracımızın diğer birçok komut satırı aracının kullandığı üçbirim özelliklerini kullanmasını nasıl sağlayacağımızı göstereceğiz. Kullanıcının aracımızın davranışını yapılandırmasına izin vermek için bir ortam 
değişkeninin değerini okuyacağız. Ayrıca hata mesajlarını standart çıktı (<code>stdout</code>) yerine standart hata konsolu 
akışına (<code>stderr</code>) yazdıracağız, böylece kullanıcı ekranda hata mesajlarını görmeye devam ederken başarılı çıktıyı bir dosyaya yönlendirebilir.</p>
<p>Bir Rust topluluğu üyesi olan Andrew Gallant, <code>ripgrep</code> adlı tam özellikli, çok hızlı bir <code>grep</code> sürümü oluşturmuştur. Karşılaştırıldığında, bizim versiyonumuz oldukça basit olacak, ancak bu bölüm size <code>ripgrep</code> gibi gerçek dünyadaki bir projeyi anlamak için ihtiyaç duyduğunuz bazı arka plan bilgilerini verecektir.</p>
<ul>
<li>Kodu organize etmek (<a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">Bölüm 7</a><!--
  ignore -->'de modüllerle ilgili öğrendiklerinizi kullanarak)</li>
<li>Vektörleri ve dizgileri kullanmak (<a href="ch08-00-common-collections.html">Bölüm 8</a><!-- ignore -->'deki koleksiyonlar)</li>
<li>Hataları işlemek (<a href="ch09-00-error-handling.html">Bölüm 9</a><!-- ignore -->)</li>
<li>Uygun yerlerde tanımları ve ömürlükleri kullanmak (<a href="ch10-00-generics.html">Bölüm 10</a><!-- ignore
  -->)</li>
<li>Testler yazmak (<a href="ch11-00-testing.html">Bölüm 11</a><!-- ignore -->)</li>
</ul>
<p>Ayrıca Bölüm <a href="ch13-00-functional-features.html">13</a><!-- ignore --> ve <a href="ch17-00-oop.html">17</a><!-- ignore -->'de ayrıntılı olarak ele alınacak olan kapanışları, 
yineleyicileri ve tanım nesnelerini kısaca tanıtacağız.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="komut-satırı-argümanlarını-kabul-etme"><a class="header" href="#komut-satırı-argümanlarını-kabul-etme">Komut Satırı Argümanlarını Kabul Etme</a></h2>
<p>Her zaman olduğu gibi <code>cargo new</code> ile yeni bir proje oluşturalım. Sisteminizde mevcut olabilecek <code>grep</code> 
aracıyla çakışmaması için projemizi <code>minigrep</code> olarak adlandıracağız</p>
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>İlk görev, <code>minigrep</code>'in iki komut satırı argümanını kabul etmesini sağlamaktır: 
dosya adı ve aranacak bir dize. Yani, programımızı <code>cargo run</code>'la, aranacak bir dize ve aranacak bir 
dosyanın yolu ile çalıştırabilmek istiyoruz, şunun gibi:</p>
<pre><code class="language-console">$ cargo run searchstring example-filename.txt
</code></pre>
<p>Şu anda, <code>cargo new</code> tarafından oluşturulan program, ona verdiğimiz argümanları işleyemiyor. 
<a href="https://crates.io/">crates.io</a>'daki bazı mevcut kütüphaneler, komut satırı argümanlarını kabul eden bir program yazmaya yardımcı olabilir, 
ancak bu kavramı yeni öğrendiğiniz için, hadi bunu kendimiz sürekleyelim.</p>
<h3 id="argüman-değerlerini-okumak"><a class="header" href="#argüman-değerlerini-okumak">Argüman Değerlerini Okumak</a></h3>
<p><code>minigrep</code>'in kendisine ilettiğimiz komut satırı argümanlarının değerlerini okumasını sağlamak için, 
Rust'ın standart kütüphanesinde bulunan <code>std::env::args</code> fonksiyonuna ihtiyacımız olacak. 
Bu fonksiyon, <code>minigrep</code>'e iletilen komut satırı argümanlarının bir yineleyicisini döndürür. 
<a href="ch13-00-functional-features.html">Bölüm 13</a><!-- ignore
-->'te yineleyicileri tam olarak ele alacağız. Şimdilik, yineleyiciler hakkında yalnızca iki ayrıntıyı bilmeniz gerekir: 
yineleyiciler bir dizi değer üretir ve bir yineleyicide onu bir koleksiyona dönüştürmek için <code>collect</code> metodunu çağırabiliriz, 
örneğin: yineleyicinin ürettiği tüm öğeleri içeren vektör.</p>
<p>Liste 12-1'deki kod, <code>minigrep</code> programınızın kendisine iletilen herhangi bir komut satırı argümanını okumasını ve 
ardından değerleri bir vektörde toplamasını sağlar.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);
}
</code></pre></pre>
<p><span class="caption">Liste 12-1: Komut satırı argümanlarını bir vektörde toplama ve yazdırma</span></p>
<p>İlk olarak, <code>args</code> fonksiyonunu kullanabilmemiz için <code>std::env</code> modülünü <code>use</code> ifade yapısı ile kapsama alıyoruz. 
<code>std::env::args</code> fonksiyonunun iki modül düzeyinde tutuluyor olduğuna dikkat edin. 
<a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths">Bölüm 7</a><!-- ignore -->'de tartıştığımız gibi, istenen fonksiyonun birden fazla modülde iç içe olduğu durumlarda, 
ana modülü fonksiyon yerine kapsama almak gelenekseldir. Bunu yaparak, <code>std::env</code>'deki diğer fonksiyonları kolayca kullanabiliriz. 
Ayrıca <code>use std::env::args</code> eklemekten ve ardından fonksiyonu yalnızca <code>args</code> ile çağırmaktan daha az belirsizdir, 
çünkü <code>arg</code>'ler kolayca geçerli modülde tanımlanan bir fonksiyonla karıştırılabilir.</p>
<blockquote>
<h3 id="args-fonksiyonu-ve-geçersiz-unicode"><a class="header" href="#args-fonksiyonu-ve-geçersiz-unicode"><code>args</code> Fonksiyonu ve Geçersiz Unicode</a></h3>
<p>Herhangi bir argüman geçersiz Unicode içeriyorsa <code>std::env::args</code> öğesinin panikleyeceğini unutmayın. 
Programınızın geçersiz Unicode içeren argümanları kabul etmesi gerekiyorsa, 
bunun yerine <code>std::env::args_os</code> kullanın. Bu fonksiyon, <code>String</code> değerleri yerine <code>OsString</code> değerleri üreten bir 
yineleyici döndürür. Basitlik için burada <code>std::env::args</code> kullanmayı seçtik, çünkü <code>OsString</code> değerleri platforma göre farklılık 
gösterir ve onlarla çalışmak <code>String</code> değerlerinden daha karmaşıktır.</p>
</blockquote>
<p><code>main</code>'in ilk satırında, <code>env::args</code>'ı çağırırız ve yineleyiciyi yineleyici tarafından üretilen tüm değerleri 
içeren bir vektöre dönüştürmek için <code>collect</code> kullanırız. Pek çok türde koleksiyon oluşturmak için <code>collect</code> 
fonksiyonunu kullanabiliriz, bu nedenle bir dizi vektörü istediğimizi belirtmek için açıkça <code>arg</code> türüne açıklama ekleriz. 
Rust'ta türlere çok nadiren açıklama eklememiz gerekse de, <code>collect</code>, genellikle açıklama eklemeniz gereken bir fonksiyondur çünkü Rust, 
istediğiniz koleksiyon türünü çıkaramaz.</p>
<p>Son olarak, vektörü hata ayıklama biçimlendiricisini (<code>:?</code>) kullanarak yazdırırız. 
Kodu önce bağımsız değişken olmadan ve ardından iki bağımsız değişkenle çalıştırmayı deneyelim:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[&quot;target/debug/minigrep&quot;]
</code></pre>
<pre><code class="language-console">$ cargo run needle haystack
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep needle haystack`
[&quot;target/debug/minigrep&quot;, &quot;needle&quot;, &quot;haystack&quot;]
</code></pre>
<p>Vektördeki ilk değerin, ikili dosyamızın adı olan <code>&quot;target/debug/minigrep&quot;</code> olduğuna dikkat edin. 
Bu, programların yürütülürken çağrıldıkları adı kullanmasına izin vererek, 
C'deki argüman listesinin davranışıyla eşleşir. Mesajlarda yazdırmak veya programı çağırmak için 
hangi komut satırı diğer adının kullanıldığına bağlı olarak programın davranışını değiştirmek istemeniz durumunda, 
program adına erişiminiz olması genellikle uygundur. Ancak bu bölümün amaçları doğrultusunda, onu görmezden geleceğiz 
ve yalnızca ihtiyacımız olan iki argümanı kaydedeceğiz.</p>
<h3 id="değişkenlerde-argüman-değerlerini-tutma"><a class="header" href="#değişkenlerde-argüman-değerlerini-tutma">Değişkenlerde Argüman Değerlerini Tutma</a></h3>
<p>Program şu anda komut satırı argümanları olarak belirtilen değerlere erişebilir. 
Şimdi değerleri programın geri kalanında kullanabilmemiz için iki argümanın değerlerini değişkenlere 
kaydetmemiz gerekiyor. Bunu Liste 12-2'de yapıyoruz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    println!(&quot;Searching for {}&quot;, query);
    println!(&quot;In file {}&quot;, filename);
}
</code></pre>
<p><span class="caption">Liste 12-2: Sorgu argümanını ve 
dosya adı argümanını tutmak için değişkenler oluşturma</span></p>
<p>Vektörü yazdırdığımızda gördüğümüz gibi, programın adı <code>args[0]</code>'daki vektördeki ilk değeri alır, 
dolayısıyla argümanları indeks <code>1</code>'den başlatıyoruz. <code>minigrep</code>'in aldığı ilk argüman, aradığımız dizgidir, 
bu yüzden değişken sorgusundaki ilk argümana bir referans koyduk. İkinci argüman dosya adı olacaktır, 
bu yüzden dosya adı değişkenine ikinci argümana bir referans koyduk.</p>
<p>Kodun istediğimiz gibi çalıştığını kanıtlamak için bu değişkenlerin değerlerini geçici olarak yazdırırız. 
Bu programı <code>test</code> ve <code>sample.txt</code> argümanları ile tekrar çalıştıralım:</p>
<pre><code class="language-console">$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>Harika, program çalışıyor! İhtiyacımız olan argümanların değerleri doğru değişkenlere kaydediliyor. 
Daha sonra, örneğin kullanıcının hiçbir argüman sağlamaması gibi bazı olası hatalı 
durumlarla başa çıkmak için bazı hata işleme ekleyeceğiz, şimdilik
bu durumu görmezden geleceğiz ve bunun yerine dosya okuma yetenekleri eklemeye çalışacağız.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dosya-okumak"><a class="header" href="#dosya-okumak">Dosya Okumak</a></h2>
<p>Şimdi, <code>filename</code> argümanında belirtilen dosyayı okumak için işlevsellik ekleyeceğiz. 
İlk olarak, bunu test etmek için örnek bir dosyaya ihtiyacımız var: 
Birkaç satırda metin içeren ve bazı tekrarlanan kelimeler içeren bir dosya kullanacağız. 
Liste 12-3'te işe yarayacak bir Emily Dickinson şiiri var! Projenizin kök dizininde <em>poem.txt</em> adlı bir dosya oluşturun 
ve “Ben Hiçkimse'yim! Sen kimsin?&quot;</p>
<p><span class="filename">Dosya adı: poem.txt</span></p>
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">Liste 12-3: Emily Dickinson'ın bir şiiri iyi bir test örneği yapıyor</span></p>
<p>Metin yerindeyken, <em>src/main.rs</em> dosyasını düzenleyin ve okunacak dosya için kod ekleyin.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">use std::env;
use std::fs;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let query = &amp;args[1];
</span><span class="boring">    let filename = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, query);
</span>    println!(&quot;In file {}&quot;, filename);

    let contents = fs::read_to_string(filename)
        .expect(&quot;Something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}
</code></pre>
<p><span class="caption">Liste 12-4: İkinci argüman tarafından belirtilen dosyanın içeriğini okuma</span></p>
<p>İlk olarak, standart kitaplığın ilgili bir bölümünü bir <code>use</code> ifadesi ile getiriyoruz: dosyaları işlemek için <code>std::fs</code>'ye ihtiyacımız var.</p>
<p><code>main</code>'de, <code>fs::read_to_string</code> ifadesi <code>filename</code> argümanını alır, dosyayı açar, ve dosyanın içeriğini tutan
<code>Result&lt;String&gt;</code>'i döndürür.</p>
<p>Bundan sonra, geçici olarak bir <code>println!</code> ifadesi koyacağız ki dosya okunduktan sonra içindekileri okuyabilelim.</p>
<p>Hadi şimdi bu kodu herhangi bir ilk komut satırı argümanıyla  (çünkü henüz
dosya arama kısmını süreklemedik) ve <em>poem.txt</em> dosyasını ikinci bir argüman olarak
kullanarak çalıştıralım. </p>
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Güzel! Bu kod dosyanın içeriğini okur ve sonra içeriğini yazar. Ama kod bazı sorunlara sahip.
<code>main</code> fonksiyonunun birden fazla işlevi var. Genel olarak tek bir fikre dayalı fonksiyonlar daha kolay
karşılanır ve sürdürülür. Bir diğer problem olaraktan, biz henüz herhangi bir hatayı işlemiyoruz.
Program küçük yani bu sıkıntılar büyük bir program değil ama program büyüdükçe bu tarz sıkıntıları temizce
çözmek zorlaşacaktır. Bu tarz sıkıntıları kodunuz büyümeden çözmek iyi bir pratik olacaktır. Bunu sonra yapacağız.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="modülerliği-ve-hata-İşlemeyi-geliştirmek-için-yeniden-düzenleme"><a class="header" href="#modülerliği-ve-hata-İşlemeyi-geliştirmek-için-yeniden-düzenleme">Modülerliği ve Hata İşlemeyi Geliştirmek için Yeniden Düzenleme</a></h2>
<p>Programımızı iyileştirmek için, programın yapısı ve olası hataları nasıl ele aldığı ile ilgili dört sorunu çözeceğiz. 
İlk olarak, <code>ma'n</code> fonksiyonumuz artık iki görevi yerine getiriyor: argümanları ayrıştırıyor ve dosyaları okuyor. 
Programımız büyüdükçe, ana fonksiyonun yerine getirdiği ayrı görevlerin sayısı artacaktır. Bir fonksiyon sorumluluk kazandıkça,
hakkında mantık yürütmek daha zor, test etmek daha zor ve parçalarından birini bozmadan değiştirmek daha zor hale gelir. 
Her fonksiyonun tek bir görevden sorumlu olması için işlevleri ayırmak en iyisidir.</p>
<p>Bu konu aynı zamanda ikinci sorunla da bağlantılıdır: sorgu ve dosya adı programımız için yapılandırma değişkenleri olsa da, 
içerik gibi değişkenler programın mantığını gerçekleştirmek için kullanılır. main ne kadar uzun olursa, 
o kadar çok değişkeni kapsama almamız gerekecektir; ne kadar çok değişkeni kapsama alırsak, her birinin amacını takip etmek o
kadar zor olacaktır. Amaçlarını netleştirmek için yapılandırma değişkenlerini tek bir yapıda gruplamak en iyisidir.</p>
<p>Üçüncü sorun, dosyayı okuma başarısız olduğunda bir hata mesajı yazdırmak için <code>expect</code> kullandık, ancak hata mesajı sadece 
<code>Something went wrong reading the file</code> yazıyor. Bir dosyayı okumak çeşitli şekillerde başarısız olabilir: örneğin, 
dosya eksik olabilir veya dosyayı açmak için iznimiz olmayabilir. Şu anda, durum ne olursa olsun, her şey için aynı hata mesajını 
yazdırırız ve bu da kullanıcıya hiçbir bilgi vermeyiz.</p>
<p>Dördüncüsü, farklı hataları işlemek için tekrar tekrar <code>expect</code> kullanıyoruz ve kullanıcı programımızı yeterli argüman belirtmeden 
çalıştırırsa, Rust'tan sorunu açıkça açıklamayan bir <code>index out of bounds</code> hatası alacaktır. Tüm hata işleme kodunun tek bir yerde olması 
en iyisidir, böylece gelecekteki bakımcılar hata işleme mantığının değişmesi gerektiğinde koda başvurmak için tek bir yere sahip olurlar.
Tüm hata işleme kodunun tek bir yerde olması, son kullanıcılarımız için anlamlı olacak mesajları yazdırmamızı da sağlayacaktır.</p>
<p>Projemizi yeniden düzenleyerek bu dört sorunu ele alalım.</p>
<h3 id="İkili-projeler-için-endişelerin-ayrılması"><a class="header" href="#İkili-projeler-için-endişelerin-ayrılması">İkili Projeler için Endişelerin Ayrılması</a></h3>
<p>Birden fazla görevin sorumluluğunun ana fonksiyona verilmesine ilişkin organizasyonel sorun, 
birçok ikili projede ortaktır. Sonuç olarak, Rust topluluğu, ana program büyümeye başladığında ikili bir programın ayrı 
endişelerini bölmek için yönergeler geliştirmiştir. Bu süreç aşağıdaki adımlardan oluşur:</p>
<ul>
<li>Programınızı <em>main.rs</em> ve <em>lib.rs</em> olarak ayırın ve programınızın ana mantığını <em>lib.rs</em>'e taşıyın.</li>
<li>Komut satırı ayrıştırma mantığınız küçük olduğu sürece <em>main.rs</em> içinde kalabilir.</li>
<li>Komut satırı ayrıştırma mantığı karmaşıklaşmaya başladığında, <em>main.rs</em>'den çıkarın ve <em>lib.rs</em>'e taşıyın.</li>
</ul>
<p>Bu işlemlerden sonra <code>main</code> fonksiyonunda kalanlar aşağıdakilerle sınırlı olmalıdır:</p>
<ul>
<li>Komut satırı ayrıştırma mantığını argüman değerleriyle çağırmak</li>
<li>Diğer yapılandırmaları ayarlama</li>
<li><em>lib.rs</em> içinde bir <code>run</code> fonksiyonu çağırma</li>
<li><code>run</code> bir hata döndürürse hatayı işleme</li>
</ul>
<p>Bu model endişeleri ayırmakla ilgilidir: <em>main.rs</em> programı çalıştırır ve <em>lib.rs</em> eldeki görevin tüm mantığını ele alır. 
<code>main</code> fonksiyonunu doğrudan test edemeyeceğiniz için, bu yapı programınızın tüm mantığını <em>lib.rs</em>'deki fonksiyonlara taşıyarak 
test etmenizi sağlar. <em>main.rs</em>'de kalan kod, okunarak doğruluğu teyit edilebilecek kadar küçük olacaktır. </p>
<p>Bu süreci takip ederek programımızı yeniden düzenleyelim.</p>
<h4 id="argüman-ayrıştırıcısını-Çıkarma"><a class="header" href="#argüman-ayrıştırıcısını-Çıkarma">Argüman Ayrıştırıcısını Çıkarma</a></h4>
<p>Komut satırı ayrıştırma mantığını <em>src/lib.rs</em>'ye taşımaya hazırlanmak için argümanları ayrıştırma işlevini 
<code>main</code>'in çağıracağı bir fonksiyona çıkaracağız. Liste 12-5, şimdilik <em>src/main.rs</em> içinde tanımlayacağımız yeni <code>parse_config</code> 
fonksiyonunu çağıran <code>main</code>'in yeni başlangıcını göstermektedir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, filename) = parse_config(&amp;args);

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, query);
</span><span class="boring">    println!(&quot;In file {}&quot;, filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename)
</span><span class="boring">        .expect(&quot;Something went wrong reading the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let filename = &amp;args[2];

    (query, filename)
}
</code></pre>
<p><span class="caption">Liste 12-5: <code>parse_config</code> fonksiyonunun <code>main</code>'den çıkarılması</span></p>
<p>Komut satırı argümanlarını hala bir vektörde topluyoruz, ancak 1. indeksteki argüman değerini sorgu değişkenine ve 
2. indeksteki argüman değerini <code>main</code> içindeki dosya adı değişkenine atamak yerine, tüm vektörü <code>parse_config</code>'e aktarıyoruz. 
<code>parse_config</code> daha sonra hangi argümanın hangi değişkene gideceğini belirleyen mantığı tutar ve değerleri <code>main</code>'e geri aktarır. 
<code>query</code> ve <code>filename</code> değişkenlerini hala <code>main</code> içinde oluşturuyoruz, ancak <code>main</code> artık komut satırı argümanlarının ve 
değişkenlerin nasıl karşılık geldiğini belirleme sorumluluğuna sahip değil.</p>
<p>Bu yeniden çalışma küçük programımız için aşırı gibi görünebilir, ancak küçük, artan adımlarla yeniden düzenliyoruz. 
Bu değişikliği yaptıktan sonra, argüman ayrıştırmanın hala çalıştığını doğrulamak için programı tekrar çalıştırın. 
İlerlemenizi sık sık kontrol etmek, ortaya çıktıklarında sorunların nedenini belirlemeye yardımcı olmak için iyidir.</p>
<h4 id="yapılandırma-değerlerini-gruplama"><a class="header" href="#yapılandırma-değerlerini-gruplama">Yapılandırma Değerlerini Gruplama</a></h4>
<p><code>parse_config</code>'i daha da geliştirmek için küçük bir adım daha atabiliriz. Şu anda bir <code>tuple</code> döndürüyoruz, ancak hemen ardından bu 
<code>tuple</code>'ı tekrar ayrı parçalara ayırıyoruz. Bu, belki de henüz doğru soyutlamaya sahip olmadığımızın bir işaretidir.</p>
<p>İyileştirme için yer olduğunu gösteren bir başka gösterge de <code>parse_config</code>'in <code>config</code> kısmıdır, 
bu da döndürdüğümüz iki değerin ilişkili olduğunu ve her ikisinin de bir yapılandırma değerinin parçası olduğunu ima eder. 
Şu anda bu anlamı, iki değeri bir <code>tuple</code> olarak gruplamak dışında verinin yapısında aktarmıyoruz; bunun yerine iki değeri 
<code>struct</code> içine koyacağız ve <code>struct</code> alanlarının her birine anlamlı bir isim vereceğiz. Bunu yapmak, bu kodun gelecekteki 
bakımcılarının farklı değerlerin birbirleriyle nasıl ilişkili olduğunu ve amaçlarının ne olduğunu anlamalarını kolaylaştıracaktır.</p>
<p>Liste 12-6, <code>parse_config</code>'de yapılan iyileştirmeleri göstermektedir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    let contents = fs::read_to_string(config.filename)
        .expect(&quot;Something went wrong reading the file&quot;);

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span>}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
</code></pre>
<p><span class="caption">Liste 12-6: <code>Config</code> yapısının örneğini döndürmek için <code>parse_config</code> öğesini 
yeniden düzenleme</span></p>
<p><code>query</code> ve <code>filename</code> adında alanlara sahip olacak şekilde tanımlanmış <code>Config</code> adında bir yapı ekledik. <code>parse_config</code>'in imzası artık 
<code>Config</code> değeri döndürdüğünü gösteriyor. Eskiden <code>args</code> içindeki <code>String</code> değerlerine referans veren dizgi dilimleri döndürdüğümüz 
<code>parse_config</code> gövdesinde, artık <code>Config</code>'i <code>String</code> değerlerini içerecek şekilde tanımlıyoruz. <code>main</code> içindeki <code>args</code> değişkeni argüman 
değerlerinin sahibidir ve yalnızca <code>parse_config</code> fonksiyonunun bunları ödünç almasına izin verir, bu da <code>Config</code>'in <code>args</code> içindeki 
değerlerin sahipliğini almaya çalışması durumunda Rust'ın ödünç alma kurallarını ihlal edeceğimiz anlamına gelir.</p>
<p><code>String</code> verilerini yönetebileceğimiz birkaç yol vardır; biraz verimsiz olsa da en kolay yol, değerler üzerinde <code>clone</code> metodunu çağırmaktır. 
Bu,<code> Config</code> örneğinin sahip olması için verilerin tam bir kopyasını oluşturacaktır, bu da dizgi verilerine bir referans depolamaktan daha 
fazla zaman ve bellek gerektirir. Bununla birlikte, verileri klonlamak kodumuzu çok basit hale getirir çünkü referansların yaşam sürelerini
yönetmek zorunda değiliz; bu durumda, basitlik kazanmak için biraz performanstan vazgeçmek değerli bir değiş tokuştur.</p>
<blockquote>
<h3 id="clone-kullanmanın-getirileri"><a class="header" href="#clone-kullanmanın-getirileri"><code>clone</code> Kullanmanın Getirileri</a></h3>
<p>Birçok Rustsever arasında, çalışma zamanı maliyeti nedeniyle sahiplik sorunlarını çözmek için 
<code>clone</code> kullanmaktan kaçınma eğilimi vardır. Bölüm 13'te, bu tür durumlarda nasıl daha verimli yöntemler 
kullanacağınızı öğreneceksiniz. Ancak şimdilik, ilerlemeye devam etmek için birkaç dizgiyi kopyalamanızda bir sakınca yok 
çünkü bu kopyaları yalnızca bir kez yapacaksınız ve <code>filename</code> ve <code>query</code> dizginiz çok küçük. İlk geçişinizde kodu aşırı optimize 
etmeye çalışmaktansa biraz verimsiz çalışan bir programa sahip olmak daha iyidir. Rust ile daha deneyimli hale geldikçe, 
en verimli çözümle başlamak daha kolay olacaktır, ancak şimdilik <code>clone</code> kullanmak tamamen kabul edilebilir.</p>
</blockquote>
<p><code>main</code>'i, <code>parse_config</code> tarafından döndürülen <code>Config</code> örneğini <code>config</code> adlı bir değişkene atayacak şekilde güncelledik 
ve daha önce ayrı <code>query</code> ve <code>filename</code> değişkenlerini kullanan kodu güncelledik, böylece artık bunun yerine <code>Config</code> yapısındaki alanları 
kullanıyor.</p>
<p>Artık kodumuz <code>query</code> ve <code>filename</code>'in ilişkili olduğunu ve amaçlarının programın nasıl çalışacağını yapılandırmak olduğunu daha açık bir 
şekilde ifade ediyor. Bu değerleri kullanan herhangi bir kod, bunları <code>config</code> örneğinde amaçlarına göre adlandırılmış alanlarda bulmayı bilir.</p>
<h4 id="config-için-bir-yapıcı-oluşturma"><a class="header" href="#config-için-bir-yapıcı-oluşturma"><code>Config</code> için Bir Yapıcı Oluşturma</a></h4>
<p>Şimdiye kadar, komut satırı argümanlarını ayrıştırmaktan sorumlu mantığı <code>main</code>'den çıkardık ve <code>parse_config</code> fonksiyonuna yerleştirdik. 
Bunu yapmak, <code>query</code> ve <code>filename</code> değerlerinin ilişkili olduğunu ve bu ilişkinin kodumuzda aktarılması gerektiğini görmemize yardımcı oldu. 
Daha sonra <code>query</code> ve <code>filename</code>'in amaçlarını adlandırmak ve <code>parse_config</code> fonksiyonundan değerlerin adlarını <code>struct</code> alan adları olarak 
döndürebilmek için bir <code>Config</code> <code>struct</code>'ı ekledik.</p>
<p>Artık <code>parse_config</code> fonksiyonunun amacı bir <code>Config</code> örneği oluşturmak olduğuna göre, <code>parse_config</code>'i düz bir fonksiyondan <code>Config</code> yapısıyla 
ilişkili <code>new</code> adlı bir fonksiyona dönüştürebiliriz. Bu değişikliği yapmak kodu daha deyimsel hale getirecektir. Standart kütüphanedeki <code>String</code> 
gibi türlerin örneklerini <code>String::new</code> fonksiyonunu çağırarak oluşturabiliriz. Benzer şekilde, <code>parse_config</code>'i <code>Config</code> ile ilişkili yeni 
bir fonksiyona dönüştürerek, <code>Config::new</code>'i çağırarak <code>Config</code>'in örneklerini oluşturabileceğiz. Liste 12-7 yapmamız 
gereken değişiklikleri göstermektedir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.filename)
</span><span class="boring">        .expect(&quot;Something went wrong reading the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span>
    // --snip--
}

// --snip--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
</code></pre>
<p><span class="caption">Liste 12-7: <code>parse_config</code>'i <code>Config::new</code> ile değiştirme</span></p>
<p><code>main</code>'de <code>parse_config</code> çağrısı yaptığımız yeri <code>Config::new</code> çağrısı yapacak şekilde güncelledik. 
<code>parse_config</code>'in adını <code>new</code> olarak değiştirdik ve yeni fonksiyonu <code>Config</code> ile ilişkilendiren <code>impl</code> bloğunun içine taşıdık. 
Çalıştığından emin olmak için bu kodu tekrar derlemeyi deneyin.</p>
<h3 id="hata-İşlemeyi-düzeltme"><a class="header" href="#hata-İşlemeyi-düzeltme">Hata İşlemeyi Düzeltme</a></h3>
<p>Şimdi hata işlememizi düzeltmeye çalışacağız. <code>args</code> vektöründeki değerlere indeks <code>1</code> veya indeks <code>2</code>'den erişmeye çalışmanın, 
vektör üçten az öğe içeriyorsa programın paniklemesine neden olacağını hatırlayın. Programı herhangi bir argüman olmadan çalıştırmayı 
deneyin; şöyle görünecektir:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:27:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p><code>index out of bounds: the len is 1 but the index is 1</code>, programcılara yönelik detaylı bir hata mesajıdır. 
Son kullanıcılarımızın bunun yerine ne yapmaları gerektiğini anlamalarına yardımcı olmaz. Şimdi bunu düzeltelim.</p>
<h3 id="hata-mesajını-İyileştirme"><a class="header" href="#hata-mesajını-İyileştirme">Hata Mesajını İyileştirme</a></h3>
<p>Liste 12-8'de, yeni fonksiyona 1. ve 2. dizine erişmeden önce dilimin yeterince uzun olduğunu doğrulayacak bir kontrol ekliyoruz. 
Dilim yeterince uzun değilse, program paniğe kapılır ve daha iyi bir hata mesajı görüntüler.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.filename)
</span><span class="boring">        .expect(&quot;Something went wrong reading the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --snip--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!(&quot;not enough arguments&quot;);
        }
        // --snip--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, filename }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 12-8: Bağımsız değişken sayısı için bir kontrol ekleme</span></p>
<p>Bu kod, <a href="ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation">Liste 9-13'te yazdığımız <code>Guess::new</code> fonksiyonuna benzer</a><!-- ignore -->; burada <code>value</code> bağımsız değişkeni 
geçerli değerler aralığının dışında kaldığında <code>panic!</code> yapar. Bir değer aralığını kontrol etmek yerine, <code>args</code> uzunluğunun en az 
3 olduğunu kontrol ediyoruz ve fonksiyonun geri kalanı bu koşulun sağlandığı varsayımı altında çalışabilir. Eğer <code>args</code> üçten az öğeye sahipse, 
bu koşul doğru olur ve programı hemen sonlandırmak için <code>panic!</code> makrosunu çağırırız.</p>
<p>Bu ekstra birkaç satırlık yeni kodla, hatanın şimdi nasıl göründüğünü görmek için programı herhangi bir 
argüman olmadan tekrar çalıştıralım:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Bu çıktı daha iyi: artık makul bir hata mesajımız var. Ancak, kullanıcılarımıza vermek istemediğimiz gereksiz bilgilere de sahibiz. 
Belki de Liste 9-13'te kullandığımız tekniği burada kullanmak en iyisi değildir: <a href="ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling">Bölüm 9'da tartışıldığı gibi</a><!-- ignore -->, 
<code>panic!</code> çağrısı bir kullanım probleminden ziyade bir programlama problemi için daha uygundur. Bunun yerine, 
Bölüm 9'da öğrendiğiniz diğer tekniği kullanacağız— başarı ya da hatayı gösteren <a href="ch09-02-recoverable-errors-with-result.html"><code>Result</code>'u döndürmek</a><!-- ignore -->.</p>
<h4 id="panic-yerine-newden-result-döndürme"><a class="header" href="#panic-yerine-newden-result-döndürme"><code>panic!</code> Yerine <code>new</code>'den <code>Result</code> Döndürme</a></h4>
<p>Bunun yerine, başarılı durumda bir <code>Config</code> örneği içeren ve hata durumunda sorunu açıklayan bir <code>Result</code> değeri döndürebiliriz. 
<code>Config::new</code> <code>main</code> ile iletişim kurarken, bir sorun olduğunu belirtmek için <code>Result</code> türünü kullanabiliriz. </p>
<p>Daha sonra <code>main</code>'i, <code>panic!</code>'in neden olduğu <code>main</code> iş parçacığı ve <code>RUST_BACKTRACE</code> ile ilgili çevreleyen metin olmadan 
kullanıcılarımız için <code>Err</code> varyantını daha pratik bir hataya dönüştürmek için değiştirebiliriz.</p>
<p>Liste 12-9, <code>Config::new</code>'in dönüş değerinde ve <code>Result</code> döndürmek için gereken fonksiyonun gövdesinde yapmamız gereken 
değişiklikleri göstermektedir. Bunun <code>main</code>'i de güncellemeden derlenmeyeceğini unutmayın, ki bunu bir sonraki listede yapacağız.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.filename)
</span><span class="boring">        .expect(&quot;Something went wrong reading the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
</code></pre>
<p><span class="caption">Liste 12-9: <code>Config::new</code>'den <code>Result</code> Döndürme</span></p>
<p>Yeni fonksiyonumuz artık başarı durumunda bir <code>Config</code> örneği ve hata durumunda <code>&amp;'static str</code> içeren bir <code>Result</code> döndürmektedir. 
Hata değerlerimiz her zaman <code>'static</code> ömüre sahip dizgi değişmezleri olacaktır.</p>
<p>Yeni fonksiyonun gövdesinde iki değişiklik yaptık: kullanıcı yeterli argüman iletmediğinde <code>panic!</code> çağrısı yapmak yerine, 
artık bir <code>Err</code> değeri döndürüyoruz ve <code>Config</code> dönüş değerini bir <code>Ok</code> içinde tuttuk. Bu değişiklikler fonksiyonun yeni tür imzasına 
uygun olmasını sağlar.</p>
<p><code>Config::new</code>'den <code>Err</code> değeri döndürmek, <code>main</code> fonksiyonun yeni fonksiyondan dönen <code>Result</code> değerini işlemesini ve hata 
durumunda süreçten daha temiz bir şekilde çıkmasını sağlar.</p>
<h4 id="confignew-Çağrısı-ve-hataların-İşlenmesi"><a class="header" href="#confignew-Çağrısı-ve-hataların-İşlenmesi"><code>Config::new</code> Çağrısı ve Hataların İşlenmesi</a></h4>
<p>Hata durumunu ele almak ve kullanıcı dostu bir mesaj yazdırmak için, Liste 12-10'da gösterildiği gibi, 
<code>Config::new</code> tarafından döndürülen <code>Result</code>'u ele almak üzere <code>main</code>'i güncellememiz gerekir. Ayrıca, komut satırı aracından 
sıfır olmayan bir hata koduyla çıkma sorumluluğunu <code>panic!</code>'ten alacağız ve elle sürekleyeceğiz. Sıfır olmayan bir çıkış durumu, 
programımızı çağıran sürece programın bir hata durumuyla çıktığını bildirmek için kullanılan bir kuraldır.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.filename)
</span><span class="boring">        .expect(&quot;Something went wrong reading the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 12-10: Yeni bir <code>Config</code> oluşturma başarısız olursa bir hata koduyla çıkmak</span></p>
<p>Bu listelemede, henüz ayrıntılı olarak ele almadığımız bir metod kullandık: standart kütüphane tarafından <code>Result&lt;T, E&gt;</code> üzerinde 
tanımlanan <code>unwrap_or_else</code>. <code>unwrap_or_else</code>'i kullanmak, panik yaratmayan bazı özel hata işleme yöntemleri tanımlamamızı sağlar. 
Eğer <code>Result</code> <code>Ok</code> değerinde ise, bu metodun davranışı <code>unwrap</code>'a benzer: <code>Ok</code>'un sarmaladığı iç değeri döndürür. 
Ancak, değer <code>Err</code> değeriyse, bu metod, tanımladığımız ve <code>unwrap_or_else</code>'ye argüman olarak aktardığımız anonim bir fonksiyon olan 
kapanış ifadesindeki kodu çağırır. Kapanış ifadelerini <a href="ch13-00-functional-features.html">Bölüm 13</a><!-- ignore -->'te daha ayrıntılı olarak ele alacağız. 
Şimdilik, <code>unwrap_or_else</code>'nin  <code>Err</code>'nin iç değerini, yani bu durumda Liste 12-9'da eklediğimiz <code>&quot;not enough arguments&quot;</code> statik dizgisini, 
dikey <em>aktarmalar</em> arasında görünen <code>err</code> argümanı içinde kapanış ifadesini aktaracağını bilmeniz yeterlidir. 
Daha sonra kapanış ifadesi içindeki kod çalıştığında <code>err</code> değerini kullanabilir.</p>
<p>Standart kütüphaneden <code>process</code>'i kapsam içine almak için yeni bir <code>use</code> satırı ekledik. Hata durumunda çalıştırılacak kapanış ifadesi
içindeki kod yalnızca iki satırdır: <code>err</code> değerini yazdırırız ve ardından <code>process::exit</code>'i çağırırız. <code>process::exit</code> fonksiyonu programı 
hemen durduracak ve çıkış durum kodu olarak aktarılan sayıyı döndürecektir. Bu, Liste 12-8'de kullandığımız <code>panic!</code>-tabanlı işleme benzer, 
ancak artık tüm ekstra çıktıları almıyoruz. Hadi deneyelim:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>Harika! Bu çıktı, kullanıcılarımız için çok daha güzel.</p>
<h3 id="mainden-mantığı-Çıkarma"><a class="header" href="#mainden-mantığı-Çıkarma"><code>main</code>'den Mantığı Çıkarma</a></h3>
<p>Yapılandırma ayrıştırmasını yeniden düzenlemeyi bitirdiğimize göre, şimdi programın mantığına dönelim. </p>
<p><a href="ch12-03-improving-error-handling-and-modularity.html#separation-of-concerns-for-binary-projects">“İkili Projeler için İşlerin Ayrılması”</a><!-- ignore --> 
bölümünde belirttiğimiz gibi, yapılandırmayı ayarlamak veya hataları ele almakla ilgili olmayan <code>main</code>'de şu anda bulunan tüm mantığı 
tutacak <code>run</code> adlı bir fonksiyon çıkaracağız. İşimiz bittiğinde, <code>main</code> kısa ve öz olacak ve inceleme yoluyla doğrulanması 
kolay olacak ve diğer tüm mantık için testler yazabileceğiz.</p>
<p>Liste 12-11 ayıklanmış çalıştırma fonksiyonunu göstermektedir. Şimdilik sadece fonksiyonu ayıklayarak küçük ve aşamalı bir iyileştirme yapıyoruz.
Fonksiyonu <em>src/main.rs</em> içinde tanımlıyoruz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.filename)
        .expect(&quot;Something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}

// --snip--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 12-11: Program mantığının geri kalanını içeren <code>run</code>'ın 
çıkarılması</span></p>
<p><code>run</code> fonksiyonu artık dosyanın okunmasından başlayarak <code>main</code>'den kalan tüm mantığı içerir. 
<code>run</code> fonksiyonu <code>Config</code> örneğini bir argüman olarak alır.</p>
<h4 id="run-fonksiyonundan-hata-döndürme"><a class="header" href="#run-fonksiyonundan-hata-döndürme"><code>run</code> Fonksiyonundan Hata Döndürme</a></h4>
<p>Kalan program mantığının <code>run</code> fonksiyonuna ayrılmasıyla, Liste 12-9'da <code>Config::new</code> ile yaptığımız gibi hata işlemeyi geliştirebiliriz. 
Bir şeyler ters gittiğinde programın <code>expect</code>'i çağırarak paniklemesine izin vermek yerine, <code>run</code> fonksiyonu <code>Result&lt;T, E&gt;</code> döndürecektir. 
Bu, hataları ele alma mantığını <code>main</code>'de kullanıcı dostu bir şekilde daha da birleştirmemizi sağlayacaktır. Liste 12-12, <code>run</code>'ın 
imzasında ve gövdesinde yapmamız gereken değişiklikleri göstermektedir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --snip--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    println!(&quot;With text:\n{}&quot;, contents);

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 12-12: <code>Result</code> döndürmek için <code>run</code>'ı değiştirme</span></p>
<p>Burada üç önemli değişiklik yaptık. İlk olarak, <code>run</code> fonksiyonunun dönüş tipini <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> olarak değiştirdik. 
Bu fonksiyon daha önce birim tipi olan <code>()'</code>i döndürüyordu ve bunu <code>Ok</code> durumunda döndürülen değer olarak tutuyoruz.</p>
<p>Hata türü için <code>Box&lt;dyn Error&gt;</code> tanım nesnesini kullandık (ve <code>std::error::Error</code>'ı en üstte bir <code>use</code> deyimiyle kapsama aldık). 
Tanım nesnelerini <a href="ch17-00-oop.html">Bölüm 17</a><!-- ignore -->'de ele alacağız. Şimdilik, <code>Box&lt;dyn Error&gt;</code>'un fonksiyonun <code>Error</code> tanımını sürekleyen 
tür döndüreceği anlamına geldiğini bilin, ancak dönüş değerinin hangi tür olacağını belirtmek zorunda değiliz. 
Bu bize farklı hata durumlarında farklı türlerde olabilecek hata değerleri döndürme esnekliği sağlar. 
<code>dyn</code> anahtar sözcüğü “dinamikin” kısaltmasıdır.</p>
<p>İkinci olarak, <a href="ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">Bölüm 9</a><!-- ignore -->'da bahsettiğimiz gibi <code>?</code> operatörü için <code>expect</code> çağrısını kaldırdık. 
Bir hatada <code>panic!</code> yerine, <code>?</code> işleci çağıranın işlemesi için geçerli fonksiyondan hata değerini döndürecektir.</p>
<p>Üçüncü olarak, <code>run</code> fonksiyonu artık başarı durumunda bir <code>Ok</code> değeri döndürmektedir. İmzada <code>run</code> fonksiyonunun başarı tipini 
<code>()</code> olarak bildirdik, bu da birim tür değerini <code>Ok</code> değerine sarmamız gerektiği anlamına geliyor. Bu <code>Ok(())</code> söz dizimi ilk başta biraz 
garip görünebilir, <code>ancak ()</code>'yi bu şekilde kullanmak, <code>run</code>'ı yalnızca yan etkileri için çağırdığımızı belirtmenin deyimsel yoludur; 
ihtiyacımız olan bir değer döndürmez.</p>
<p>Bu kodu çalıştırdığınızda, derlenecek ancak bir uyarı görüntülenecektir:</p>
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `minigrep` (bin &quot;minigrep&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Rust bize kodumuzun <code>Result</code> değerini göz ardı ettiğini ve <code>Result</code> değerinin bir hata oluştuğunu gösterebileceğini söyler. 
Ancak bir hata olup olmadığını kontrol etmiyoruz ve derleyici bize muhtemelen burada bazı hata işleme kodlarına sahip olmamız gerektiğini 
hatırlatıyor! Şimdi bu sorunu düzeltelim.</p>
<h4 id="mainde-Çalıştırmadan-dönen-hataları-İşleme"><a class="header" href="#mainde-Çalıştırmadan-dönen-hataları-İşleme"><code>main</code>'de Çalıştırmadan Dönen Hataları İşleme</a></h4>
<p>Hataları kontrol edeceğiz ve bunları Liste 12-10'da <code>Config::new</code> ile kullandığımıza benzer bir teknik kullanarak ele alacağız, 
ancak küçük bir farkla:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><code>run</code>'ın bir <code>Err</code> değeri döndürüp döndürmediğini kontrol etmek ve döndürürse <code>process::exit(1)</code>'i çağırmak için <code>unwrap_or_else</code> yerine 
<code>if let</code> kullanırız. <code>run</code> fonksiyonu, <code>Config::new</code>'in <code>Config</code> örneğini döndürdüğü gibi <code>unwrap</code> etmek istediğimiz bir değer döndürmez. 
<code>run</code> başarı durumunda <code>()</code> değerini döndürdüğü için, yalnızca bir hatayı tespit etmekle ilgileniyoruz, bu nedenle <code>unwrap_or_else</code>'in 
yalnızca <code>()</code> değerini döndürmesine gerek yok.</p>
<p><code>if let</code> ve <code>unwrap_or_else</code> fonksiyonlarının gövdeleri her iki durumda da aynıdır: hatayı yazdırır ve çıkarız.</p>
<h3 id="kodu-kütüphane-kasasına-bölme"><a class="header" href="#kodu-kütüphane-kasasına-bölme">Kodu Kütüphane Kasasına Bölme</a></h3>
<p><code>minigrep</code> projemiz şu ana kadar iyi görünüyor! Şimdi <em>src/main.rs</em> dosyasını böleceğiz ve <em>src/lib.rs</em> dosyasına bazı kodlar koyacağız. 
Bu şekilde kodu test edebilir ve daha az sorumluluğu olan bir <em>src/main.rs</em> dosyasına sahip olabiliriz.</p>
<p><code>main</code> fonksiyonu olmayan tüm kodları <em>src/main.rs</em> dosyasından <em>src/lib.rs</em> dosyasına taşıyalım:</p>
<ul>
<li><code>run</code> fonksiyonu tanımı</li>
<li>İlişkili <code>use</code> deyimleri</li>
<li><code>Config</code>'in tanımı</li>
<li><code>Config::new</code> fonksiyon tanımı</li>
</ul>
<p><em>src/lib.rs</em> dosyasının içeriği Liste 12-13'te gösterilen imzalara sahip olmalıdır (kısa olması için fonksiyonların gövdelerini atladık). 
Liste 12-14'te <em>src/main.rs</em>'yi değiştirene kadar bunun derlenmeyeceğini unutmayın.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --snip--
<span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}
</code></pre>
<p><span class="caption">Liste 12-13: <code>Config</code> ve <code>run</code>'ı <em>src/lib.rs</em>'e taşıma</span></p>
<p><code>pub</code> anahtar sözcüğünü bolca kullandık: <code>Config</code> üzerinde, <code>Config</code>'in alanları üzerinde, <code>new</code> metodu üzerinde ve <code>run</code> fonksiyonu üzerinde. 
Artık test edebileceğimiz herkese açık bir API'ye sahip bir kütüphane kasamız var!</p>
<p>Şimdi <em>src/lib.rs</em> dosyasına taşıdığımız kodu, Liste 12-14'te gösterildiği gibi 
<em>src/main.rs</em> dosyasındaki ikili kasanın kapsamına almamız gerekiyor.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.filename);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // --snip--
<span class="boring">        println!(&quot;Application error: {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span>    }
}
</code></pre>
<p><span class="caption">Liste 12-14: <em>src/main.rs</em> içinde <code>minigrep</code> kütüphanesini kullanma</span></p>
<p><code>Config</code> türünü kütüphane kasasından ikili kasanın kapsamına getirmek için <code>use minigrep::Config</code> satırı ekliyoruz ve 
<code>run</code> fonksiyonunun önüne kasa adımızı ekliyoruz. Artık tüm fonksiyonlar birbirine bağlı olmalı ve çalışmalıdır. 
Programı <code>cargo run</code> ile çalıştırın ve her şeyin doğru çalıştığından emin olun.</p>
<p>Vay be! Sanki bu <strong>seni</strong> ve <em>beni</em> çok yormuş gibi duruyor, ancak gelecekte başarılı olmak için bunları yapmalıydık. 
Artık hataları ele almak çok daha kolay ve kodu daha modüler hale getirdik. Bundan sonraki neredeyse tüm işlerimiz <em>src/lib.rs</em> içinde 
yapılacak.</p>
<p>Eski kodla zor olan ancak yeni kodla kolay olan bir şeyi yaparak bu yeni modülerlikten yararlanalım: 
bazı testler yazacağız!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="test-odaklı-geliştirme-ile-kütüphanenin-İşlevselliğini-geliştirme"><a class="header" href="#test-odaklı-geliştirme-ile-kütüphanenin-İşlevselliğini-geliştirme">Test Odaklı Geliştirme ile Kütüphanenin İşlevselliğini Geliştirme</a></h2>
<p>Artık kök mantığı <em>src/lib.rs</em>'ye çıkardığımıza ve argüman toplama ve hata işlemeyi <em>src/main.rs</em>'de bıraktığımıza göre, 
kodumuzun temel işlevselliği için test yazmak çok daha kolay. Fonksiyonları çeşitli argümanlarla doğrudan çağırabilir ve 
ikili dosyamızı komut satırından çağırmak zorunda kalmadan dönüş değerlerini kontrol edebiliriz.</p>
<p>Bu bölümde, aşağıdaki adımlarla test odaklı geliştirme (TDD) sürecini kullanarak <code>minigrep</code> programına arama mantığını ekleyeceğiz:</p>
<ol>
<li>Başarısız olan bir test yazın ve beklediğiniz nedenden dolayı başarısız olduğundan emin olmak için çalıştırın.</li>
<li>Yeni testin geçmesi için yeterli kodu yazın veya değiştirin.</li>
<li>Yeni eklediğiniz veya değiştirdiğiniz kodu yeniden düzenleyin ve testlerin geçmeye devam ettiğinden emin olun.</li>
<li>Adım 1'den itibaren tekrarlayın!</li>
</ol>
<p>TDD, yazılım yazmanın birçok yolundan yalnızca biri olsa da kod tasarımını yönlendirmeye yardımcı olabilir. 
Testin geçmesini sağlayan kodu yazmadan önce testi yazmak, süreç boyunca yüksek test kapsamının korunmasına yardımcı olur.</p>
<p>Dosya içeriğindeki sorgu dizgisini gerçekten arayacak ve sorguyla eşleşen satırların bir listesini üretecek işlevselliğin uygulanmasını test edeceğiz. 
Bu işlevselliği <code>search</code> adlı bir fonksiyona ekleyeceğiz.</p>
<h3 id="başarısız-bir-test-yazma"><a class="header" href="#başarısız-bir-test-yazma">Başarısız Bir Test Yazma</a></h3>
<p>Artık onlara ihtiyacımız olmadığından, programın davranışını kontrol etmek için kullandığımız <code>println!</code> ifade yapılarını 
<em>src/lib.rs</em> ve <em>src/main.rs</em> dosyalarından kaldıralım. Daha sonra, <em>src/lib.rs</em> dosyasına, Bölüm 11'de yaptığımız gibi bir test 
fonksiyonu içeren bir <code>tests</code> modülü ekleyelim. Test fonksiyonu, <code>search</code> fonksiyonunun sahip olmasını istediğimiz davranışı belirtir: 
bir sorgu ve aranacak metni alır ve metinden yalnızca sorguyu içeren satırları döndürür. Liste 12-15, henüz derlenmeyecek olan bu 
testi göstermektedir.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.&quot;;

        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
    }
}
</code></pre>
<p><span class="caption">Liste 12-15: Keşke yapsaydık dediğimiz <code>search</code> fonksiyonu için başarısız bir test oluşturma</span></p>
<p>Bu test <code>&quot;duct&quot;</code> dizgisini arar. Aradığımız metin, yalnızca biri <code>&quot;duct&quot;</code> içeren üç satırdır (Açılıştaki çift tırnak işaretinden sonraki 
ters eğik çizginin Rust'a bu dize değişmezinin içeriğinin başına yeni satır karakteri koymamasını söylediğine dikkat edin). 
Arama fonksiyonundan dönen değerin sadece beklediğimiz satırı içerdiğini iddia ediyoruz.</p>
<p>Henüz bu testi çalıştırıp başarısız olmasını izleyemiyoruz çünkü test derlenmiyor bile: arama fonksiyonu henüz mevcut değil! 
TDD ilkelerine uygun olarak, Liste 12-16'da gösterildiği gibi her zaman boş bir vektör döndüren bir arama fonksiyonu tanımı ekleyerek 
testin derlenmesini ve çalışmasını sağlayacak kadar kod ekleyeceğiz. Ardından test derlenmeli ve başarısız olmalıdır çünkü boş bir vektör 
<code>&quot;safe, fast, productive&quot;</code> satırını içeren bir vektörle eşleşmez.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 12-16: Testimizin derlenebilmesi için <code>search</code> fonksiyonunun değiştirilmesi</span></p>
<p><code>search</code>'ın imzasında açık bir <code>'a</code> yaşam süresi tanımlamamız ve bu yaşam süresini <code>contents</code> argümanı ve dönüş değeri ile kullanmamız 
gerektiğine dikkat edin. <a href="ch10-03-lifetime-syntax.html">Bölüm 10</a><!-- ignore -->'da yaşam süresi parametrelerinin hangi argüman yaşam süresinin 
geri dönüş değerinin yaşam süresine bağlı olduğunu belirttiğini hatırlayın. Bu durumda, döndürülen vektörün (argüman sorgusu yerine) 
argüman <code>contents</code>'in dilimlerine referans veren dizgi dilimleri içermesi gerektiğini belirtiriz.</p>
<p>Başka bir deyişle, Rust'a <code>search</code> fonksiyonu tarafından döndürülen verilerin, <code>contents</code> argümanında <code>search</code> fonksiyonuna aktarılan 
veriler kadar uzun yaşayacağını söylüyoruz. Bu çok önemlidir! Referansın geçerli olabilmesi için bir dilim tarafından referans verilen 
verinin geçerli olması gerekir; derleyici içerik yerine sorgunun dize dilimlerini oluşturduğumuzu varsayarsa, 
güvenlik kontrolünü yanlış yapacaktır.</p>
<p>Eğer yaşam süresi ek açıklamalarını unutur ve bu fonksiyonu derlemeye çalışırsak, bu hatayı alırız:</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:28:51
   |
28 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                      ----            ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
   |
28 | pub fn search&lt;'a&gt;(query: &amp;'a str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
   |              ++++         ++                 ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` due to previous error
</code></pre>
<p>Rust bu iki argümandan hangisine ihtiyacımız olduğunu bilemez, bu yüzden bunu ona açıkça söylememiz gerekir. 
<code>contents</code> tüm metnimizi içeren argüman olduğundan ve bu metnin eşleşen kısımlarını döndürmek istediğimizden, 
<code>contents</code>'in <code>lifetime</code> söz dizimini kullanarak dönüş değerine bağlanması gereken argüman olduğunu biliyoruz.</p>
<p>Diğer programlama dilleri, imzada argümanları dönüş değerlerine bağlamanızı gerektirmez, ancak bu uygulama zamanla daha kolay hale gelecektir. 
Bu örneği Bölüm 10'daki <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“Referansları Yaşam Süreleri ile Doğrulama”</a><!-- ignore --> bölümü ile 
karşılaştırmak isteyebilirsiniz.</p>
<p>Şimdi testi çalıştıralım:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `[&quot;safe, fast, productive.&quot;]`,
 right: `[]`', src/lib.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Harika, test tam da beklediğimiz gibi başarısız oldu. Hadi testi geçelim!</p>
<h3 id="testi-geçirmek-İçin-kod-yazma"><a class="header" href="#testi-geçirmek-İçin-kod-yazma">Testi Geçirmek İçin Kod Yazma</a></h3>
<p>Şu anda, her zaman boş bir vektör döndürdüğümüz için testimiz başarısız oluyor. Bunu düzeltmek ve <code>search</code>'ü uygulamak için 
programımızın aşağıdaki adımları izlemesi gerekir:</p>
<ul>
<li>İçeriğin her satırını yineleyin.</li>
<li>Satırın sorgu dizemizi içerip içermediğini kontrol edin.</li>
<li>Eğer içeriyorsa, döndürdüğümüz değerler listesine ekleyin.</li>
<li>Eğer içermiyorsa, hiçbir şey yapmayın.</li>
<li>Eşleşen sonuçların listesini döndürün.</li>
</ul>
<p>Satırlar arasında yineleme ile başlayarak her adımda çalışalım.</p>
<h4 id="lines-metodu-ile-satırlar-arasında-yineleme"><a class="header" href="#lines-metodu-ile-satırlar-arasında-yineleme"><code>lines</code> Metodu ile Satırlar Arasında Yineleme</a></h4>
<p>Rust, dizgilerin satır satır yinelenmesini işlemek için uygun bir şekilde satır olarak adlandırılan ve Liste 12-17'de 
gösterildiği gibi çalışan yararlı bir metoda sahiptir. Bunun henüz derlenmeyeceğini unutmayın.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 12-17: <code>contents</code>'teki her satırı yineleme</span></p>
<p><code>lines</code> metodu bir yineleyici döndürür. Yineleyiciler hakkında <a href="ch13-02-iterators.html">Bölüm 13</a><!-- ignore -->'te derinlemesine 
konuşacağız, ancak bir yineleyici kullanmanın bu yolunu, bir koleksiyondaki her bir öğe üzerinde bazı kodlar çalıştırmak 
için bir yineleyici ile bir <code>for</code> döngüsü kullandığımız <a href="ch03-05-control-flow.html#looping-through-a-collection-with-for">Liste 3-5</a><!-- ignore -->'te gördüğünüzü hatırlayın.</p>
<h4 id="sorgu-için-her-satırı-arama"><a class="header" href="#sorgu-için-her-satırı-arama">Sorgu için Her Satırı Arama</a></h4>
<p>Ardından, geçerli satırın sorgu dizemizi içerip içermediğini kontrol edeceğiz. Neyse ki, <code>String</code> bunu bizim için yapan <code>contains</code> adında 
yararlı bir metoda sahiptir! Liste 12-18'de gösterildiği gibi, <code>search</code> fonksiyonuna <code>contains</code> metoduna bir çağrı ekleyin. 
Bunun henüz derlenmeyeceğini unutmayın.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 12-18: Satırın <code>query</code>'deki dizgiyi içerip içermediğini görmek için yeni bir işlevsellik ekleme</span></p>
<p>Şu anda işlevsellik geliştiriyoruz. Derlemek için, fonksiyon imzasında belirttiğimiz gibi gövdeden bir 
değer döndürmemiz gerekiyor.</p>
<h4 id="eşleşen-satırları-depolama"><a class="header" href="#eşleşen-satırları-depolama">Eşleşen Satırları Depolama</a></h4>
<p>Bu fonksiyonu tamamlamak için, döndürmek istediğimiz eşleşen satırları saklamanın bir yoluna ihtiyacımız var. 
Bunun için, <code>for</code> döngüsünden önce değiştirilebilir bir vektör oluşturabilir ve bir satırı vektörde saklamak için <code>push</code> metodunu çağırabiliriz. 
<code>for</code> döngüsünden sonra, Liste 12-19'da gösterildiği gibi vektörü döndürürüz.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 12-19: Eşleşen satırları döndürebilmek için depolamak</span></p>
<p>Şimdi <code>search</code> fonksiyonu yalnızca <code>query</code>'i içeren satırları döndürmeli ve testimiz geçmelidir. Testi çalıştıralım:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Testimiz geçti, bu yüzden işe yaradığını biliyoruz!</p>
<p>Bu noktada, aynı işlevselliği korumak için testlerin geçmesini sağlarken <code>search</code> fonksiyonunun süreklemesini yeniden 
düzenleme fırsatlarını değerlendirebiliriz. <code>search</code> fonksiyonundaki kod çok da <em>kötü</em> <strong>değil</strong>, ancak yineleyicilerin bazı yararlı 
özelliklerinden yararlanmıyor <em>o kadar</em>. Yineleyicileri ayrıntılı olarak inceleyeceğimiz <a href="ch13-02-iterators.html">Bölüm 13</a><!-- ignore -->'te bu örneğe 
geri döneceğiz ve nasıl geliştirebileceğimize bakacağız.</p>
<h4 id="search-fonksiyonunu-run-fonksiyonunda-kullanma"><a class="header" href="#search-fonksiyonunu-run-fonksiyonunda-kullanma"><code>search</code> Fonksiyonunu <code>run</code> Fonksiyonunda Kullanma</a></h4>
<p>Artık <code>search</code> fonksiyonu çalıştığına ve test edildiğine göre, <code>run</code> fonksiyonumuzdan <code>search</code>'ü çağırmamız gerekiyor. 
<code>config.query</code> değerini ve <code>run</code>'ın dosyadan okuduğu içeriği <code>search</code> fonksiyonuna aktarmamız gerekiyor. 
Ardından <code>run</code>, <code>search</code> çağrısından dönen her satırı yazdıracaktır:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Her satırı <code>search</code>'ten döndürmek ve yazdırmak için hala bir <code>for</code> döngüsü kullanıyoruz.</p>
<p>Artık programımız çalışmalıdır! İlk olarak Emily Dickinson şiirinden tam olarak bir dizgi döndürmesi gereken bir sözcük ile deneyelim, “frog”:</p>
<pre><code class="language-console">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>Harika! Şimdi “body” gibi birden fazla satırla eşleşecek bir sözcüğü deneyelim:</p>
<pre><code class="language-console">$ cargo run body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Ve son olarak, “monomorphization” gibi şiirin hiçbir yerinde olmayan bir sözcüğü aradığımızda herhangi bir satır 
almadığımızdan emin olalım:</p>
<pre><code class="language-console">$ cargo run monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>Mükemmel! Klasik aracın kendi mini versiyonumuzu oluşturduk ve uygulamaların nasıl yapılandırılacağı hakkında çok şey öğrendik. 
Ayrıca dosya girişi ve çıkışı, yaşam süreleri, test etme ve komut satırı ayrıştırma hakkında da biraz bilgi edindik.</p>
<p>Bu projeyi tamamlamak için, her ikisi de komut satırı programları yazarken yararlı olan ortam değişkenleriyle nasıl çalışılacağını ve 
standart hataya nasıl yazdırılacağını kısaca göstereceğiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ortam-değişkenleriyle-Çalışmak"><a class="header" href="#ortam-değişkenleriyle-Çalışmak">Ortam Değişkenleriyle Çalışmak</a></h2>
<p>Ekstra bir özellik ekleyerek <code>minigrep</code>'i geliştireceğiz: kullanıcının bir ortam değişkeni aracılığıyla açabileceği
büyük/küçük harfe duyarlı olmayan arama seçeneği. Bu özelliği bir komut satırı seçeneği haline getirebilir
ve kullanıcıların her uygulamak istediklerinde girmelerini isteyebilirdik, ancak bunun yerine bir ortam değişkeni yaparak,
kullanıcılarımızın ortam değişkenini bir kez ayarlamalarına ve o terminal oturumunda tüm aramalarının büyük/küçük harfe duyarsız
olmasına izin veriyoruz.</p>
<h3 id="büyükküçük-harfe-duyarsız-search-fonksiyonu-için-başarısız-testi-yazma"><a class="header" href="#büyükküçük-harfe-duyarsız-search-fonksiyonu-için-başarısız-testi-yazma">Büyük/Küçük Harfe Duyarsız <code>search</code> Fonksiyonu için Başarısız Testi Yazma</a></h3>
<p>İlk olarak, ortam değişkeni bir değere sahip olduğunda çağrılacak yeni bir <code>search_case_insensitive</code> fonksiyonu ekliyoruz.
TDD sürecini takip etmeye devam edeceğiz, bu nedenle ilk adım yine başarısız bir test yazmaktır. Yeni <code>search_case_insensitive</code> fonksiyonu
için yeni bir test ekleyeceğiz ve Liste 12-20'de gösterildiği gibi iki test arasındaki farkları netleştirmek için eski testimizin adını
<code>one_result</code>'tan <code>case_sensitive</code>'e değiştireceğiz.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Duct tape.&quot;;

        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}
</code></pre>
<p><span class="caption">Liste 12-20: Eklemek üzere olduğumuz 
<em>büyük/küçük harfe duyarlı olmayan</em> fonksiyon için yeni bir başarısız test ekleme</span></p>
<p>Eski testin <code>contents</code>'ini de düzenlediğimizi unutmayın. 
Büyük/küçük harfe duyarlı bir şekilde arama yaparken <code>&quot;duct&quot;</code> sorgusuyla 
eşleşmemesi gereken büyük D harfini kullanarak <code>&quot;Duct tape.&quot;</code> metnini içeren yeni bir satır 
ekledik. Eski testi bu şekilde değiştirmek, halihazırda uyguladığımız büyük/küçük harfe 
duyarlı arama işlevini yanlışlıkla bozmamamızı sağlamaya yardımcı olur. Bu test şimdi geçmeli 
ve biz büyük/küçük harfe duyarsız arama üzerinde çalışırken sorunsuzca geçmeye devam 
etmelidir.</p>
<p>Büyük/küçük harfe duyarlı olmayan <code>search</code> için yeni test, sorgu olarak
<code>&quot;rUsT&quot;</code> kullanır. Eklemek üzere olduğumuz <code>search_case_insensitive</code> fonksiyonunda,
<code>&quot;rUsT&quot;</code> sorgusu, büyük R ile <code>&quot;Rust:&quot;</code> içeren satırla eşleşmeli ve her ikisi de sorgudan 
farklı harflere sahip olsa bile <code>&quot;Trust me.&quot;</code> satırıyla eşleşmelidir. Bu bizim başarısız 
testimizdir ve henüz <code>search_case_insensitive</code> fonksiyonunu tanımlamadığımız için 
derlenemeyecektir. Testin derlenip başarısız olduğunu görmek için Liste 12-16'daki
<code>search</code> fonksiyonu için yaptığımıza benzer şekilde, her zaman boş bir vektör döndüren bir 
sürekleme eklemekten çekinmeyin.</p>
<h3 id="search_case_insensitive-fonksiyonunun-süreklenmesi"><a class="header" href="#search_case_insensitive-fonksiyonunun-süreklenmesi"><code>search_case_insensitive</code> Fonksiyonunun Süreklenmesi</a></h3>
<p>Liste 12-21'de gösterilen <code>search_case_insensitive</code> fonksiyonu, <code>search</code> fonksiyonuyla 
neredeyse aynı olacaktır. Tek fark, sorguyu ve her satırı küçük harfle yazacağız, 
böylece girdi argümanlarının büyük/küçük harf durumu ne olursa olsun, 
satırın sorguyu içerip içermediğini kontrol ettiğimizde aynı büyük/küçük harf 
durumunda olacaklar.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 12-21: Sorguyu ve satırı karşılaştırmadan önce küçük harfle yazmak için <code>search_case_insensitive</code> 
fonksiyonunu tanımlama</span></p>
<p>İlk olarak, sorgu dizesini küçük harfle yazarız ve aynı ada sahip gölgeli bir değişkende saklarız. 
Sorgu üzerinde <code>to_lowercase</code> çağrısı yapmak gereklidir, böylece kullanıcının sorgusu <code>&quot;rust&quot;</code>, <code>&quot;RUST&quot;</code>, <code>&quot;Rust&quot;</code> 
veya <code>&quot;rUsT&quot;</code> olsun, sorguyu <code>&quot;rust&quot;</code> olarak ele alacağız ve fonksiyona büyük/küçük harfe duyarsız şekilde
yönlendireceğiz. <code>to_lowercase</code> temel Unicode'u işleyecek olsa da, tüm durumlarda %100 doğru çalışmayacaktır. 
Gerçek bir uygulama yazıyor olsaydık, burada biraz daha fazla durumu işlemek isterdik, ancak bu bölüm Unicode değil, 
ortam değişkenleri ile ilgilidir, bu yüzden burada bırakacağız.</p>
<p>Sorgunun artık bir dizgi dilimi yerine bir <code>String</code> olduğuna dikkat edin, çünkü <code>to_lowercase</code> çağrısı mevcut verilere 
başvurmak yerine yeni veriler oluşturur. Örnek olarak, sorgunun <code>&quot;rUsT&quot;</code> olduğunu varsayalım: bu dizgi diliminde 
kullanabileceğimiz küçük harfli bir <em>u</em> veya <em>t</em> bulunmadığından, <code>&quot;rust&quot;</code> içeren yeni bir <code>String</code> tahsis etmemiz gerekir. 
Şimdi sorguyu <code>contains</code> metoduna argüman olarak ilettiğimizde, <code>contains</code>'ın imzası bir dizgi dilimi alacak şekilde 
tanımlandığı için bir ve işareti eklememiz gerekir.</p>
<p>Ardından, tüm karakterleri küçük harfle yazmak için her satıra <code>to_lowercase</code> çağrısı ekliyoruz. 
Artık satırı ve sorguyu küçük harfe dönüştürdüğümüze göre, sorgunun büyük/küçük harf durumu ne olursa olsun
<code>match</code> yapısını kullanarak bulacağız.</p>
<p>Bakalım bu sürekleme testleri geçebilecek mi?</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Harika! Geçti. Şimdi, <code>run</code> fonksiyonundan yeni <code>search_case_insensitive</code> fonksiyonunu çağıralım. 
İlk olarak, büyük/küçük harfe duyarlı ve duyarsız arama arasında geçiş yapmak için <code>Config</code> yapısına bir 
yapılandırma seçeneği ekleyeceğiz. Bu alanı eklemek derleyici hatalarına neden olacaktır çünkü bu alanı henüz hiçbir 
yerde tanımlamıyoruz:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>pub struct Config {
    pub query: String,
    pub filename: String,
    pub ignore_case: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Bir Boole tutan <code>ignore_case</code> alanını ekledik. Daha sonra, <code>ignore_case</code> alanının değerini kontrol etmek ve 
bunu Liste 12-22'de gösterildiği gibi <code>search</code> fonksiyonunu mu yoksa <code>search_case_insensitive</code> fonksiyonunu mu çağıracağımıza 
karar vermek için kullanacak <code>run</code> fonksiyonuna ihtiyacımız olacak. Bu hala derlenmeyecektir.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    let results = if config.ignore_case {
        search_case_insensitive(&amp;config.query, &amp;contents)
    } else {
        search(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 12-22: <code>config.ignore_case</code> içindeki değere bağlı olarak <code>search</code> ya da 
<code>search_case_insensitive</code> çağrısı</span></p>
<p>Son olarak, ortam değişkenini kontrol etmemiz gerekiyor. Ortam değişkenleriyle çalışma fonksiyonları standart kütüphanedeki <code>env</code> modülündedir, 
bu yüzden bu modülü <em>src/lib.rs</em> dosyasının üst kısmına getiriyoruz. 
Ardından, Liste 12-23'te gösterildiği gibi, <code>IGNORE_CASE</code> adlı bir ortam değişkeni için herhangi bir değer ayarlanıp 
ayarlanmadığını kontrol etmek için <code>env</code> modülündeki <code>var</code> fonksiyonunu kullanacağız.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::env;
// --snip--

<span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            filename,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 12-23: IGNORE_CASE` adlı bir ortam değişkeninde herhangi bir değer olup olmadığını kontrol 
etmek</span></p>
<p>Burada, yeni bir <code>ignore_case</code> değişkeni oluşturuyoruz. 
Değeri ayarlamak için <code>env::var</code> fonksiyonunu çağırıyoruz ve ona <code>IGNORE_CASE</code> ortam değişkeninin adını aktarıyoruz.
<code>env::var</code> fonksiyonu, ortam değişkeni herhangi bir değere ayarlanmışsa, ortam değişkeninin değerini içeren başarılı <code>Ok</code> 
değişkeni olacak bir <code>Result</code> döndürür. Ortam değişkeni ayarlanmamışsa <code>Err</code> değişkenini döndürür.</p>
<p>Ortam değişkeninin ayarlanıp ayarlanmadığını kontrol etmek için <code>Result</code> üzerinde <code>is_ok</code> metodunu kullanıyoruz, 
bu da programın büyük/küçük harfe duyarlı olmayan bir arama yapması gerektiği anlamına geliyor.
<code>IGNORE_CASE</code> ortam değişkeni herhangi bir şeye ayarlanmamışsa, <code>is_ok</code> yöntemi <code>false</code> değerini döndürür ve 
program büyük/küçük harfe duyarlı bir arama gerçekleştirir. Ortam değişkeninin değeriyle henüz ilgilenmiyoruz, 
sadece ayarlı ya da ayarsız olmasıyla ilgileniyoruz, bu yüzden <code>unwrap</code>, <code>expect</code> ya da <code>Result</code>'ta 
gördüğümüz diğer metodlardan birini kullanmak yerine <code>is_ok</code>'u kontrol ediyoruz.</p>
<p><code>ignore_case</code> değişkenindeki değeri <code>Config</code> örneğine aktarırız, böylece <code>run</code> fonksiyonu bu değeri okuyabilir ve 
Liste 12-22'de yaptığımız gibi <code>search_case_insensitive</code> veya <code>search</code> çağrısı oluşturup oluşturmayacağına karar verebilir.</p>
<p>Hadi deneyelim! İlk olarak, programımızı ortam değişkeni ayarlanmadan; <code>to</code> sorgusuyla çalıştıracağız; bu sorgu,
<code>to</code> sözcüğünü tümüyle küçük harfli şekilde içeren herhangi bir satırla eşleşmelidir:</p>
<pre><code class="language-console">$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Görünüşe göre hala çalışıyor! Şimdi, programı <code>IGNORE_CASE</code> <code>1</code> olarak ayarlanmış şekilde,
aynı sorgu ile çalıştıralım.</p>
<pre><code class="language-console">$ IGNORE_CASE=1 cargo run to poem.txt
</code></pre>
<p>PowerShell kullanıyorsanız, ortam değişkenini ayarlamanız ve programı ayrı komutlar olarak 
çalıştırmanız gerekecektir:</p>
<pre><code class="language-console">PS&gt; $Env:IGNORE_CASE=1; cargo run to poem.txt
</code></pre>
<p>Bu, kabuk oturumunuzun geri kalanında
<code>IGNORE_CASE</code>'in kalıcı olmasını sağlayacaktır. <code>Remove-Item</code> <code>cmdlet</code>'i ile bu ayar kaldırılabilir:</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:IGNORE_CASE
</code></pre>
<p>“to” içeren, büyük harfli olabilecek satırlar görmeliyiz:</p>
<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
IGNORE_CASE=1 cargo run to poem.txt
can't extract because of the environment variable
-->
<pre><code class="language-console">Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Muhteşem, “To” içeren satırlarımızı da görüyoruz! <code>minigrep</code> programımız artık bir ortam değişkeni 
tarafından kontrol edilen büyük/küçük harfe duyarlı olmayan arama yapabiliyor. Artık komut satırı argümanları 
ya da ortam değişkenleri kullanılarak ayarlanan seçenekleri nasıl yöneteceğinizi biliyorsunuz.</p>
<p>Bazı programlar aynı yapılandırma için argümanlara <em>ve</em> ortam değişkenlerine izin verir. 
Bu durumlarda, programlar birinin ya da diğerinin öncelikli olduğuna karar verir. 
Kendi başınıza başka bir alıştırma yapmak için, bir komut satırı argümanı veya bir ortam değişkeni aracılığıyla 
büyük/küçük harf duyarlılığını kontrol etmeyi deneyin. Program biri büyük/küçük harfe duyarlı diğeri 
büyük/küçük harfi yok sayacak şekilde ayarlanmış olarak çalıştırılırsa komut satırı argümanının mı yoksa ortam 
değişkeninin mi öncelikli olacağına karar verin.</p>
<p><code>std::env</code> modülü, ortam değişkenleriyle başa çıkmak için daha birçok yararlı özellik içerir:
nelerin mevcut olduğunu görmek için ilgili dokümantasyonuna göz atın.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="standart-Çıktı-yerine-standart-hataya-hata-mesajları-yazma"><a class="header" href="#standart-Çıktı-yerine-standart-hataya-hata-mesajları-yazma">Standart Çıktı Yerine Standart Hataya Hata Mesajları Yazma</a></h2>
<p>Şu anda çıktımızın tamamını <code>println!</code> makrosunu kullanarak uçbirime yazıyoruz. 
Çoğu uçbirimde iki tür çıktı vardır: genel bilgiler için standart çıktı (<code>stdout</code>) ve hata mesajları için standart hata (<code>stderr</code>). 
Bu ayrım, kullanıcıların bir programın başarılı çıktısını bir dosyaya yönlendirmeyi, 
ancak yine de ekrana hata mesajlarını yazdırmayı seçmelerini sağlar.</p>
<p><code>prıntln!</code> makrosu yalnızca standart çıktıya yazdırabilir, bu nedenle standart hataya yazdırmak 
için başka bir şey kullanmamız gerekir.</p>
<h3 id="hataların-nerede-yazıldığını-kontrol-etme"><a class="header" href="#hataların-nerede-yazıldığını-kontrol-etme">Hataların Nerede Yazıldığını Kontrol Etme</a></h3>
<p>Öncelikle <code>minigrep</code> tarafından yazdırılan içeriğin şu anda standart çıktıya nasıl yazıldığını gözlemleyelim, 
bunun yerine standart hataya yazmak istediğimiz herhangi bir hata mesajı dahil. Bunu, kasıtlı olarak bir hataya 
neden olurken standart çıktı akışını bir dosyaya yeniden yönlendirerek yapacağız. Standart hata akışını yeniden 
yönlendirmeyeceğiz, bu nedenle standart hataya gönderilen herhangi bir içerik ekranda görüntülenmeye devam edecektir.</p>
<p>Komut satırı programlarının standart hata akışına hata mesajları göndermesi beklenir, böylece standart çıktı akışını 
bir dosyaya yönlendirsek bile ekranda hata mesajlarını görebiliriz.</p>
<p>Bu davranışı göstermek için programı <code>&gt;</code> ve standart çıktı akışını yönlendirmek istediğimiz 
<em>output.txt</em> dosya adıyla çalıştıracağız. Hataya neden olacak herhangi bir argüman iletmiyoruz:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
</code></pre>
<p><code>&gt;</code> söz dizimi, kabuğa standart çıktının içeriğini ekrana değil de <em>output.txt</em> dosyasına yazmasını söyler. 
Ekrana yazdırılmasını beklediğimiz hata mesajını görmedik, bu da dosyada bittiği anlamına geliyor. <em>output.txt</em> şunları içerir:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>Evet, hata mesajımız standart çıktıya yazdırılıyor. Bunun gibi hata mesajlarının standart hataya 
yazdırılması çok daha kullanışlıdır, bu nedenle dosyada yalnızca başarılı bir çalıştırmadan 
elde edilen veriler biter. Bunu değiştireceğiz.</p>
<h3 id="hataları-standart-hataya-yazdırma"><a class="header" href="#hataları-standart-hataya-yazdırma">Hataları Standart Hataya Yazdırma</a></h3>
<p>Hata mesajlarının nasıl yazdırılacağını değiştirmek için Liste 12-24'teki kodu kullanacağız. 
Bu bölümde daha önce yaptığımız yeniden düzenleme nedeniyle, hata mesajlarını yazdıran tüm kodlar tek bir fonksiyondadır. 
Standart kütüphane, standart hata akışına yazdıran <code>eprintln!</code> makrosunu sağlar, bu yüzden hataları yazdırmak için <code>println!</code> 
dediğimiz iki yeri değiştirelim ve bunun yerine <code>eprintln!</code> kullanalım.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p><span class="caption">Liste 12-24: <code>eprintln!</code> kullanarak standart çıktı yerine 
hata mesajlarını standart hataya yazma</span></p>
<p>Şimdi programı aynı şekilde, herhangi bir argüman olmadan ve standart çıktıyı <code>&gt;</code> ile yeniden 
yönlendirerek tekrar çalıştıralım:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Şimdi ekranda hatayı görüyoruz ve <em>output.txt</em> hiçbir şey içermiyor, bu da komut satırı programlarından beklediğimiz davranış.</p>
<p>Programı, hataya neden olmayan ancak yine de standart çıktıyı bir dosyaya yönlendiren argümanlarla tekrar çalıştıralım, şöyle:</p>
<pre><code class="language-console">$ cargo run to poem.txt &gt; output.txt
</code></pre>
<p>Uçbirimde herhangi bir çıktı görmeyeceğiz ve <em>output.txt</em> sonuçlarımızı içerecektir:</p>
<p><span class="filename">Dosya adı: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Bu, başarılı çıktı için standart çıktıyı ve uygun olduğu şekilde hata çıktısı için standart hatayı kullandığımızı gösterir.</p>
<h2 id="Özet-8"><a class="header" href="#Özet-8">Özet</a></h2>
<p>Bu bölüm, şimdiye kadar öğrendiğiniz bazı temel kavramları özetledi ve Rust'ta genel *G/Ç/ işlemlerinin nasıl gerçekleştirileceğini ele aldı. 
Komut satırı bağımsız değişkenlerini, dosyaları, ortam değişkenlerini ve <code>eprintln!</code> makrosunu kullanmaya ve komut 
satırı uygulamaları yazmaya hazırsınız. Önceki bölümlerdeki kavramlarla birleştiğinde, kodunuz iyi organize edilecek, 
verileri uygun veri yapılarında etkin bir şekilde depolayacak, hataları güzel bir şekilde ele alacak ve iyi test edilecektir.</p>
<p>Ardından, fonksiyonel dillerden etkilenen bazı Rust özelliklerini keşfedeceğiz: kapanış ifadeleri ve yineleyiciler.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fonksiyonel-dil-Özellikleri-yineleyiciler-ve-kapanış-İfadeleri"><a class="header" href="#fonksiyonel-dil-Özellikleri-yineleyiciler-ve-kapanış-İfadeleri">Fonksiyonel Dil Özellikleri: Yineleyiciler ve Kapanış İfadeleri</a></h1>
<p>Rust'ın tasarımı birçok mevcut dil ve teknikten ilham almıştır ve önemli bir etkisi de fonksiyonel programlamadır. 
Fonksiyonel bir tarzda programlama, genellikle, fonksiyonları argümanlarda ileterek, diğer fonksiyonlardan geri döndürerek, 
daha sonra yürütülmek üzere değişkenlere atayarak vb. değerler olarak kullanmayı içerir.</p>
<p>Bu bölümde, fonksiyonel programlamanın ne olduğu veya olmadığı konusunu tartışmayacağız, 
bunun yerine Rust'ın birçok dilde genellikle fonksiyonel olarak adlandırılan özelliklere benzeyen bazı 
özelliklerini tartışacağız.</p>
<p>Daha özel olarak, ele alacağız:</p>
<ul>
<li><em>Kapanış ifadeleri</em>, bir değişkende saklayabileceğiniz fonksiyon benzeri bir yapı</li>
<li><em>Yineleyiciler</em>, bir dizi elemanı işlemenin bir yolu</li>
<li>Bölüm 12'deki I/O projesini geliştirmek için bu iki özelliğin nasıl kullanılacağı</li>
<li>Bu iki özelliğin performansı (Spoiler uyarısı: düşündüğünüzden daha hızlılar!)</li>
</ul>
<p>Diğer bölümlerde ele aldığımız model eşleştirme ve numaralandırma gibi diğer Rust özellikleri de fonksiyonel stilden etkilenir. 
Kapanış ifadelerine ve yineleyicilere hakim olmak, deyimsel, hızlı Rust kodu yazmanın önemli bir parçasıdır, bu yüzden bu bölümün tamamını 
onlara ayıracağız.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kapanış-İfadeleri-Çevrelerini-yakalayabilen-anonim-fonksiyonlar"><a class="header" href="#kapanış-İfadeleri-Çevrelerini-yakalayabilen-anonim-fonksiyonlar">Kapanış İfadeleri: Çevrelerini Yakalayabilen Anonim Fonksiyonlar</a></h2>
<p>Rust'ın kapanışları, bir değişkene kaydedebileceğiniz veya diğer fonksiyonlara argüman olarak aktarabileceğiniz 
anonim fonksiyonlardır. Kapanışları bir yerde oluşturabilir ve daha sonra farklı bir bağlamda
değerlendirmek için kapanışları çağırabilirsiniz. Fonksiyonların aksine, kapanışlar tanımlandıkları kapsamdaki değerleri yakalayabilir. 
Bu kapanış özelliklerinin kodun yeniden kullanımına ve davranış özelleştirmesine nasıl izin verdiğini göstereceğiz.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a></p>
<h3 id="kapanışlar-ile-ortamı-yakalama"><a class="header" href="#kapanışlar-ile-ortamı-yakalama">Kapanışlar ile Ortamı Yakalama</a></h3>
<p>Kapanışların inceleyeceğimiz ilk yönü, kapanışların tanımlandıkları ortamdaki değerleri daha sonra kullanmak üzere yakalayabilmeleridir. 
İşte senaryo: Bir tişört şirketi, e-posta listesindeki bir kişiye sık sık ücretsiz bir tişört hediye ediyor. 
E-posta listesindeki kişiler isteğe bağlı olarak profillerine favori renklerini ekleyebilirler. 
Ücretsiz tişörtü almak için seçilen kişinin profilinde en sevdiği renk varsa, 
o renk tişörtü alır. Kişi favori rengini belirtmemişse, şirketin şu anda en çok sahip olduğu rengi alır.</p>
<p>Bunu yapmanın birçok yolu vardır. Bu örnek için, <code>Red</code> ve <code>Blue</code> değişkenlerine sahip <code>ShirtColor</code> adlı bir <code>enum</code> kullanacağız. 
Şirketin envanteri, şu anda stokta bulunan tişörtleri temsil eden bir <code>Vec&lt;ShirtColor&gt;</code> içeren <code>shirts</code> adlı bir alana sahip bir
<code>Inventory</code> <code>struct</code>'ı ile temsil edilir. <code>Inventory</code> üzerinde tanımlanan <code>shirt_giveaway</code> metodu, ücretsiz gömlek alacak kişinin 
isteğe bağlı gömlek rengi tercihini alır ve kişinin alacağı gömlek rengini döndürür. Bu, Liste 13-1'de gösterilmektedir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        &quot;The user with preference {:?} gets {:?}&quot;,
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        &quot;The user with preference {:?} gets {:?}&quot;,
        user_pref2, giveaway2
    );
}
</code></pre>
<p><span class="caption">Liste 13-1: Tişört şirketi çekilişi</span></p>
<p><code>main</code>'de tanımlı <code>store</code>'da iki mavi ve bir kırmızı gömlek bulunmaktadır. 
Ardından, kırmızı gömlek tercihi olan bir kullanıcı ve herhangi bir tercihi olmayan bir kullanıcı için <code>giveaway</code> metodunu 
çağırmış olsun. Bu kodu çalıştırmak şunları yazdırırır:</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
</code></pre>
<p>Yine, bu kod birçok şekilde uygulanabilir, ancak bu yol, bir kapanışları kullanan <code>giveaway</code> metodunun gövdesi dışında, 
daha önce öğrendiğiniz kavramları kullanır. <code>giveaway</code> metodu kullanıcı tercihi <code>Option&lt;ShirtColor&gt;</code>'ı alır ve üzerinde
<code>unwrap_or_else</code> çağrısı yapar. <a href="../std/option/enum.Option.html#method.unwrap_or_else"><code>Option&lt;T&gt;</code> üzerindeKİ <code>unwrap_or_else</code> metodu</a><!-- ignore -->
metodu standart kütüphane tarafından tanımlanmıştır. Bir argüman alır: <code>T</code> (<code>Option&lt;T&gt;</code>'nin <code>Some</code> varyantında saklanan aynı tür, 
bu durumda bir <code>ShirtColor</code>) döndüren herhangi bir 
argümanı olmayan bir kapanıştır. <code>Option&lt;T&gt;</code>, <code>Some</code> varyantı ise <code>unwrap_or_else</code>, <code>Some</code> içindeki değeri döndürür.
<code>Option&lt;T&gt;</code> <code>None</code> varyantıysa, <code>unwrap_or_else</code> kapanışı çağırır ve ka tarafından döndürülen değeri döndürür.</p>
<p>Bu ilginçtir çünkü mevcut <code>Inventory</code> örneğinde <code>self.most_stocked()</code> fonksiyonunu çağıran bir kapanış geçirdik. 
Standart kütüphanenin, tanımladığımız <code>Inventory</code> veya <code>ShirtColor</code> türleri ya da bu senaryoda kullanmak istediğimiz mantık hakkında 
hiçbir şey bilmesine gerek yoktu. Kapanış, <code>self Inventory</code> örneğine değişmez bir referans yakaladı ve <code>unwrap_or_else</code> metoduna belirttiğimiz 
kodla birlikte aktardı. Fonksiyonlar kendi ortamlarını bu şekilde yakalayamazlar.</p>
<h3 id="kapanış-tür-Çıkarsaması-ve-ek-açıklama"><a class="header" href="#kapanış-tür-Çıkarsaması-ve-ek-açıklama">Kapanış Tür Çıkarsaması ve Ek Açıklama</a></h3>
<p>Fonksiyonlar ve kapanışlar arasında daha fazla fark vardır. Kapanışlar genellikle <code>fn</code> fonksiyonlarında olduğu gibi parametrelerin 
veya dönüş değerinin türlerini açıklamanızı gerektirmez. Kullanıcılarınıza açık bir arayüzün parçası oldukları için fonksiyonlarda tür ek 
açıklamaları gereklidir. Bu arayüzü katı bir şekilde tanımlamak, bir fonksiyonun kullandığı ve döndürdüğü değer türleri konusunda herkesin 
hemfikir olmasını sağlamak açısından önemlidir. Ancak kapanışlar bu şekilde açık bir arayüzde kullanılmazlar: 
değişkenlerde saklanırlar ve isimlendirilmeden ve kütüphanemizin kullanıcılarına gösterilmeden kullanılırlar.</p>
<p>Kapanışlar tipik olarak kısadır ve herhangi bir rastgele senaryodan ziyade yalnızca dar bir bağlamda önemlidir. 
Bu sınırlı bağlamlarda derleyici, çoğu değişkenin türünü çıkarabildiği gibi parametrelerin türlerini ve dönüş türünü de çıkarabilir 
(derleyicinin kapanış türü ek açıklamalarına ihtiyaç duyduğu nadir durumlar da vardır).</p>
<p>Değişkenlerde olduğu gibi, kesinlikle gerekli olandan daha ayrıntılı olma pahasına açıklığı ve netliği artırmak istiyorsak tür 
ek açıklamaları ekleyebiliriz. Bir kapanış için tür açıklamaları Liste 13-2'de gösterilen tanıma benzeyecektir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!(&quot;Today, do {} pushups!&quot;, expensive_closure(intensity));
</span><span class="boring">        println!(&quot;Next, do {} situps!&quot;, expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;Today, run for {} minutes!&quot;,
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 13-2: Kapanıştaki parametre ve dönüş değeri türlerinin isteğe bağlı tür ek açıklamalarının eklenmesi</span></p>
<p>Tür ek açıklamaları eklendiğinde, kapanışların söz dizimi fonksiyonların söz dizimine daha yakın görünür. 
Aşağıda, parametresine <code>1</code> ekleyen bir fonksiyon ile aynı davranışa sahip bir kapanış tanımının söz diziminin dikey bir karşılaştırması 
yer almaktadır. İlgili kısımları hizalamak için bazı boşluklar ekledik. Bu, kapanış söz diziminin, boruların kullanımı ve isteğe bağlı 
söz dizimi miktarı dışında fonksiyon söz dizimine nasıl benzediğini göstermektedir:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<p>İlk satır bir fonksiyon tanımını, ikinci satır ise tam açıklamalı bir kapanış tanımını göstermektedir. Üçüncü satırda kapanış tanımından 
tür ek açıklamaları kaldırılır ve dördüncü satırda kapanış gövdesinde yalnızca bir ifade olduğu için isteğe bağlı olan parantezler kaldırılır. 
Bunların hepsi, çağrıldıklarında aynı davranışı üretecek geçerli tanımlardır. Kapanışların çağrılması <code>add_one_v3</code> ve <code>add_one_v4</code>'ün derlenebilmesi 
için gereklidir çünkü türler kullanımlarından çıkarılacaktır.</p>
<p>Kapanış tanımları, parametrelerinin her biri ve dönüş değerleri için çıkarılan bir somut türe sahip olacaktır.
Örneğin, Liste 13-3 sadece parametre olarak aldığı değeri döndüren bir kısa kapanış tanımını göstermektedir. 
Bu kapanış, bu örneğin amaçları dışında çok kullanışlı değildir. Tanıma herhangi bir tür ek açıklaması eklemediğimize dikkat edin: 
ilk seferinde argüman olarak bir <code>String</code> ve ikinci seferinde bir <code>u32</code> kullanarak kapanışı iki kez çağırmaya çalışırsak, bir hata alırız.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from(&quot;hello&quot;));
    let n = example_closure(5);
<span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 13-3: Türleri iki farklı türle çıkarılan bir kapanış çağrılmaya çalışılıyor</span></p>
<p>Derleyici bu hatayı verir:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |                             ^- help: try using a conversion method: `.to_string()`
  |                             |
  |                             expected struct `String`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` due to previous error
</code></pre>
<p><code>String</code> değeriyle <code>example_closure</code> öğesini ilk kez çağırdığımızda, derleyici <code>x</code>'in türünü ve kapanışın dönüş türünü
<code>String</code> olarak çıkarır. Bu türler daha sonra <code>example_closure</code>'daki kapanışa kilitlenir ve aynı kapanış ile farklı bir tür kullanmaya 
çalışırsak bir tür hatası alırız.</p>
<h3 id="referansları-yakalama-veya-sahipliği-taşıma"><a class="header" href="#referansları-yakalama-veya-sahipliği-taşıma">Referansları Yakalama veya Sahipliği Taşıma</a></h3>
<p>Kapanışlar çevrelerinden üç şekilde değer alabilir, bu da doğrudan bir fonksiyonun parametre alabileceği üç yolla eşleşir: 
değişmez olarak ödünç alma, değişebilir olarak ödünç alma ve sahiplik alma. Kapanış, fonksiyonun gövdesinin yakalanan değerlerle ne 
yaptığına bağlı olarak bunlardan hangisini kullanacağına karar verecektir.</p>
<p>Liste 13-4, <code>list</code> adlı vektöre değişmez bir ödünç alan bir kapanış tanımlar çünkü değeri yazdırmak için yalnızca değişmez 
bir ödünç almaya ihtiyaç duyar. Bu örnek aynı zamanda bir değişkenin bir kapanış tanımına bağlanabileceğini ve 
kapanışın daha sonra değişken adı ve parantezler kullanılarak sanki değişken adı bir fonksiyon adıymış gibi çağrılabileceğini göstermektedir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {:?}&quot;, list);

    let only_borrows = || println!(&quot;From closure: {:?}&quot;, list);

    println!(&quot;Before calling closure: {:?}&quot;, list);
    only_borrows();
    println!(&quot;After calling closure: {:?}&quot;, list);
}
</code></pre></pre>
<p><span class="caption">Liste 13-4: Değişmez bir ödünç almayı yakalayan bir kapanış tanımlama ve çağırma</span></p>
<p><code>list</code>, kapanış tanımından önce, kapanış tanımından sonra ancak kapanış çağrılmadan önce ve kapanış çağrıldıktan sonra kod 
tarafından hala erişilebilir çünkü aynı anda birden fazla değişmez <code>list</code>'i ödünç alabiliriz. 
Bu kod derlenir, çalıştırılır ve yazdırılır:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
</code></pre>
<p>Ardından, Liste 13-5, kapanış gövdesi liste vektörüne bir eleman eklediği için kapanış tanımını değiştirilebilir bir ödünç 
almaya ihtiyaç duyacak şekilde değiştirir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {:?}&quot;, list);

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!(&quot;After calling closure: {:?}&quot;, list);
}
</code></pre></pre>
<p><span class="caption">Liste 13-5: Değiştirilebilir bir ödünç almayı yakalayan bir kapanış tanımlama ve çağırma</span></p>
<p>Bu kod derlenir, çalışır ve bunu yazdırır:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
</code></pre>
<p>Tanım ile <code>borrows_mutably</code> kapanışının çağrısı arasında artık bir <code>println!</code> olmadığına dikkat edin:
<code>borrows_mutably</code> tanımlandığında, <code>list</code>'e değiştirilebilir bir referans yakalar. Kapanış çağrıldıktan sonra, 
o noktadan sonra kapanışı tekrar kullanmadığımız için, <code>mutable</code> ödünç alma işlemi sona erer. Kapanış tanımı ve kapanış çağrısı arasında,
<code>print</code>'e değişmez bir ödünç almaya izin verilmez çünkü değişebilir bir ödünç alma olduğunda başka ödünç almaya izin verilmez. 
Nasıl bir hata mesajı alacağınızı görmek için oraya bir <code>println!</code> eklemeyi deneyin!</p>
<p>Kapanışın gövdesi kesinlikle sahipliğe ihtiyaç duymasa bile kapanışı ortamda kullandığı değerlerin sahipliğini almaya zorlamak istiyorsanız, 
parametre listesinden önce <code>move</code> anahtar sözcüğünü kullanabilirsiniz. Bu teknik çoğunlukla bir kapanışı yeni bir iş parçacığına aktarırken, 
verileri yeni iş parçacığına ait olacak şekilde taşımak için kullanışlıdır. Eşzamanlılık hakkında konuştuğumuz 16. Bölümde
<code>move</code> kapanışları ile ilgili daha fazla örneğimiz olacak.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a></p>
<h3 id="yakalanan-değerleri-kapanış-ve-fn-tanımlarının-dışına-taşıma"><a class="header" href="#yakalanan-değerleri-kapanış-ve-fn-tanımlarının-dışına-taşıma">Yakalanan Değerleri Kapanış ve <code>Fn</code> Tanımlarının Dışına Taşıma</a></h3>
<p>Bir kapanış bir referansı yakaladığında veya bir değeri kapanışa taşıdığında, fonksiyonun gövdesindeki kod da 
fonksiyonun çağrılmasının bir sonucu olarak referanslara veya değerlere ne olacağını etkiler. 
Bir kapanış gövdesi, yakalanan bir değeri kapanış dışına taşıyabilir, yakalanan değeri değiştirebilir, 
yakalanan değeri ne taşıyabilir ne de değiştirebilir veya ortamdan hiçbir şey yakalayamaz. 
Bir kapanışın ortamdan değerleri yakalama ve işleme şekli, kapanışın hangi özellikleri uyguladığını etkiler. 
Tanımlar, fonksiyonların ve yapıların ne tür kapanışları kullanabileceklerini belirtme şeklidir.</p>
<p>Kapanışlar otomatik olarak bu <code>Fn</code> tanımlarından birini, ikisini ya da üçünü de eklenebilir bir şekilde sürekleyecektir:</p>
<ol>
<li><code>FnOnce</code> en az bir kez çağrılabilen kapanışlar için geçerlidir. Tüm kapanışlar bu tanımı sürekler, çünkü tüm kapanışlar çağrılabilir. 
Bir kapanış yakalanan değerleri gövdesinin dışına taşırsa, bu kapanış yalnızca <code>FnOnce</code> tanımını sürekler ve diğer
<code>Fn</code> tanımlarından hiçbirini süreklemez, çünkü yalnızca bir kez çağrılabilir.</li>
<li><code>FnMut</code>, yakalanan değerleri gövdelerinin dışına taşımayan ancak yakalanan değerleri mutasyona uğratabilen kapanışlar için geçerlidir. 
Bu kapanışlar birden fazla kez çağrılabilir.</li>
<li><code>Fn</code>, yakalanan değerleri gövdelerinin dışına taşımayan ve yakalanan değerleri mutasyona uğratmayan kapamalar için geçerlidir. Bu kapanışlar, 
ortamlarını değiştirmeden birden fazla kez çağrılabilir; bu da bir closure'ın aynı anda birden fazla kez çağrılması gibi durumlarda önemlidir.
Çevrelerinden hiçbir şey yakalamayan kapanışlar <code>Fn</code>'i sürekler.</li>
</ol>
<p>Liste 13-6'da kullandığımız <code>Option&lt;T&gt;</code> üzerindeki <code>unwrap_or_else</code> metodunun tanımına bakalım:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}
</code></pre>
<p><code>T</code>'nin, <code>Option</code>'ın <code>Some</code> varyantındaki değerin türünü temsil eden yaygın tür olduğunu hatırlayın. 
Bu <code>T</code> türü aynı zamanda <code>unwrap_or_else</code> fonksiyonunun dönüş türüdür: örneğin bir <code>Option&lt;String&gt;</code> üzerinde <code>unwrap_or_else</code> çağrısı yapan 
kod bir <code>String</code> elde edecektir.</p>
<p>Daha sonra, <code>unwrap_or_else</code> fonksiyonunun ek bir yaygın tür parametresi olduğuna dikkat edin: <code>F</code>. <code>F</code> türü,
<code>unwrap_or_else</code> fonksiyonunu çağırırken sağladığımız kapanış olan <code>f</code> adlı parametrenin tipidir.</p>
<p><code>F</code> yaygın türünde belirtilen tanım bağlılığı <code>FnOnce() -&gt; T</code>'dir, yani <code>F</code> en az bir kez çağrılabilmeli, hiçbir argüman almamalı ve 
bir <code>T</code> döndürmelidir. Tanım bağlılığında <code>FnOnce</code> kullanılması, <code>unwrap_or_else</code> fonksiyonunun <code>f</code>'yi yalnızca en fazla bir kez 
çağıracağı kısıtlamasını ifade eder. <code>unwrap_or_else</code>'in gövdesinde; <code>Option</code> <code>Some</code> ise <code>f</code>'nin çağrılmayacağını görebiliriz.
<code>Option</code> <code>None</code> ise, <code>f</code> bir kez çağrılacaktır. Tüm kapanışlar <code>FnOnce</code>'ı uyguladığından, <code>unwrap_or_else</code> en farklı kapanış türlerini 
kabul eder ve olabildiğince esnektir.</p>
<blockquote>
<p>Not: Fonksiyonlar da <code>Fn</code> tanımının üçünü de sürekleyebilir. Yapmak istediğimiz şey ortamdan bir değer yakalamayı gerektirmiyorsa, 
<code>Fn</code> tanımlarından birini sürekleyen bir şeye ihtiyaç duyduğumuz yerde kapanış yerine fonksiyonun adını kullanabiliriz. 
Örneğin, <code>Option&lt;Vec&lt;T&gt;&gt;</code> değeri üzerinde, değer <code>None</code> ise yeni ve boş bir vektör elde etmek için 
<code>unwrap_or_else(Vec::new)</code> çağrısı yapabiliriz.</p>
</blockquote>
<p>Şimdi bunun nasıl farklılaştığını görmek için dilimler üzerinde tanımlanan standart kütüphane metodu <code>sort_by_key</code>'e bakalım.
<code>FnMut</code>'i sürekleyen bir kapanış alır. Kapanış, dikkate alınan dilimdeki geçerli öğeye bir referans olmak üzere bir argüman alır ve 
sıralanabilen <code>K</code> türünde bir değer döndürür. Bu fonksiyon, bir dilimi her bir öğenin belirli bir özelliğine göre sıralamak 
istediğinizde kullanışlıdır. Liste 13-7'de, <code>Rectangle</code> örneklerinden oluşan bir listemiz var ve bunları <code>width</code> niteliklerine göre 
düşükten yükseğe doğru sıralamak için <code>sort_by_key</code>'i kullanıyoruz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle {
            width: 10,
            height: 1,
        },
        Rectangle {
            width: 3,
            height: 5,
        },
        Rectangle {
            width: 7,
            height: 12,
        },
    ];

    list.sort_by_key(|r| r.width);
    println!(&quot;{:#?}&quot;, list);
}
</code></pre></pre>
<p><span class="caption">Liste 13-7: <code>Rectangle</code> örneklerinden oluşan bir listeyi <code>width</code> değerlerine göre sıralamak için <code>sort_by_key</code>'i ve
kapanışları kullanma</span></p>
<p>Bu kod şunları yazdırır:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p><code>sort_by_key</code>'in <code>FnMut</code> kapanışı alacak şekilde tanımlanmasının nedeni, kapanışı birden çok kez çağırmasıdır: 
dilimdeki her öğe için bir kez. <code>|r| r.width</code> kapanışı, çevresinden herhangi bir şeyi yakalamaz, mutasyona uğratmaz veya dışarı taşımaz, 
bu nedenle tanım bağlılığı gereksinimlerini karşılar.</p>
<p>Buna karşılık, Liste 13-8, ortamdan bir değer taşıdığı için yalnızca <code>FnOnce</code> uygulayan bir kapanış örneğini gösterir. 
Derleyici bu kapanışı <code>sort_by_key</code> ile kullanmamıza izin vermez:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle {
            width: 10,
            height: 1,
        },
        Rectangle {
            width: 3,
            height: 5,
        },
        Rectangle {
            width: 7,
            height: 12,
        },
    ];

    let mut sort_operations = vec![];
    let value = String::from(&quot;by key called&quot;);

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!(&quot;{:#?}&quot;, list);
}
</code></pre>
<p><span class="caption">Liste 13-8: <code>sort_by_key</code> ile <code>FnOnce</code> kapanışını kullanma girişimi</span></p>
<p>Bu, <code>list</code>'i sıralarken <code>sort_by_key</code>'in kaç kez çağrıldığını saymaya çalışmak için uydurulmuş, karmaşık bir yoldur (işe yaramaz). 
Bu kod bu sayımı, kapanış ortamından bir <code>String</code> olan değeri <code>sort_operations</code> vektörüne iterek yapmaya çalışır. 
Kapanış değeri yakalar ve ardından değerin sahipliğini <code>sort_operations</code> vektörüne aktararak değeri kapanış dışına taşır. 
Bu kapanış bir kez çağrılabilir; ikinci kez çağırmaya çalışmak işe yaramaz çünkü değer artık <code>sort_operations</code>'a tekrar itilecek ortamda 
olmayacaktır! Bu nedenle, bu kapanış yalnızca <code>FnOnce</code>'ı sürekler. Bu kodu derlemeye çalıştığımızda, değerin kapanış dışına taşınamayacağını 
çünkü kapanıın <code>FnMut</code>'u süreklemesi gerektiğini belirten bir hata alırız:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:27:30
   |
24 |       let value = String::from(&quot;by key called&quot;);
   |           ----- captured outer variable
25 | 
26 |       list.sort_by_key(|r| {
   |  ______________________-
27 | |         sort_operations.push(value);
   | |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait
28 | |         r.width
29 | |     });
   | |_____- captured by this `FnMut` closure

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` due to previous error
</code></pre>
<p>Hata, değeri ortamın dışına taşıyan kapatma gövdesindeki satıra işaret eder. Bunu düzeltmek için, kapanış gövdesini 
değerleri ortamın dışına taşımayacak şekilde değiştirmemiz gerekir. <code>sort_by_key</code>'in kaç kez çağrıldığıyla ilgileniyorsak, 
ortamda bir sayaç tutmak ve kapanış gövdesinde değerini artırmak bunu hesaplamanın daha kolay bir yoludur. 
Liste 13-9'daki kapanış <code>sort_by_key</code> ile çalışır çünkü sadece <code>num_sort_operations</code> sayacına değiştirilebilir bir referans yakalar 
ve bu nedenle birden fazla kez çağrılabilir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle {
            width: 10,
            height: 1,
        },
        Rectangle {
            width: 3,
            height: 5,
        },
        Rectangle {
            width: 7,
            height: 12,
        },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!(&quot;{:#?}, sorted in {num_sort_operations} operations&quot;, list);
}
</code></pre></pre>
<p><span class="caption">Liste 13-9: <code>sort_by_key</code> ile bir <code>FnMut</code> kapanışının kullanılmasına izin verilir</span></p>
<p><code>Fn</code> tanımları, kapanışlardan yararlanan fonksiyonları veya türleri tanımlarken veya kullanırken önemlidir. 
Bir sonraki bölümde yineleyiciler ele alınmaktadır ve birçok yineleyici yöntemi kapanış argümanları alır.
Yineleyicileri keşfederken kapanışlarla ilgili bu ayrıntıları aklınızda tutun!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="yineleyicilerle-bir-Öğe-serisini-İşleme"><a class="header" href="#yineleyicilerle-bir-Öğe-serisini-İşleme">Yineleyicilerle Bir Öğe Serisini İşleme</a></h2>
<p>Yineleyici deseni, sırayla bir dizi öğe üzerinde bazı görevleri gerçekleştirmenize olanak tanır. 
Bir yineleyici, her bir öğe üzerinde yineleme mantığından ve dizinin ne zaman bittiğini belirlemekten sorumludur. 
Yineleyicileri kullandığınızda, bu mantığı kendiniz yeniden uygulamak zorunda kalmazsınız.</p>
<p>Rust'ta yineleyiciler <em>tembeldir</em>, yani siz onu kullanmak için yineleyiciyi tüketen metodları 
çağırana kadar hiçbir etkileri yoktur. Örneğin, Liste 13-10'daki kod, <code>Vec&lt;T&gt;</code> üzerinde tanımlanan
<code>iter</code> metodunu çağırarak <code>v1</code> vektöründeki öğeler üzerinde bir yineleyici oluşturur. 
Bu kod kendi başına yararlı bir şey yapmaz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 13-10: Yineleyici oluşturmak</span></p>
<p>Bir yineleyici oluşturduktan sonra, onu çeşitli şekillerde kullanabiliriz. 
Bölüm 3'teki Liste 3-5'te, öğelerinin her birinde bazı kodlar çalıştırmak için <code>for</code> döngüsü kullanarak bir dizi 
üzerinde yineleme yaptık. Bu dolaylı olarak bir yineleyici oluşturdu ve sonra üzerinden geçti, 
ancak şimdiye kadar bunun tam olarak nasıl çalıştığını geçtik.</p>
<p>Liste 13-11'deki örnek, yineleyicinin oluşturulmasını <code>for</code> döngüsündeki yineleyici kullanımından ayırır. 
Yineleyici <code>v1_iter</code> değişkeninde saklanır ve o sırada herhangi bir yineleme gerçekleşmez.
<code>v1_iter</code> içindeki yineleyici kullanılarak <code>for</code> döngüsü çağrıldığında, yineleyicideki her öğe döngünün bir 
yinelemesinde kullanılır ve her değer yazdırılır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!(&quot;Got: {}&quot;, val);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 13-11: Bir <code>for</code> döngüsünde yineleyici kullanma</span></p>
<p>Standart kütüphaneleri tarafından sağlanan yineleyicilere sahip olmayan dillerde,
muhtemelen aynı fonksiyonu <code>0</code> indeksinde bir değişken başlatarak, bir değer elde etmek için vektörü indekslemek
üzere bu değişkeni kullanarak ve vektördeki toplam öğe sayısına ulaşana kadar değişken değerini bir döngü içinde 
artırarak yazarsınız.</p>
<p>Yineleyiciler tüm bu mantığı sizin için halleder ve potansiyel olarak karıştırabileceğiniz tekrarlayan kodu azaltır. 
Yineleyiciler, aynı mantığı yalnızca vektörler gibi indeksleyebileceğiniz veri yapılarıyla değil, birçok farklı türde 
diziyle kullanmanız için size daha fazla esneklik sağlar. Yineleyicilerin bunu nasıl yaptığını inceleyelim.</p>
<h3 id="iterator-tanımı-ve-next-metodu"><a class="header" href="#iterator-tanımı-ve-next-metodu"><code>Iterator</code> Tanımı ve <code>next</code> Metodu</a></h3>
<p>Tüm yineleyiciler, standart kütüphanede tanımlanan <code>Iterator</code> adlı tanımı sürekler. 
Tanımın <em>tanımı</em> şu şekildedir:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
<span class="boring">}
</span></code></pre></pre>
<p>Bu tanımın bazı yeni söz dizimleri kullandığına dikkat edin:
<code>Item</code> ve <code>Self::Item</code> türleri bu özellik ile <em>ilişkili bir tür</em> tanımlamaktadır. 
İlişkili türler hakkında Bölüm 19'da derinlemesine konuşacağız. Şimdilik bilmeniz gereken tek şey, 
bu kodun <code>Iterator</code> tanımını süreklemenin <code>Item</code> türünü de tanımlamanızı gerektirdiğini ve bu
<code>Item</code> türünün bir sonraki metodun dönüş türünde kullanıldığını söylediğidir. Başka bir deyişle,
<code>Item</code> türü yineleyiciden döndürülen tür olacaktır.</p>
<p><code>Iterator</code> tanımı, sürekleyicilerin yalnızca bir metod tanımlamasını gerektirir:
<code>Some</code> içine sarılmış olarak her seferinde yineleyicinin bir öğesini döndüren ve yineleme sona erdiğinde
<code>None</code> döndüren <code>next</code> metodu.</p>
<p>Yineleyicilerde <code>next</code> metodunu doğrudan çağırabiliriz; Liste 13-12, vektörden oluşturulan yineleyicide
<code>next</code> metodunun tekrarlanan çağrılarından hangi değerlerin döndürüldüğünü gösterir.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 13-12: Yineleyici üzerinde <code>next</code> metodunun çağrılması</span></p>
<p><code>v1_iter</code>'ı değiştirilebilir yapmamız gerektiğine dikkat edin: bir yineleyici üzerinde <code>next</code> 
metodunu çağırmak, yineleyicinin sıralamada nerede olduğunu takip etmek için kullandığı dahili durumu değiştirir. 
Başka bir deyişle, bu kod yineleyiciyi tüketir ya da kullanır. Her <code>next</code> çağrısı yineleyiciden bir öğe tüketir. 
Bir <code>for</code> döngüsü kullandığımızda <code>v1_iter</code>'ı değiştirilebilir yapmamıza gerek yoktu çünkü döngü <code>v1_iter</code>'ın sahipliğini 
aldı ve onu <em>perde arkasında</em> değiştirilebilir yaptı.</p>
<p>Ayrıca <code>next</code> çağrısından elde ettiğimiz değerlerin vektördeki değerlere değişmez referanslar olduğuna dikkat edin.
<code>iter</code> metodu, değişmez referanslar üzerinde bir yineleyici üretir. Eğer <code>v1</code>'in sahipliğini alan ve 
sahip olunan değerleri döndüren bir yineleyici oluşturmak istiyorsak, <code>iter</code> yerine <code>into_iter</code>'ı çağırabiliriz. 
Benzer şekilde, değiştirilebilir referanslar üzerinde yineleme yapmak istiyorsak, <code>iter</code> yerine <code>iter_mut</code> metodunu 
çağırabiliriz.</p>
<h3 id="yineleyici-kullanan-metodlar"><a class="header" href="#yineleyici-kullanan-metodlar">Yineleyici Kullanan Metodlar</a></h3>
<p><code>Iterator</code> tanımı, standart kütüphane tarafından sağlanan varsayılan süreklemelere sahip bir dizi farklı 
metoda sahiptir; <code>Iterator</code> tanımı için standart kütüphane API dokümantasyonuna bakarak bu metodlar hakkında bilgi 
edinebilirsiniz. Bu metodlardan bazıları tanımlarında <code>next</code> metodunu çağırır, bu nedenle <code>Iterator</code> tanımını 
süreklerken <code>next</code> metodunu da süreklememiz gerekir.</p>
<p><code>next</code> metodunu çağıran metodlara <em>tüketim uyarlayıcıları</em> denir, çünkü bunları çağırmak yineleyiciyi kullanır. 
Bunun bir örneği, yineleyicinin sahipliğini alan ve <code>next</code> metodunu tekrar tekrar çağırarak öğeler arasında yineleme 
yapan ve böylece yineleyiciyi tüketen <code>sum</code> metodudur. Yineleme sırasında, her öğeyi çalışan bir toplama ekler 
ve yineleme tamamlandığında toplamı döndürür. Liste 13-13, <code>sum</code> metodunun kullanımını gösteren bir test içerir:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 13-13: Yineleyicideki tüm öğelerin toplamını almak için <code>sum</code> metodunu çağırma</span></p>
<p><code>sum</code> çağrısından sonra <code>v1_iter</code> kullanmamıza izin verilmez çünkü <code>sum</code>, çağırdığımız yineleyicinin sahipliğini alır.</p>
<h3 id="diğer-yineleyicileri-Üreten-metodlar"><a class="header" href="#diğer-yineleyicileri-Üreten-metodlar">Diğer Yineleyicileri Üreten Metodlar</a></h3>
<p><code>Iterator</code> tanımı üzerinde tanımlanan ve <em>yineleyici adaptorü</em> olarak bilinen diğer metodlar, 
yineleyiciyi farklı yineleyici türlerine dönüştürmenize olanak tanır. Karmaşık eylemleri okunabilir bir 
şekilde gerçekleştirmek için yineleyici uyarlayıcılarına birden fazla çağrıyı zincirleyebilirsiniz. 
Ancak tüm yineleyiciler tembel olduğundan, yineleyici uyarlayıcılarına yapılan çağrılardan sonuç almak için 
tüketen uyarlayıcı metodlardan birini çağırmanız gerekir.</p>
<p>Liste 13-14, yeni bir yineleyici üretmek için her öğede çağrılacak bir kapanış alan yineleyici uyarlayıcı 
yöntemi olan <code>map</code>'i çağırmanın bir örneğini göstermektedir. Buradaki kapanış, 
vektördeki her öğenin <code>1</code> artırıldığı yeni bir yineleyici oluşturur. Ancak, bu kod bir uyarı üretir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 13-14: Yeni bir yineleyici oluşturmak için <code>map</code> yineleyici uyarlayıcısını çağırma</span></p>
<p>Aldığımız uyarı şudur:</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

warning: `iterators` (bin &quot;iterators&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>Liste 13-14'teki kod hiçbir şey yapmaz; belirttiğimiz kapanış hiçbir zaman çağrılmaz. 
Uyarı bize nedenini gösteriyor: yineleyici uyarlayıcıları <em>tembeldir</em> ve burada yineleyiciyi tüketmemiz gerekir.</p>
<p>Bunu düzeltmek ve yineleyiciyi tüketmek için, Bölüm 12'de Liste 12-1'de <code>env::args</code> ile kullandığımız <code>collect</code> 
metodunu kullanacağız. Bu metod yineleyiciyi tüketir ve elde edilen değerleri bir koleksiyon veri türünde toplar.</p>
<p>Liste 13-15'te, <code>map</code> çağrısından döndürülen yineleyici üzerinde yineleme sonuçlarını bir vektörde topluyoruz. 
Bu vektör, orijinal vektördeki her bir öğenin <code>1</code> ile artırılmış halini içerecektir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 13-15: Yeni bir yineleyici oluşturmak için <code>map</code> metodunu çağırmak ve ardından yeni 
yineleyiciyi tüketmek ve bir vektör oluşturmak için <code>collect</code> metodunu çağırmak</span></p>
<p><code>map</code> bir kapanış aldığı için, her bir öğe üzerinde gerçekleştirmek istediğimiz herhangi bir işlemi belirtebiliriz. 
Bu, kapanışların <code>Iterator</code> tanımını sağladığı yineleme davranışını yeniden kullanırken bazı davranışları özelleştirmenize 
nasıl izin verdiğinin harika bir örneğidir.</p>
<h3 id="ortamlarını-yakalayan-kapanışları-kullanma"><a class="header" href="#ortamlarını-yakalayan-kapanışları-kullanma">Ortamlarını Yakalayan Kapanışları Kullanma</a></h3>
<p>Yineleyicileri tanıttığımıza göre, <code>filter</code> <em>yineleyici adaptörünü</em> kullanarak çevrelerini yakalayan kapanışların 
yaygın bir kullanımını gösterebiliriz. Bir yineleyici üzerindeki <code>filter</code> metodu, yineleyicideki her bir 
öğeyi alan ve bir Boole döndüren bir kapanış alır. Eğer kapanış <code>true</code> döndürürse, değer
<code>filter</code> tarafından üretilen yineleyiciye dahil edilecektir. Kapanış <code>false</code> döndürürse, değer 
elde edilen yineleyiciye dahil edilmez.</p>
<p>Liste 13-16'da, <code>Shoe</code> <code>struct</code> örneklerinden oluşan bir koleksiyon üzerinde yineleme yapmak için ortamından
<code>shoe_size</code> değişkenini yakalayan bir kapanış ile <code>filter</code>'ı kullanırız. Yalnızca belirtilen boyutta olan 
ayakkabıları döndürür.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from(&quot;sneaker&quot;),
            },
            Shoe {
                size: 13,
                style: String::from(&quot;sandal&quot;),
            },
            Shoe {
                size: 10,
                style: String::from(&quot;boot&quot;),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from(&quot;sneaker&quot;)
                },
                Shoe {
                    size: 10,
                    style: String::from(&quot;boot&quot;)
                },
            ]
        );
    }
}
</code></pre>
<p><span class="caption">Liste 13-16: <code>shoe_size</code> öğesini yakalayan bir kapanış ile <code>filter</code> metodunu kullanma</span></p>
<p><code>shoes_in_size</code> fonksiyonu, parametre olarak bir ayakkabı vektörüne ve bir <code>shoe_size</code>'a yani
ayakkabı boyutuna sahip olur. 
Yalnızca belirtilen boyuttaki ayakkabıları içeren bir vektör döndürür.</p>
<p><code>shoes_in_size</code>'ın gövdesinde, vektörün sahipliğini alan bir yineleyici oluşturmak için <code>into_iter</code>'ı çağırıyoruz. 
Daha sonra bu yineleyiciyi yalnızca kapanışın <code>true</code> döndürdüğü öğeleri içeren yeni bir yineleyiciye uyarlamak için
<code>filter</code>'ı çağırıyoruz.</p>
<p>Kapanış, <code>shoe_size</code> parametresini ortamdan alır ve değeri her <code>shoe_size</code>'ı karşılaştırarak 
yalnızca belirtilendekileri tutar. Son olarak, <code>collect</code> çağrısı, uyarlanmış yineleyici tarafından döndürülen değerleri,
fonksiyon tarafından döndürülen bir vektörde toplar.</p>
<p>Test, <code>shoes_in_size</code> öğesini çağırdığımızda, yalnızca belirttiğimiz değerle aynı boyuta sahip 
ayakkabıları geri aldığımızı gösterir.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gÇ-projemizi-geliştirmek"><a class="header" href="#gÇ-projemizi-geliştirmek">G/Ç Projemizi Geliştirmek</a></h2>
<p>Yineleyiciler hakkındaki bu yeni bilgiyle, koddaki yerleri daha açık ve öz hale getirmek için yineleyicileri kullanarak Bölüm 12'deki 
G/Ç projesini geliştirebiliriz. Şimdi yineleyicilerin <code>Config::new</code> fonksiyonu ve <code>search</code> fonksiyonu uygulamamızı nasıl 
geliştirebileceğine bakalım.</p>
<h3 id="yineleyici-kullanarak-bir-cloneu-kaldırma"><a class="header" href="#yineleyici-kullanarak-bir-cloneu-kaldırma">Yineleyici Kullanarak bir <code>clone</code>'u Kaldırma</a></h3>
<p>Liste 12-6'da, <code>String</code> değerlerinin bir dilimini alan ve dilime indeksleme yapıp değerleri klonlayarak <code>Config</code> yapısının bir 
örneğini oluşturan ve <code>Config</code> yapısının bu değerlere sahip olmasını sağlayan kodu ekledik. Liste 13-17'de, <code>Config::new</code> fonksiyonunun 
uygulamasını Liste 12-23'te olduğu gibi yeniden ürettik:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            filename,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 13-17: Liste 12-23'ten <code>Config::new</code> işlevinin çoğaltılması</span></p>
<p>O zaman, verimsiz <code>clone</code> çağrıları konusunda endişelenmememizi çünkü gelecekte bunları kaldıracağımızı söylemiştik. 
İşte o zaman şimdi!</p>
<p>Burada <code>clone</code>'a ihtiyacımız vardı çünkü parametre <code>args</code>'ta <code>String</code> öğeleri olan bir dilimimiz var, 
ancak yeni fonksiyon <code>args</code>'a sahip değil. Bir <code>Config</code> örneğinin sahipliğini döndürmek için <code>Config</code>'in <code>query</code> ve <code>filename</code> 
alanlarındaki değerleri klonlamamız gerekiyordu, böylece <code>Config</code> örneği kendi değerlerine sahip olabilirdi.</p>
<p>Yineleyiciler hakkındaki yeni bilgilerimizle, yeni fonksiyonu bir dilimi ödünç almak yerine argümanı olarak bir
yineleyicinin sahipliğini alacak şekilde değiştirebiliriz. Dilimin uzunluğunu kontrol eden ve belirli konumlara indeksleyen 
kod yerine yineleyici fonksiyonu kullanacağız. Bu, <code>Config::new</code> fonksiyonunun ne yaptığını netleştirecektir çünkü yineleyici 
değerlere erişecektir.</p>
<p><code>Config::new</code> yineleyicinin sahipliğini aldığında ve ödünç alan indeksleme işlemlerini kullanmayı bıraktığında, 
<code>String</code> değerlerini <code>clone</code>'u çağırmak ve yeni bir tahsisat yapmak yerine yineleyiciden <code>Config</code>'e taşıyabiliriz.</p>
<h4 id="döndürülen-yineleyiciyi-doğrudan-kullanma"><a class="header" href="#döndürülen-yineleyiciyi-doğrudan-kullanma">Döndürülen Yineleyiciyi Doğrudan Kullanma</a></h4>
<p>G/Ç projenizin aşağıdaki gibi görünmesi gereken <em>src/main.rs</em> dosyasını açın:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Application error: {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
</code></pre>
<p>Liste 12-24'te sahip olduğumuz <code>main</code> fonksiyonun başlangıcını Liste 13-18'deki kodla değiştireceğiz. 
Bu, biz <code>Config::new</code>'i de güncelleyene kadar derlenmeyecektir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Application error: {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
</code></pre>
<p><span class="caption">Liste 13-18: <code>env::args</code> dönüş değerinin <code>Config::new</code> 
öğesine iletilmesi</span></p>
<p><code>env::args</code> fonksiyonu bir yineleyici döndürür! Yineleyici değerlerini bir vektörde toplamak ve ardından bir 
dilimi <code>Config::new</code>'e aktarmak yerine, şimdi <code>env::args</code>'dan dönen yineleyicinin sahipliğini doğrudan <code>Config::new</code>'e aktarıyoruz.</p>
<p>Daha sonra, <code>Config::new</code>'in tanımını güncellememiz gerekiyor. G/Ç projenizin <em>src/lib.rs</em> dosyasında, 
<code>Config::new</code>'in imzasını Liste 13-19'daki gibi görünecek şekilde değiştirelim. Bu yine de derlenmeyecektir çünkü fonksiyon 
gövdesini güncellememiz gerekir.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            filename,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 13-19: Bir yineleyici beklemek için <code>Config::new</code> 
imzasını güncelleme</span></p>
<p><code>env::args</code> fonksiyonunun standart kütüphane belgeleri, döndürdüğü yineleyicinin türünün <code>std::env::Args</code> olduğunu ve bu türün 
<code>Iterator</code> özelliğini uyguladığını ve <code>String</code> değerleri döndürdüğünü gösterir.</p>
<p><code>Config::new</code> fonksiyonunun imzasını güncelledik, böylece <code>args</code> parametresi <code>&amp;[String]</code> yerine tanım sınırları olan 
<code>impl Iterator&lt;Item = String&gt;</code> ile yaygın bir türe sahip olacak. Bölüm 10'un <a href="ch10-02-traits.html#traits-as-parameters">“Parametreler Olarak Tanımlar”</a><!-- ignore --> bölümünde
tartıştığımız <code>impl Trait</code> söz diziminin bu kullanımı, <code>args</code>'nin <code>Iterator</code> türünü uygulayan ve <code>String</code> öğeleri döndüren herhangi bir tür 
olabileceği anlamına gelir.</p>
<p><code>args</code>'nin sahipliğini aldığımız ve üzerinde yineleme yaparak <code>args</code>'yi mutasyona uğratacağımız için, <code>mut</code> anahtar sözcüğünü <code>args</code> 
parametresinin belirtimine ekleyerek onu mutasyona uğratılabilir hale getirebiliriz.</p>
<h4 id="İndeksleme-yerine-iterator-tanım-yöntemlerini-kullanma"><a class="header" href="#İndeksleme-yerine-iterator-tanım-yöntemlerini-kullanma">İndeksleme Yerine <code>Iterator</code> Tanım Yöntemlerini Kullanma</a></h4>
<p>Sonra, <code>Config::new</code>'in gövdesini düzelteceğiz. <code>args</code>, <code>Iterator</code> tanımını uyguladığı için, bir sonraki 
yöntemi çağırabileceğimizi biliyoruz! Liste 13-20, <code>next</code> yöntemini kullanmak için Liste 12-23'teki kodu günceller:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a query string&quot;),
        };

        let filename = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a file name&quot;),
        };

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            filename,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 13-20: Yineleyici yöntemlerini kullanmak için <code>Config::new</code> gövdesini değiştirme</span></p>
<p><code>env::args</code>'ın dönüş değerindeki ilk değerin programın adı olduğunu unutmayın. 
Bunu yok saymak ve bir sonraki değere ulaşmak istiyoruz, bu yüzden önce <code>next</code>'i çağırıyoruz ve geri dönüş değeriyle hiçbir şey yapmıyoruz. 
İkinci olarak, <code>Config'</code>in <code>query</code> alanına koymak istediğimiz değeri almak için <code>next</code>'i çağırıyoruz. <code>next</code>, <code>Some</code> döndürürse, 
değeri çıkarmak için <code>match</code> kullanırız. <code>None</code> döndürürse, yeterli argüman verilmediği anlamına gelir ve bir <code>Err</code> değeriyle erken döneriz. 
Aynı şeyi <code>filename</code> değeri için de yaparız.</p>
<h3 id="yineleyici-bağdaştırıcılar-ile-kodu-daha-anlaşılır-hale-getirme"><a class="header" href="#yineleyici-bağdaştırıcılar-ile-kodu-daha-anlaşılır-hale-getirme">Yineleyici Bağdaştırıcılar ile Kodu Daha Anlaşılır Hale Getirme</a></h3>
<p>G/Ç projemizdeki <code>search</code> fonksiyonunda da yineleyicilerden yararlanabiliriz; bu fonksiyon burada Liste 12-19'da olduğu gibi 
Liste 13-21'de yeniden üretilmiştir:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 13-21: Liste 12-19'dan <code>search</code> fonksiyonunun yazılması</span></p>
<p>Bu kodu yineleyici bağdaştırıcı metodlarını kullanarak daha kısa bir şekilde yazabiliriz. 
Bunu yapmak aynı zamanda değiştirilebilir bir ara <code>results</code> vektörüne sahip olmaktan kaçınmamızı sağlar. 
Fonksiyonel programlama stili, kodu daha anlaşılır hale getirmek için değiştirilebilir durum miktarını en aza indirmeyi tercih eder. 
Değişken durumu kaldırmak, <code>results</code> vektörüne eşzamanlı erişimi yönetmek zorunda kalmayacağımız için gelecekte yapılacak bir 
geliştirmeyle aramanın paralel olarak yapılmasını sağlayabilir. Liste 13-22 bu değişikliği göstermektedir:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(
</span><span class="boring">        mut args: impl Iterator&lt;Item = String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        args.next();
</span><span class="boring">
</span><span class="boring">        let query = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;Didn't get a query string&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let filename = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;Didn't get a file name&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            filename,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 13-22: &quot;arama&quot; işlevinin uygulanmasında yineleyici bağdaştırıcı 
yöntemlerini kullanma</span></p>
<p><code>search</code> fonksiyonunun amacının, <code>query</code>'i içeren içerikteki tüm satırları döndürmek olduğunu hatırlayın. Liste 13-16'daki 
<code>filter</code> örneğine benzer şekilde, bu kod yalnızca <code>line.contains(query)</code> öğesinin <code>true</code> döndürdüğü satırları tutmak için <code>filter</code> 
kullanır. Daha sonra eşleşen satırları <code>collect</code> ile başka bir vektörde topluyoruz. Çok daha basit! 
Aynı değişikliği <code>search_case_insensitive</code> fonksiyonunda yineleyici yöntemlerini kullanmak için de yapmaktan çekinmeyin.</p>
<p>Bir sonraki mantıksal soru, kendi kodunuzda hangi stili ve neden seçmeniz gerektiğidir: Liste 13-21'deki orijinal uygulama mı yoksa 
Liste 13-22'deki yineleyicileri kullanan sürüm mü? Çoğu Rust programcısı yineleyici stilini kullanmayı tercih eder. 
İlk başta alışmak biraz daha zordur, ancak çeşitli yineleyici uyarlayıcılarını ve ne yaptıklarını bir kez hissettiğinizde, 
yineleyicileri anlamak daha kolay olabilir. Döngünün çeşitli kısımlarıyla uğraşmak ve yeni vektörler oluşturmak yerine, 
kod döngünün üst düzey hedefine odaklanır. Bu, sıradan kodların bazılarını soyutlaştırır, böylece yineleyicideki her bir öğenin 
geçmesi gereken filtreleme koşulu gibi bu koda özgü kavramları görmek daha kolaydır.</p>
<p>Ancak iki uygulama gerçekten eş değer midir? Sezgisel varsayım, daha düşük seviyeli döngünün daha hızlı olacağı yönünde olabilir. 
Şimdi performans hakkında konuşalım.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="performans-karşılaştırması-döngüler-ve-yineleyiciler"><a class="header" href="#performans-karşılaştırması-döngüler-ve-yineleyiciler">Performans Karşılaştırması: Döngüler ve Yineleyiciler</a></h2>
<p>Döngülerin mi yoksa yineleyicilerin mi kullanılacağını belirlemek için, hangi uygulamanın daha hızlı olduğunu bilmeniz gerekir: 
<code>search</code> fonksiyonunun açık bir <code>for</code> döngüsüne sahip versiyonu ya da yineleyicilere sahip versiyonu.</p>
<p>Sir Arthur Conan Doyle'un <em>The Adventures of Sherlock Holmes</em>'un tüm içeriğini bir <code>String</code>'e yükleyerek ve içerikte 
kelimeyi arayarak bir kıyaslama yaptık. Burada, <code>for</code> döngüsünü kullanan arama sürümü ve yineleyicileri kullanan sürümle 
ilgili karşılaştırmanın sonuçları:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>Yineleyici sürümü biraz daha hızlıydı! Burada kıyaslama kodunu açıklamayacağız, 
çünkü mesele iki versiyonun eşdeğer olduğunu kanıtlamak değil, bu iki uygulamanın performans açısından nasıl karşılaştırıldığına 
dair genel bir fikir edinmek.</p>
<p>Daha kapsamlı bir kıyaslama için, içerik olarak çeşitli boyutlarda çeşitli metinler, sorgu olarak farklı kelimeler ve 
farklı uzunluklarda kelimeler ve her türlü diğer varyasyonları kontrol etmelisiniz. </p>
<p>Mesele şudur: yineleyiciler, üst düzey bir soyutlama olmasına rağmen, alt düzey kodu kendiniz yazmışsınız gibi kabaca aynı koda derlenir. 
Yineleyiciler, Rust'ın <em>sıfır maliyetli soyutlamalarından</em> biridir; bununla, soyutlamayı kullanmanın ek çalışma zamanı yükü getirmediğini
kastediyoruz. Bu, C++'ın orijinal tasarımcısı ve uygulayıcısı olan Bjarne Stroustrup'un “Foundations of C++”'ta (2012) 
sıfır yükü tanımlamasına benzer:</p>
<blockquote>
<p>Genel olarak, C++ uygulamaları sıfır genel gider ilkesine uyar: 
Kullanmadığınız şey için ödeme yapmazsınız. 
Ve dahası: Ne kullanırsanız kullanın, kodu daha iyi veremezdiniz.</p>
</blockquote>
<p>Başka bir örnek olarak, aşağıdaki kod bir ses kod çözücüsünden alınmıştır. 
Kod çözme algoritması, önceki örneklerin doğrusal bir fonksiyonuna dayalı olarak gelecekteki değerleri tahmin 
etmek için doğrusal tahmin matematiksel işlemini kullanır. Bu kod, kapsamdaki üç değişken üzerinde biraz matematik yapmak 
için bir yineleyici zinciri kullanır: bir arabellek veri dilimi, 12 katsayı dizisi ve <code>qlp_shift</code>'te verilerin kaydırılacağı miktar. 
Bu örnekte değişkenleri tanımladık ancak onlara herhangi bir değer vermedik; Bu kodun bağlamı dışında pek bir anlamı olmamasına rağmen, 
yine de Rust'ın yüksek seviyeli fikirleri düşük seviyeli koda nasıl çevirdiğinin kısa ve gerçek bir örneğidir.</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
</code></pre>
<p><code>prediction</code> değerini hesaplamak için bu kod, katsayılardaki 12 değerin her birini yineler ve katsayı değerlerini arabellekteki önceki 
12 değerle eşleştirmek için <code>zip</code> metodunu kullanır. Ardından, her bir çift için değerleri birlikte çarparız, 
tüm sonuçları toplarız ve toplam <code>qlp_shift</code> bitlerindeki bitleri sağa kaydırırız.</p>
<p>Ses kod çözücüler gibi uygulamalardaki hesaplamalar genellikle performansa en yüksek önceliği verir. 
Burada, iki bağdaştırıcı kullanarak bir yineleyici oluşturuyoruz ve ardından değeri kullanıyoruz. 
Bu Rust kodu hangi Assembly koduna derler? Eh, bu yazı itibariyle, elle yazacağınız derlemeye kadar derlenir. 
Katsayılardaki değerler üzerinde yinelemeye karşılık gelen hiçbir döngü yoktur: Rust, 12 yineleme olduğunu bilir, 
bu nedenle döngüyü “açar”. <em>Açmak</em>, döngü kontrol kodunun ek yükünü ortadan kaldıran ve bunun yerine döngünün her 
yinelemesi için tekrarlayan kod üreten bir optimizasyondur.</p>
<p>Tüm katsayılar kayıtlarda saklanır, bu da değerlere erişmenin çok hızlı olduğu anlamına gelir. 
Çalışma zamanında dizi erişiminde sınır denetimi yoktur. Rust'ın uygulayabildiği tüm bu optimizasyonlar, 
ortaya çıkan kodu son derece verimli hale getirir. Artık bunu bildiğinize göre, yineleyicileri ve kapanış ifadelerini 
korkmadan kullanabilirsiniz! Kodun daha yüksek bir seviye gibi görünmesini sağlarlar, 
ancak bunu yapmak için bir çalışma zamanı performans <em>kapitülasyonlarını</em> vermezler.</p>
<h2 id="Özet-9"><a class="header" href="#Özet-9">Özet</a></h2>
<p>Kapanış ifadeleri ve yineleyiciler, fonksiyonel programlama dili fikirlerinden ilham alan Rust özellikleridir. 
Rust'ın üst düzey fikirleri düşük düzeyde performansla açıkça ifade etme yeteneğine katkıda bulunurlar. 
Kapanış ifadelerinin ve yineleyicilerin uygulamaları, çalışma zamanı performansının etkilenmeyeceği şekildedir. 
Bu, Rust'ın <em>sıfır maliyetli soyutlamalar</em> sağlama hedefinin bir parçasıdır.</p>
<p>G/Ç projemizin dışavurumunu iyileştirdiğimize göre, şimdi projeyi dünyayla paylaşmamıza yardımcı 
olacak <code>cargo</code>'nun bazı özelliklerine bakalım.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-ve-cratesio-hakkında-daha-fazla-bilgi"><a class="header" href="#cargo-ve-cratesio-hakkında-daha-fazla-bilgi">Cargo ve Crates.io Hakkında Daha Fazla Bilgi</a></h1>
<p>Şimdiye kadar; kodumuzu oluşturmak, çalıştırmak ve test etmek için Cargo'nun yalnızca en temel özelliklerini kullandık, 
ancak Cargo çok daha fazlasına sahiptir. 
Bu bölümde, aşağıdakileri nasıl yapacağınızı göstermek için diğer gelişmiş özelliklerinden bazılarını tartışacağız:</p>
<ul>
<li>Yayın profilleri aracılığıyla yapınızı özelleştirmek</li>
<li><a href="https://crates.io/">crates.io</a><!-- ignore -->'da kütüphaneler yayınlamak</li>
<li>Çalışma alanlarıyla büyük projeleri organize edin</li>
<li><a href="https://crates.io/">crates.io</a><!-- ignore -->'dan yürütülebilirleri ve kütüphaneleri
yüklemek.</li>
<li>Özel komutları kullanarak Cargo'yu genişletmek.</li>
</ul>
<p>Cargo, bu bölümde ele aldığımız işlevlerden daha fazlasını yapabilir, 
bu nedenle tüm özelliklerinin tam açıklaması için <a href="https://doc.rust-lang.org/cargo/">dokümantasyonuna</a> bakın.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dağıtım-profilleri-ile-yapıları-Özelleştirme"><a class="header" href="#dağıtım-profilleri-ile-yapıları-Özelleştirme">Dağıtım Profilleri ile Yapıları Özelleştirme</a></h2>
<p>Rust'ta dağıtım profilleri, bir programcının kod derlemek için çeşitli seçenekler üzerinde daha fazla kontrole sahip 
olmasını sağlayan farklı konfigürasyonlara sahip önceden tanımlanmış ve özelleştirilebilir profillerdir. 
Her profil diğerlerinden bağımsız olarak yapılandırılır.</p>
<p>Cargo'nun iki ana profili vardır: Cargo'nun, <code>cargo build</code>'i çalıştırdığınızda kullandığı <code>dev</code> profili ve 
<code>cargo build --release</code>'i çalıştırdığınızda kullandığı <code>release</code> profili geliştirme için iyi varsayılanlarla tanımlanır 
ve dağıtım profili, dağıtım derlemeleri için iyi varsayılanlara sahiptir.</p>
<p>Bu profil adları, yapılarınızın çıktısından tanıdık gelebilir:</p>
<!-- manual-regeneration
anywhere, run:
cargo build
cargo build --release
and ensure output below is accurate
-->
<pre><code class="language-console">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
</code></pre>
<p><code>dev</code> ve <code>release</code>, derleyici tarafından kullanılan farklı tür profillerdir.</p>
<p>Cargo'nun, projenin <em>Cargo.toml</em> dosyasına açıkça herhangi bir <code>[profile.*]</code> bölümü eklemediğinizde uygulanan profillerin 
her biri için varsayılan ayarları vardır. Özelleştirmek istediğiniz herhangi bir profil için 
<code>[profil.*]</code> bölümlerini ekleyerek, varsayılan ayarların herhangi bir alt kümesini geçersiz kılarsınız. 
Örneğin, <code>dev</code> ve <code>release</code> profilleri için <code>opt-level</code> ayarının varsayılan değerleri şunlardır:</p>
<p><span class="filename">Dosya adı: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>Optimizasyon düzeyi (<code>opt-level</code>) ayarı, 0 ila 3 aralığında Rust'ın kodunuza uygulayacağı optimizasyonların 
sayısını kontrol eder. Bu nedenle <code>dev</code> profili için varsayılan tercih düzeyi 0'dır. Kodunuzu yayınlamaya hazır olduğunuzda, 
derlemeye daha fazla zaman harcamak en iyisidir. Dağıtım modunda yalnızca bir kez derlersiniz, 
ancak derlenmiş programı birçok kez çalıştırırsınız, bu nedenle dağıtım modu, daha hızlı çalışan kod için 
daha uzun derleme süresi değiştirir. Bu nedenle, <code>release</code> profili için varsayılan tercih düzeyi 3'tür.</p>
<p><em>Cargo.toml</em>'da bunun için farklı bir değer ekleyerek bir varsayılan ayarı geçersiz kılabilirsiniz. 
Örneğin geliştirme profilinde birinci optimizasyon seviyesini kullanmak istiyorsak projemizin <em>Cargo.toml</em> 
dosyasına şu iki satırı ekleyebiliriz:</p>
<p><span class="filename">Dosya adı: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>Bu kod, varsayılan <code>0</code> ayarını geçersiz kılar. Şimdi, <code>cargo build</code>'i çalıştırdığımızda, 
Cargo, <code>dev</code> profili için varsayılanları ve ayrıca <code>opt-level</code> özelleştirmemizi kullanacak. 
<code>opt-level</code>'i <code>1</code> olarak ayarladığımız için, Cargo varsayılandan daha fazla optimizasyon uygulayacak, 
ancak bir <code>release</code> yapısındaki kadar değil.</p>
<p>Her profil için yapılandırma seçeneklerinin ve varsayılanların tam listesi için
<a href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargo'nun dokümantasyonuna</a> bakın.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cratesioda-kasa-yayınlama"><a class="header" href="#cratesioda-kasa-yayınlama">Crates.io'da Kasa Yayınlama</a></h2>
<p>Biz <a href="https://crates.io/">crates.io</a><!-- ignore -->'daki paketleri projemizin bağımlılıkları olarak kullandık, 
ancak siz de kendi paketlerinizi yayınlayarak kodunuzu diğer insanlarla paylaşabilirsiniz. <a href="https://crates.io/">crates.io</a><!-- ignore -->'daki kasa kaydı, 
paketlerinizin kaynak kodunu dağıtır, bu nedenle öncelikle açık kaynak kodunu barındırır.</p>
<p>Rust ve Cargo, yayınladığınız paketin insanlar tarafından bulunmasını ve kullanılmasını kolaylaştıran özelliklere sahiptir. 
Şimdi bu özelliklerden bazılarından bahsedeceğiz ve ardından bir paketin nasıl yayınlanacağını açıklayacağız.</p>
<h3 id="faydalı-dokümantasyon-yorumları-yapmak"><a class="header" href="#faydalı-dokümantasyon-yorumları-yapmak">Faydalı Dokümantasyon Yorumları Yapmak</a></h3>
<p>Paketlerinizi doğru bir şekilde belgelendirmek, diğer kullanıcıların bunları nasıl ve ne zaman kullanacaklarını bilmelerine 
yardımcı olacaktır, bu nedenle belge yazmak için zaman ayırmaya değer. Bölüm 3'te, iki eğik çizgi (<code>//</code>) kullanarak Rust 
kodunu nasıl yorumlayacağımızı tartıştık. Rust ayrıca, HTML dokümantasyonu oluşturacak, dokümantasyon 
yorumu olarak bilinen, dokümantasyon için özel bir yorum türüne sahiptir. HTML, kasanızın nasıl süreklendiğinden ziyade 
kasanızın nasıl kullanılacağını bilmek isteyen programcılara yönelik genel API öğeleri için dokümantasyon yorumlarının içeriğini 
görüntüler.</p>
<p>Dokümantasyon yorumları iki yerine üç eğik çizgi (<code>///</code>) kullanır ve metni biçimlendirmek için <em>Markdown</em> 
gösterimini destekler. Dokümantasyon yorumlarını belgeledikleri öğeden hemen önce yerleştirin. 
Liste 14-1, <code>my_crate</code> adlı kasadaki <code>add_one</code> fonksiyonu için dokümantasyon yorumlarını göstermektedir.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p><span class="caption">Listing 14-1: Fonksiyon için dokümantasyon yorumu</span></p>
<p>Burada, <code>add_one</code> fonksiyonunun ne işe yaradığına dair bir açıklama veriyoruz, <code>Examples</code> başlıklı bir bölüm 
açıyoruz ve ardından <code>add_one</code> fonksiyonunun nasıl kullanılacağını gösteren bir kod sunuyoruz. 
Bu dokümantasyon yorumundan, <code>cargo doc</code> çalıştırarak HTML dokümantasyonunu oluşturabiliriz. 
Bu komut, Rust ile birlikte dağıtılan <code>rustdoc</code> aracını çalıştırır ve oluşturulan HTML belgelerini 
<em>target/doc</em> dizinine koyar.</p>
<p>Kolaylık sağlamak için, <code>cargo doc --open</code> komutunu çalıştırmak mevcut kasanızın dokümantasyonu için HTML oluşturacak 
(ayrıca kasanızın tüm bağımlılıkları için dokümantasyon) ve sonucu bir web tarayıcısında açacaktır.
<code>add_one</code> fonksiyonuna gidin ve Şekil 14-1'de gösterildiği gibi dokümantasyon yorumlarındaki metnin nasıl oluşturulduğunu 
göreceksiniz:</p>
<img alt="`my_crate`'nin `add_one` fonksiyonu için işlenmiş HTML dokümantasyonu" src="img/trpl14-01.png" class="center" />
<p><span class="caption">Şekil 14-1: <code>add_one</code> fonksiyonu için HTML dokümantasyonu</span></p>
<h4 id="sıkça-kullanılan-bölümler"><a class="header" href="#sıkça-kullanılan-bölümler">Sıkça Kullanılan Bölümler</a></h4>
<p>HTML'de “Examples” başlıklı bir bölüm oluşturmak için Liste 14-1'deki <code># Examples</code> başlığını kullandık. 
İşte kasa yazarlarının belgelerinde yaygın olarak kullandıkları diğer bazı bölümler:</p>
<ul>
<li><strong>Panikler</strong>: Belgelenen fonksiyonun panik yapabileceği senaryolar. Programlarının paniklemesini istemeyen fonksiyonu 
çağıranlar, bu durumlarda fonksiyonu çağırmadıklarından emin olmalıdırlar.</li>
<li><strong>Hatalar</strong>: Fonksiyon <code>Result</code> döndürüyorsa, oluşabilecek hata türlerini ve hangi koşulların bu hataların<br />
döndürülmesine neden olabileceğini açıklamak, arayanlara yardımcı olabilir, böylece farklı hata türlerini farklı 
şekillerde ele almak için kod yazabilirler.</li>
<li><strong>Güvenlik</strong>: Eğer fonksiyon çağrılması güvenli değilse (güvensizliği Bölüm 19'da tartışacağız), fonksiyonun neden 
güvensiz olduğunu açıklayan ve fonksiyonun çağıranların uymasını beklediği değişmezleri kapsayan bir bölüm olmalıdır.</li>
</ul>
<p>Çoğu dokümantasyon açıklamasında bu bölümlerin hepsine gerek yoktur, ancak bu, kodunuzun kullanıcıların bilmek 
isteyeceği yönlerini size hatırlatmak için iyi bir kontrol listesidir.</p>
<h4 id="test-olarak-dokümantasyon-yorumları"><a class="header" href="#test-olarak-dokümantasyon-yorumları">Test Olarak Dokümantasyon Yorumları</a></h4>
<p>Belge açıklamalarınıza örnek kod blokları eklemek, kütüphanenizin nasıl kullanılacağını göstermeye yardımcı olabilir ve 
bunu yapmanın ek bir avantajı vardır: <code>cargo test</code>'i çalıştırmak, belgelerinizdeki kod örneklerini test olarak 
çalıştıracaktır! Hiçbir şey örnekli dokümantasyondan daha iyi olamaz. Ancak hiçbir şey, dokümantasyonun yazılmasından
bu yana kod değiştiği için çalışmayan örneklerden daha kötü olamaz. Liste 14-1'deki <code>add_one</code> fonksiyonunun dokümantasyonu ile
<code>cargo test</code>'i çalıştırırsak, test sonuçlarında aşağıdaki gibi bir bölüm görürüz:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-->
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
<p>Şimdi fonksiyonu ya da örneği değiştirirsek, örnekteki <code>assert_eq!</code> panik yapar ve <code>cargo test</code>'i tekrar çalıştırırsak, 
dokümantasyon testlerinin örnek ve kodun birbiriyle senkronize olmadığını yakaladığını göreceğiz!</p>
<h4 id="İçerdiği-Öğeleri-yorumlama"><a class="header" href="#İçerdiği-Öğeleri-yorumlama">İçerdiği Öğeleri Yorumlama</a></h4>
<p>Dokümantasyon yorum satırı (<code>//!</code>) stili, belgeleri yorumları takip eden öğeler yerine yorumları içeren öğeye ekler. 
Bu dokümantasyon yorumları genellikle kasa kök dosyasının içinde (geleneksel olarak <em>src/lib.rs</em>) veya bir modülün 
içinde kasayı veya modülü bir bütün olarak belgelemek için kullanırız.</p>
<p>Örneğin, <code>add_one</code> fonksiyonunu içeren <code>my_crate</code> kasasının amacını açıklayan belgeler eklemek için, 
Liste 14-2'de gösterildiği gibi <em>src/lib.rs</em> dosyasının başına <code>//!</code> ile başlayan belge yorumları ekleriz:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
<span class="boring">///
</span><span class="boring">/// # Examples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let arg = 5;
</span><span class="boring">/// let answer = my_crate::add_one(arg);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, answer);
</span><span class="boring">/// ```
</span><span class="boring">pub fn add_one(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 14-2: Bir bütün olarak <code>my_crate</code> kasası için dokümantasyon</span></p>
<p>Son satırdan sonra <code>//!</code> ile başlayan herhangi bir kod olmadığına dikkat edin. 
Yorumlara <code>///</code> yerine <code>//!</code> ile başladığımız için, bu yorumu takip eden bir öğe yerine bu yorumu içeren öğeyi 
belgeliyoruz. Bu durumda, bu öğe kasa kökü olan <em>src/lib.rs</em> dosyasıdır. Bu yorumlar tüm kasayı tanımlar.</p>
<p><code>cargo doc --open</code> komutunu çalıştırdığımızda, bu yorumlar Şekil 14-2'de gösterildiği gibi <code>my_crate</code> dokümantasyonunun 
ön sayfasında kasadaki genel öğelerin listesinin üzerinde görüntülenecektir:</p>
<img alt="Bir bütün olarak kasa için bir yorum içeren işlenmiş HTML dokümantasyonu" src="img/trpl14-02.png" class="center" />
<p>Öğeler içindeki dokümantasyon yorumları özellikle kasaları ve modülleri tanımlamak için kullanışlıdır.
Kullanıcılarınızın kasanın organizasyonunu anlamalarına yardımcı olmak için konteynerin genel amacını açıklamak
için bunları kullanın.</p>
<h3 id="pub-use-ile-kullanışlı-genel-apiyi-dışa-aktarma"><a class="header" href="#pub-use-ile-kullanışlı-genel-apiyi-dışa-aktarma"><code>pub use</code> ile Kullanışlı Genel API'yi Dışa Aktarma</a></h3>
<p>Genel API'nizin yapısı, bir kasa yayınlarken göz önünde bulundurulması gereken önemli bir husustur.
Kasanızı kullanan kişiler yapıya sizden daha az aşinadır ve kasanızın büyük bir modül hiyerarşisine sahipse
kullanmak istedikleri parçaları bulmakta zorluk çekebilirler.</p>
<p>Bölüm 7'de, <code>pub</code> anahtar sözcüğünü kullanarak öğeleri nasıl herkese açık hale getireceğimizi ve <code>use</code> anahtar sözcüğünü
kullanarak öğeleri bir kapsama nasıl dahil edeceğimizi ele almıştık. Ancak, bir kasa geliştirirken size mantıklı gelen yapı,
kullanıcılarınız için çok uygun olmayabilir. Yapılarınızı birden fazla seviye içeren bir hiyerarşide
düzenlemek isteyebilirsiniz, ancak bu durumda hiyerarşinin derinliklerinde tanımladığınız bir türü kullanmak isteyen
kişiler bu türün var olduğunu bulmakta zorlanabilir. Ayrıca, <code>use my_crate::UsefulType;</code> yerine use
<code>my_crate::some_module::another_module::UsefulType;</code> girmek zorunda kalmaktan da rahatsız olabilirler.</p>
<p>İyi haber şu ki, yapı başkalarının başka bir kütüphaneden kullanması için uygun değilse, iç organizasyonunuzu
yeniden düzenlemeniz gerekmez: bunun yerine, <code>pub use</code> kullanarak özel yapınızdan farklı bir genel yapı
oluşturmak için öğeleri yeniden dışa aktarabilirsiniz. Yeniden dışa aktarma, bir konumdaki herkese açık bir
öğeyi alır ve sanki diğer konumda tanımlanmış gibi başka bir konumda herkese açık hale getirir.</p>
<p>Örneğin, sanatsal kavramları modellemek için <code>art</code> adında bir kütüphane oluşturduğumuzu varsayalım.
Bu kütüphanede iki modül vardır: <code>PrimaryColor</code> ve <code>SecondaryColor</code> adında iki <code>enum</code> içeren bir <code>kinds</code> modülü ve
Liste 14-3'te gösterildiği gibi <code>mix</code> adında bir fonksiyon içeren bir <code>utils</code> modülü:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
<span class="boring">        unimplemented!();
</span>    }
}
</code></pre>
<p><span class="caption">Liste 14-3: <code>kinds</code> ve <code>utils</code> halinde düzenlenmiş öğeler içeren bir <code>art</code> kütüphanesi</span></p>
<p>Şekil 14-3, bu kasa için <code>cargo doc</code> tarafından oluşturulan belgelerin ön sayfasının nasıl görüneceğini 
göstermektedir:</p>
<img alt="`art` kasası için `kinds` ve `utils` modüllerini listeleyen işlenmiş dokümantasyonlar" src="img/trpl14-03.png" class="center" />
<p><span class="caption">Şekil 14-3: <code>kinds</code> ve <code>utils</code> modüllerini listeleyen <code>art</code> dokümantasyonunun ön sayfası</span></p>
<p><code>PrimaryColor</code> ve <code>SecondaryColor</code> türlerinin ön sayfada listelenmediğine ve <code>mix</code> fonksiyonunun da bulunmadığına 
dikkat edin. Bunları görmek için türlere ve yardımcı programlara tıklamamız gerekiyor.</p>
<p>Bu kütüphaneye bağlı olan başka bir kasa, şu anda tanımlanmış olan modül yapısını belirterek,
<code>art</code>'taki öğeleri kapsama getiren <code>use</code> ifade yapılarına ihtiyaç duyacaktır. Liste 14-4, <code>art</code> kasasındaki
<code>PrimaryColor</code> ve <code>mix</code> öğelerini kullanan bir kasa örneğini göstermektedir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
</code></pre>
<p><span class="caption">Liste 14-4: İç yapısı dışa aktarılmış <code>art</code> kasasının öğelerini kullanan bir kasa</span></p>
<p>Liste 14-4'teki <code>art</code> kasasını kullanan kodun yazarı,
<code>PrimaryColor</code>'ın <code>kinds</code> modülünde ve <code>mix</code>'in <code>utils</code> modülünde olduğunu anlamak zorunda kalmıştır.
<code>art</code> kasasının modül yapısı, onu kullananlardan ziyade <code>art</code> kasası üzerinde çalışan geliştiriciler için
daha önemlidir. İç yapı, <code>art</code> kasasının nasıl kullanılacağını anlamaya çalışan biri için herhangi 
bir yararlı bilgi içermez, aksine kafa karışıklığına neden olur, çünkü onu kullanan geliştiriciler nereye bakacaklarını 
bulmak ve use deyimlerinde modül adlarını belirtmek zorundadır.</p>
<p>Dahili organizasyonu genel API'den kaldırmak için, Liste 14-3'teki <code>art</code> kasa kodunu değiştirerek, 
Liste 14-5'te gösterildiği gibi üst düzeydeki öğeleri yeniden dışa aktarmak için <code>pub use</code> ifade yapısını
ekleyebiliriz:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
<span class="boring">    /// The primary colors according to the RYB color model.
</span><span class="boring">    pub enum PrimaryColor {
</span><span class="boring">        Red,
</span><span class="boring">        Yellow,
</span><span class="boring">        Blue,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// The secondary colors according to the RYB color model.
</span><span class="boring">    pub enum SecondaryColor {
</span><span class="boring">        Orange,
</span><span class="boring">        Green,
</span><span class="boring">        Purple,
</span><span class="boring">    }
</span>}

pub mod utils {
    // --snip--
<span class="boring">    use crate::kinds::*;
</span><span class="boring">
</span><span class="boring">    /// Combines two primary colors in equal amounts to create
</span><span class="boring">    /// a secondary color.
</span><span class="boring">    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
</span><span class="boring">        SecondaryColor::Orange
</span><span class="boring">    }
</span>}
</code></pre>
<p><span class="caption">Liste 14-5: Öğeleri yeniden dışa aktarmak için <code>pub use</code> ifade yapıları ekleme</span></p>
<p><code>cargo doc</code>'un bu kasa için oluşturduğu API dokümantasyonu artık Şekil 14-4'te gösterildiği gibi ön 
sayfada yeniden dışa aktarmaları listeleyecek ve bağlayacak, böylece <code>PrimaryColor</code> ve
<code>SecondaryColor</code> türleri ile <code>mix</code> fonksiyonunun bulunması kolaylaşacaktır.</p>
<img alt="Ön sayfadaki yeniden dışa aktarımlarla birlikte `art` kasası için oluşturulmuş dokümantasyonlar" src="img/trpl14-04.png" class="center" />
<p><span class="caption">Şekil 14-4: Yeniden dahil etmeyi listeleyen <code>art</code> dokümantasyonunun ön sayfası</span></p>
<p><code>art</code> kasası kullanıcıları, Liste 14-4'te gösterildiği gibi Liste 14-3'teki dahili yapıyı
görmeye ve kullanmaya devam edebilir ya da Liste 14-6'da gösterildiği gibi Liste 14-5'teki
daha kullanışlı yapıyı kullanabilirler:
<span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::mix;
use art::PrimaryColor;

fn main() {
    // --snip--
<span class="boring">    let red = PrimaryColor::Red;
</span><span class="boring">    let yellow = PrimaryColor::Yellow;
</span><span class="boring">    mix(red, yellow);
</span>}
</code></pre>
<p><span class="caption">Liste 14-6: <code>art</code> kasasından dahil edilen öğeleri kullanan bir program</span></p>
<p>İç içe geçmiş çok sayıda modülün bulunduğu durumlarda, en üst seviyedeki türlerin <code>pub</code> kullanımıyla 
yeniden dışa aktarılması, kasayı kullanan kişilerin deneyiminde önemli bir fark yaratabilir.</p>
<p>Kullanışlı bir genel API yapısı oluşturmak bilimden çok bir sanattır ve kullanıcılarınız 
için en iyi çalışan API'yi bulmak için yineleme yapabilirsiniz. <code>pub</code> kullanımını seçmek, kasanızı dahili 
olarak nasıl yapılandırdığınız konusunda size esneklik sağlar ve bu dahili yapıyı kullanıcılarınıza 
sunduğunuzdan ayırır. İç yapılarının genel API'lerinden farklı olup olmadığını görmek için yüklediğiniz 
bazı kasaların kodlarına bakın.</p>
<h3 id="cratesio-hesabı-oluşturma"><a class="header" href="#cratesio-hesabı-oluşturma">Crates.io Hesabı Oluşturma</a></h3>
<p>Herhangi bir kasayı yayınlayabilmeniz için önce <a href="https://crates.io/">crates.io</a><!-- ignore -->'da bir hesap
oluşturmanız ve bir API anahtarı almanız gerekir. Bunu yapmak için <a href="https://crates.io/">crates.io</a><!-- ignore --> adresindeki
ana sayfayı ziyaret edin ve bir GitHub hesabı aracılığıyla oturum açın. (GitHub hesabı şu anda bir gerekliliktir, 
ancak site gelecekte hesap oluşturmanın diğer yollarını da gelecekte destekleyebilir). 
Giriş yaptıktan sonra <a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> adresinden hesap 
ayarlarınızı ziyaret edin ve API anahtarınızı alın. Ardından <code>cargo login</code> komutunu API 
anahtarınızla aşağıdaki gibi çalıştırın:</p>
<pre><code class="language-console">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>Bu komut Cargo'ya API token'ınızı bildirecek ve yerel olarak <em>~/.cargo/credentials</em> içinde saklayacaktır. 
Bu belirtecin bir sır olduğunu unutmayın: başkasıyla paylaşmayın. Herhangi bir nedenle herhangi 
biriyle paylaşırsanız, iptal etmeli ve <a href="https://crates.io/">crates.io</a><!-- ignore
-->'dan yeni bir token oluşturmalısınız.</p>
<h3 id="yeni-bir-kasaya-meta-veri-ekleme"><a class="header" href="#yeni-bir-kasaya-meta-veri-ekleme">Yeni Bir Kasaya Meta Veri Ekleme</a></h3>
<p>Diyelim ki yayınlamak istediğiniz bir kasanız var. Yayınlamadan önce, 
kasanın <em>Cargo.toml</em> dosyasının <code>[package]</code> bölümüne bazı meta veriler eklemeniz gerekir.</p>
<p>Kasanızın benzersiz bir isme ihtiyacı olacaktır. Yerel olarak bir kasa üzerinde çalışırken, 
sandığa istediğiniz adı verebilirsiniz. Ancak <a href="https://crates.io/">crates.io</a><!-- ignore -->'daki kasa
adları ilk gelene ilk hizmet esasına göre tahsis edilir. Bir kasa adı alındıktan sonra, 
başka hiç kimse bu adla bir kasa yayınlayamaz. Bir kasa yayınlamaya çalışmadan önce, 
kullanmak istediğiniz adı arayın. İsim kullanılmışsa, başka bir isim bulmanız ve 
<em>Cargo.toml</em> dosyasında <code>[package]</code> bölümü altındaki <code>name</code> alanını, yayınlama için yeni ismi 
kullanacak şekilde düzenlemeniz gerekecektir:</p>
<p><span class="filename">Dosya adı: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
</code></pre>
<p>Benzersiz bir ad seçmiş olsanız bile, bu noktada kasayı yayınlamak için <code>cargo publish</code>'i çalıştırdığınızda, 
bir uyarı ve ardından bir hata alırsınız:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error: missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata
</code></pre>
<p>Bu hata, bazı önemli bilgilerin eksik olmasından kaynaklanmaktadır: 
insanların kasanızın ne işe yaradığını ve hangi koşullar altında kullanabileceklerini bilmeleri için 
bir açıklama ve lisans gereklidir. <em>Cargo.toml</em> dosyasına sadece bir veya iki cümlelik bir açıklama ekleyin, 
çünkü bu açıklama arama sonuçlarında kasanızla birlikte görünecektir. <code>license</code> alanı için bir lisans 
tanımlayıcı değeri vermeniz gerekir. <a href="http://spdx.org/licenses/">Linux Foundation’un Software Package Data Exchange (SPDX)</a> listesi 
bu değer için kullanabileceğiniz tanımlayıcıları listeler. Örneğin, kasanızı MIT Lisansı kullanarak 
lisansladığınızı belirtmek için <code>MIT</code> tanımlayıcısını ekleyin:</p>
<p><span class="filename">Dosya adı: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
license = &quot;MIT&quot;
</code></pre>
<p>SPDX'te görünmeyen bir lisans kullanmak istiyorsanız, bu lisansın metnini bir dosyaya yerleştirmeniz, 
dosyayı projenize dahil etmeniz ve ardından lisans anahtarını kullanmak yerine bu dosyanın adını belirtmek 
için <code>license-file</code> kullanmanız gerekir.</p>
<p>Projeniz için hangi lisansın uygun olduğuna ilişkin rehberlik bu kitabın kapsamı dışındadır. 
Rust topluluğundaki birçok kişi, <code>MIT VEYA Apache-2.0</code> ikili lisansını kullanarak projelerini Rust ile 
aynı şekilde lisanslar. Bu uygulama, projeniz için birden fazla lisansa sahip olmak için <code>OR</code> ile ayrılmış 
birden fazla lisans tanımlayıcısı da belirtebileceğinizi göstermektedir.</p>
<p>Benzersiz bir ad, sürüm, açıklamanız ve bir lisans eklendiğinde, yayınlamaya hazır bir proje için 
<em>Cargo.toml</em> dosyası aşağıdaki gibi görünebilir:</p>
<p><span class="filename">Dosya adı: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
description = &quot;A fun game where you guess what number the computer has chosen.&quot;
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo’nun dokümantasyonunda</a>, başkalarının kasanızı daha kolay 
keşfedip kullanabilmesini sağlamak için belirtebileceğiniz diğer meta veriler açıklanmaktadır.</p>
<h3 id="cratesioda-yayınlama-süreci"><a class="header" href="#cratesioda-yayınlama-süreci">Crates.io'da Yayınlama Süreci</a></h3>
<p>Artık bir hesap oluşturduğunuza, API token'ınızı kaydettiğinize, kasanız için bir ad seçtiğinize 
ve gerekli meta verileri belirlediğinize göre yayınlamaya hazırsınız! Bir kasa yayınlamak, başkalarının
kullanması için <a href="https://crates.io/">crates.io</a><!-- ignore -->'ya belirli bir sürümü yükler.</p>
<p>Dikkatli olun, çünkü yayınlama kalıcıdır. Sürümün üzerine asla yazılamaz ve kod silinemez.
<a href="https://crates.io/">crates.io</a><!-- ignore -->'nun en önemli amaçlarından biri kalıcı bir kod arşivi 
olarak hareket etmektir, böylece <a href="https://crates.io/">crates.io</a><!-- ignore -->'daki kasalara bağlı olan 
tüm projelerin yapıları çalışmaya devam edecektir. Sürüm silme işlemlerine izin vermek 
bu hedefin gerçekleştirilmesini imkansız hale getirecektir. Bununla birlikte, 
yayınlayabileceğiniz kasa sürümlerinin sayısında bir sınır yoktur.</p>
<p><code>cargo publish</code> komutunu tekrar çalıştırın. Şimdi çalışması gerekir:</p>
<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>Tebrikler! Artık kodunuzu Rust topluluğu ile paylaştınız ve herkes kasanızı kolayca 
projelerinin bir bağımlılığı olarak ekleyebilir.</p>
<h3 id="mevcut-bir-kasanın-yeni-sürümünü-yayınlama"><a class="header" href="#mevcut-bir-kasanın-yeni-sürümünü-yayınlama">Mevcut Bir Kasanın Yeni Sürümünü Yayınlama</a></h3>
<p>Sandığınızda değişiklikler yaptığınızda ve yeni bir sürüm yayınlamaya hazır olduğunuzda, 
<em>Cargo.toml</em> dosyanızda belirtilen sürüm değerini değiştirir ve yeniden yayınlarsınız. 
Yaptığınız değişiklik türlerine göre uygun bir sonraki sürüm numarasının ne olduğuna 
karar vermek için <a href="http://semver.org/">Anlamsal Sürüm Oluşturma</a> kurallarını kullanın. 
Ardından yeni sürümü göndermek için <code>cargo publish</code>'ı çalıştırın.</p>
<!-- Old link, do not remove -->
<p><a id="removing-versions-from-cratesio-with-cargo-yank"></a></p>
<h3 id="cargo-yank-ile-cratesiodan-sürümleri-kaldırma"><a class="header" href="#cargo-yank-ile-cratesiodan-sürümleri-kaldırma"><code>cargo yank</code> ile Crates.io'dan Sürümleri Kaldırma</a></h3>
<p>Bir sandığın önceki sürümlerini kaldıramasanız da, gelecekteki projelerin 
bunları yeni bir bağımlılık olarak eklemesini önleyebilirsiniz. 
Bu, bir kasa sürümü bir nedenle bozulduğunda kullanışlıdır. 
Bu gibi durumlarda, Cargo kasa sürümünün kaldırılmasını destekler.</p>
<p>Bir sürümü çekmek, yeni projelerin o sürüme bağlı olmasını engellerken, 
ona bağlı olan tüm mevcut projelerin devam etmesine izin verir. 
Esasen, çekme, <em>Cargo.lock</em>'a sahip tüm projelerin bozulmayacağı ve gelecekte üretilen herhangi 
bir <em>Cargo.lock</em> dosyasının çekilmiş sürümü kullanmayacağı anlamına gelir.</p>
<p>Bir kasanın sürümünü çekmek için, daha önce yayınladığınız kasanın dizininde <code>cargo yank</code> 
komutunu çalıştırın ve hangi sürümü çekmek istediğinizi belirtin:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1
</code></pre>
<p>Ayrıca komuta <code>--undo</code> ekleyerek bir çekme işlemini geri alabilir ve projelerin yeniden 
bir sürüme bağlı olarak başlamasına izin verebilirsiniz:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
</code></pre>
<p>Bir çekme herhangi bir kodu silmez. Örneğin, yanlışlıkla yüklenen sırları silemez. 
Böyle bir durumda, bu sırları derhal sıfırlamanız gerekir.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-workspaces"><a class="header" href="#cargo-workspaces">Cargo Workspaces</a></h2>
<p>In Chapter 12, we built a package that included a binary crate and a library
crate. As your project develops, you might find that the library crate
continues to get bigger and you want to split your package further into
multiple library crates. Cargo offers a feature called <em>workspaces</em> that can
help manage multiple related packages that are developed in tandem.</p>
<h3 id="creating-a-workspace"><a class="header" href="#creating-a-workspace">Creating a Workspace</a></h3>
<p>A <em>workspace</em> is a set of packages that share the same <em>Cargo.lock</em> and output
directory. Let’s make a project using a workspace—we’ll use trivial code so we
can concentrate on the structure of the workspace. There are multiple ways to
structure a workspace, so we'll just show one common way. We’ll have a
workspace containing a binary and two libraries. The binary, which will provide
the main functionality, will depend on the two libraries. One library will
provide an <code>add_one</code> function, and a second library an <code>add_two</code> function.
These three crates will be part of the same workspace. We’ll start by creating
a new directory for the workspace:</p>
<pre><code class="language-console">$ mkdir add
$ cd add
</code></pre>
<p>Next, in the <em>add</em> directory, we create the <em>Cargo.toml</em> file that will
configure the entire workspace. This file won’t have a <code>[package]</code> section or
the metadata we’ve seen in other <em>Cargo.toml</em> files. Instead, it will start
with a <code>[workspace]</code> section that will allow us to add members to the workspace
by specifying the path to the package with our binary crate; in this case,
that path is <em>adder</em>:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
]
</code></pre>
<p>Next, we’ll create the <code>adder</code> binary crate by running <code>cargo new</code> within the
<em>add</em> directory:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-01-adder-crate/add
rm -rf adder
cargo new adder
copy output below
-->
<pre><code class="language-console">$ cargo new adder
     Created binary (application) `adder` package
</code></pre>
<p>At this point, we can build the workspace by running <code>cargo build</code>. The files
in your <em>add</em> directory should look like this:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>The workspace has one <em>target</em> directory at the top level that the compiled
artifacts will be placed into; the <code>adder</code> package doesn’t have its own
<em>target</em> directory. Even if we were to run <code>cargo build</code> from inside the
<em>adder</em> directory, the compiled artifacts would still end up in <em>add/target</em>
rather than <em>add/adder/target</em>. Cargo structures the <em>target</em> directory in a
workspace like this because the crates in a workspace are meant to depend on
each other. If each crate had its own <em>target</em> directory, each crate would have
to recompile each of the other crates in the workspace to place the artifacts
in its own <em>target</em> directory. By sharing one <em>target</em> directory, the crates
can avoid unnecessary rebuilding.</p>
<h3 id="creating-the-second-package-in-the-workspace"><a class="header" href="#creating-the-second-package-in-the-workspace">Creating the Second Package in the Workspace</a></h3>
<p>Next, let’s create another member package in the workspace and call it
<code>add_one</code>. Change the top-level <em>Cargo.toml</em> to specify the <em>add_one</em> path in
the <code>members</code> list:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
    &quot;add_one&quot;,
]
</code></pre>
<p>Then generate a new library crate named <code>add_one</code>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-02-add-one/add
rm -rf add_one
cargo new add_one --lib
copy output below
-->
<pre><code class="language-console">$ cargo new add_one --lib
     Created library `add_one` package
</code></pre>
<p>Your <em>add</em> directory should now have these directories and files:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add_one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>In the <em>add_one/src/lib.rs</em> file, let’s add an <code>add_one</code> function:</p>
<p><span class="filename">Filename: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p>Now we can have the <code>adder</code> package with our binary depend on the <code>add_one</code>
package that has our library. First, we’ll need to add a path dependency on
<code>add_one</code> to <em>adder/Cargo.toml</em>.</p>
<p><span class="filename">Filename: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
add_one = { path = &quot;../add_one&quot; }
</code></pre>
<p>Cargo doesn’t assume that crates in a workspace will depend on each other, so
we need to be explicit about the dependency relationships.</p>
<p>Next, let’s use the <code>add_one</code> function (from the <code>add_one</code> crate) in the
<code>adder</code> crate. Open the <em>adder/src/main.rs</em> file and add a <code>use</code> line at the
top to bring the new <code>add_one</code> library crate into scope. Then change the <code>main</code>
function to call the <code>add_one</code> function, as in Listing 14-7.</p>
<p><span class="filename">Filename: adder/src/main.rs</span></p>
<pre><code class="language-rust ignore">use add_one;

fn main() {
    let num = 10;
    println!(
        &quot;Hello, world! {} plus one is {}!&quot;,
        num,
        add_one::add_one(num)
    );
}
</code></pre>
<p><span class="caption">Listing 14-7: Using the <code>add_one</code> library crate from the
<code>adder</code> crate</span></p>
<p>Let’s build the workspace by running <code>cargo build</code> in the top-level <em>add</em>
directory!</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
</code></pre>
<p>To run the binary crate from the <em>add</em> directory, we can specify which
package in the workspace we want to run by using the <code>-p</code> argument and the
package name with <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo run -p adder
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>This runs the code in <em>adder/src/main.rs</em>, which depends on the <code>add_one</code> crate.</p>
<h4 id="depending-on-an-external-package-in-a-workspace"><a class="header" href="#depending-on-an-external-package-in-a-workspace">Depending on an External Package in a Workspace</a></h4>
<p>Notice that the workspace has only one <em>Cargo.lock</em> file at the top level,
rather than having a <em>Cargo.lock</em> in each crate’s directory. This ensures that
all crates are using the same version of all dependencies. If we add the <code>rand</code>
package to the <em>adder/Cargo.toml</em> and <em>add_one/Cargo.toml</em> files, Cargo will
resolve both of those to one version of <code>rand</code> and record that in the one
<em>Cargo.lock</em>. Making all crates in the workspace use the same dependencies
means the crates will always be compatible with each other. Let’s add the
<code>rand</code> crate to the <code>[dependencies]</code> section in the <em>add_one/Cargo.toml</em> file
so we can use the <code>rand</code> crate in the <code>add_one</code> crate:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
-->
<p><span class="filename">Filename: add_one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.8.3&quot;
</code></pre>
<p>We can now add <code>use rand;</code> to the <em>add_one/src/lib.rs</em> file, and building the
whole workspace by running <code>cargo build</code> in the <em>add</em> directory will bring in
and compile the <code>rand</code> crate. We will get one warning because we aren’t
referring to the <code>rand</code> we brought into scope:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-dependency/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
   --snip--
   Compiling rand v0.8.3
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
warning: unused import: `rand`
 --&gt; add_one/src/lib.rs:1:5
  |
1 | use rand;
  |     ^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: 1 warning emitted

   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18s
</code></pre>
<p>The top-level <em>Cargo.lock</em> now contains information about the dependency of
<code>add_one</code> on <code>rand</code>. However, even though <code>rand</code> is used somewhere in the
workspace, we can’t use it in other crates in the workspace unless we add
<code>rand</code> to their <em>Cargo.toml</em> files as well. For example, if we add <code>use rand;</code>
to the <em>adder/src/main.rs</em> file for the <code>adder</code> package, we’ll get an error:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-03-use-rand/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
  --snip--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 --&gt; adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no external crate `rand`
</code></pre>
<p>To fix this, edit the <em>Cargo.toml</em> file for the <code>adder</code> package and indicate
that <code>rand</code> is a dependency for it as well. Building the <code>adder</code> package will
add <code>rand</code> to the list of dependencies for <code>adder</code> in <em>Cargo.lock</em>, but no
additional copies of <code>rand</code> will be downloaded. Cargo has ensured that every
crate in every package in the workspace using the <code>rand</code> package will be using
the same version, saving us space and ensuring that the crates in the workspace
will be compatible with each other.</p>
<h4 id="adding-a-test-to-a-workspace"><a class="header" href="#adding-a-test-to-a-workspace">Adding a Test to a Workspace</a></h4>
<p>For another enhancement, let’s add a test of the <code>add_one::add_one</code> function
within the <code>add_one</code> crate:</p>
<p><span class="filename">Filename: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
</code></pre>
<p>Now run <code>cargo test</code> in the top-level <em>add</em> directory. Running <code>cargo test</code> in
a workspace structured like this one will run the tests for all the crates in
the workspace:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test
copy output below; the output updating script doesn't handle subdirectories in
paths properly
-->
<pre><code class="language-console">$ cargo test
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.27s
     Running target/debug/deps/add_one-f0253159197f7841

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running target/debug/deps/adder-49979ff40686fa8e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>The first section of the output shows that the <code>it_works</code> test in the <code>add_one</code>
crate passed. The next section shows that zero tests were found in the <code>adder</code>
crate, and then the last section shows zero documentation tests were found in
the <code>add_one</code> crate.</p>
<p>We can also run tests for one particular crate in a workspace from the
top-level directory by using the <code>-p</code> flag and specifying the name of the crate
we want to test:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test -p add_one
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo test -p add_one
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running target/debug/deps/add_one-b3235fea9a156f74

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>This output shows <code>cargo test</code> only ran the tests for the <code>add_one</code> crate and
didn’t run the <code>adder</code> crate tests.</p>
<p>If you publish the crates in the workspace to <a href="https://crates.io/">crates.io</a>,
each crate in the workspace will need to be published separately. Like <code>cargo test</code>, we can publish a particular crate in our workspace by using the <code>-p</code>
flag and specifying the name of the crate we want to publish.</p>
<p>For additional practice, add an <code>add_two</code> crate to this workspace in a similar
way as the <code>add_one</code> crate!</p>
<p>As your project grows, consider using a workspace: it’s easier to understand
smaller, individual components than one big blob of code. Furthermore, keeping
the crates in a workspace can make coordination between crates easier if they
are often changed at the same time.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old link, do not remove -->
<p><a id="installing-binaries-from-cratesio-with-cargo-install"></a></p>
<h2 id="cargo-install-ile-İkili-dosyaları-yükleme"><a class="header" href="#cargo-install-ile-İkili-dosyaları-yükleme"><code>cargo install</code> ile İkili Dosyaları Yükleme</a></h2>
<p><code>cargo install</code> komutu, ikili kasaları yerelde kurmanıza ve kullanmanıza olanak tanır. 
Bunun sistem paketlerinin yerini alması amaçlanmamıştır; Rust geliştiricilerinin, diğer geliştiricilerin 
<a href="https://crates.io/">crates.io</a><!-- ignore -->'da paylaştığı araçları yüklemeleri için uygun bir yol olması amaçlanmıştı. 
Yalnızca ikili hedefleri olan paketleri kurabileceğinizi unutmayın. <em>İkili hedef</em>, sandıkta bir <em>src/main.rs</em> dosyası 
veya ikili olarak belirtilen başka bir dosya varsa o kasa çalıştırılabilir kod içeriyor olabilir. Genellikle kasalar, <em>README</em>
dosyasında bir kasanın kütüphane mi, çalıştırılabilir mi yoksa her ikisi mi olduğu hakkında bilgi içermektedir.</p>
<p><code>cargo install</code> ile kurulan tüm ikili dosyalar, kurulum kökünün <em>bin</em> dizininde saklanır. 
Rust'ı <em>rustup.rs</em> kullanarak yüklediyseniz ve herhangi bir özel yapılandırmanız yoksa bu dizin <em>$HOME/.cargo/bin</em> 
olacaktır. <code>cargo install</code>'i kullanarak kurduğunuz programları çalıştırabilmek için dizinin <em>$PATH</em> içinde olduğundan emin olun.</p>
<p>Örneğin, Bölüm 12'de, dosyaları aramak için <code>ripgrep</code> adlı <code>grep</code> aracının bir Rust süreklemesi olduğundan bahsetmiştik. 
<code>Ripgrep</code>'i kurmak için aşağıdakileri çalıştırabiliriz:</p>
<!-- manual-regeneration
cargo install something you don't have, copy relevant output below
-->
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v11.0.2
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v11.0.2
--snip--
   Compiling ripgrep v11.0.2
    Finished release [optimized + debuginfo] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v11.0.2` (executable `rg`)
</code></pre>
<p>Aynı şekilde, bir inşa sistemi olan <a href="https://github.com/ferhatgec/elite">Elite</a>'i de aynı yolla (<code>cargo install elite</code>) kurabiliriz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Özel-komutlarla-cargoyu-genişletme"><a class="header" href="#Özel-komutlarla-cargoyu-genişletme">Özel Komutlarla Cargo'yu Genişletme</a></h2>
<p>Cargo, Cargo'yu değiştirmek zorunda kalmadan yeni alt komutlarla genişletebilmeniz için tasarlanmıştır. 
<code>$PATH</code>'inizdeki bir ikili dosya <code>cargo-bir şey</code> olarak adlandırılmışsa, <code>cargo-bir şey</code>'i çalıştırarak onu bir Cargo alt komutuymuş gibi çalıştırabilirsiniz. Bunun gibi özel komutlar, <code>cargo --list</code> çalıştırdığınızda da listelenir. 
Uzantıları yüklemek için <code>cargo install</code>'ı kullanabilmek ve ardından bunları yerleşik Cargo araçları gibi çalıştırabilmek, </p>
<h2 id="Özet-10"><a class="header" href="#Özet-10">Özet</a></h2>
<p>Cargo ve <a href="https://crates.io/">crates.io</a><!-- ignore --> ile kod paylaşımı, Rust ekosistemini birçok farklı görev için faydalı kılan şeyin bir 
parçasıdır. Rust'ın standart kütüphanesi küçük ve kararlıdır, ancak kasaların dilden farklı bir zaman çizelgesinde paylaşılması, 
kullanılması ve geliştirilmesi kolaydır. <a href="https://crates.io/">crates.io</a><!-- ignore -->'da işinize yarayacak kodu paylaşmaktan çekinmeyin; muhtemelen bir başkası için de faydalı olacaktır!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="akıllı-İşaretçiler"><a class="header" href="#akıllı-İşaretçiler">Akıllı İşaretçiler</a></h1>
<p><em>İşaretçi</em>, bellekte bir adres içeren bir değişken için genel bir kavramdır. 
Bu adres, diğer bazı verilere atıfta bulunur veya “işaret eder”. 
Rust'taki en yaygın işaretçi türü, Bölüm 4'te öğrendiğiniz bir referanstır. 
Referanslar <code>&amp;</code> sembolü ile gösterilir ve işaret ettikleri değeri ödünç alırlar. 
Verilere atıfta bulunmak dışında herhangi bir özel yetenekleri yoktur ve ek yükleri yoktur.</p>
<p><em>Akıllı işaretçiler</em> ise işaretçi gibi davranan ancak ek meta veri ve yeteneklere sahip veri yapılarıdır. 
Akıllı işaretçiler kavramı Rust'a özgü değildir: akıllı işaretçiler ilk C++'ta ortaya çıkmıştır ve 
diğer birçok dilde de mevcuttur. Rust, standart kütüphanede tanımlanan ve referanslar tarafından sağlananın 
ötesinde işlevsellik sağlayan çeşitli akıllı işaretçilere sahiptir. Genel konsepti keşfetmek için, 
bir <em>referans sayma</em> akıllı işaretçi türü de dahil olmak üzere birkaç farklı akıllı işaretçi örneğine bakacağız. 
Bu işaretçi, sahiplerin sayısını takip ederek ve hiçbir sahip kalmadığında verileri temizleyerek verilerin
birden fazla sahibinin olmasına izin vermenizi sağlar.</p>
<p>Sahiplik ve ödünç alma kavramıyla Rust, referanslar ve akıllı işaretçiler arasında ek bir farka sahiptir: 
referanslar yalnızca veri ödünç alırken, çoğu durumda akıllı işaretçiler işaret ettikleri verilere sahiptir.</p>
<p>O zamanlar onları bu kadar çok farklı şekillerde adlandırmasak da, 
Bölüm 8'de konuştuğumuz <code>String</code> ve <code>Vec&lt;T&gt;</code> dahil olmak üzere bu kitapta birkaç akıllı işaretçiyle zaten 
karşılaştık. Ek olarak bu işaretçiler meta verilere ve ekstra yeteneklere veya garantilere sahiptirler. 
Örneğin <code>String</code>, kapasitesini meta veri olarak depolar ve verilerinin her zaman geçerli bir UTF-8 olmasını sağlamak için ekstra yeteneğe sahiptir.</p>
<p>Akıllı işaretçiler genellikle yapılar kullanılarak süreklenirler. Sıradan bir yapının aksine, akıllı işaretçiler <code>Deref</code> ve <code>Drop</code> tanımlarını uygular. <code>Deref</code> özelliği, akıllı işaretçi yapısının bir örneğinin referansı gibi davranmasına izin verir, 
böylece kodunuzu başvurularla veya akıllı işaretçilerle çalışacak şekilde yazabilirsiniz. 
<code>Drop</code> tanımı, akıllı işaretçinin bir örneği kapsam dışına çıktığında çalıştırılan kodu özelleştirmenize olanak tanır. 
Bu bölümde, her iki özelliği de tartışacağız ve akıllı işaretçiler için neden önemli olduklarını göstereceğiz.</p>
<p>Akıllı işaretçi kalıbının Rust'ta sıkça kullanılan genel bir tasarım kalıbı olduğu düşünüldüğünde, 
bu bölüm mevcut her akıllı işaretçiyi kapsamayacaktır. Birçok kütüphanenin kendi akıllı işaretçileri 
vardır ve hatta kendinizinkini bile yazabilirsiniz. Bu bölümde standart kütüphanedeki en yaygın akıllı 
işaretçileri ele alacağız:</p>
<ul>
<li><code>Box&lt;T&gt;</code>, yığın üzerinde yer tahsis eden bir tür</li>
<li><code>Rc&lt;T&gt;</code>, çoklu sahiplik sağlayan bir referans sayma türü</li>
<li><code>Ref&lt;T&gt;</code> ve <code>RefMut&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> aracılığıyla erişilen, derleme zamanı yerine çalışma zamanında ödünç alma kurallarını 
uygulamaya zorlayan bir tür</li>
</ul>
<p>Ek olarak, değişmez bir türün bir iç değeri mutasyona uğratmak için çıkardığı iç değişebilirlik modelini ele alacağız. 
Ayrıca <em>referans döngülerinin</em> nasıl bellek sızdırabilecekleri ve nasıl önlenebilecekleri hakkında tartışacağız.</p>
<p>Öyleyse, hadi dalalım!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="yığın-Üzerindeki-verilere-İşaret-etmek-için-boxt-kullanma"><a class="header" href="#yığın-Üzerindeki-verilere-İşaret-etmek-için-boxt-kullanma">Yığın Üzerindeki Verilere İşaret Etmek için <code>Box&lt;T&gt;</code> Kullanma</a></h2>
<p>En basit akıllı işaretçi, türü <code>Box&lt;T&gt;</code> olarak yazılan bir çeşit <em>kutudur</em>. 
Kutular, verileri yığıt yerine yığın (heap) üzerinde saklamanıza olanak tanır. 
Yığıtta kalan şey, yığın verisinin işaretçisidir. Yığıt ve yığın arasındaki farkı incelemek için Bölüm 4'e bakın.</p>
<p>Kutular, verilerini yığıt yerine yığın üzerinde saklamak dışında performans ek yüküne sahip değildir. 
Ancak çok fazla ekstra yetenekleri de yoktur. Onları en çok bu durumlarda kullanacaksınız:</p>
<ul>
<li>Boyutu derleme zamanında bilinemeyen bir türünüz olduğunda ve bu türden bir değeri tam boyut gerektiren 
bir bağlamda kullanmak istediğinizde</li>
<li>Büyük miktarda veriye sahip olduğunuzda ve sahipliği devretmek istediğinizde ancak bunu yaparken verilerin 
kopyalanmayacağından emin olmak istediğinizde</li>
<li>Bir değere sahip olmak istediğinizde ve belirli bir türde olmasından ziyade yalnızca belirli bir tanımı sürekleyen 
bir tür olmasını önemsediğinizde</li>
</ul>
<p>İlk durumu <a href="ch15-01-box.html#enabling-recursive-types-with-boxes">“Kutularla Özyinelemeli Türleri Etkinleştirme”</a><!-- ignore -->
bölümünde göstereceğiz. İkinci durumda, büyük miktarda verinin sahipliğinin aktarılması uzun sürebilir
çünkü veriler yığıt üzerinde kopyalanır. Bu durumda performansı artırmak için, büyük miktardaki veriyi 
yığında bir kutu içinde saklayabiliriz. Ardından, yalnızca küçük miktarda işaretçi verisi yığıt 
üzerinde kopyalanırken, referans verdiği veriler yığın üzerinde tek bir yerde kalır. 
Üçüncü durum özellik nesnesi olarak bilinir ve Bölüm 17,
<a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Farklı Türlerde Değerlere İzin Veren Tanım Nesnelerini Kullanma”</a><!--
ignore --> başlıklı bir bölümün tamamını bu konuya ayırmıştır. Yani burada öğrendiklerinizi 
Bölüm 17'de tekrar uygulayacaksınız!</p>
<h3 id="verileri-yığın-Üzerinde-saklamak-için-boxt-kullanma"><a class="header" href="#verileri-yığın-Üzerinde-saklamak-için-boxt-kullanma">Verileri Yığın Üzerinde Saklamak için <code>Box&lt;T&gt;</code> Kullanma</a></h3>
<p><code>Box&lt;T&gt;</code> için yığın depolama kullanım durumunu tartışmadan önce, 
söz dizimini ve bir <code>Box&lt;T&gt;</code> içinde depolanan değerlerle nasıl etkileşimde bulunacağımızı ele alacağız.</p>
<p>Liste 15-1, bir <code>i32</code> değerini yığın üzerinde saklamak için bir kutunun nasıl kullanılacağını gösterir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<p><span class="caption">Liste 15-1: Bir kutu kullanarak bir <code>i32</code> değerini yığın üzerinde saklama</span></p>
<p><code>b</code> değişkenini, yığın üzerinde ayrılmış olan <code>5</code> değerine işaret eden bir <code>Box</code> değerine sahip 
olacak şekilde tanımlarız. Bu program <code>b = 5</code> yazdıracaktır; bu durumda, kutudaki verilere, 
bu veriler yığıtta olsaydı yapacağımız gibi erişebiliriz. Tıpkı sahip olunan herhangi bir değer gibi,
<code>main</code>'in sonunda <code>b</code>'nin yaptığı gibi bir kutu kapsam dışına çıktığında, bellekten silinecektir. 
Bellekten silme işlemi hem kutu (yığıt üzerinde saklanır) hem de işaret ettiği veri 
(yığın üzerinde saklanır) için gerçekleşir.</p>
<p>Yığına tek bir değer koymak çok kullanışlı değildir, bu nedenle kutuları bu şekilde tek başlarına çok sık 
kullanmazsınız. Varsayılan olarak saklandıkları yığıtta tek bir <code>i32</code> gibi değerlere sahip olmak, 
çoğu durumda daha uygundur. Kutuların, kutular olmasaydı tanımlamamıza izin verilmeyecek türleri 
tanımlamamıza izin verdiği bir duruma bakalım.</p>
<h3 id="kutularla-Özyinelemeli-türleri-etkinleştirme"><a class="header" href="#kutularla-Özyinelemeli-türleri-etkinleştirme">Kutularla Özyinelemeli Türleri Etkinleştirme</a></h3>
<p><em>Özyinelemeli türdeki</em> bir değer, kendisinin bir parçası olarak aynı türde başka bir değere sahip olabilir. 
Özyinelemeli türler bir sorun teşkil eder çünkü derleme zamanında Rust'ın bir türün ne kadar yer 
kapladığını bilmesi gerekir. Ancak, özyinelemeli türlerin değerlerinin iç içe geçmesi teorik 
olarak sonsuza kadar devam edebilir, bu nedenle Rust değerin ne kadar alana ihtiyaç duyduğunu bilemez. 
Kutular bilinen bir boyuta sahip olduğundan, özyinelemeli tür tanımına bir kutu ekleyerek özyinelemeli 
türleri etkinleştirebiliriz.</p>
<p>Bir özyinelemeli tür örneği olarak, <em>cons listesini</em> inceleyelim. 
Bu, fonksiyonel programlama dillerinde yaygın olarak bulunan bir veri türüdür. 
Tanımlayacağımız <em>cons listesi</em> türü, özyineleme dışında basittir; bu nedenle, üzerinde çalışacağımız 
örnekteki kavramlar, özyinelemeli türleri içeren daha karmaşık durumlarla karşılaştığınızda yararlı olacaktır.</p>
<h3 id="cons-listesi-hakkında-daha-fazla-bilgi"><a class="header" href="#cons-listesi-hakkında-daha-fazla-bilgi"><em>Cons Listesi</em> Hakkında Daha Fazla Bilgi</a></h3>
<p>Cons listesi, Lisp programlama dili ve lehçelerinden gelen ve iç içe geçmiş çiftlerden oluşan bir 
veri yapısıdır. Adı, Lisp'te iki argümanından yeni bir çift oluşturan <code>cons</code> fonksiyonundan (“construct function”'ın kısaltması) 
gelir. Bir değer ve başka bir çiftten oluşan bir çift üzerinde <code>cons</code> çağırarak, 
özyinelemeli çiftlerden oluşan <em>cons listeleri</em> oluşturabiliriz.</p>
<p>Örneğin, burada 1, 2, 3 listesini içeren ve her bir çifti parantez içinde olan bir <em>cons listesinin</em> 
sözde kod gösterimi yer almaktadır:</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>Bir cons listesindeki her öğe iki öğe içerir: geçerli öğenin değeri ve bir sonraki öğe. 
Listedeki son öğe, bir sonraki öğe olmaksızın yalnızca <code>Nil</code> adlı bir değer içerir. 
Bir cons listesi, <code>cons</code> fonksiyonunun özyinelemeli olarak çağrılmasıyla oluşturulur. 
Özyinelemenin temel durumunu gösteren yaygın kullanılan ad <code>Nil</code>'dir. 
Bunun Bölüm 6'daki “null” or “nil” kavramıyla aynı olmadığına dikkat edin; bu kavram geçersiz veya 
olmayan bir değerdir.</p>
<p>Cons listesi Rust'ta yaygın olarak kullanılan bir veri yapısı değildir. 
Rust'ta bir öğe listesine sahip olduğunuzda çoğu zaman <code>Vec&lt;T&gt;</code> kullanmak daha iyi bir seçimdir. 
Diğer, daha karmaşık özyinelemeli veri tipleri çeşitli durumlarda kullanışlıdır, 
ancak bu bölümde cons listesi ile başlayarak, kutuların fazla dikkat dağıtmadan özyinelemeli 
bir veri tipi tanımlamamıza nasıl izin verdiğini keşfedebiliriz.</p>
<p>Liste 15-2, cons listesi için bir <code>enum</code> tanımını içerir. 
Bu kodun henüz derlenmeyeceğini unutmayın çünkü <code>List</code> türünün bilinen bir boyutu yoktur, 
bunu daha sonra göstereceğiz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p><span class="caption">Liste 15-2: <code>i32</code> değerlerinden oluşan bir cons listesi veri yapısını temsil etmek için bir
<code>enum</code> tanımlamaya yönelik ilk girişim</span></p>
<blockquote>
<p>Not: Bu örneğin amaçları doğrultusunda yalnızca <code>i32</code> değerlerini tutan bir cons listesi yapıyoruz.
Bölüm 10'da tartıştığımız gibi, herhangi bir türden değerleri saklayabilen bir cons liste türü tanımlamak için
yaygınları kullanabilirdik.</p>
</blockquote>
<p><code>List</code> türünü <code>1, 2, 3</code> listesini saklamak için kullanırsak, Liste 15-3'teki gibi bir kod yazmamız gerekir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<p><span class="caption">Listing 15-3: <code>1, 2, 3</code> listesini saklamak için <code>List</code> <code>enum</code>'unu kullanma</span></p>
<p>İlk <code>Cons</code> değeri <code>1</code>'i ve başka bir `` değerini tutar. 
Bu <code>List</code> değeri, <code>2</code> ve başka bir <code>List</code> değerini tutan başka bir <code>Cons</code> değeridir. 
Bu <code>List</code> değeri, <code>3</code>'ü ve bir diğer <code>List</code> değerini tutan bir <code>Cons</code> değeridir ve son 
olarak listenin sonunu işaret eden özyinelemesiz tür olan <code>Nil</code>'dir.</p>
<p>Liste 15-3'teki kodu derlemeye çalışırsak, Liste 15-4'te gösterilen hatayı alırız:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing drop-check constraints for `List`
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing drop-check constraints for `List` again
  = note: cycle used when computing dropck types for `Canonical { max_universe: U0, variables: [], value: ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, value: List } }`

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` due to 2 previous errors
</code></pre>
<p><span class="caption">Liste 15-4: Özyinelemeli bir <code>enum</code> tanımlamaya çalıştığımızda aldığımız hata</span></p>
<p>Hata, bu türün “sonsuz boyutu” olduğunu gösterir. Bunun nedeni, <code>List</code>'i özyinelemeli bir değişkenle 
tanımlamış olmamızdır: doğrudan kendisinin başka bir değerini tutar. Sonuç olarak, Rust
<code>List</code> değerini saklamak için ne kadar alana ihtiyacı olduğunu bulamaz. Bu hatayı neden aldığımızı inceleyelim. 
İlk olarak, Rust'ın özyinelemeli olmayan bir türdeki bir değeri saklamak için ne kadar alana ihtiyaç 
duyduğuna nasıl karar verdiğine bakacağız.</p>
<h4 id="Özyinelemeli-olmayan-bir-türün-boyutunu-hesaplama"><a class="header" href="#Özyinelemeli-olmayan-bir-türün-boyutunu-hesaplama">Özyinelemeli Olmayan Bir Türün Boyutunu Hesaplama</a></h4>
<p>Bölüm 6'da <code>enum</code> tanımlarını tartışırken Liste 6-2'de tanımladığımız <code>Message</code> <code>enum</code>'unu hatırlayın:</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Bir <code>Message</code> değeri için ne kadar alan ayrılacağını belirlemek için Rust, hangi varyantın en fazla alana ihtiyaç 
duyduğunu görmek için varyantların her birini gözden geçirir. Rust, <code>Message::Quit</code>'in herhangi bir alana ihtiyaç 
duymadığını, <code>Message::Move</code>'un iki <code>i32</code> değerini depolamak için yeterli alana ihtiyaç duyduğunu ve benzerlerini görür. 
Yalnızca bir değişken kullanılacağından, bir <code>Message</code> değerinin ihtiyaç duyacağı en fazla alan, değişkenlerinin en 
büyüğünü depolamak için gereken alandır.</p>
<p>Rust, Liste 15-2'deki <code>List</code> <code>enum</code>'u gibi özyinelemeli bir türün ne kadar alana ihtiyaç duyduğunu belirlemeye 
çalıştığında ortaya çıkan durumla bunu karşılaştırın. Derleyici, <code>i32</code> türünde bir değer ve <code>List</code> türünde bir değer tutan
<code>Cons</code> değişkenine bakarak başlar. Bu nedenle <code>Cons</code>, <code>i32</code>'nin boyutu artı bir <code>List</code>'in boyutuna eşit 
miktarda alana ihtiyaç duyar. Derleyici, <code>List</code> türünün ne kadar belleğe ihtiyacı olduğunu bulmak için <code>Cons</code> 
değişkeninden başlayarak tüm sıralı değişkenlere bakar. <code>Cons</code> değişkeni <code>i32</code> türünde bir değer ve
<code>List</code> türünde bir değer tutar ve bu işlem Şekil 15-1'de gösterildiği gibi <em>sonsuza kadar</em> devam eder.</p>
<img alt="Sonsuz bir Cons listesi" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Şekil 15-1: Sonsuz <code>Cons</code> varyantlarından oluşan sonsuz bir <code>List</code></span></p>
<h4 id="boyutu-bilinen-Özyinelemeli-bir-tür-elde-etmek-için-boxt-kullanmak"><a class="header" href="#boyutu-bilinen-Özyinelemeli-bir-tür-elde-etmek-için-boxt-kullanmak">Boyutu Bilinen Özyinelemeli Bir Tür Elde Etmek için <code>Box&lt;T&gt;</code> Kullanmak</a></h4>
<p>Rust, özyinelemeli olarak tanımlanan türler için ne kadar alan ayırması gerektiğini bulamadığından, 
derleyici bu yararlı öneriyle birlikte bir hata verir:</p>
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ^^^^    ^
</code></pre>
<p>Bu öneride “dolayı yönlendirme” (“indirection”), bir değeri doğrudan depolamak yerine, 
veri yapısını değiştirerek değeri dolaylı olarak depolamamız gerektiği ve bunun yerine değere bir işaretçi 
depolamamız gerektiği anlamına gelir.</p>
<p><code>Box&lt;T&gt;</code> bir işaretçi olduğundan, Rust her zaman bir <code>Box&lt;T&gt;</code>'nin ne kadar alana ihtiyacı olduğunu bilir: 
bir işaretçinin boyutu, işaret ettiği veri miktarına bağlı olarak değişmez. Bu, doğrudan başka bir
<code>List</code> değeri yerine <code>Cons</code> değişkeninin içine bir <code>Box&lt;T&gt;</code> koyabileceğimiz anlamına gelir.
<code>Box&lt;T&gt;</code>, <code>Cons</code> değişkeninin içinde olmak yerine yığın üzerinde olacak bir sonraki <code>List</code> değerine 
işaret edecektir. Kavramsal olarak, hala diğer listeleri tutan listelerle oluşturulmuş bir listemiz var, 
ancak bu uygulama artık öğeleri birbirinin içine yerleştirmek yerine yan yana yerleştirmeye benziyor.</p>
<p>Liste 15-2'deki <code>List</code> <code>enum</code>'unun tanımını ve Liste 15-3'teki <code>List</code> kullanımını, derlenecek olan 
Liste 15-5'teki kodla değiştirebiliriz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
</code></pre></pre>
<p><span class="caption">Liste 15-5: Bilinen bir boyuta sahip olmak için <code>Box&lt;T&gt;</code> kullanan <code>List</code> tanımı</span></p>
<p><code>Cons</code> varyantı, bir <code>i32</code> boyutuna ve kutunun işaretçi verilerini depolamak için alana ihtiyaç duyar.
<code>Nil</code> değişkeni hiçbir değer saklamaz, bu nedenle <code>Cons</code> değişkeninden daha az alana ihtiyaç duyar. 
Artık herhangi bir <code>List</code> değerinin bir <code>i32</code> boyutu artı bir kutunun işaretçi verisinin boyutunu kaplayacağını biliyoruz. 
Bir kutu kullanarak sonsuz, özyinelemeli zinciri kırdık, böylece derleyici bir <code>List</code> değerini saklamak için gereken 
boyutu bulabilir. Şekil 15-2, <code>Cons</code> varyantının şimdi nasıl göründüğünü göstermektedir.</p>
<img alt="Sonlu bir Cons listesi" src="img/trpl15-02.svg" class="center" />
<p><span class="caption">Şekil 15-2: <code>Cons</code> <code>Box</code>'ı tuttuğu için sonsuz boyutlu olmayan bir <code>List</code></span></p>
<p>Kutular yalnızca dolaylama ve heap tahsisi sağlar; diğer akıllı işaretçi türlerinde göreceğimiz gibi başka özel 
yetenekleri yoktur. Ayrıca, bu özel yeteneklerin neden olduğu performans ek yüküne de sahip değildirler, 
bu nedenle dolaylamanın ihtiyaç duyduğumuz tek özellik olduğu cons listesi gibi durumlarda yararlı olabilirler. 
Bölüm 17'de kutular için daha fazla kullanım alanına da bakacağız.</p>
<p><code>Box&lt;T&gt;</code> türü akıllı bir işaretçidir çünkü <code>Box&lt;T&gt;</code> değerlerinin referanslar gibi ele alınmasını sağlayan
<code>Deref</code> tanımını sürekler. <code>Box&lt;T&gt;</code> değeri kapsam dışına çıktığında, <code>Drop</code> tanımının süreklenmesi nedeniyle 
kutunun işaret ettiği yığın verileri de temizlenir. Bu iki tanım, bu bölümün geri kalanında tartışacağımız diğer 
akıllı işaretçi türleri tarafından sağlanan işlevsellik için daha da önemli olacaktır. 
Şimdi bu iki tanımı daha ayrıntılı olarak inceleyelim.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="treating-smart-pointers-like-regular-references-with-the-deref-trait"><a class="header" href="#treating-smart-pointers-like-regular-references-with-the-deref-trait">Treating Smart Pointers Like Regular References with the <code>Deref</code> Trait</a></h2>
<p>Implementing the <code>Deref</code> trait allows you to customize the behavior of the
<em>dereference operator</em> <code>*</code> (not to be confused with the multiplication or glob
operator). By implementing <code>Deref</code> in such a way that a smart pointer can be
treated like a regular reference, you can write code that operates on
references and use that code with smart pointers too.</p>
<p>Let’s first look at how the dereference operator works with regular references.
Then we’ll try to define a custom type that behaves like <code>Box&lt;T&gt;</code>, and see why
the dereference operator doesn’t work like a reference on our newly defined
type. We’ll explore how implementing the <code>Deref</code> trait makes it possible for
smart pointers to work in ways similar to references. Then we’ll look at
Rust’s <em>deref coercion</em> feature and how it lets us work with either references
or smart pointers.</p>
<blockquote>
<p>Note: there’s one big difference between the <code>MyBox&lt;T&gt;</code> type we’re about to
build and the real <code>Box&lt;T&gt;</code>: our version will not store its data on the heap.
We are focusing this example on <code>Deref</code>, so where the data is actually stored
is less important than the pointer-like behavior.</p>
</blockquote>
<!-- Old link, do not remove -->
<p><a id="following-the-pointer-to-the-value-with-the-dereference-operator"></a></p>
<h3 id="following-the-pointer-to-the-value"><a class="header" href="#following-the-pointer-to-the-value">Following the Pointer to the Value</a></h3>
<p>A regular reference is a type of pointer, and one way to think of a pointer is
as an arrow to a value stored somewhere else. In Listing 15-6, we create a
reference to an <code>i32</code> value and then use the dereference operator to follow the
reference to the value:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Listing 15-6: Using the dereference operator to follow a
reference to an <code>i32</code> value</span></p>
<p>The variable <code>x</code> holds an <code>i32</code> value <code>5</code>. We set <code>y</code> equal to a reference to
<code>x</code>. We can assert that <code>x</code> is equal to <code>5</code>. However, if we want to make an
assertion about the value in <code>y</code>, we have to use <code>*y</code> to follow the reference
to the value it’s pointing to (hence <em>dereference</em>) so the compiler can compare
the actual value. Once we dereference <code>y</code>, we have access to the integer value
<code>y</code> is pointing to that we can compare with <code>5</code>.</p>
<p>If we tried to write <code>assert_eq!(5, y);</code> instead, we would get this compilation
error:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` due to previous error
</code></pre>
<p>Comparing a number and a reference to a number isn’t allowed because they’re
different types. We must use the dereference operator to follow the reference
to the value it’s pointing to.</p>
<h3 id="using-boxt-like-a-reference"><a class="header" href="#using-boxt-like-a-reference">Using <code>Box&lt;T&gt;</code> Like a Reference</a></h3>
<p>We can rewrite the code in Listing 15-6 to use a <code>Box&lt;T&gt;</code> instead of a
reference; the dereference operator used on the <code>Box&lt;T&gt;</code> in Listing 15-7
functions in the same way as the dereference operator used on the reference in
Listing 15-6:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Listing 15-7: Using the dereference operator on a
<code>Box&lt;i32&gt;</code></span></p>
<p>The main difference between Listing 15-7 and Listing 15-6 is that here we set
<code>y</code> to be an instance of a box pointing to a copied value of <code>x</code> rather than a
reference pointing to the value of <code>x</code>. In the last assertion, we can use the
dereference operator to follow the box’s pointer in the same way that we did
when <code>y</code> was a reference. Next, we’ll explore what is special about <code>Box&lt;T&gt;</code>
that enables us to use the dereference operator by defining our own box type.</p>
<h3 id="defining-our-own-smart-pointer"><a class="header" href="#defining-our-own-smart-pointer">Defining Our Own Smart Pointer</a></h3>
<p>Let’s build a smart pointer similar to the <code>Box&lt;T&gt;</code> type provided by the
standard library to experience how smart pointers behave differently from
references by default. Then we’ll look at how to add the ability to use the
dereference operator.</p>
<p>The <code>Box&lt;T&gt;</code> type is ultimately defined as a tuple struct with one element, so
Listing 15-8 defines a <code>MyBox&lt;T&gt;</code> type in the same way. We’ll also define a
<code>new</code> function to match the <code>new</code> function defined on <code>Box&lt;T&gt;</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 15-8: Defining a <code>MyBox&lt;T&gt;</code> type</span></p>
<p>We define a struct named <code>MyBox</code> and declare a generic parameter <code>T</code>, because
we want our type to hold values of any type. The <code>MyBox</code> type is a tuple struct
with one element of type <code>T</code>. The <code>MyBox::new</code> function takes one parameter of
type <code>T</code> and returns a <code>MyBox</code> instance that holds the value passed in.</p>
<p>Let’s try adding the <code>main</code> function in Listing 15-7 to Listing 15-8 and
changing it to use the <code>MyBox&lt;T&gt;</code> type we’ve defined instead of <code>Box&lt;T&gt;</code>. The
code in Listing 15-9 won’t compile because Rust doesn’t know how to dereference
<code>MyBox</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
<p><span class="caption">Listing 15-9: Attempting to use <code>MyBox&lt;T&gt;</code> in the same
way we used references and <code>Box&lt;T&gt;</code></span></p>
<p>Here’s the resulting compilation error:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` due to previous error
</code></pre>
<p>Our <code>MyBox&lt;T&gt;</code> type can’t be dereferenced because we haven’t implemented that
ability on our type. To enable dereferencing with the <code>*</code> operator, we
implement the <code>Deref</code> trait.</p>
<h3 id="treating-a-type-like-a-reference-by-implementing-the-deref-trait"><a class="header" href="#treating-a-type-like-a-reference-by-implementing-the-deref-trait">Treating a Type Like a Reference by Implementing the <code>Deref</code> Trait</a></h3>
<p>As discussed in the <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">“Implementing a Trait on a Type”</a><!-- ignore
--> section of Chapter 10, to implement a trait, we need to provide
implementations for the trait’s required methods. The <code>Deref</code> trait, provided
by the standard library, requires us to implement one method named <code>deref</code> that
borrows <code>self</code> and returns a reference to the inner data. Listing 15-10
contains an implementation of <code>Deref</code> to add to the definition of <code>MyBox</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 15-10: Implementing <code>Deref</code> on <code>MyBox&lt;T&gt;</code></span></p>
<p>The <code>type Target = T;</code> syntax defines an associated type for the <code>Deref</code>
trait to use. Associated types are a slightly different way of declaring a
generic parameter, but you don’t need to worry about them for now; we’ll cover
them in more detail in Chapter 19.</p>
<p>We fill in the body of the <code>deref</code> method with <code>&amp;self.0</code> so <code>deref</code> returns a
reference to the value we want to access with the <code>*</code> operator; recall from the
<a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">“Using Tuple Structs without Named Fields to Create Different
Types”</a><!-- ignore --> section of Chapter 5 that <code>.0</code> accesses
the first value in a tuple struct. The <code>main</code> function in Listing 15-9 that
calls <code>*</code> on the <code>MyBox&lt;T&gt;</code> value now compiles, and the assertions pass!</p>
<p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&amp;</code> references.
The <code>deref</code> method gives the compiler the ability to take a value of any type
that implements <code>Deref</code> and call the <code>deref</code> method to get a <code>&amp;</code> reference that
it knows how to dereference.</p>
<p>When we entered <code>*y</code> in Listing 15-9, behind the scenes Rust actually ran this
code:</p>
<pre><code class="language-rust ignore">*(y.deref())
</code></pre>
<p>Rust substitutes the <code>*</code> operator with a call to the <code>deref</code> method and then a
plain dereference so we don’t have to think about whether or not we need to
call the <code>deref</code> method. This Rust feature lets us write code that functions
identically whether we have a regular reference or a type that implements
<code>Deref</code>.</p>
<p>The reason the <code>deref</code> method returns a reference to a value, and that the
plain dereference outside the parentheses in <code>*(y.deref())</code> is still necessary,
is to do with the ownership system. If the <code>deref</code> method returned the value
directly instead of a reference to the value, the value would be moved out of
<code>self</code>. We don’t want to take ownership of the inner value inside <code>MyBox&lt;T&gt;</code> in
this case or in most cases where we use the dereference operator.</p>
<p>Note that the <code>*</code> operator is replaced with a call to the <code>deref</code> method and
then a call to the <code>*</code> operator just once, each time we use a <code>*</code> in our code.
Because the substitution of the <code>*</code> operator does not recurse infinitely, we
end up with data of type <code>i32</code>, which matches the <code>5</code> in <code>assert_eq!</code> in
Listing 15-9.</p>
<h3 id="implicit-deref-coercions-with-functions-and-methods"><a class="header" href="#implicit-deref-coercions-with-functions-and-methods">Implicit Deref Coercions with Functions and Methods</a></h3>
<p><em>Deref coercion</em> converts a reference to a type that implements the <code>Deref</code>
trait into a reference to another type. For example, deref coercion can convert
<code>&amp;String</code> to <code>&amp;str</code> because <code>String</code> implements the <code>Deref</code> trait such that it
returns <code>&amp;str</code>. Deref conversion is a convenience Rust performs on arguments to
functions and methods, and works only on types that implement the <code>Deref</code>
trait. It happens automatically when we pass a reference to a particular type’s
value as an argument to a function or method that doesn’t match the parameter
type in the function or method definition. A sequence of calls to the <code>deref</code>
method converts the type we provided into the type the parameter needs.</p>
<p>Deref coercion was added to Rust so that programmers writing function and
method calls don’t need to add as many explicit references and dereferences
with <code>&amp;</code> and <code>*</code>. The deref coercion feature also lets us write more code that
can work for either references or smart pointers.</p>
<p>To see deref coercion in action, let’s use the <code>MyBox&lt;T&gt;</code> type we defined in
Listing 15-8 as well as the implementation of <code>Deref</code> that we added in Listing
15-10. Listing 15-11 shows the definition of a function that has a string slice
parameter:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn hello(name: &amp;str) {
    println!(&quot;Hello, {}!&quot;, name);
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 15-11: A <code>hello</code> function that has the parameter
<code>name</code> of type <code>&amp;str</code></span></p>
<p>We can call the <code>hello</code> function with a string slice as an argument, such as
<code>hello(&quot;Rust&quot;);</code> for example. Deref coercion makes it possible to call <code>hello</code>
with a reference to a value of type <code>MyBox&lt;String&gt;</code>, as shown in Listing 15-12:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hello, {}!&quot;, name);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;m);
}
</code></pre></pre>
<p><span class="caption">Listing 15-12: Calling <code>hello</code> with a reference to a
<code>MyBox&lt;String&gt;</code> value, which works because of deref coercion</span></p>
<p>Here we’re calling the <code>hello</code> function with the argument <code>&amp;m</code>, which is a
reference to a <code>MyBox&lt;String&gt;</code> value. Because we implemented the <code>Deref</code> trait
on <code>MyBox&lt;T&gt;</code> in Listing 15-10, Rust can turn <code>&amp;MyBox&lt;String&gt;</code> into <code>&amp;String</code>
by calling <code>deref</code>. The standard library provides an implementation of <code>Deref</code>
on <code>String</code> that returns a string slice, and this is in the API documentation
for <code>Deref</code>. Rust calls <code>deref</code> again to turn the <code>&amp;String</code> into <code>&amp;str</code>, which
matches the <code>hello</code> function’s definition.</p>
<p>If Rust didn’t implement deref coercion, we would have to write the code in
Listing 15-13 instead of the code in Listing 15-12 to call <code>hello</code> with a value
of type <code>&amp;MyBox&lt;String&gt;</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hello, {}!&quot;, name);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;(*m)[..]);
}
</code></pre></pre>
<p><span class="caption">Listing 15-13: The code we would have to write if Rust
didn’t have deref coercion</span></p>
<p>The <code>(*m)</code> dereferences the <code>MyBox&lt;String&gt;</code> into a <code>String</code>. Then the <code>&amp;</code> and
<code>[..]</code> take a string slice of the <code>String</code> that is equal to the whole string to
match the signature of <code>hello</code>. This code without deref coercions is harder to
read, write, and understand with all of these symbols involved. Deref coercion
allows Rust to handle these conversions for us automatically.</p>
<p>When the <code>Deref</code> trait is defined for the types involved, Rust will analyze the
types and use <code>Deref::deref</code> as many times as necessary to get a reference to
match the parameter’s type. The number of times that <code>Deref::deref</code> needs to be
inserted is resolved at compile time, so there is no runtime penalty for taking
advantage of deref coercion!</p>
<h3 id="how-deref-coercion-interacts-with-mutability"><a class="header" href="#how-deref-coercion-interacts-with-mutability">How Deref Coercion Interacts with Mutability</a></h3>
<p>Similar to how you use the <code>Deref</code> trait to override the <code>*</code> operator on
immutable references, you can use the <code>DerefMut</code> trait to override the <code>*</code>
operator on mutable references.</p>
<p>Rust does deref coercion when it finds types and trait implementations in three
cases:</p>
<ul>
<li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<p>The first two cases are the same as each other except that the second
implements mutability. The first case states that if you have a <code>&amp;T</code>, and <code>T</code>
implements <code>Deref</code> to some type <code>U</code>, you can get a <code>&amp;U</code> transparently. The
second case states that the same deref coercion happens for mutable references.</p>
<p>The third case is trickier: Rust will also coerce a mutable reference to an
immutable one. But the reverse is <em>not</em> possible: immutable references will
never coerce to mutable references. Because of the borrowing rules, if you have
a mutable reference, that mutable reference must be the only reference to that
data (otherwise, the program wouldn’t compile). Converting one mutable
reference to one immutable reference will never break the borrowing rules.
Converting an immutable reference to a mutable reference would require that the
initial immutable reference is the only immutable reference to that data, but
the borrowing rules don’t guarantee that. Therefore, Rust can’t make the
assumption that converting an immutable reference to a mutable reference is
possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="drop-tanımı-ile-temizleme-Üzerinde-kod-Çalıştırma"><a class="header" href="#drop-tanımı-ile-temizleme-Üzerinde-kod-Çalıştırma"><code>Drop</code> Tanımı ile Temizleme Üzerinde Kod Çalıştırma</a></h2>
<p>Akıllı işaretçi modeli için önemli olan ikinci tanım, bir değer kapsam dışına çıkmak üzereyken ne olacağını 
özelleştirmenize olanak tanıyan <code>Drop</code>'tur. Herhangi bir tür üzerinde <code>Drop</code> için bir sürekleme sağlayabilirsiniz 
ve bu kod, dosyalar veya ağ bağlantıları gibi kaynakları serbest bırakmak için kullanılabilir.
<code>Drop</code>'u akıllı işaretçiler bağlamında tanıtıyoruz çünkü <code>Drop</code>'un işlevselliği neredeyse her zaman bir akıllı 
işaretçi uygulanırken kullanılır. Örneğin, bir <code>Box&lt;T&gt;</code> bırakıldığında, yığın üzerinde kutunun işaret ettiği alan 
belleğe iade edilir.</p>
<p>Bazı dillerde, bazı türler için, programcı bu türlerin bir örneğini kullanmayı her bitirdiğinde belleği veya kaynakları 
boşaltmak için kod çağırmalıdır. Örnekler arasında dosya tutamaçları, soketler veya kilitler yer alır. Eğer 
unuturlarsa, sistem aşırı yüklenebilir ve çökebilir. Rust'ta, bir değer kapsam dışına çıktığında belirli bir 
kod parçasının çalıştırılmasını belirtebilirsiniz ve derleyici bu kodu otomatik olarak ekleyecektir. 
Sonuç olarak, belirli bir türün bir örneğinin bittiği bir programın her yerine temizleme kodu yerleştirme 
konusunda dikkatli olmanız gerekmez—yine de kaynak sızdırmazsınız!</p>
<p><code>Drop</code> tanımını sürekleyerek bir değer kapsam dışına çıktığında çalıştırılacak kodu belirlersiniz.
<code>Drop</code>, <code>self</code> öğesine değiştirilebilir bir referans alan <code>drop</code> adlı bir metodu tanımlamanızı gerektirir. 
Rust'ın <code>drop</code>'u ne zaman çağırdığını görmek için şimdilik <code>drop</code>'u <code>println!</code> ifade yapılarıyla kullanalım.</p>
<p>Liste 15-14, Rust'ın <code>drop</code> fonksiyonunu ne zaman çalıştırdığını göstermek için, örnek kapsam dışına çıktığında
<code>Dropping CustomSmartPointer!</code> yazdıracak olan tek gizli fonksiyonu olan bir <code>CustomSmartPointer</code> yapısını gösterir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;my stuff&quot;),
    };
    let d = CustomSmartPointer {
        data: String::from(&quot;other stuff&quot;),
    };
    println!(&quot;CustomSmartPointers created.&quot;);
}
</code></pre></pre>
<p><span class="caption">Liste 15-14: Temizleme kodumuzu koyacağımız <code>Drop</code>'u sürekleyen bir <code>CustomSmartPointer</code> yapısı</span></p>
<p><code>Drop</code> tanımı genel Rust yapısına dahil edilmiştir, bu nedenle onu kapsam içine almamıza gerek yoktur.
<code>CustomSmartPointer</code> üzerinde <code>Drop</code>'u sürekliyoruz ve <code>println!</code> çağrısı yapan <code>drop</code> metodu için bir tanımlama sağlıyoruz.
<code>Drop</code> fonksiyonunun gövdesi, türünüzün bir örneği kapsam dışına çıktığında çalıştırmak istediğiniz herhangi bir mantığı yerleştireceğiniz yerdir. 
Rust'ın <code>drop</code>'u ne zaman çağıracağını görsel olarak göstermek için burada bazı metinler yazdırıyoruz.</p>
<p><code>main</code>'de, iki <code>CustomSmartPointer</code> örneği oluşturuyoruz ve ardından oluşturulan <code>CustomSmartPointer</code>'ları yazdırıyoruz.
<code>main</code>'in sonunda, <code>CustomSmartPointer</code> örneklerimiz kapsam dışına çıkacak ve Rust, <code>drop</code>'a koyduğumuz kodu çağırarak son 
mesajımızı yazdıracak. <code>drop</code> metodunu açıkça çağırmamıza gerek olmadığına dikkat edin.</p>
<p>Bu programı çalıştırdığımızda aşağıdaki çıktıyı göreceğiz:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<p>Örneklerimiz kapsam dışına çıktığında Rust bizim için otomatik olarak <code>drop</code>'u çağırdı ve belirttiğimiz kodu çalıştırdı. 
Değişkenler oluşturulma sıralarının tersine bırakılır, bu nedenle <code>d</code>, <code>c</code>'den önce bırakılır. Bu örneğin amacı,
<code>drop</code> metodunun nasıl çalıştığına dair görsel bir kılavuz sunmaktır; genellikle bir yazdırma mesajı yerine türünüzün çalışması gereken 
temizleme kodunu belirtirsiniz.</p>
<h3 id="stdmemdrop-ile-bir-değeri-erken-bırakma"><a class="header" href="#stdmemdrop-ile-bir-değeri-erken-bırakma"><code>std::mem::drop</code> ile Bir Değeri Erken Bırakma</a></h3>
<p>Ne yazık ki, otomatik <code>drop</code> fonksiyonunu devre dışı bırakmak kolay değildir. <code>drop</code>'u devre dışı bırakmak genellikle gerekli değildir;
<code>Drop</code> tanımının tüm amacı bunun otomatik olarak halledilmesidir. Ancak bazen, bir değeri erkenden temizlemek isteyebilirsiniz. 
Buna bir örnek, kilitleri yöneten akıllı işaretçiler kullanırken verilebilir: kilidi serbest bırakan <code>drop</code> metodunu zorlamak isteyebilirsiniz, 
böylece aynı kapsamdaki diğer kodlar kilidi alabilir. Rust, <code>Drop</code>'un <code>drop</code> metodunu manuel olarak çağırmanıza izin vermez; 
bunun yerine, bir değeri kapsamının sonundan önce bırakılmaya zorlamak istiyorsanız standart kütüphane tarafından sağlanan
<code>std::mem::drop</code> işlevini çağırmanız gerekir.</p>
<p>Liste 15-15'te gösterildiği gibi, Liste 15-14'teki <code>main</code> fonksiyonunu değiştirerek <code>Drop</code>'un <code>drop</code> metodunu manuel olarak çağırmaya çalışırsak, 
bir derleyici hatası alırız:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;some data&quot;),
    };
    println!(&quot;CustomSmartPointer created.&quot;);
    c.drop();
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre>
<p><span class="caption">Liste 15-15: Erken temizlemek için <code>Drop</code> tanımından <code>drop</code> metodunu manuel olarak çağırma girişimi</span></p>
<p>Bu kodu derlemeye çalıştığımızda alacağımız hata budur:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |     --^^^^--
   |     | |
   |     | explicit destructor calls not allowed
   |     help: consider using `drop` function: `drop(c)`

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` due to previous error
</code></pre>
<p>Bu hata mesajı, <code>drop</code>'u açıkça çağırmamıza izin verilmediğini belirtir. Hata mesajı, bir örneği temizleyen bir 
fonksiyon için genel programlama terimi olan <em>yıkıcı</em> terimini kullanır. Bir yıkıcı, bir örnek oluşturan bir yapıcıya benzer. 
Rust'taki <code>drop</code> fonksiyonu belirli bir yıkıcıdır.</p>
<p>Rust, <code>drop</code>'u açıkça çağırmamıza izin vermez, çünkü Rust yine de <code>main</code>'in sonundaki değer üzerinde otomatik olarak <code>drop</code>'u çağıracaktır. 
Bu, Rust aynı değeri iki kez temizlemeye çalışacağı için <em>çift serbest bırakma hatasına</em> neden olur.</p>
<p>Bir değer kapsam dışına çıktığında <code>drop</code>'un otomatik olarak eklenmesini devre dışı bırakamayız ve <code>drop</code> metodunu açıkça çağıramayız. 
Bu nedenle, bir değeri erken temizlenmeye zorlamamız gerekiyorsa, <code>std::mem::drop</code> fonksiyonunu kullanırız.</p>
<p><code>std::mem::drop</code> fonksiyonu <code>Drop</code> tanımındaki <code>drop</code> metodundan farklıdır. Düşürmeye zorlamak istediğimiz değeri argüman olarak ileterek çağırırız. 
Fonksiyon genel Rust yapısındadır, bu nedenle Liste 15-15'teki <code>main</code>'i, Liste 15-16'da gösterildiği gibi <code>drop</code> fonksiyonunu çağıracak şekilde 
değiştirebiliriz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;some data&quot;),
    };
    println!(&quot;CustomSmartPointer created.&quot;);
    drop(c);
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre></pre>
<p><span class="caption">Liste 15-16: Bir değeri kapsam dışına çıkmadan önce açıkça bırakmak için <code>std::mem::drop</code> çağrısı</span></p>
<p>Bu kodu çalıştırmak aşağıdakileri yazdıracaktır:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<p><code>CustomSmartPointer</code> oluşturulduğu esnada <code>Dropping CustomSmartPointer with data (some data)!</code> metni yazdırılır ve 
<code>CustomSmartPointer dropped before the end of main.</code> metni, <code>drop</code> metod kodunun bu noktada <code>c</code>'yi bırakmak için çağrıldığını gösterir.</p>
<p><code>Drop</code> tanım süreklemesinde belirtilen kodu, temizlemeyi kolay ve güvenli hale getirmek için birçok şekilde kullanabilirsiniz: 
örneğin, kendi bellek ayırıcınızı oluşturmak için kullanabilirsiniz! <code>Drop</code> tanımı ve Rust'ın sahiplik sistemi sayesinde, 
temizlemeyi hatırlamak zorunda kalmazsınız çünkü Rust bunu otomatik olarak yapar.</p>
<p>Ayrıca, hala kullanımda olan değerlerin yanlışlıkla temizlenmesinden kaynaklanan sorunlar hakkında endişelenmenize de gerek yoktur: 
referansların her zaman geçerli olmasını sağlayan sahiplik sistemi, <code>drop</code>'un değer artık kullanılmadığında yalnızca bir kez çağrılmasını da sağlar.</p>
<p><code>Box&lt;T&gt;</code>'yi ve akıllı işaretçilerin bazı özelliklerini incelediğimize göre, şimdi standart kütüphanede tanımlanan diğer birkaç akıllı 
işaretçiye bakalım.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rct-referans-sayaçlı-akıllı-İşaretçi"><a class="header" href="#rct-referans-sayaçlı-akıllı-İşaretçi"><code>Rc&lt;T&gt;</code>, Referans Sayaçlı Akıllı İşaretçi</a></h2>
<p>Çoğu durumda, sahiplik açıktır: Belirli bir değere hangi değişkenin sahip olduğunu tam olarak bilirsiniz. 
Ancak, tek bir değerin birden çok sahibi olabileceği durumlar vardır. 
Örneğin, grafik veri yapılarında, birden çok kenar aynı düğüme işaret edebilir ve bu düğüm kavramsal olarak ona işaret 
eden tüm kenarlara aittir. Bir düğüm, kendisine işaret eden herhangi bir kenarı olmadığı ve dolayısıyla sahibi olmadığı sürece temizlenmemelidir.</p>
<p><em>Referans sayımının</em> kısaltması olan Rust türü <code>Rc&lt;T&gt;</code>'yi kullanarak birden çok sahipliği açıkça etkinleştirmeniz gerekir. 
<code>Rc&lt;T&gt;</code> türü, değerin hala kullanımda olup olmadığını belirlemek için bir değere yapılan başvuruların sayısını takip eder. 
Bir değere sıfır referans varsa, hiçbir referans geçersiz hale gelmeden değer temizlenebilir.</p>
<p><code>Rc&lt;T&gt;</code>'yi bir aile odasındaki bir TV olarak hayal edin. Bir kişi TV izlemek için girdiğinde onu açar. 
Diğerleri odaya gelip televizyon izleyebilir. Son kişi odadan ayrıldığında, artık kullanılmadığı için televizyonu kapatırlar. 
Biri televizyonu kapatırsa, diğerleri hala onu seyrediyorsa, kalan televizyon izleyicilerinden büyük bir kargaşa çıkar!</p>
<p><code>Rc&lt;T&gt;</code> türünü, programımızın birden fazla bölümünün okuması için yığın üzerinde bazı verileri tahsis etmek istediğimizde kullanırız ve 
derleme zamanında verileri en son hangi bölümün bitireceğini belirleyemeyiz. Hangi bölümün en son biteceğini bilseydik, 
o bölümü verinin sahibi yapabilirdik ve derleme zamanında uygulanan normal sahiplik kuralları yürürlüğe girecekti.</p>
<p><code>Rc&lt;T&gt;</code> öğesinin yalnızca tek iş parçacıklı senaryolarda kullanım için olduğunu unutmayın. 
Bölüm 16'da eşzamanlılığı tartıştığımızda, çok iş parçacıklı programlarda referans sayımının nasıl yapıldığını ele alacağız.</p>
<h3 id="veri-paylaşmak-için-rct-kullanmak"><a class="header" href="#veri-paylaşmak-için-rct-kullanmak">Veri Paylaşmak için <code>Rc&lt;T&gt;</code> Kullanmak</a></h3>
<p>Liste 15-5'teki liste örneğimize dönelim. <code>Box&lt;T&gt;</code> kullanarak tanımladığımızı hatırlayın. 
Bu sefer, her ikisi de üçüncü bir listenin sahipliğini paylaşan iki liste oluşturacağız. 
Kavramsal olarak, bu Şekil 15-3'e benziyor:</p>
<img alt="Üçüncü bir listenin sahipliğini paylaşan iki liste" src="img/trpl15-03.svg" class="center" />
<p><span class="caption">Şekil 15-3: İki liste, <code>b</code> ve <code>c</code>, 
üçüncü bir listenin sahipliğini paylaşan <code>a</code></span></p>
<p><code>5</code> ve ardından <code>10</code>'u içeren bir <code>a</code> listesi oluşturacağız.
Ardından, <code>3</code> ile başlayan <code>b</code> ve <code>4</code> ile başlayan <code>c</code> olmak üzere iki liste daha yapacağız. 
Daha sonra hem <code>b</code> hem de <code>c</code> listeleri, <code>5</code>'i ve <code>10</code>'u içeren ilk listeye devam edecek.
Başka bir deyişle, her iki liste de <code>5</code> ve <code>10</code>'u içeren ilk listeyi paylaşacaktır.</p>
<p>Liste 15-17'de gösterildiği gibi, <code>Box&lt;T&gt;</code>'li <code>List</code> tanımımızı kullanarak bu senaryoyu uygulamaya 
çalışmak işe yaramaz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<p><span class="caption">Liste 15-17: Üçüncü bir listenin sahipliğini paylaşmaya çalışan <code>Box&lt;T&gt;</code> kullanan iki listeye sahip 
olmamıza izin verilmediğini gösteriyor</span></p>
<p>Kodu derlediğimizde, şu hatayı alırız:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` due to previous error
</code></pre>
<p><code>Cons</code> varyantları, tuttukları verilere sahiptir, bu nedenle <code>b</code> listesini oluşturduğumuzda <code>a</code>, <code>b</code>'ye taşınır ve <code>b</code>, <code>a</code>'ya sahiptir. 
Ardından, <code>c</code>'yi oluştururken <code>a</code>'yı tekrar kullanmaya çalıştığımızda, <code>a</code> taşınmış olduğu için buna izin verilmiyor.</p>
<p>Bunun yerine referansları tutmak için <code>Cons</code>'un tanımını değiştirebilirdik, ancak daha sonra ömür boyu parametreleri belirtmemiz gerekecekti. 
Yaşam süresi parametreleri belirterek, listedeki her öğenin en az tüm liste kadar yaşayacağını belirtmiş oluruz. 
Bu, Liste 15-17'deki öğeler ve listeler için geçerlidir, ancak her senaryoda geçerli değildir.</p>
<p>Bunun yerine <code>List</code> tanımımızı, Liste 15-18'de gösterildiği gibi <code>Box&lt;T&gt;</code> yerine <code>Rc&lt;T&gt;</code> kullanacak şekilde değiştireceğiz. 
Her <code>Cons</code> varyantı artık bir değere ve bir Listeye işaret eden bir <code>Rc&lt;T&gt;</code>'ye sahip olacaktır. <code>b</code>'yi yarattığımızda, <code>a</code>'nın sahipliğini almak yerine, <code>a</code>'nın sahip olduğu <code>Rc&lt;List&gt;</code>'i klonlayacağız, böylece referans sayısını birden ikiye çıkaracağız ve <code>a</code> ve <code>b</code>'nin o 
<code>Rc&lt;List&gt;</code>'deki verilerin sahipliğini paylaşmasına izin vereceğiz. Ayrıca <code>c</code>'yi oluştururken <code>a</code>'yı klonlayarak referans sayısını 
ikiden üçe çıkaracağız. <code>Rc::clone</code>'u her çağırdığımızda, <code>Rc&lt;List&gt;</code> içindeki verilere referans sayısı artacak ve sıfır referans 
olmadıkça veriler temizlenmeyecektir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Liste 15-18: <code>Rc&lt;T&gt;</code> kullanan bir <code>List</code> tanımı</span></p>
<p><code>Rc&lt;T&gt;</code>'yi kapsam içine almak için bir <code>use</code> ifadesi eklememiz gerekiyor çünkü bu başlangıç kısmında değil. 
<code>main</code>'de, 5 ve 10'u tutan listeyi oluşturuyoruz ve onu <code>a</code>'da yeni bir <code>Rc&lt;List&gt;</code> içinde saklıyoruz. 
Daha sonra <code>b</code> ve <code>c</code>'yi oluşturduğumuzda, <code>Rc::clone</code> fonksiyonunu çağırırız ve argüman olarak <code>a</code>'daki <code>Rc&lt;List&gt;</code>'e bir referansını 
iletiriz.</p>
<p><code>Rc::clone(&amp;a)</code> yerine <code>a.clone()</code>'u çağırabilirdik, ancak Rust'ın kuralı bu durumda <code>Rc::clone</code> kullanmaktır. 
<code>Rc::clone</code>'un süreklenmesi, çoğu türde <code>clone</code> süreklemesinin yaptığı gibi tüm verilerin derin bir kopyasını oluşturmaz. 
<code>Rc::clone</code> çağrısı yalnızca referans sayısını artırır, bu da fazla zaman almaz. Verilerin derin kopyaları çok zaman alabilir. 
Referans sayımı için <code>Rc::clone</code> kullanarak, derin kopyalı klon türleri ile referans sayısını artıran klon türleri arasında görsel olarak ayrım yapabiliriz. Kodda performans sorunları ararken, yalnızca derin kopya klonlarını dikkate almamız gerekir ve <code>Rc::clone</code>'a yapılan çağrıları göz ardı edebiliriz.</p>
<h3 id="rctyi-klonlamak-referans-sayısını-artırır"><a class="header" href="#rctyi-klonlamak-referans-sayısını-artırır"><code>Rc&lt;T&gt;</code>'yi Klonlamak Referans Sayısını Artırır</a></h3>
<p>Liste 15-18'deki çalışma örneğimizi değiştirelim, böylece <code>a</code> içindeki <code>Rc&lt;List&gt;</code>e referansları oluşturup bıraktıkça 
referans sayılarının değiştiğini görebilelim.</p>
<p>Liste 15-19'da, <code>main</code>'i, <code>c</code> listesi etrafında bir iç kapsama sahip olacak şekilde değiştireceğiz; 
o zaman <code>c</code> kapsam dışına çıktığında referans sayısının nasıl değiştiğini görebiliriz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;count after creating a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;count after creating b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;count after creating c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;count after c goes out of scope = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Liste 15-19: Referans sayısının yazdırılması</span></p>
<p>Referans sayısının değiştiği programdaki her noktada, <code>Rc::strong_count</code> fonksiyonunu çağırarak elde ettiğimiz referans 
sayısını yazdırırız. Bu fonksiyon, <code>count</code> yerine <code>strong_count</code> olarak adlandırılır, 
çünkü <code>Rc&lt;T&gt;</code> türünde bir <code>weak_count</code> da vardır; <a href="ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt">“Referans Döngülerini Önleme: Bir <code>Rc&lt;T&gt;</code>'yi 
<code>Weak&lt;T&gt;</code>'ye Çevirme”</a><!-- ignore -->  bölümünde <code>weak_count</code>'ın ne için kullanıldığını göreceğiz.</p>
<p>Bu kod şunları yazdırır:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p><code>a</code> içindeki <code>Rc&lt;List&gt;</code> öğesinin ilk referans sayısının <code>1</code> olduğunu görebiliriz; sonra <code>clone</code>'u her çağırdığımızda, 
sayı 1 artar. <code>c</code> kapsam dışına çıktığında, sayı 1 azalır. <code>Rc</code>'yi çağırmamız gerektiği gibi referans sayısını azaltmak için 
bir fonksiyon çağırmamız gerekmez: referans sayısını artırmak için klonlayın: <code>Drop</code> tanımının süreklenmesi, 
bir <code>Rc&lt;T&gt;</code> değeri kapsam dışına çıktığında referans sayısını otomatik olarak azaltır.</p>
<p>Bu örnekte göremediğimiz şey, <code>main</code> sonunda <code>b</code> ve ardından <code>a</code> kapsam dışına çıktığında, sayının <code>0</code> olduğu ve <code>Rc&lt;List&gt;</code>'in tamamen temizlendiğidir.
<code>Rc&lt;T&gt;</code> kullanmak, tek bir değerin birden çok sahibine sahip olmasına izin verir ve sayı, 
sahiplerden herhangi biri var olduğu sürece değerin geçerli kalmasını sağlar.</p>
<p>Değişmez referanslar aracılığıyla, <code>Rc&lt;T&gt;</code>, programınızın birden çok bölümü arasında salt okuma için veri paylaşmanıza olanak tanır. 
Eğer <code>Rc&lt;T&gt;</code> birden çok değişken referansa sahip olmanıza da izin veriyorsa, Bölüm 4'te tartışılan ödünç alma kurallarından 
birini ihlal etmiş olabilirsiniz: aynı yere birden fazla değişken ödünç alma veri yarışlarına ve tutarsızlıklara neden olabilir.
Ancak verileri değiştirebilmek çok faydalıdır! Bir sonraki bölümde, bu değişmezlik kısıtlamasıyla çalışmak için bir <code>Rc&lt;T&gt;</code>
ile birlikte kullanabileceğiniz iç değişkenlik modelini ve <code>RefCell&lt;T&gt;</code> türünü tartışacağız.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refcellt-and-the-interior-mutability-pattern"><a class="header" href="#refcellt-and-the-interior-mutability-pattern"><code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</a></h2>
<p><em>Interior mutability</em> is a design pattern in Rust that allows you to mutate
data even when there are immutable references to that data; normally, this
action is disallowed by the borrowing rules. To mutate data, the pattern uses
<code>unsafe</code> code inside a data structure to bend Rust’s usual rules that govern
mutation and borrowing. We haven’t yet covered unsafe code that indicates we're
checking the rules manually instead of the compiler checking them for us; we
will discuss unsafe code more in Chapter 19. We can use types that use the
interior mutability pattern only when we can ensure that the borrowing rules
will be followed at runtime, even though the compiler can’t guarantee that. The
<code>unsafe</code> code involved is then wrapped in a safe API, and the outer type is
still immutable.</p>
<p>Let’s explore this concept by looking at the <code>RefCell&lt;T&gt;</code> type that follows the
interior mutability pattern.</p>
<h3 id="enforcing-borrowing-rules-at-runtime-with-refcellt"><a class="header" href="#enforcing-borrowing-rules-at-runtime-with-refcellt">Enforcing Borrowing Rules at Runtime with <code>RefCell&lt;T&gt;</code></a></h3>
<p>Unlike <code>Rc&lt;T&gt;</code>, the <code>RefCell&lt;T&gt;</code> type represents single ownership over the data
it holds. So, what makes <code>RefCell&lt;T&gt;</code> different from a type like <code>Box&lt;T&gt;</code>?
Recall the borrowing rules you learned in Chapter 4:</p>
<ul>
<li>At any given time, you can have <em>either</em> (but not both) one mutable reference
or any number of immutable references.</li>
<li>References must always be valid.</li>
</ul>
<p>With references and <code>Box&lt;T&gt;</code>, the borrowing rules’ invariants are enforced at
compile time. With <code>RefCell&lt;T&gt;</code>, these invariants are enforced <em>at runtime</em>.
With references, if you break these rules, you’ll get a compiler error. With
<code>RefCell&lt;T&gt;</code>, if you break these rules, your program will panic and exit.</p>
<p>The advantages of checking the borrowing rules at compile time are that errors
will be caught sooner in the development process, and there is no impact on
runtime performance because all the analysis is completed beforehand. For those
reasons, checking the borrowing rules at compile time is the best choice in the
majority of cases, which is why this is Rust’s default.</p>
<p>The advantage of checking the borrowing rules at runtime instead is that
certain memory-safe scenarios are then allowed, where they would’ve been
disallowed by the compile-time checks. Static analysis, like the Rust compiler,
is inherently conservative. Some properties of code are impossible to detect by
analyzing the code: the most famous example is the Halting Problem, which is
beyond the scope of this book but is an interesting topic to research.</p>
<p>Because some analysis is impossible, if the Rust compiler can’t be sure the
code complies with the ownership rules, it might reject a correct program; in
this way, it’s conservative. If Rust accepted an incorrect program, users
wouldn’t be able to trust in the guarantees Rust makes. However, if Rust
rejects a correct program, the programmer will be inconvenienced, but nothing
catastrophic can occur. The <code>RefCell&lt;T&gt;</code> type is useful when you’re sure your
code follows the borrowing rules but the compiler is unable to understand and
guarantee that.</p>
<p>Similar to <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> is only for use in single-threaded scenarios
and will give you a compile-time error if you try using it in a multithreaded
context. We’ll talk about how to get the functionality of <code>RefCell&lt;T&gt;</code> in a
multithreaded program in Chapter 16.</p>
<p>Here is a recap of the reasons to choose <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, or <code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> enables multiple owners of the same data; <code>Box&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>
have single owners.</li>
<li><code>Box&lt;T&gt;</code> allows immutable or mutable borrows checked at compile time; <code>Rc&lt;T&gt;</code>
allows only immutable borrows checked at compile time; <code>RefCell&lt;T&gt;</code> allows
immutable or mutable borrows checked at runtime.</li>
<li>Because <code>RefCell&lt;T&gt;</code> allows mutable borrows checked at runtime, you can
mutate the value inside the <code>RefCell&lt;T&gt;</code> even when the <code>RefCell&lt;T&gt;</code> is
immutable.</li>
</ul>
<p>Mutating the value inside an immutable value is the <em>interior mutability</em>
pattern. Let’s look at a situation in which interior mutability is useful and
examine how it’s possible.</p>
<h3 id="interior-mutability-a-mutable-borrow-to-an-immutable-value"><a class="header" href="#interior-mutability-a-mutable-borrow-to-an-immutable-value">Interior Mutability: A Mutable Borrow to an Immutable Value</a></h3>
<p>A consequence of the borrowing rules is that when you have an immutable value,
you can’t borrow it mutably. For example, this code won’t compile:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre>
<p>If you tried to compile this code, you’d get the following error:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
2 |     let x = 5;
  |         - help: consider changing this to be mutable: `mut x`
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` due to previous error
</code></pre>
<p>However, there are situations in which it would be useful for a value to mutate
itself in its methods but appear immutable to other code. Code outside the
value’s methods would not be able to mutate the value. Using <code>RefCell&lt;T&gt;</code> is
one way to get the ability to have interior mutability, but <code>RefCell&lt;T&gt;</code>
doesn’t get around the borrowing rules completely: the borrow checker in the
compiler allows this interior mutability, and the borrowing rules are checked
at runtime instead. If you violate the rules, you’ll get a <code>panic!</code> instead of
a compiler error.</p>
<p>Let’s work through a practical example where we can use <code>RefCell&lt;T&gt;</code> to mutate
an immutable value and see why that is useful.</p>
<h4 id="a-use-case-for-interior-mutability-mock-objects"><a class="header" href="#a-use-case-for-interior-mutability-mock-objects">A Use Case for Interior Mutability: Mock Objects</a></h4>
<p>Sometimes during testing a programmer will use a type in place of another type,
in order to observe particular behavior and assert it's implemented correctly.
This placeholder type is called a <em>test double</em>. Think of it in the sense of a
&quot;stunt double&quot; in filmmaking, where a person steps in and substitutes for an
actor to do a particular tricky scene. Test doubles stand in for other types
when we're running tests. <em>Mock objects</em> are specific types of test doubles
that record what happens during a test so you can assert that the correct
actions took place.</p>
<p>Rust doesn’t have objects in the same sense as other languages have objects,
and Rust doesn’t have mock object functionality built into the standard library
as some other languages do. However, you can definitely create a struct that
will serve the same purposes as a mock object.</p>
<p>Here’s the scenario we’ll test: we’ll create a library that tracks a value
against a maximum value and sends messages based on how close to the maximum
value the current value is. This library could be used to keep track of a
user’s quota for the number of API calls they’re allowed to make, for example.</p>
<p>Our library will only provide the functionality of tracking how close to the
maximum a value is and what the messages should be at what times. Applications
that use our library will be expected to provide the mechanism for sending the
messages: the application could put a message in the application, send an
email, send a text message, or something else. The library doesn’t need to know
that detail. All it needs is something that implements a trait we’ll provide
called <code>Messenger</code>. Listing 15-20 shows the library code:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send(&quot;Error: You are over your quota!&quot;);
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
        }
    }
}
</code></pre>
<p><span class="caption">Listing 15-20: A library to keep track of how close a
value is to a maximum value and warn when the value is at certain levels</span></p>
<p>One important part of this code is that the <code>Messenger</code> trait has one method
called <code>send</code> that takes an immutable reference to <code>self</code> and the text of the
message. This trait is the interface our mock object needs to implement so that
the mock can be used in the same way a real object is. The other important part
is that we want to test the behavior of the <code>set_value</code> method on the
<code>LimitTracker</code>. We can change what we pass in for the <code>value</code> parameter, but
<code>set_value</code> doesn’t return anything for us to make assertions on. We want to be
able to say that if we create a <code>LimitTracker</code> with something that implements
the <code>Messenger</code> trait and a particular value for <code>max</code>, when we pass different
numbers for <code>value</code>, the messenger is told to send the appropriate messages.</p>
<p>We need a mock object that, instead of sending an email or text message when we
call <code>send</code>, will only keep track of the messages it’s told to send. We can
create a new instance of the mock object, create a <code>LimitTracker</code> that uses the
mock object, call the <code>set_value</code> method on <code>LimitTracker</code>, and then check that
the mock object has the messages we expect. Listing 15-21 shows an attempt to
implement a mock object to do just that, but the borrow checker won’t allow it:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
</code></pre>
<p><span class="caption">Listing 15-21: An attempt to implement a <code>MockMessenger</code>
that isn’t allowed by the borrow checker</span></p>
<p>This test code defines a <code>MockMessenger</code> struct that has a <code>sent_messages</code>
field with a <code>Vec</code> of <code>String</code> values to keep track of the messages it’s told
to send. We also define an associated function <code>new</code> to make it convenient to
create new <code>MockMessenger</code> values that start with an empty list of messages. We
then implement the <code>Messenger</code> trait for <code>MockMessenger</code> so we can give a
<code>MockMessenger</code> to a <code>LimitTracker</code>. In the definition of the <code>send</code> method, we
take the message passed in as a parameter and store it in the <code>MockMessenger</code>
list of <code>sent_messages</code>.</p>
<p>In the test, we’re testing what happens when the <code>LimitTracker</code> is told to set
<code>value</code> to something that is more than 75 percent of the <code>max</code> value. First, we
create a new <code>MockMessenger</code>, which will start with an empty list of messages.
Then we create a new <code>LimitTracker</code> and give it a reference to the new
<code>MockMessenger</code> and a <code>max</code> value of 100. We call the <code>set_value</code> method on the
<code>LimitTracker</code> with a value of 80, which is more than 75 percent of 100. Then
we assert that the list of messages that the <code>MockMessenger</code> is keeping track
of should now have one message in it.</p>
<p>However, there’s one problem with this test, as shown here:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
2  |     fn send(&amp;self, msg: &amp;str);
   |             ----- help: consider changing that to be a mutable reference: `&amp;mut self`
...
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` due to previous error
warning: build failed, waiting for other jobs to finish...
error: build failed
</code></pre>
<p>We can’t modify the <code>MockMessenger</code> to keep track of the messages, because the
<code>send</code> method takes an immutable reference to <code>self</code>. We also can’t take the
suggestion from the error text to use <code>&amp;mut self</code> instead, because then the
signature of <code>send</code> wouldn’t match the signature in the <code>Messenger</code> trait
definition (feel free to try and see what error message you get).</p>
<p>This is a situation in which interior mutability can help! We’ll store the
<code>sent_messages</code> within a <code>RefCell&lt;T&gt;</code>, and then the <code>send</code> method will be
able to modify <code>sent_messages</code> to store the messages we’ve seen. Listing 15-22
shows what that looks like:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
</code></pre>
<p><span class="caption">Listing 15-22: Using <code>RefCell&lt;T&gt;</code> to mutate an inner
value while the outer value is considered immutable</span></p>
<p>The <code>sent_messages</code> field is now of type <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> instead of
<code>Vec&lt;String&gt;</code>. In the <code>new</code> function, we create a new <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>
instance around the empty vector.</p>
<p>For the implementation of the <code>send</code> method, the first parameter is still an
immutable borrow of <code>self</code>, which matches the trait definition. We call
<code>borrow_mut</code> on the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> in <code>self.sent_messages</code> to get a
mutable reference to the value inside the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, which is the
vector. Then we can call <code>push</code> on the mutable reference to the vector to keep
track of the messages sent during the test.</p>
<p>The last change we have to make is in the assertion: to see how many items are
in the inner vector, we call <code>borrow</code> on the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> to get an
immutable reference to the vector.</p>
<p>Now that you’ve seen how to use <code>RefCell&lt;T&gt;</code>, let’s dig into how it works!</p>
<h4 id="keeping-track-of-borrows-at-runtime-with-refcellt"><a class="header" href="#keeping-track-of-borrows-at-runtime-with-refcellt">Keeping Track of Borrows at Runtime with <code>RefCell&lt;T&gt;</code></a></h4>
<p>When creating immutable and mutable references, we use the <code>&amp;</code> and <code>&amp;mut</code>
syntax, respectively. With <code>RefCell&lt;T&gt;</code>, we use the <code>borrow</code> and <code>borrow_mut</code>
methods, which are part of the safe API that belongs to <code>RefCell&lt;T&gt;</code>. The
<code>borrow</code> method returns the smart pointer type <code>Ref&lt;T&gt;</code>, and <code>borrow_mut</code>
returns the smart pointer type <code>RefMut&lt;T&gt;</code>. Both types implement <code>Deref</code>, so we
can treat them like regular references.</p>
<p>The <code>RefCell&lt;T&gt;</code> keeps track of how many <code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code> smart
pointers are currently active. Every time we call <code>borrow</code>, the <code>RefCell&lt;T&gt;</code>
increases its count of how many immutable borrows are active. When a <code>Ref&lt;T&gt;</code>
value goes out of scope, the count of immutable borrows goes down by one. Just
like the compile-time borrowing rules, <code>RefCell&lt;T&gt;</code> lets us have many immutable
borrows or one mutable borrow at any point in time.</p>
<p>If we try to violate these rules, rather than getting a compiler error as we
would with references, the implementation of <code>RefCell&lt;T&gt;</code> will panic at
runtime. Listing 15-23 shows a modification of the implementation of <code>send</code> in
Listing 15-22. We’re deliberately trying to create two mutable borrows active
for the same scope to illustrate that <code>RefCell&lt;T&gt;</code> prevents us from doing this
at runtime.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 15-23: Creating two mutable references in the
same scope to see that <code>RefCell&lt;T&gt;</code> will panic</span></p>
<p>We create a variable <code>one_borrow</code> for the <code>RefMut&lt;T&gt;</code> smart pointer returned
from <code>borrow_mut</code>. Then we create another mutable borrow in the same way in the
variable <code>two_borrow</code>. This makes two mutable references in the same scope,
which isn’t allowed. When we run the tests for our library, the code in Listing
15-23 will compile without any errors, but the test will fail:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'main' panicked at 'already borrowed: BorrowMutError', src/lib.rs:60:53
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Notice that the code panicked with the message <code>already borrowed: BorrowMutError</code>. This is how <code>RefCell&lt;T&gt;</code> handles violations of the borrowing
rules at runtime.</p>
<p>Choosing to catch borrowing errors at runtime rather than compile time, as
we've done here, means you'd potentially be finding mistakes in your code later
in the development process: possibly not until your code was deployed to
production. Also, your code would incur a small runtime performance penalty as
a result of keeping track of the borrows at runtime rather than compile time.
However, using <code>RefCell&lt;T&gt;</code> makes it possible to write a mock object that can
modify itself to keep track of the messages it has seen while you’re using it
in a context where only immutable values are allowed. You can use <code>RefCell&lt;T&gt;</code>
despite its trade-offs to get more functionality than regular references
provide.</p>
<h3 id="having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt"><a class="header" href="#having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt">Having Multiple Owners of Mutable Data by Combining <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code></a></h3>
<p>A common way to use <code>RefCell&lt;T&gt;</code> is in combination with <code>Rc&lt;T&gt;</code>. Recall that
<code>Rc&lt;T&gt;</code> lets you have multiple owners of some data, but it only gives immutable
access to that data. If you have an <code>Rc&lt;T&gt;</code> that holds a <code>RefCell&lt;T&gt;</code>, you can
get a value that can have multiple owners <em>and</em> that you can mutate!</p>
<p>For example, recall the cons list example in Listing 15-18 where we used
<code>Rc&lt;T&gt;</code> to allow multiple lists to share ownership of another list. Because
<code>Rc&lt;T&gt;</code> holds only immutable values, we can’t change any of the values in the
list once we’ve created them. Let’s add in <code>RefCell&lt;T&gt;</code> to gain the ability to
change the values in the lists. Listing 15-24 shows that by using a
<code>RefCell&lt;T&gt;</code> in the <code>Cons</code> definition, we can modify the value stored in all
the lists:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {:?}&quot;, a);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}
</code></pre></pre>
<p><span class="caption">Listing 15-24: Using <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> to create a
<code>List</code> that we can mutate</span></p>
<p>We create a value that is an instance of <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> and store it in a
variable named <code>value</code> so we can access it directly later. Then we create a
<code>List</code> in <code>a</code> with a <code>Cons</code> variant that holds <code>value</code>. We need to clone
<code>value</code> so both <code>a</code> and <code>value</code> have ownership of the inner <code>5</code> value rather
than transferring ownership from <code>value</code> to <code>a</code> or having <code>a</code> borrow from
<code>value</code>.</p>
<p>We wrap the list <code>a</code> in an <code>Rc&lt;T&gt;</code> so when we create lists <code>b</code> and <code>c</code>, they
can both refer to <code>a</code>, which is what we did in Listing 15-18.</p>
<p>After we’ve created the lists in <code>a</code>, <code>b</code>, and <code>c</code>, we want to add 10 to the
value in <code>value</code>. We do this by calling <code>borrow_mut</code> on <code>value</code>, which uses the
automatic dereferencing feature we discussed in Chapter 5 (see the section
<a href="ch05-03-method-syntax.html#wheres-the---operator">“Where’s the <code>-&gt;</code> Operator?”</a><!-- ignore -->) to
dereference the <code>Rc&lt;T&gt;</code> to the inner <code>RefCell&lt;T&gt;</code> value. The <code>borrow_mut</code>
method returns a <code>RefMut&lt;T&gt;</code> smart pointer, and we use the dereference operator
on it and change the inner value.</p>
<p>When we print <code>a</code>, <code>b</code>, and <code>c</code>, we can see that they all have the modified
value of 15 rather than 5:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>This technique is pretty neat! By using <code>RefCell&lt;T&gt;</code>, we have an outwardly
immutable <code>List</code> value. But we can use the methods on <code>RefCell&lt;T&gt;</code> that provide
access to its interior mutability so we can modify our data when we need to.
The runtime checks of the borrowing rules protect us from data races, and it’s
sometimes worth trading a bit of speed for this flexibility in our data
structures.</p>
<p>The standard library has other types that provide interior mutability, such as
<code>Cell&lt;T&gt;</code>, which is similar except that instead of giving references to the
inner value, the value is copied in and out of the <code>Cell&lt;T&gt;</code>. There’s also
<code>Mutex&lt;T&gt;</code>, which offers interior mutability that’s safe to use across threads;
we’ll discuss its use in Chapter 16. Check out the standard library docs for
more details on the differences between these types.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="reference-cycles-can-leak-memory"><a class="header" href="#reference-cycles-can-leak-memory">Reference Cycles Can Leak Memory</a></h2>
<p>Rust’s memory safety guarantees make it difficult, but not impossible, to
accidentally create memory that is never cleaned up (known as a <em>memory leak</em>).
Preventing memory leaks entirely is not one of Rust’s guarantees, meaning
memory leaks are memory safe in Rust. We can see that Rust allows memory leaks
by using <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>: it’s possible to create references where
items refer to each other in a cycle. This creates memory leaks because the
reference count of each item in the cycle will never reach 0, and the values
will never be dropped.</p>
<h3 id="creating-a-reference-cycle"><a class="header" href="#creating-a-reference-cycle">Creating a Reference Cycle</a></h3>
<p>Let’s look at how a reference cycle might happen and how to prevent it,
starting with the definition of the <code>List</code> enum and a <code>tail</code> method in Listing
15-25:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}
</code></pre></pre>
<p><span class="caption">Listing 15-25: A cons list definition that holds a
<code>RefCell&lt;T&gt;</code> so we can modify what a <code>Cons</code> variant is referring to</span></p>
<p>We’re using another variation of the <code>List</code> definition from Listing 15-5. The
second element in the <code>Cons</code> variant is now <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, meaning that
instead of having the ability to modify the <code>i32</code> value as we did in Listing
15-24, we want to modify the <code>List</code> value a <code>Cons</code> variant is pointing to.
We’re also adding a <code>tail</code> method to make it convenient for us to access the
second item if we have a <code>Cons</code> variant.</p>
<p>In Listing 15-26, we’re adding a <code>main</code> function that uses the definitions in
Listing 15-25. This code creates a list in <code>a</code> and a list in <code>b</code> that points to
the list in <code>a</code>. Then it modifies the list in <code>a</code> to point to <code>b</code>, creating a
reference cycle. There are <code>println!</code> statements along the way to show what the
reference counts are at various points in this process.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a next item = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b next item = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!(&quot;a next item = {:?}&quot;, a.tail());
}
</code></pre></pre>
<p><span class="caption">Listing 15-26: Creating a reference cycle of two <code>List</code>
values pointing to each other</span></p>
<p>We create an <code>Rc&lt;List&gt;</code> instance holding a <code>List</code> value in the variable <code>a</code>
with an initial list of <code>5, Nil</code>. We then create an <code>Rc&lt;List&gt;</code> instance holding
another <code>List</code> value in the variable <code>b</code> that contains the value 10 and points
to the list in <code>a</code>.</p>
<p>We modify <code>a</code> so it points to <code>b</code> instead of <code>Nil</code>, creating a cycle. We do
that by using the <code>tail</code> method to get a reference to the <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>
in <code>a</code>, which we put in the variable <code>link</code>. Then we use the <code>borrow_mut</code>
method on the <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> to change the value inside from an <code>Rc&lt;List&gt;</code>
that holds a <code>Nil</code> value to the <code>Rc&lt;List&gt;</code> in <code>b</code>.</p>
<p>When we run this code, keeping the last <code>println!</code> commented out for the
moment, we’ll get this output:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p>The reference count of the <code>Rc&lt;List&gt;</code> instances in both <code>a</code> and <code>b</code> are 2 after
we change the list in <code>a</code> to point to <code>b</code>. At the end of <code>main</code>, Rust drops the
variable <code>b</code>, which decreases the reference count of the <code>Rc&lt;List&gt;</code> instance
from 2 to 1. The memory that <code>Rc&lt;List&gt;</code> has on the heap won’t be dropped at
this point, because its reference count is 1, not 0. Then Rust drops <code>a</code>, which
decreases the reference count of the <code>a</code> <code>Rc&lt;List&gt;</code> instance from 2 to 1 as
well. This instance’s memory can’t be dropped either, because the other
<code>Rc&lt;List&gt;</code> instance still refers to it. The memory allocated to the list will
remain uncollected forever. To visualize this reference cycle, we’ve created a
diagram in Figure 15-4.</p>
<img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" />
<p><span class="caption">Figure 15-4: A reference cycle of lists <code>a</code> and <code>b</code>
pointing to each other</span></p>
<p>If you uncomment the last <code>println!</code> and run the program, Rust will try to
print this cycle with <code>a</code> pointing to <code>b</code> pointing to <code>a</code> and so forth until it
overflows the stack.</p>
<p>Compared to a real-world program, the consequences creating a reference cycle
in this example aren’t very dire: right after we create the reference cycle,
the program ends. However, if a more complex program allocated lots of memory
in a cycle and held onto it for a long time, the program would use more memory
than it needed and might overwhelm the system, causing it to run out of
available memory.</p>
<p>Creating reference cycles is not easily done, but it’s not impossible either.
If you have <code>RefCell&lt;T&gt;</code> values that contain <code>Rc&lt;T&gt;</code> values or similar nested
combinations of types with interior mutability and reference counting, you must
ensure that you don’t create cycles; you can’t rely on Rust to catch them.
Creating a reference cycle would be a logic bug in your program that you should
use automated tests, code reviews, and other software development practices to
minimize.</p>
<p>Another solution for avoiding reference cycles is reorganizing your data
structures so that some references express ownership and some references don’t.
As a result, you can have cycles made up of some ownership relationships and
some non-ownership relationships, and only the ownership relationships affect
whether or not a value can be dropped. In Listing 15-25, we always want <code>Cons</code>
variants to own their list, so reorganizing the data structure isn’t possible.
Let’s look at an example using graphs made up of parent nodes and child nodes
to see when non-ownership relationships are an appropriate way to prevent
reference cycles.</p>
<h3 id="preventing-reference-cycles-turning-an-rct-into-a-weakt"><a class="header" href="#preventing-reference-cycles-turning-an-rct-into-a-weakt">Preventing Reference Cycles: Turning an <code>Rc&lt;T&gt;</code> into a <code>Weak&lt;T&gt;</code></a></h3>
<p>So far, we’ve demonstrated that calling <code>Rc::clone</code> increases the
<code>strong_count</code> of an <code>Rc&lt;T&gt;</code> instance, and an <code>Rc&lt;T&gt;</code> instance is only cleaned
up if its <code>strong_count</code> is 0. You can also create a <em>weak reference</em> to the
value within an <code>Rc&lt;T&gt;</code> instance by calling <code>Rc::downgrade</code> and passing a
reference to the <code>Rc&lt;T&gt;</code>. Strong references are how you can share ownership of
an <code>Rc&lt;T&gt;</code> instance. Weak references don’t express an ownership relationship,
and their count doesn't affect when an <code>Rc&lt;T&gt;</code> instance is cleaned up. They
won’t cause a reference cycle because any cycle involving some weak references
will be broken once the strong reference count of values involved is 0.</p>
<p>When you call <code>Rc::downgrade</code>, you get a smart pointer of type <code>Weak&lt;T&gt;</code>.
Instead of increasing the <code>strong_count</code> in the <code>Rc&lt;T&gt;</code> instance by 1, calling
<code>Rc::downgrade</code> increases the <code>weak_count</code> by 1. The <code>Rc&lt;T&gt;</code> type uses
<code>weak_count</code> to keep track of how many <code>Weak&lt;T&gt;</code> references exist, similar to
<code>strong_count</code>. The difference is the <code>weak_count</code> doesn’t need to be 0 for the
<code>Rc&lt;T&gt;</code> instance to be cleaned up.</p>
<p>Because the value that <code>Weak&lt;T&gt;</code> references might have been dropped, to do
anything with the value that a <code>Weak&lt;T&gt;</code> is pointing to, you must make sure the
value still exists. Do this by calling the <code>upgrade</code> method on a <code>Weak&lt;T&gt;</code>
instance, which will return an <code>Option&lt;Rc&lt;T&gt;&gt;</code>. You’ll get a result of <code>Some</code>
if the <code>Rc&lt;T&gt;</code> value has not been dropped yet and a result of <code>None</code> if the
<code>Rc&lt;T&gt;</code> value has been dropped. Because <code>upgrade</code> returns an <code>Option&lt;Rc&lt;T&gt;&gt;</code>,
Rust will ensure that the <code>Some</code> case and the <code>None</code> case are handled, and
there won’t be an invalid pointer.</p>
<p>As an example, rather than using a list whose items know only about the next
item, we’ll create a tree whose items know about their children items <em>and</em>
their parent items.</p>
<h4 id="creating-a-tree-data-structure-a-node-with-child-nodes"><a class="header" href="#creating-a-tree-data-structure-a-node-with-child-nodes">Creating a Tree Data Structure: a <code>Node</code> with Child Nodes</a></h4>
<p>To start, we’ll build a tree with nodes that know about their child nodes.
We’ll create a struct named <code>Node</code> that holds its own <code>i32</code> value as well as
references to its children <code>Node</code> values:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}
</span></code></pre></pre>
<p>We want a <code>Node</code> to own its children, and we want to share that ownership with
variables so we can access each <code>Node</code> in the tree directly. To do this, we
define the <code>Vec&lt;T&gt;</code> items to be values of type <code>Rc&lt;Node&gt;</code>. We also want to
modify which nodes are children of another node, so we have a <code>RefCell&lt;T&gt;</code> in
<code>children</code> around the <code>Vec&lt;Rc&lt;Node&gt;&gt;</code>.</p>
<p>Next, we’ll use our struct definition and create one <code>Node</code> instance named
<code>leaf</code> with the value 3 and no children, and another instance named <code>branch</code>
with the value 5 and <code>leaf</code> as one of its children, as shown in Listing 15-27:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}
</code></pre></pre>
<p><span class="caption">Listing 15-27: Creating a <code>leaf</code> node with no children
and a <code>branch</code> node with <code>leaf</code> as one of its children</span></p>
<p>We clone the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> and store that in <code>branch</code>, meaning the
<code>Node</code> in <code>leaf</code> now has two owners: <code>leaf</code> and <code>branch</code>. We can get from
<code>branch</code> to <code>leaf</code> through <code>branch.children</code>, but there’s no way to get from
<code>leaf</code> to <code>branch</code>. The reason is that <code>leaf</code> has no reference to <code>branch</code> and
doesn’t know they’re related. We want <code>leaf</code> to know that <code>branch</code> is its
parent. We’ll do that next.</p>
<h4 id="adding-a-reference-from-a-child-to-its-parent"><a class="header" href="#adding-a-reference-from-a-child-to-its-parent">Adding a Reference from a Child to Its Parent</a></h4>
<p>To make the child node aware of its parent, we need to add a <code>parent</code> field to
our <code>Node</code> struct definition. The trouble is in deciding what the type of
<code>parent</code> should be. We know it can’t contain an <code>Rc&lt;T&gt;</code>, because that would
create a reference cycle with <code>leaf.parent</code> pointing to <code>branch</code> and
<code>branch.children</code> pointing to <code>leaf</code>, which would cause their <code>strong_count</code>
values to never be 0.</p>
<p>Thinking about the relationships another way, a parent node should own its
children: if a parent node is dropped, its child nodes should be dropped as
well. However, a child should not own its parent: if we drop a child node, the
parent should still exist. This is a case for weak references!</p>
<p>So instead of <code>Rc&lt;T&gt;</code>, we’ll make the type of <code>parent</code> use <code>Weak&lt;T&gt;</code>,
specifically a <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Now our <code>Node</code> struct definition looks
like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
</span><span class="boring">}
</span></code></pre></pre>
<p>A node will be able to refer to its parent node but doesn’t own its parent.
In Listing 15-28, we update <code>main</code> to use this new definition so the <code>leaf</code>
node will have a way to refer to its parent, <code>branch</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}
</code></pre></pre>
<p><span class="caption">Listing 15-28: A <code>leaf</code> node with a weak reference to its
parent node <code>branch</code></span></p>
<p>Creating the <code>leaf</code> node looks similar to Listing 15-27 with the exception of
the <code>parent</code> field: <code>leaf</code> starts out without a parent, so we create a new,
empty <code>Weak&lt;Node&gt;</code> reference instance.</p>
<p>At this point, when we try to get a reference to the parent of <code>leaf</code> by using
the <code>upgrade</code> method, we get a <code>None</code> value. We see this in the output from the
first <code>println!</code> statement:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>When we create the <code>branch</code> node, it will also have a new <code>Weak&lt;Node&gt;</code>
reference in the <code>parent</code> field, because <code>branch</code> doesn’t have a parent node.
We still have <code>leaf</code> as one of the children of <code>branch</code>. Once we have the
<code>Node</code> instance in <code>branch</code>, we can modify <code>leaf</code> to give it a <code>Weak&lt;Node&gt;</code>
reference to its parent. We use the <code>borrow_mut</code> method on the
<code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> in the <code>parent</code> field of <code>leaf</code>, and then we use the
<code>Rc::downgrade</code> function to create a <code>Weak&lt;Node&gt;</code> reference to <code>branch</code> from
the <code>Rc&lt;Node&gt;</code> in <code>branch.</code></p>
<p>When we print the parent of <code>leaf</code> again, this time we’ll get a <code>Some</code> variant
holding <code>branch</code>: now <code>leaf</code> can access its parent! When we print <code>leaf</code>, we
also avoid the cycle that eventually ended in a stack overflow like we had in
Listing 15-26; the <code>Weak&lt;Node&gt;</code> references are printed as <code>(Weak)</code>:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>The lack of infinite output indicates that this code didn’t create a reference
cycle. We can also tell this by looking at the values we get from calling
<code>Rc::strong_count</code> and <code>Rc::weak_count</code>.</p>
<h4 id="visualizing-changes-to-strong_count-and-weak_count"><a class="header" href="#visualizing-changes-to-strong_count-and-weak_count">Visualizing Changes to <code>strong_count</code> and <code>weak_count</code></a></h4>
<p>Let’s look at how the <code>strong_count</code> and <code>weak_count</code> values of the <code>Rc&lt;Node&gt;</code>
instances change by creating a new inner scope and moving the creation of
<code>branch</code> into that scope. By doing so, we can see what happens when <code>branch</code> is
created and then dropped when it goes out of scope. The modifications are shown
in Listing 15-29:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}
</code></pre></pre>
<p><span class="caption">Listing 15-29: Creating <code>branch</code> in an inner scope and
examining strong and weak reference counts</span></p>
<p>After <code>leaf</code> is created, its <code>Rc&lt;Node&gt;</code> has a strong count of 1 and a weak
count of 0. In the inner scope, we create <code>branch</code> and associate it with
<code>leaf</code>, at which point when we print the counts, the <code>Rc&lt;Node&gt;</code> in <code>branch</code>
will have a strong count of 1 and a weak count of 1 (for <code>leaf.parent</code> pointing
to <code>branch</code> with a <code>Weak&lt;Node&gt;</code>). When we print the counts in <code>leaf</code>, we’ll see
it will have a strong count of 2, because <code>branch</code> now has a clone of the
<code>Rc&lt;Node&gt;</code> of <code>leaf</code> stored in <code>branch.children</code>, but will still have a weak
count of 0.</p>
<p>When the inner scope ends, <code>branch</code> goes out of scope and the strong count of
the <code>Rc&lt;Node&gt;</code> decreases to 0, so its <code>Node</code> is dropped. The weak count of 1
from <code>leaf.parent</code> has no bearing on whether or not <code>Node</code> is dropped, so we
don’t get any memory leaks!</p>
<p>If we try to access the parent of <code>leaf</code> after the end of the scope, we’ll get
<code>None</code> again. At the end of the program, the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> has a strong
count of 1 and a weak count of 0, because the variable <code>leaf</code> is now the only
reference to the <code>Rc&lt;Node&gt;</code> again.</p>
<p>All of the logic that manages the counts and value dropping is built into
<code>Rc&lt;T&gt;</code> and <code>Weak&lt;T&gt;</code> and their implementations of the <code>Drop</code> trait. By
specifying that the relationship from a child to its parent should be a
<code>Weak&lt;T&gt;</code> reference in the definition of <code>Node</code>, you’re able to have parent
nodes point to child nodes and vice versa without creating a reference cycle
and memory leaks.</p>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>This chapter covered how to use smart pointers to make different guarantees and
trade-offs from those Rust makes by default with regular references. The
<code>Box&lt;T&gt;</code> type has a known size and points to data allocated on the heap. The
<code>Rc&lt;T&gt;</code> type keeps track of the number of references to data on the heap so
that data can have multiple owners. The <code>RefCell&lt;T&gt;</code> type with its interior
mutability gives us a type that we can use when we need an immutable type but
need to change an inner value of that type; it also enforces the borrowing
rules at runtime instead of at compile time.</p>
<p>Also discussed were the <code>Deref</code> and <code>Drop</code> traits, which enable a lot of the
functionality of smart pointers. We explored reference cycles that can cause
memory leaks and how to prevent them using <code>Weak&lt;T&gt;</code>.</p>
<p>If this chapter has piqued your interest and you want to implement your own
smart pointers, check out <a href="../nomicon/index.html">“The Rustonomicon”</a> for more useful
information.</p>
<p>Next, we’ll talk about concurrency in Rust. You’ll even learn about a few new
smart pointers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="korkusuz-eşzamanlılık"><a class="header" href="#korkusuz-eşzamanlılık">Korkusuz Eşzamanlılık</a></h1>
<p><em>Eşzamanlı programlamayı</em> güvenli ve verimli bir şekilde kullanmak, Rust'ın ana hedeflerinden birisidir. 
Bir programın farklı bölümlerinin bağımsız olarak yürütüldüğü <em>eşzamanlı programlama</em> ve bir programın farklı bölümlerinin aynı anda yürütüldüğü <em>paralel programlama</em> giderek daha önemli hale geliyor.</p>
<p>Tarihsel olarak, bu tarz bir programlama zor ve hataya açıktı: Rust, bunu değiştirmeyi umuyor. 
Başlangıçta Rust ekibi, bellek güvenliğini sağlamanın ve eşzamanlılık sorunlarını önlemenin farklı yöntemlerle çözülmesi gereken iki ayrı zorluk olduğunu düşündü. Zamanla ekip, sahiplik <em>ve</em> tür sistemlerinin bellek güvenliği ve eşzamanlılık sorunlarını yönetmeye yardımcı olacak güçlü bir araç seti olduğunu keşfetti! 
Rust, bir çalışma zamanı eşzamanlılık hatasının oluştuğu kesin koşulları yeniden oluşturmaya çalışmak için fazladan zaman harcamak yerine, yanlış kod derlemeyi reddedecek ve sorunu açıklayan bir hata sunacaktır. Sonuç olarak, kodunuz üretime gönderildikten sonra değil, siz üzerinde çalışırken kodunuzu düzeltebilirsiniz. Rust'ın <em>korkusuz</em> eşzamanlılığının bu yönüne bir takma ad verdik. <em>Korkusuz</em> eşzamanlılık, ince hatalardan arınmış ve yeni hatalar eklemeden yeniden düzenlenebilmesi yönüyle kolay kod yazmanıza olanak tanır. </p>
<blockquote>
<p>Not: Basitlik olması babından, eşzamanlı ve/veya paralel diyerek daha kesin olmak yerine birçok soruna <em>eşzamanlı</em> olarak değineceğiz. 
Bu kitap eşzamanlılık ve/veya paralellik hakkında olsaydı, daha spesifik açıklardık. Bu bölüm için, <em>eşzamanlı</em> kullandığımızda lütfen zihinsel olarak 
eşzamanlı ve/veya paralel olarak değiştirin.</p>
</blockquote>
<p>Birçok dil, eşzamanlı sorunları ele almak için sundukları çözümler konusunda dogmatiktir. 
Örneğin, Erlang, mesaj iletme eşzamanlılığı için zarif bir işlevselliğe sahiptir, ancak iş parçacıkları arasında durumu paylaşmak için yalnızca belirsiz yollara sahiptir. Olası çözümlerin yalnızca bir alt kümesini desteklemek, üst düzey diller için makul bir stratejidir, çünkü daha yüksek düzeyli bir dil, soyutlamalar elde etmek için bazı kontrollerden vazgeçmenin yararlarını vaat eder. 
Bununla birlikte, daha düşük seviyeli dillerin, herhangi bir durumda en iyi performansla çözümü sağlaması ve donanım üzerinde daha az soyutlamaya sahip olması beklenir. 
Bu nedenle Rust, durumunuza ve gereksinimlerinize uygun olan herhangi bir şekilde problemleri modellemek için çeşitli araçlar sunar.</p>
<p>İşte bu bölümde ele alacağımız konulardan bazıları:</p>
<ul>
<li>Aynı anda birden çok kod parçasını çalıştırmak için iş parçacıklarının nasıl oluşturulacağı</li>
<li><em>Mesaj geçişi</em> türünde eşzamanlılık, iş parçacıklarının ileti dizileri arasında mesaj gönderdiği yer</li>
<li><em>Paylaşılan durum</em> türünde eşzamanlılık, birden çok iş parçacığının bir veri parçasına erişimi olduğu yer</li>
<li>Rust'ın eşzamanlılık garantilerini kullanıcı tanımlı türlere ve standart kütüphane tarafından sağlanan türlere 
genişleten <code>Sync</code> ve <code>Send</code> tanımları</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="using-threads-to-run-code-simultaneously"><a class="header" href="#using-threads-to-run-code-simultaneously">Using Threads to Run Code Simultaneously</a></h2>
<p>In most current operating systems, an executed program’s code is run in a
<em>process</em>, and the operating system will manage multiple processes at once.
Within a program, you can also have independent parts that run simultaneously.
The features that run these independent parts are called <em>threads</em>. For
example, a web server could have multiple threads so that it could respond to
more than one request at the same time.</p>
<p>Splitting the computation in your program into multiple threads to run multiple
tasks at the same time can improve performance, but it also adds complexity.
Because threads can run simultaneously, there’s no inherent guarantee about the
order in which parts of your code on different threads will run. This can lead
to problems, such as:</p>
<ul>
<li>Race conditions, where threads are accessing data or resources in an
inconsistent order</li>
<li>Deadlocks, where two threads are waiting for each other, preventing both
threads from continuing</li>
<li>Bugs that happen only in certain situations and are hard to reproduce and fix
reliably</li>
</ul>
<p>Rust attempts to mitigate the negative effects of using threads, but
programming in a multithreaded context still takes careful thought and requires
a code structure that is different from that in programs running in a single
thread.</p>
<p>Programming languages implement threads in a few different ways, and many
operating systems provide an API the language can call for creating new
threads. The Rust standard library uses a <em>1:1</em> model of thread implementation,
whereby a program uses one operating system thread per one language thread.
There are crates that implement other models of threading that make different
tradeoffs to the 1:1 model.</p>
<h3 id="creating-a-new-thread-with-spawn"><a class="header" href="#creating-a-new-thread-with-spawn">Creating a New Thread with <code>spawn</code></a></h3>
<p>To create a new thread, we call the <code>thread::spawn</code> function and pass it a
closure (we talked about closures in Chapter 13) containing the code we want to
run in the new thread. The example in Listing 16-1 prints some text from a main
thread and other text from a new thread:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p><span class="caption">Listing 16-1: Creating a new thread to print one thing
while the main thread prints something else</span></p>
<p>Note that when the main thread of a Rust program completes, all spawned threads
are shut down, whether or not they have finished running. The output from this
program might be a little different every time, but it will look similar to the
following:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>The calls to <code>thread::sleep</code> force a thread to stop its execution for a short
duration, allowing a different thread to run. The threads will probably take
turns, but that isn’t guaranteed: it depends on how your operating system
schedules the threads. In this run, the main thread printed first, even though
the print statement from the spawned thread appears first in the code. And even
though we told the spawned thread to print until <code>i</code> is 9, it only got to 5
before the main thread shut down.</p>
<p>If you run this code and only see output from the main thread, or don’t see any
overlap, try increasing the numbers in the ranges to create more opportunities
for the operating system to switch between the threads.</p>
<h3 id="waiting-for-all-threads-to-finish-using-join-handles"><a class="header" href="#waiting-for-all-threads-to-finish-using-join-handles">Waiting for All Threads to Finish Using <code>join</code> Handles</a></h3>
<p>The code in Listing 16-1 not only stops the spawned thread prematurely most of
the time due to the main thread ending, but because there is no guarantee on
the order in which threads run, we also can’t guarantee that the spawned thread
will get to run at all!</p>
<p>We can fix the problem of the spawned thread not running or ending prematurely
by saving the return value of <code>thread::spawn</code> in a variable. The return type of
<code>thread::spawn</code> is <code>JoinHandle</code>. A <code>JoinHandle</code> is an owned value that, when we
call the <code>join</code> method on it, will wait for its thread to finish. Listing 16-2
shows how to use the <code>JoinHandle</code> of the thread we created in Listing 16-1 and
call <code>join</code> to make sure the spawned thread finishes before <code>main</code> exits:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">Listing 16-2: Saving a <code>JoinHandle</code> from <code>thread::spawn</code>
to guarantee the thread is run to completion</span></p>
<p>Calling <code>join</code> on the handle blocks the thread currently running until the
thread represented by the handle terminates. <em>Blocking</em> a thread means that
thread is prevented from performing work or exiting. Because we’ve put the call
to <code>join</code> after the main thread’s <code>for</code> loop, running Listing 16-2 should
produce output similar to this:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>The two threads continue alternating, but the main thread waits because of the
call to <code>handle.join()</code> and does not end until the spawned thread is finished.</p>
<p>But let’s see what happens when we instead move <code>handle.join()</code> before the
<code>for</code> loop in <code>main</code>, like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p>The main thread will wait for the spawned thread to finish and then run its
<code>for</code> loop, so the output won’t be interleaved anymore, as shown here:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>Small details, such as where <code>join</code> is called, can affect whether or not your
threads run at the same time.</p>
<h3 id="using-move-closures-with-threads"><a class="header" href="#using-move-closures-with-threads">Using <code>move</code> Closures with Threads</a></h3>
<p>We'll often use the <code>move</code> keyword with closures passed to <code>thread::spawn</code>
because the closure will then take ownership of the values it uses from the
environment, thus transferring ownership of those values from one thread to
another. In the <a href="ch13-01-closures.html#capturing-the-environment-with-closures">“Capturing the Environment with Closures”</a><!-- ignore
--> section of Chapter 13, we discussed <code>move</code> in the context of closures. Now,
we’ll concentrate more on the interaction between <code>move</code> and <code>thread::spawn</code>.</p>
<p>Notice in Listing 16-1 that the closure we pass to <code>thread::spawn</code> takes no
arguments: we’re not using any data from the main thread in the spawned
thread’s code. To use data from the main thread in the spawned thread, the
spawned thread’s closure must capture the values it needs. Listing 16-3 shows
an attempt to create a vector in the main thread and use it in the spawned
thread. However, this won’t yet work, as you’ll see in a moment.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre>
<p><span class="caption">Listing 16-3: Attempting to use a vector created by the
main thread in another thread</span></p>
<p>The closure uses <code>v</code>, so it will capture <code>v</code> and make it part of the closure’s
environment. Because <code>thread::spawn</code> runs this closure in a new thread, we
should be able to access <code>v</code> inside that new thread. But when we compile this
example, we get the following error:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!(&quot;Here's a vector: {:?}&quot;, v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` due to previous error
</code></pre>
<p>Rust <em>infers</em> how to capture <code>v</code>, and because <code>println!</code> only needs a reference
to <code>v</code>, the closure tries to borrow <code>v</code>. However, there’s a problem: Rust can’t
tell how long the spawned thread will run, so it doesn’t know if the reference
to <code>v</code> will always be valid.</p>
<p>Listing 16-4 provides a scenario that’s more likely to have a reference to <code>v</code>
that won’t be valid:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}
</code></pre>
<p><span class="caption">Listing 16-4: A thread with a closure that attempts to
capture a reference to <code>v</code> from a main thread that drops <code>v</code></span></p>
<p>If Rust allowed us to run this code, there’s a possibility the spawned thread
would be immediately put in the background without running at all. The spawned
thread has a reference to <code>v</code> inside, but the main thread immediately drops
<code>v</code>, using the <code>drop</code> function we discussed in Chapter 15. Then, when the
spawned thread starts to execute, <code>v</code> is no longer valid, so a reference to it
is also invalid. Oh no!</p>
<p>To fix the compiler error in Listing 16-3, we can use the error message’s
advice:</p>
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>By adding the <code>move</code> keyword before the closure, we force the closure to take
ownership of the values it’s using rather than allowing Rust to infer that it
should borrow the values. The modification to Listing 16-3 shown in Listing
16-5 will compile and run as we intend:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">Listing 16-5: Using the <code>move</code> keyword to force a closure
to take ownership of the values it uses</span></p>
<p>We might be tempted to try the same thing to fix the code in Listing 16-4 where
the main thread called <code>drop</code> by using a <code>move</code> closure. However, this fix will
not work because what Listing 16-4 is trying to do is disallowed for a
different reason. If we added <code>move</code> to the closure, we would move <code>v</code> into the
closure’s environment, and we could no longer call <code>drop</code> on it in the main
thread. We would get this compiler error instead:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  | 
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!(&quot;Here's a vector: {:?}&quot;, v);
   |                                           - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` due to previous error
</code></pre>
<p>Rust’s ownership rules have saved us again! We got an error from the code in
Listing 16-3 because Rust was being conservative and only borrowing <code>v</code> for the
thread, which meant the main thread could theoretically invalidate the spawned
thread’s reference. By telling Rust to move ownership of <code>v</code> to the spawned
thread, we’re guaranteeing Rust that the main thread won’t use <code>v</code> anymore. If
we change Listing 16-4 in the same way, we’re then violating the ownership
rules when we try to use <code>v</code> in the main thread. The <code>move</code> keyword overrides
Rust’s conservative default of borrowing; it doesn’t let us violate the
ownership rules.</p>
<p>With a basic understanding of threads and the thread API, let’s look at what we
can <em>do</em> with threads.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="İş-parçacıkları-arasında-veri-aktarmak-için-mesaj-geçişini-kullanma"><a class="header" href="#İş-parçacıkları-arasında-veri-aktarmak-için-mesaj-geçişini-kullanma">İş Parçacıkları Arasında Veri Aktarmak için Mesaj Geçişini Kullanma</a></h2>
<p>Güvenli eşzamanlılık sağlamak için giderek daha popüler hale gelen bir yaklaşım, 
iş parçacıklarının veya aktörlerin birbirlerine veri içeren mesajlar göndererek iletişim kurduğu mesaj geçişidir. 
İşte <a href="https://golang.org/doc/effective_go.html#concurrency">Go dil dokümantasyonundan</a> bir slogan:
“Belleği paylaşarak iletişim kurmayın; bunun yerine iletişim kurarak belleği paylaşın.”</p>
<p>Mesaj gönderme eşzamanlılığını gerçekleştirmek için Rust'ın standart kütüphanesi bir <em>kanal</em> süreklemesi sağlar. 
Kanal, verilerin bir iş parçacığından diğerine gönderildiği genel bir programlama kavramıdır.</p>
<p>Programlamada bir kanalı, bir dere veya nehir gibi yönlü bir su kanalı gibi düşünebilirsiniz. 
Bir nehre lastik ördek gibi bir şey koyarsanız, su yolunun sonuna kadar aşağı doğru hareket edecektir.</p>
<p>Bir kanalın iki yarısı vardır: bir verici ve bir alıcı. Verici yarı, nehre lastik ördek koyduğunuz yukarı akış konumudur 
ve alıcı yarı, lastik ördeğin aşağı akışta sona erdiği yerdir. Kodunuzun bir kısmı göndermek istediğiniz verilerle 
vericideki yöntemleri çağırır ve başka bir kısmı da gelen mesajlar için alıcı ucunu kontrol eder.
Verici veya alıcı yarısından herhangi biri düşerse bir kanalın kapalı olduğu söylenir.</p>
<p>Burada, değerler üreten ve bunları bir kanaldan gönderen bir iş parçacığına ve değerleri alıp yazdıracak başka 
bir iş parçacığına sahip bir program üzerinde çalışacağız. Özelliği göstermek için bir kanal kullanarak iş parçacıkları 
arasında basit değerler göndereceğiz. Tekniğe aşina olduktan sonra, sohbet sistemi veya birçok iş parçacığının bir 
hesaplamanın parçalarını gerçekleştirdiği ve parçaları sonuçları toplayan bir iş parçacığına gönderdiği bir sistem gibi 
birbirleri arasında iletişim kurması gereken herhangi bir iş parçacığı için kanalları kullanabilirsiniz.</p>
<p>İlk olarak, Liste 16-6'da bir kanal oluşturacağız ancak onunla hiçbir şey yapmayacağız. 
Bunun henüz derlenmeyeceğini unutmayın çünkü Rust kanal üzerinden ne tür değerler göndermek istediğimizi söyleyemez.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
</code></pre>
<p><span class="caption">Liste 16-6: Bir kanal oluşturma ve iki yarıyı <code>tx</code> ve <code>rx</code> olarak atama</span></p>
<p><code>mpsc::channel</code> fonksiyonunu kullanarak yeni bir kanal oluşturuyoruz; <code>mpsc</code> <em>çoklu üretici, 
tekli tüketici</em> anlamına geliyor. Kısacası, Rust'ın standart kütüphanesinin kanalları sürekleme şekli, bir 
kanalın değer üreten birden fazla gönderen uca sahip olabileceği, ancak bu değerleri tüketen yalnızca bir 
alıcı uca sahip olabileceği anlamına gelir. Birden fazla akarsuyun birlikte büyük bir nehre aktığını düşünün: 
akarsulardan herhangi birine gönderilen her şey sonunda tek bir nehirde son bulacaktır. Şimdilik tek bir üretici ile 
başlayacağız, ancak bu örneği çalıştırdığımızda birden fazla üretici ekleyeceğiz.</p>
<p><code>mpsc::channel</code> fonksiyonu bir <code>tuple</code> döndürür, ilk elemanı gönderen uç-verici- ve ikinci elemanı alan uç-alıcıdır.
<code>tx</code> ve <code>rx</code> kısaltmaları geleneksel olarak birçok alanda sırasıyla verici ve alıcı için kullanılır, 
bu nedenle değişkenlerimizi her bir ucu belirtmek için bu şekilde adlandırıyoruz. <code>tuple</code>'ları yıkıma uğratan bir kalıp 
ile <code>let</code> ifade yapısını kullanıyoruz; <code>let</code> ifade yapılarında kalıp kullanımı ve yıkım konusunu Bölüm 18'de tartışacağız. 
Şimdilik, let deyimini bu şekilde kullanmanın <code>mpsc::channel</code> tarafından döndürülen <code>tuple</code> parçalarını ayıklamak için uygun 
bir yaklaşım olduğunu bilin.</p>
<p>İletim ucunu oluşturulmuş bir iş parçacığına taşıyalım ve bir dize göndermesini sağlayalım, böylece oluşturulmuş iş 
parçacığı Liste 16-7'de gösterildiği gibi ana iş parçacığı ile iletişim kurar. Bu, nehrin yukarısına bir lastik ördek 
koymak veya bir iş parçacığından diğerine bir sohbet mesajı göndermek gibidir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });
}
</code></pre></pre>
<p><span class="caption">Liste 16-7: <code>tx</code>i doğmuş bir iş parçacığına taşıma ve “hello” gönderme</span></p>
<p>Yine, yeni bir iş parçacığı oluşturmak için <code>thread::spawn</code> kullanıyoruz ve ardından <code>tx</code>'i kapanışa taşımak için
<code>move</code> kullanıyoruz, böylece oluşturulan iş parçacığı <code>tx</code>'e sahip oluyor. Ortaya çıkan iş parçacığının kanal üzerinden 
mesaj gönderebilmesi için vericiye sahip olması gerekir. Verici, göndermek istediğimiz değeri alan bir <code>send</code> metoda 
sahiptir. <code>send</code> metodu <code>Result&lt;T, E&gt;</code> türü döndürür, bu nedenle alıcı zaten bırakılmışsa ve değer gönderilecek bir yer yoksa,
<code>send</code> metodu bir hata döndürür. Bu örnekte, hata durumunda paniklemek için <code>unwrap</code>'i çağırıyoruz. Ancak gerçek bir 
süreklemede bunu düzgün bir şekilde ele alırız: düzgün hata işleme stratejilerini gözden geçirmek için Bölüm 9'a dönün.</p>
<p>Liste 16-8'de, ana iş parçacığındaki alıcıdan değeri alacağız. Bu, nehrin sonundaki sudan lastik ördeği almak veya 
bir sohbet mesajı almak gibidir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre></pre>
<p><span class="caption">Liste 16-8: Ana iş parçacığında “hi” değerinin alınması ve yazdırılması</span></p>
<p>Alıcının iki faydalı yöntemi vardır: <code>recv</code> ve <code>try_recv</code>. Ana iş parçacığının çalışmasını engelleyecek ve kanaldan bir 
değer gönderilinceye kadar bekleyecek olan <code>recv</code>'yi kullanıyoruz. Bir değer gönderildiğinde, <code>recv</code> bu değeri <code>Result&lt;T, E&gt;</code> 
olarak döndürür. Verici kapandığında, <code>recv</code> daha fazla değer gelmeyeceğini belirtmek için bir hata döndürecektir.</p>
<p><code>try_recv</code> yöntemi bloke olmaz, ancak bunun yerine hemen bir <code>Result&lt;T, E&gt;</code> döndürür: mevcutsa bir mesaj içeren bir
<code>Ok</code> değeri ve bu sefer herhangi bir mesaj yoksa bir <code>Err</code> değeri. Bu iş parçacığının mesajları beklerken yapacak
başka işleri varsa <code>try_recv</code>'i kullanmak yararlıdır: <code>try_recv</code>'i sık sık çağıran, varsa bir mesajı işleyen ve aksi 
takdirde tekrar kontrol edene kadar kısa bir süre başka işler yapan bir döngü yazabiliriz.</p>
<p>Bu örnekte basitlik için <code>recv</code> kullandık; ana iş parçacığının mesajları beklemek dışında yapacağı başka bir işimiz yok, 
bu nedenle ana iş parçacığını engellemek uygundur.</p>
<p>Liste 16-8'deki kodu çalıştırdığımızda, ana iş parçacığından yazdırılan değeri göreceğiz:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
</code></pre>
<p>Mükemmel!</p>
<h3 id="kanallar-ve-sahiplik-transferi"><a class="header" href="#kanallar-ve-sahiplik-transferi">Kanallar ve Sahiplik Transferi</a></h3>
<p>Sahiplik kuralları mesaj göndermede hayati bir rol oynar çünkü güvenli, eşzamanlı kod yazmanıza yardımcı olurlar. 
Eşzamanlı programlamada hataları önlemek, Rust programlarınız boyunca sahiplik hakkında düşünmenin avantajıdır. 
Kanalların ve sahipliğin sorunları önlemek için nasıl birlikte çalıştığını göstermek için bir deney yapalım: 
kanaldan aşağı gönderdikten sonra ortaya çıkan iş parçacığında bir <code>val</code> değeri kullanmaya çalışacağız. 
Bu koda neden izin verilmediğini görmek için Liste 16-9'daki kodu derlemeyi deneyin:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
        println!(&quot;val is {}&quot;, val);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre>
<p><span class="caption">Liste 16-9: Kanaldan gönderdikten sonra <code>val</code> kullanmayı denemek</span></p>
<p>Burada, <code>tx.send</code> aracılığıyla kanala gönderdikten sonra <code>val</code>'ı yazdırmayı deniyoruz. Buna izin vermek kötü 
bir fikir olacaktır: değer başka bir iş parçacığına gönderildikten sonra, biz değeri tekrar kullanmaya çalışmadan 
önce o iş parçacığı değeri değiştirebilir veya düşürebilir. Potansiyel olarak, diğer iş parçacığının değişiklikleri 
tutarsız veya var olmayan veriler nedeniyle hatalara veya beklenmedik sonuçlara neden olabilir. 
Ancak, Liste 16-9'daki kodu derlemeye çalışırsak Rust bize bir hata verir:</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:31
   |
8  |         let val = String::from(&quot;hi&quot;);
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val is {}&quot;, val);
   |                               ^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` due to previous error
</code></pre>
<p>Eşzamanlılık hatamız bir derleme zamanı hatasına neden oldu. <code>send</code> fonksiyonu parametresinin sahipliğini alır ve 
değer taşındığında alıcı onun sahipliğini alır. Bu, değeri gönderdikten sonra yanlışlıkla tekrar kullanmamızı engeller; 
sahiplik sistemi her şeyin yolunda olup olmadığını kontrol eder.</p>
<h3 id="birden-fazla-değer-gönderme-ve-alıcının-beklediğini-görme"><a class="header" href="#birden-fazla-değer-gönderme-ve-alıcının-beklediğini-görme">Birden Fazla Değer Gönderme ve Alıcının Beklediğini Görme</a></h3>
<p>Liste 16-8'deki kod derlendi ve çalıştırıldı, ancak bize iki ayrı iş parçacığının kanal üzerinden birbiriyle konuştuğunu 
açıkça göstermedi. Liste 16-10'da, Liste 16-8'deki kodun eşzamanlı olarak çalıştığını kanıtlayacak bazı değişiklikler yaptık: 
ortaya çıkan iş parçacığı artık birden fazla mesaj gönderecek ve her mesaj arasında bir saniye duracak.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust noplayground">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre>
<p><span class="caption">Liste 16-10: Birden fazla mesaj gönderme ve her biri arasında duraklama</span></p>
<p>Bu kez, ortaya çıkan iş parçacığı ana iş parçacığına göndermek istediğimiz dizelerden oluşan bir vektöre sahiptir. 
Bunların üzerinde yineleme yaparak her birini ayrı ayrı gönderiyoruz ve <code>thread::sleep</code> fonksiyonunu <code>1</code> saniyelik bir
<code>Duration</code> değeriyle çağırarak her biri arasında duraklatıyoruz.</p>
<p>Ana iş parçacığında, artık <code>recv</code> fonksiyonunu açıkça çağırmıyoruz: bunun yerine, <code>rx</code>'i yineleyici olarak ele alıyoruz. 
Alınan her değer için onu yazdırıyoruz. Kanal kapatıldığında, yineleme sona erecektir.</p>
<p>Liste 16-10'daki kodu çalıştırdığınızda, her satır arasında <code>1</code> saniyelik bir duraklama ile aşağıdaki çıktıyı görmelisiniz:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>Ana iş parçacığındaki <code>for</code> döngüsünde duraklatan veya geciktiren herhangi bir kodumuz olmadığından, 
ana iş parçacığının ortaya çıkan iş parçacığından değer almayı beklediğini söyleyebiliriz.</p>
<h3 id="vericiyi-klonlayarak-birden-fazla-Üretici-oluşturma"><a class="header" href="#vericiyi-klonlayarak-birden-fazla-Üretici-oluşturma">Vericiyi Klonlayarak Birden Fazla Üretici Oluşturma</a></h3>
<p>Daha önce <code>mpsc</code>'nin çoklu üretici, tekli tüketici için kullanılan bir kısaltma olduğundan bahsetmiştik. 
Şimdi <code>mpsc</code>'yi kullanalım ve hepsi aynı alıcıya değer gönderen birden fazla iş parçacığı oluşturmak için Liste 16-10'daki 
kodu genişletelim. Bunu, Liste 16-11'de gösterildiği gibi vericiyi klonlayarak yapabiliriz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;more&quot;),
            String::from(&quot;messages&quot;),
            String::from(&quot;for&quot;),
            String::from(&quot;you&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }

    // --snip--
<span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 16-11: Birden fazla üreticiden birden fazla mesaj gönderme</span></p>
<p>Bu kez, ilk iş parçacığını oluşturmadan önce, vericide <code>clone</code> çağrısı yapıyoruz. 
Bu bize ilk iş parçacığına aktarabileceğimiz yeni bir verici verecektir. Orijinal vericiyi ikinci bir 
iş parçacığına aktarırız. Bu bize her biri bir alıcıya farklı mesajlar gönderen iki iş parçacığı verir.</p>
<p>Kodu çalıştırdığınızda, çıktınız aşağıdaki gibi görünmelidir:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>Sisteminize bağlı olarak değerleri farklı bir sırada görebilirsiniz. Eşzamanlılığı zor olduğu kadar ilginç kılan da budur.
<code>Thread::sleep</code> ile denemeler yaparsanız, farklı iş parçacıklarında farklı değerler verirseniz, her çalıştırma daha 
belirsiz olacak ve her seferinde farklı çıktılar oluşturacaktır.</p>
<p>Kanalların nasıl çalıştığına baktığımıza göre, şimdi farklı bir eşzamanlılık yöntemine bakalım.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="paylaşılan-durum-eşzamanlılığı"><a class="header" href="#paylaşılan-durum-eşzamanlılığı">Paylaşılan Durum Eşzamanlılığı</a></h2>
<p>Mesaj geçişi, eşzamanlılığı ele almanın iyi bir yoludur, ancak tek yol değildir. Başka bir yöntem de birden fazla iş 
parçacığının aynı paylaşılan veriye erişmesidir. Go dil dokümantasyonundaki sloganın bu kısmını tekrar düşünün: 
“belleği paylaşarak iletişim kurmayın.”</p>
<p>Bellek paylaşarak iletişim kurmak neye benzer? Buna ek olarak, mesaj geçişi meraklıları neden bellek paylaşımını 
kullanmamaya dikkat ederler?</p>
<p>Bir bakıma, herhangi bir programlama dilindeki kanallar tekil sahipliğe benzer, çünkü bir değeri bir kanaldan aşağı 
aktardığınızda, artık o değeri kullanmamalısınız. Paylaşılan bellek eşzamanlılığı çoklu sahiplik gibidir: birden fazla 
iş parçacığı aynı bellek konumuna aynı anda erişebilir. Akıllı işaretçilerin çoklu sahipliği mümkün kıldığı Bölüm 15'te 
gördüğünüz gibi, çoklu sahiplik karmaşıklık yaratabilir çünkü bu farklı sahiplerin yönetilmesi gerekir. Rust'ın tür sistemi ve 
sahiplik kuralları bu yönetimin doğru yapılmasına büyük ölçüde yardımcı olur. Bir örnek olarak, paylaşılan bellek için 
en yaygın eşzamanlılık ilkellerinden biri olan mutekslere bakalım.</p>
<h3 id="aynı-anda-bir-İş-parçacığından-veriye-erişime-İzin-vermek-için-muteksleri-kullanma"><a class="header" href="#aynı-anda-bir-İş-parçacığından-veriye-erişime-İzin-vermek-için-muteksleri-kullanma">Aynı Anda Bir İş Parçacığından Veriye Erişime İzin Vermek için Muteksleri Kullanma</a></h3>
<p><em>Muteks</em>, <em>karşılıklı dışlamanın</em> kısaltmasıdır, yani bir muteks herhangi bir zamanda yalnızca bir iş
parçacığının bazı verilere erişmesine izin verir. Bir muteks içindeki verilere erişmek için, bir iş parçacığı
önce muteksin kilidini almak isteyerek erişim istediğini belirtmelidir. Kilit, muteksin bir parçası olan 
ve o anda verilere kimin özel erişime sahip olduğunu takip eden bir veri yapısıdır. Bu nedenle muteks, 
kilitleme sistemi aracılığıyla tuttuğu verileri koruyor olarak tanımlanır.</p>
<p>Mutekslerin kullanımı zor olmakla ünlüdür çünkü iki kuralı hatırlamanız gerekir:</p>
<ul>
<li>Veriyi kullanmadan önce kilidi elde etmeye çalışmalısınız.</li>
<li>Muteksin koruduğu verilerle işiniz bittiğinde, diğer iş parçacıklarının kilidi alabilmesi için verilerin kilidini açmanız
gerekir.</li>
</ul>
<p>Muteks için gerçek dünyadan bir benzetme yapmak gerekirse, bir konferansta yalnızca bir mikrofonun olduğu bir panel 
tartışması hayal edin. Bir panelist konuşmadan önce mikrofonu kullanmak istediğini söylemeli ya da 
işaret etmelidir. Mikrofonu aldıklarında, istedikleri kadar konuşabilirler ve daha sonra mikrofonu konuşmak
isteyen bir sonraki paneliste verirler. Eğer bir panelist işi bittiğinde mikrofonu vermeyi unutursa, 
başka kimse konuşamaz. Paylaşılan mikrofonun yönetimi yanlış giderse, panel planlandığı gibi çalışmaz!</p>
<p>Mutekslerin yönetimini doğru yapmak inanılmaz derecede zor olabilir, bu yüzden pek çok insan kanallar konusunda 
heveslidir. Ancak Rust'ın tür sistemi ve sahiplik kuralları sayesinde kilitleme
ve kilit açma işlemlerini yanlış yapamazsınız.</p>
<h3 id="mutext-apisi"><a class="header" href="#mutext-apisi"><code>Mutex&lt;T&gt;</code> API'si</a></h3>
<p>Bir muteksin nasıl kullanılacağına örnek olarak, Liste 16-12'de gösterildiği gibi tek iş parçacıklı bir bağlamda bir 
muteks kullanarak başlayalım:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}
</code></pre></pre>
<p><span class="caption">Liste 16-12: Basitlik için tek iş parçacıklı bir bağlamda <code>Mutex&lt;T&gt;</code> API'sini keşfetmek</span></p>
<p>Birçok türde olduğu gibi, ilişkili <code>new</code> fonksiyonunu kullanarak bir <code>Mutex&lt;T&gt;</code> oluşturuyoruz. <code>Mutex</code> içindeki verilere 
erişmek için <code>lock</code> metodunu kullanarak kilidi alırız. Bu çağrı mevcut iş parçacığını bloke eder, böylece kilide sahip 
olma sırası bize gelene kadar herhangi bir iş yapamaz.</p>
<p>Kilidi elinde tutan başka bir iş parçacığı paniğe kapılırsa lock çağrısı başarısız olur. Bu durumda, hiç kimse kilidi alamaz, 
bu nedenle böyle bir durumla karşılaşırsak kilidi açmayı ve bu iş parçacığının paniklemesini sağlamayı seçtik.</p>
<p>Kilidi elde ettikten sonra, bu durumda num olarak adlandırılan geri dönüş değerini, içindeki verilere değiştirilebilir bir referans olarak
ele alabiliriz. Tür sistemi, <code>m</code> içindeki değeri kullanmadan önce bir kilit elde etmemizi sağlar. <code>m</code>'nin tipi <code>i32</code> değil
<code>Mutex&lt;i32&gt;</code>'dir, bu nedenle <code>i32</code> değerini kullanabilmek için <code>lock</code>'u çağırmalıyız. Unutmamalıyız; aksi takdirde 
tür sistemi içteki <code>i32</code>'ye erişmemize izin vermez.</p>
<p>Tahmin edebileceğiniz gibi, <code>Mutex&lt;T&gt;</code> akıllı bir işaretçidir. Daha doğrusu, <code>lock</code> çağrısı, <code>unwrap</code> çağrısıyla işlediğimiz
bir <code>LockResult</code>'a sarılmış <code>MutexGuard</code> adlı bir akıllı işaretçi döndürür. <code>MutexGuard</code> akıllı işaretçisi, 
iç verilerimize işaret etmek için <code>Deref</code>'i uygular; akıllı işaretçi ayrıca, bir <code>MutexGuard</code> kapsam dışına 
çıktığında kilidi otomatik olarak serbest bırakan bir <code>Drop</code>'a sahiptir, bu da iç kapsamın sonunda gerçekleşir. </p>
<p>Sonuç olarak, kilidi serbest bırakmayı unutma. Muteksin diğer iş parçacıkları
tarafından kullanılmasını engelleme riskimiz yoktur, çünkü kilit serbest bırakma işlemi otomatik olarak gerçekleşir.</p>
<p>Kilidi bıraktıktan sonra muteks değerini yazdırabilir ve <code>i32</code>'yi <code>6</code> olarak değiştirebildiğimizi görebiliriz.</p>
<h3 id="birden-fazla-İş-parçacığı-arasında-mutext-paylaşımı"><a class="header" href="#birden-fazla-İş-parçacığı-arasında-mutext-paylaşımı">Birden Fazla İş Parçacığı Arasında <code>Mutex&lt;T&gt;</code> Paylaşımı</a></h3>
<p>Şimdi, <code>Mutex&lt;T&gt;</code> kullanarak bir değeri birden fazla iş parçacığı arasında paylaştırmayı deneyelim. 
10 iş parçacığı oluşturacağız ve her birinin bir sayaç değerini 1 artırmasını sağlayacağız, böylece sayaç 
0'dan 10'a gidecek. Liste 16-13'teki bir sonraki örnekte bir derleyici hatası olacak ve bu hatayı
<code>Mutex&lt;T&gt;</code> kullanımı ve Rust'ın bunu doğru kullanmamıza nasıl yardımcı olduğu hakkında daha fazla bilgi edinmek için 
kullanacağız.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">Liste 16-13: On iş parçacığının her biri bir <code>Mutex&lt;T&gt;</code> tarafından korunan bir sayacı artırır</span></p>
<p>Liste 16-12'de yaptığımız gibi, <code>Mutex&lt;T&gt;</code> içinde <code>i32</code> tutmak için bir <code>counter</code> değişkeni oluşturuyoruz. ,
Ardından, bir dizi sayı üzerinde yineleme yaparak 10 iş parçacığı oluşturuyoruz.
<code>Thread::spawn</code> kullanıyoruz ve tüm iş parçacıklarına aynı kapanışı veriyoruz: sayacı iş parçacığına taşıyan,
<code>lock</code> metodunu çağırarak <code>Mutex&lt;T&gt;</code> üzerinde bir kilit elde ediyor ve ardından muteksteki değere 1 eklemiş oluyoruz. 
Bir iş parçacığı kapanışını çalıştırmayı bitirdiğinde, <code>num</code> kapsam dışına çıkar ve kilidi serbest bırakır, böylece
başka bir iş parçacığı onu alabilir.</p>
<p>Ana iş parçacığında, tüm birleştirme tutamaçlarını toplarız. Ardından, Liste 16-2'de yaptığımız gibi, tüm iş parçacıklarının 
bittiğinden emin olmak için her bir tanıtıcıda <code>join</code> çağrısı yaparız. Bu noktada, ana iş parçacığı kilidi alacak ve bu
programın sonucunu yazdıracaktır.</p>
<p>Bu örneğin derlenmeyeceğini demiştik. Şimdi nedenini bulalım!</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:9:36
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
9  |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^ value moved into closure here, in previous iteration of loop
10 |             let mut num = counter.lock().unwrap();
   |                           ------- use occurs due to use in closure

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` due to previous error
</code></pre>
<p>Hata mesajı, <code>counter</code> değerinin döngünün önceki yinelemesinde taşındığını belirtir. Rust bize kilit sayacının sahipliğini
birden fazla iş parçacığına taşıyamayacağımızı söylüyor. Derleyici hatasını Bölüm 15'te tartıştığımız çoklu sahiplik yöntemi
ile düzeltelim.</p>
<h4 id="Çoklu-İş-parçacığı-ile-Çoklu-sahiplik"><a class="header" href="#Çoklu-İş-parçacığı-ile-Çoklu-sahiplik">Çoklu İş Parçacığı ile Çoklu Sahiplik</a></h4>
<p>Bölüm 15'te, referans sayılan bir değer oluşturmak için <code>Rc&lt;T&gt;</code> akıllı işaretçisini kullanarak bir değere 
birden fazla sahip vermiştik. Burada da aynısını yapalım ve ne olacağını görelim. Liste 16-14'te <code>Mutex&lt;T&gt;</code>'yi <code>Rc&lt;T&gt;</code>'ye 
saracağız ve sahipliği iş parçacığına taşımadan önce <code>Rc&lt;T&gt;</code>'yi klonlayacağız.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">Liste 16-14: Birden fazla iş parçacığının <code>Mutex&lt;T&gt;</code>ye sahip olmasına izin vermek için <code>Rc&lt;T&gt;</code> kullanılmaya çalışılıyor</span></p>
<p>Bir kez daha derliyoruz ve... farklı farklı hatalar alıyoruz! Derleyici bize çok şey öğretiyor.</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:11:22
    |
11  |           let handle = thread::spawn(move || {
    |  ______________________^^^^^^^^^^^^^_-
    | |                      |
    | |                      `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
12  | |             let mut num = counter.lock().unwrap();
13  | |
14  | |             *num += 1;
15  | |         });
    | |_________- within this `[closure@src/main.rs:11:36: 15:10]`
    |
    = help: within `[closure@src/main.rs:11:36: 15:10]`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`
    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10]`
note: required by a bound in `spawn`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` due to previous error
</code></pre>
<p>İlgiçtir ki, bu hata mesajı çok karışık duruyor! İşte odaklanmanız gereken önemli kısım:
<code>Rc&lt;Mutex&lt;i32&gt;&gt;</code> iş parçacıkları arasında güvenli bir şekilde gönderilemez (<code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>) . Derleyici bize bunun nedenini de söylüyor:
<code>Send</code> tanımı <code>Rc&lt;Mutex&lt;i32&gt;&gt;</code> için uygulanmıyor. <code>Send</code> hakkında bir sonraki bölümde konuşacağız: <code>thread</code>'lerle 
kullandığımız türlerin eşzamanlı durumlarda kullanılmasını sağlayan özelliklerden biridir.</p>
<p>Ne yazık ki, <code>Rc&lt;T&gt;</code>'nin iş parçacıkları arasında paylaşılması güvenli değildir. <code>Rc&lt;T&gt;</code> referans sayımını yönetirken, 
her <code>clone</code> çağrısı için sayıma ekleme yapar ve her klon bırakıldığında sayıdan çıkarma yapar. Ancak, sayıdaki 
değişikliklerin başka bir iş parçacığı tarafından kesintiye uğratılamayacağından emin olmak için herhangi 
bir eşzamanlılık ilkeli kullanmaz. Bu, yanlış sayımlara yol açabilir - bu da bellek sızıntılarına veya 
bir değerin işimiz bitmeden önce bırakılmasına neden olabilecek ince hatalara yol açabilir. 
İhtiyacımız olan şey tam olarak <code>Rc&lt;T&gt;</code> gibi bir türdür, ancak referans sayımındaki değişiklikleri iş parçacığı 
güvenli bir şekilde yapan bir türdür.</p>
<h4 id="arct-ile-atomik-referans-sayma"><a class="header" href="#arct-ile-atomik-referans-sayma"><code>Arc&lt;T&gt;</code> ile Atomik Referans Sayma</a></h4>
<p>Neyse ki <code>Arc&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code> gibi eşzamanlı durumlarda kullanımı güvenli olan bir türdür. <code>A</code> <em>atomik</em> anlamına gelir, 
yani atomik olarak referans sayılan bir türdür. Atomikler, burada ayrıntılı olarak ele almayacağımız ek bir 
eşzamanlılık ilkelidir: daha fazla ayrıntı için <a href="../std/sync/atomic/index.html"><code>std::sync::atomic</code></a><!-- ignore --> için standart kütüphane 
dokümantasyonlarına bakın. Bu noktada, atomiklerin ilkel tipler gibi çalıştığını ancak iş parçacıkları 
arasında paylaşılmasının güvenli olduğunu bilmeniz yeterlidir.</p>
<p>O zaman neden tüm ilkel tiplerin atomik olmadığını ve neden standart kütüphane tiplerinin varsayılan 
olarak <code>Arc&lt;T&gt;</code> kullanacak şekilde uygulanmadığını merak edebilirsiniz. Bunun nedeni, iş parçacığı güvenliğinin yalnızca 
gerçekten ihtiyaç duyduğunuzda ödemek isteyeceğiniz bir performans cezası ile birlikte gelmesidir. 
Sadece tek bir iş parçacığı içinde değerler üzerinde işlem yapıyorsanız, atomiklerin sağladığı garantileri 
uygulamak zorunda kalmazsanız kodunuz daha hızlı çalışabilir.</p>
<p>Örneğimize geri dönelim: <code>Arc&lt;T&gt;</code> ve <code>Rc&lt;T&gt;</code> aynı API'ye sahiptir, bu nedenle <code>use</code> satırını, <code>new</code> çağrısını ve <code>clone</code> 
çağrısını değiştirerek programımızı düzeltiriz. Liste 16-15'teki kod nihayet derlenecek ve çalışacaktır:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<p><span class="caption">Liste 16-15: Sahipliği birden fazla iş parçacığı arasında paylaştırabilmek için <code>Mutex&lt;T&gt;</code>yi sarmak üzere bir <code>Arc&lt;T&gt;</code> kullanmak</span></p>
<p>Bu kod aşağıdakileri yazdıracaktır:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Result: 10
</code></pre>
<p>Başardık! 0'dan 10'a kadar saydık, bu çok etkileyici görünmeyebilir, ancak bize <code>Mutex&lt;T&gt;</code> ve iş parçacığı güvenliği hakkında 
çok şey öğretti. Bu programın yapısını bir sayacı artırmaktan daha karmaşık işlemler yapmak için de kullanabilirsiniz. 
Bu stratejiyi kullanarak, bir hesaplamayı bağımsız parçalara bölebilir, bu parçaları iş parçacıkları arasında paylaştırabilir ve
ardından her iş parçacığının nihai sonucu kendi parçasıyla güncellemesini sağlamak için <code>Mutex&lt;T&gt;</code>'i kullanabilirsiniz.</p>
<h3 id="refcelltrct-ve-mutextarct-arasındaki-benzerlikler"><a class="header" href="#refcelltrct-ve-mutextarct-arasındaki-benzerlikler"><code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> ve <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code> Arasındaki Benzerlikler</a></h3>
<p>Sayacın değişmez olduğunu ancak içindeki değere değişebilir bir referans alabileceğimizi fark etmiş olabilirsiniz; bu,
<code>Mutex&lt;T&gt;</code>'nin <code>Cell</code> ailesinin yaptığı gibi iç değişebilirlik sağladığı anlamına gelir. Bölüm 15'te <code>RefCell&lt;T&gt;</code>'yi bir <code>Rc&lt;T&gt;</code> içindeki içeriği
değiştirmemize izin vermek için kullandığımız gibi, <code>Mutex&lt;T&gt;</code>'yi bir <code>Arc&lt;T&gt;</code> içindeki içeriği değiştirmek için kullanırız.</p>
<p>Unutulmaması gereken bir diğer ayrıntı da <code>Mutex&lt;T&gt;</code> kullandığınızda Rust'ın sizi her türlü mantık hatasından koruyamayacağıdır. 
Bölüm 15'te <code>Rc&lt;T&gt;</code> kullanmanın, iki <code>Rc&lt;T&gt;</code> değerinin birbirine atıfta bulunduğu ve bellek sızıntılarına neden olan referans döngüleri
oluşturma riskiyle birlikte geldiğini hatırlayın. Benzer şekilde, <code>Mutex&lt;T&gt;</code> de kilitlenme yaratma riskini beraberinde getirir. 
Bunlar, bir işlemin iki kaynağı kilitlemesi gerektiğinde ve iki iş parçacığının her biri kilitlerden birini aldığında ortaya çıkar ve 
birbirlerini sonsuza kadar beklemelerine neden olur. Kilitlenmelerle ilgileniyorsanız, kilitlenmeye sahip bir Rust programı oluşturmayı deneyin; 
daha sonra herhangi bir dilde muteksler için kilitlenme azaltma stratejilerini araştırın ve bunları Rust'ta uygulamayı deneyin. <code>Mutex&lt;T&gt;</code> ve
<code>MutexGuard</code> için standart kütüphane API belgeleri faydalı bilgiler sunar.</p>
<p>Bu bölümü <code>Send</code> ve <code>Sync</code> tanımlarından ve bunları özel türlerle nasıl kullanabileceğimizden bahsederek tamamlayacağız.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sync-ve-send-tanımlarıyla-genişletilebilir-eşzamanlılık"><a class="header" href="#sync-ve-send-tanımlarıyla-genişletilebilir-eşzamanlılık"><code>Sync</code> ve <code>Send</code> Tanımlarıyla Genişletilebilir Eşzamanlılık</a></h2>
<p>İlginç bir şekilde, Rust dili çok az eşzamanlılık özelliğine sahiptir. Bu bölümde şimdiye kadar bahsettiğimiz neredeyse 
tüm eşzamanlılık özellikleri dilin değil, standart kütüphanenin bir parçasıydı. Eşzamanlılığı ele almak için seçenekleriniz 
dil veya standart kütüphane ile sınırlı değildir; kendi eşzamanlılık özelliklerinizi yazabilir veya başkaları tarafından 
yazılanları kullanabilirsiniz.</p>
<p>Ancak, iki eşzamanlılık kavramı dilin içine yerleştirilmiştir: <code>std::marker</code> tanımları <code>Sync</code> ve <code>Send</code>.</p>
<h3 id="send-ile-İş-parçacıkları-arasında-sahiplik-aktarımına-İzin-verme"><a class="header" href="#send-ile-İş-parçacıkları-arasında-sahiplik-aktarımına-İzin-verme"><code>Send</code> ile İş Parçacıkları Arasında Sahiplik Aktarımına İzin Verme</a></h3>
<p><code>Send</code> işaretleyici tanımı, <code>Send</code>'i sürekleyen türdeki değerlerin sahipliğinin iş parçacıkları arasında aktarılabileceğini gösterir. 
Hemen hemen her Rust türü <code>Send</code>'dir, ancak <code>Rc&lt;T&gt;</code> gibi bazı istisnalar vardır: bu tür <code>Send</code> olamaz, çünkü bir <code>Rc&lt;T&gt;</code> değerini klonlarsanız 
ve klonun sahipliğini başka bir iş parçacığına aktarmaya çalışırsanız, her iki iş parçacığı da referans sayısını aynı anda güncelleyebilir. 
Bu nedenle <code>Rc&lt;T&gt;</code>, iş parçacığı güvenli performans cezasını ödemek istemediğiniz tek iş parçacıklı durumlarda kullanılmak üzere uygulanmıştır.</p>
<p>Bu nedenle, Rust'ın tür sistemi ve tanım bağlılığı, bir <code>Rc&lt;T&gt;</code> değerini asla yanlışlıkla iş parçacıkları arasında güvenli olmayan bir şekilde
gönderemeyeceğinizi garanti eder. Bunu Liste 16-14'te yapmaya çalıştığımızda, <code>Send</code> tanımının <code>Rc&lt;Mutex&lt;i32&gt;&gt;</code> için süreklenmediği hatasını almıştık.
<code>Send</code>'i süreklemiş <code>Arc&lt;T&gt;</code>'ye geçtiğimizde kod derlendi.</p>
<p>Tamamen <code>Send</code> türlerinden oluşan herhangi bir tür de otomatik olarak <code>Send</code> olarak işaretlenir. 
Bölüm 19'da tartışacağımız ham işaretçiler dışında neredeyse tüm ilkel tipler <code>Send</code>'dir.</p>
<h3 id="sync-ile-birden-fazla-İş-parçacığından-erişime-İzin-verme"><a class="header" href="#sync-ile-birden-fazla-İş-parçacığından-erişime-İzin-verme"><code>Sync</code> ile Birden Fazla İş Parçacığından Erişime İzin Verme</a></h3>
<p><code>Sync</code> işaretleyici tanımı, <code>Sync</code>'i sürekleyen türe birden fazla iş parçacığından başvurulmasının güvenli olduğunu belirtir. 
Başka bir deyişle, <code>&amp;T</code> (<code>T</code>'ye değişmez bir referans) <code>Send</code> ise herhangi bir <code>T</code> türü <code>Sync</code>'tir, yani referans başka bir iş 
parçacığına güvenle gönderilebilir. <code>Send</code>'e benzer şekilde, ilkel tipler <code>Sync</code>'tir ve tamamen <code>Sync</code> olan tiplerden oluşan tipler de 
<code>Sync</code>'tir.</p>
<p>Akıllı işaretçi <code>Rc&lt;T&gt;</code> de <code>Send</code> olmamasıyla aynı nedenlerden dolayı <code>Sync</code> değildir. <code>RefCell&lt;T&gt;</code> türü (Bölüm 15'te bahsetmiştik) 
ve ilgili <code>Cell&lt;T&gt;</code> türleri ailesi <code>Sync</code> değildir. <code>RefCell&lt;T&gt;</code>'nin çalışma zamanında yaptığı ödünç alma denetimi uygulaması iş parçacığı 
güvenli değildir. Akıllı işaretçi <code>Mutex&lt;T&gt;</code> <code>Sync</code>'tir ve <a href="ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads">“Bir <code>Mutex&lt;T&gt;</code>'i Birden Fazla İş Parçacığı Arasında Paylaşma”</a><!-- ignore --> bölümünde gördüğünüz gibi erişimi birden fazla iş parçacığı ile paylaşmak için kullanılabilir.</p>
<h3 id="send-ve-synci-manuel-olarak-süreklemek-güvenli-değildir"><a class="header" href="#send-ve-synci-manuel-olarak-süreklemek-güvenli-değildir"><code>Send</code> ve <code>Sync</code>'i Manuel Olarak Süreklemek Güvenli Değildir</a></h3>
<p><code>Send</code> ve <code>Sync</code> tanımlarından oluşan türler otomatik olarak <code>Send</code> ve <code>Sync</code> özelliklerine de sahip olduğundan, 
bu özellikleri manuel olarak süreklememiz gerekmez. İşaretleyici tanımlar olarak, süreklenecek herhangi bir metodları bile yoktur. 
Sadece eşzamanlılıkla ilgili değişmezleri uygulamak için kullanışlıdırlar.</p>
<p>Bu tanımların manuel olarak uygulanması, güvenli olmayan Rust kodunun uygulanmasını gerektirir. 
Güvensiz Rust kodunun kullanımı hakkında Bölüm 19'da konuşacağız; şimdilik önemli bilgi, <code>Send</code> ve <code>Sync</code> parçalarından oluşmayan yeni eşzamanlı 
türler oluşturmanın güvenlik garantilerini korumak için dikkatli düşünmeyi gerektirdiğidir. 
<a href="../nomicon/index.html">“The Rustonomicon”</a> bu garantiler ve bunların nasıl korunacağı hakkında daha fazla bilgi içerir.</p>
<h2 id="Özet-11"><a class="header" href="#Özet-11">Özet</a></h2>
<p>Bu kitapta eşzamanlılıkla ilgili göreceğiniz son şey bu değil: Bölüm 20'deki proje, bu bölümdeki kavramları burada 
tartışılan küçük örneklerden daha gerçekçi bir durumda kullanacaktır.</p>
<p>Daha önce de belirtildiği gibi, Rust'ın eşzamanlılığı nasıl ele aldığının çok azı dilin bir parçası olduğu için, 
birçok eşzamanlılık çözümü kasa olarak süreklenmektedir. Bunlar standart kütüphaneden daha hızlı gelişir, bu
nedenle çok iş parçacıklı durumlarda kullanılacak güncel, son teknoloji ürünü kasalar için doğru çevrimiçi arama yaptığınızdan emin olun.</p>
<p>Rust standart kütüphanesi, mesaj geçişi için kanallar ve eş zamanlı bağlamlarda kullanımı güvenli olan <code>Mutex&lt;T&gt;</code> ve <code>Arc&lt;T&gt;</code> gibi akıllı 
işaretçi türleri sağlar. Tür sistemi ve ödünç denetleyicisi, bu çözümleri kullanan kodun veri yarışları veya geçersiz referanslarla 
sonuçlanmamasını sağlar. Kodunuzun derlenmesini sağladıktan sonra, diğer dillerde yaygın olan izlenmesi zor hata türleri olmadan 
birden fazla iş parçacığında mutlu bir şekilde çalışacağından emin olabilirsiniz. Eşzamanlı programlama artık korkulacak bir kavram değil: 
gidin ve programlarınızı korkusuzca eşzamanlı hale getirin!</p>
<p>Daha sonra, Rust programlarınız büyüdükçe sorunları modellemenin ve çözümleri yapılandırmanın deyimsel yollarından bahsedeceğiz. 
Ayrıca, Rust'ın deyimlerinin nesne yönelimli programlamadan aşina olabileceğiniz deyimlerle nasıl ilişkili olduğunu tartışacağız.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustta-nesne-yönelimli-programlama-Özellikleri"><a class="header" href="#rustta-nesne-yönelimli-programlama-Özellikleri">Rust'ta Nesne Yönelimli Programlama Özellikleri</a></h1>
<p>Nesne Yönelimli Programlama (NYP, OOP) programları modellemenin bir yoludur.</p>
<p>Programlanabilir bir kavram olarak nesneler, 1960'larda Simula dilinde tanıtıldı. 
Bu yaklaşım, Alan Kay'in nesnelerin birbirine mesaj ilettiği programlama mimarisini etkiledi. 
Bu mimariyi tanımlamak için 1967'de nesne yönelimli programlama terimini türetti. 
Birçok rakip dil NYP'nin ne olduğunu tanımlar ve bu tanımların bazılarını baz aldığımız taktirde Rust nesne yönelimlidir, 
ancak diğerleri için değildir. Bu bölümde, yaygın olarak nesne yönelimli dillerin desteklediği kabul edilen belirli özellikleri 
ve bu özelliklerin Rust'a nasıl çevrildiğini keşfedeceğiz. Daha sonra size Rust'ta nesne yönelimli 
bir tasarım deseninin nasıl uygulanacağını göstereceğiz ve bunun yerine Rust'ın bazı güçlü yanlarını kullanarak 
bir çözüm uygulamakla bunun arasındaki farkları tartışacağız.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nesne-yönelimli-dillerin-karakteristik-Özellikleri"><a class="header" href="#nesne-yönelimli-dillerin-karakteristik-Özellikleri">Nesne Yönelimli Dillerin Karakteristik Özellikleri</a></h2>
<p>Programlama topluluğunda, bir dilin nesne yönelimli olarak kabul 
edilmesi için hangi özelliklerin olması gerektiği konusunda bir fikir birliği yoktur. Rust, NYP (OOP) dahil olmak üzere birçok programlama paradigmasından etkilenir; 
örneğin, Bölüm 13'te işlevsel programlamadan gelen özellikleri araştırdık. 
Muhtemelen, NYP dilleri nesneler, kapsülleme ve kalıtım gibi belirli ortak özellikleri paylaşır. 
Bu özelliklerin her birinin ne anlama geldiğine ve Rust'ın bunu destekleyip desteklemediğine bakalım.</p>
<h3 id="nesneler-veri-ve-davranış-İçeriyor"><a class="header" href="#nesneler-veri-ve-davranış-İçeriyor">Nesneler Veri ve Davranış İçeriyor</a></h3>
<p>Erich Gamma, Richard Helm, Ralph Johnson ve John Vlissides (Addison-Wesley Professional, 1994) 
tarafından yazılan <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> kitabı (Addison-Wesley Professional, 1994), 
halk arasında <em>The Gang of Four</em> kitabı olarak anılır, bir nesne kataloğudur. Bu kitap, NYP'ı şu şekilde tanımlar: </p>
<blockquote>
<p>Nesne yönelimli programlar nesnelerden oluşur.
Bir nesne hem verileri hem de bu veriler üzerinde çalışan prosedürleri paketler.
Prosedürlere tipik olarak <em>yöntemler</em> veya <em>işlemler</em> denir. </p>
</blockquote>
<p>Bu tanımı kullanırsak, Rust nesne yönelimlidir: yapılar ve numaralandırılmışlar verilere sahiptir ve <code>impl</code> blokları, 
yapılar ve numaralandırılmışlar üzerinde metodlar sağlar. Metodları olan yapılar ve numaralandırılmışlar nesne olarak adlandırılmasa da, 
The Gang of Four'un nesne tanımına göre aynı işlevselliği sağlarlar.</p>
<h3 id="sürekleme-ayrıntılarını-gizleyen-kapsülleme"><a class="header" href="#sürekleme-ayrıntılarını-gizleyen-kapsülleme">Sürekleme Ayrıntılarını Gizleyen Kapsülleme</a></h3>
<p>NYP ile yaygın olarak ilişkilendirilen başka bir yön, <em>kapsülleme</em> fikridir; 
bu, bir nesnenin uygulama ayrıntılarına o nesneyi kullanarak erişemeyeceği anlamına gelir. 
Bu nedenle, bir nesneyle etkileşim kurmanın tek yolu, onun genel API'sidir; nesneyi kullanan kod, nesnenin iç kısımlarına erişememeli ve verileri veya davranışı doğrudan değiştirememelidir. Bu, programcının, nesneyi kullanan kodu değiştirmeye gerek kalmadan 
bir nesnenin içindekileri değiştirmesini ve yeniden düzenlemesini sağlar.</p>
<p>Kapsüllemenin nasıl kontrol edileceğini Bölüm 7'de tartıştık: 
kodumuzdaki hangi modüllerin, türlerin, fonksiyonların ve yöntemlerin genel olacağına karar vermek için <code>pub</code> anahtar sözcüğünü kullanabiliriz ve varsayılan olarak diğer her şey <code>private</code> olur. Örneğin, bir <code>i32</code> vektörü bir <code>AveragedCollection</code> yapısı tanımlayabiliriz. 
Yapı, vektördeki değerlerin ortalamasını içeren bir alana da sahip olabilir; bu da, herhangi birinin ihtiyaç duyduğunda ortalamanın talep üzerine hesaplanması gerekmediği anlamına gelir. Başka bir deyişle, <code>AveragedCollection</code> hesaplanan ortalamayı bizim için önbelleğe alacaktır. Liste 17-1, <code>AveragedCollection</code> yapısını tanımlar:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
</code></pre>
<p><span class="caption">Liste 17-1: <code>AveragedCollection</code> yapısı koleksiyondaki öğelerin tamsayılarının ve ortalamalarının bir listesini tutar</span></p>
<p>Yapı, diğer kodların kullanabilmesi için <code>pub</code> olarak işaretlenir, ancak yapı içindeki alanlar özel kalır. 
Bu, bu durumda önemlidir, çünkü listeye bir değer eklendiğinde veya listeden çıkarıldığında, ortalamanın da güncellenmesini sağlamak istiyoruz. 
Bunu, Liste 17-2'de gösterildiği gibi, yapıya ekleme, kaldırma ve ortalama fonksiyonlarını uygulayarak yapıyoruz:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
</code></pre>
<p><span class="caption">Liste 17-2: Ortalama toplama, kaldırma ve ortalamaya ilişkin genel fonksiyonların süreklenmesi</span></p>
<p>Genel fonksiyonlar olan ekleme (<code>add</code>), kaldırma (<code>remove</code>) ve ortalama (<code>average</code>), 
bir <code>AveragedCollection</code> örneğindeki verilere erişmenin veya verileri değiştirmenin tek yoludur. 
Bir öğe, ekleme yöntemi kullanılarak listeye eklendiğinde veya kaldır yöntemi kullanılarak kaldırıldığında, 
her birinin süreklemeleri, ortalama alanı güncellemeyi de işleyen özel <code>update_average</code> metodunu çağırır. </p>
<p><code>list</code>'i ve <code>average</code> alanlarını özel olarak tutuyoruz, bu nedenle harici kodun liste alanına doğrudan öğe eklemesi veya liste alanından öğe kaldırması mümkün değildir; aksi takdirde, liste değiştiğinde <code>average</code> alanı senkronize olmayabilir. <code>average</code> metodu, <code>avetage</code> alanındaki değeri döndürür ve harici kodun ortalamayı okumasına ancak değiştirmemesine izin verir. <code>AveragedCollection</code> yapısının sürekleme detaylarını kapsüllediğimiz için, 
gelecekte veri yapısı gibi yönlerini kolayca değiştirebiliriz. </p>
<p>Örneğin, <code>list</code> alanı için <code>Vec&lt;i32&gt;</code> yerine <code>HashSet&lt;i32&gt;</code> kullanabiliriz. 
Ekleme, kaldırma ve ortalama genel metodlarının imzaları aynı kaldığı sürece, <code>AveragedCollection</code> kullanan kodun değişmesi gerekmez. 
Bunun yerine <code>list</code>'i <code>public</code> olarak işleseydik, durum böyle olmazdı: <code>HashSet&lt;i32&gt;</code> ve <code>Vec&lt;i32&gt;</code> öğeleri eklemek ve kaldırmak için farklı yöntemlere sahipti, bu nedenle, listeyi doğrudan değiştiriyorsa harici kodun büyük olasılıkla değişmesi gerekirdi. 
Bir dilin nesne yönelimli olarak kabul edilmesi için kapsülleme gerekli bir özellikse, Rust bu gereksinimi karşılar. 
Kodun farklı bölümleri için <code>pub</code> kullanma veya kullanmama seçeneği, uygulama ayrıntılarının kapsüllenmesini sağlar.</p>
<h3 id="tür-sistemi-ve-kod-paylaşımı-olarak-kalıtım"><a class="header" href="#tür-sistemi-ve-kod-paylaşımı-olarak-kalıtım">Tür Sistemi ve Kod Paylaşımı Olarak Kalıtım</a></h3>
<p><em>Kalıtım</em>, bir nesnenin başka bir nesnenin tanımından öğeleri devralabileceği, böylece onları yeniden tanımlamanıza gerek kalmadan üst nesnenin verilerini ve davranışını kazanabileceği bir mekanizmadır.</p>
<p>Bir dilin nesne yönelimli bir dil olması için kalıtıma sahip olması gerekiyorsa, 
Rust bunlardan birisi değildir. Üst yapının alanlarını ve fonksiyon süreklemelerini devralan bir yapı tanımlamanın bir yolu yoktur. 
Bununla birlikte, programlama araç kutunuzdan kalıtım almaya alıştıysanız, ilk etapta kalıtım için ulaşma nedeninize bağlı olarak Rust'taki diğer çözümleri kullanabilirsiniz.</p>
<p>İki ana nedenden dolayı kalıtımı seçersiniz. Biri kodun yeniden kullanımı içindir: bir tür için belirli davranışı uygulayabilirsiniz ve kalıtım, bu uygulamayı farklı bir tür için yeniden kullanmanızı sağlar. Rust kodunu, <code>Summary</code> tanımındaki <code>summarize</code> metodunun varsayılan bir uygulamasını eklediğimizde Liste 10-14'te gördüğünüz gibi, varsayılan tanım fonksiyon süreklemelerini kullanarak paylaşabilirsiniz. </p>
<p><code>Summary</code> tanımını sürekleyen herhangi bir tür, üzerinde başka bir kod olmadan <code>summarize</code> metoduna da sahip olacaktır. 
Bu, bir metodun süreklemesine sahip bir üst sınıfa ve aynı zamanda yöntemin uygulanmasına sahip olan miras alan bir alt sınıfa benzer. 
Ayrıca, bir üst sınıftan miras alınan bir metodun uygulanmasını geçersiz kılan bir alt sınıfa benzer olan <code>Summary</code> tanımını 
süreklediğimizde, <code>summarize</code> metodunun varsayılan uygulamasını da geçersiz kılabiliriz.</p>
<p>Kalıtımı kullanmanın diğer nedeni, tür sistemiyle ilgilidir: bir alt türün üst türle aynı yerlerde kullanılmasını sağlamaktır. 
Buna <em>polimorfizm</em>, çok biçimlilik de denir; bu, belirli karakteristik özellikleri paylaşıyorlarsa çalışma zamanında birden 
çok nesneyi birbirinin yerine koyabileceğiniz anlamına gelir.</p>
<blockquote>
<h3 id="Çok-biçimlilik"><a class="header" href="#Çok-biçimlilik">Çok Biçimlilik</a></h3>
<p>Birçok insan için çok biçimlilik kalıtımla eş anlamlıdır. 
Aslında, birden çok türdeki verilerle çalışabilen kodu ifade eden daha genel bir kavramdır. 
Kalıtım için bu türler genellikle alt sınıflardır.
Bunun yerine Rust, farklı olası türler üzerinde soyutlamak için yaygın türleri ve bu türlerin sağlaması gerekenlere 
kısıtlamalar getirmek için özellik sınırlarını kullanır. Buna bazen sınırlı <em>parametrik çok biçimlilik</em> de denir.</p>
</blockquote>
<p>Kalıtım, son zamanlarda birçok programlama dilinde bir programlama tasarım çözümü olarak gözden düştü çünkü genellikle gereğinden 
fazla kod paylaşma riskini taşıyor. Alt sınıflar her zaman üst sınıflarının tüm özelliklerini paylaşmamalıdır, ancak bunu 
kalıtımı kullanırsalar yapacaklardır. Bu, bir programın tasarımını daha az esnek hale getirebilir. Ayrıca, mantıklı olmayan 
veya metodların alt sınıfa süreklenmediği durumlar için hatalara neden olan alt sınıflardaki metodları çağırma olasılığını da sunar. 
Ek olarak, bazı diller bir alt sınıfın yalnızca bir sınıftan miras almasına izin vererek program tasarımının esnekliğini daha da kısıtlar.</p>
<p>Bu nedenlerle Rust, kalıtım yerine tanım nesnelerini kullanma konusunda farklı bir yaklaşım benimser. 
Tanım nesnelerinin Rust'ta çok biçimliliği nasıl sağladığına bakalım.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="farklı-türlerdeki-değerlere-İzin-veren-tanım-nesnelerini-kullanma"><a class="header" href="#farklı-türlerdeki-değerlere-İzin-veren-tanım-nesnelerini-kullanma">Farklı Türlerdeki Değerlere İzin Veren Tanım Nesnelerini Kullanma</a></h2>
<p>Bölüm 8'de, vektörlerin bir sınırlamasının yalnızca tek bir türden elemanları saklayabilmeleri olduğundan bahsetmiştik. 
Liste 8-9'da tam sayıları, kayan değerleri ve metni tutmak için varyantları olan bir <code>SpreadsheetCell</code> <code>enum</code>'u tanımladığımız 
geçici bir çözüm oluşturduk. Bu, her hücrede farklı veri türlerini saklayabileceğimiz ve yine de bir hücre satırını temsil eden 
bir vektöre sahip olabileceğimiz anlamına geliyordu. Bu, değiştirilebilir öğelerimiz kodumuz derlendiğinde bildiğimiz sabit bir tür 
kümesi olduğunda mükemmel bir çözümdür.</p>
<p>Ancak, bazen kütüphane kullanıcımızın belirli bir durumda geçerli olan türler kümesini genişletebilmesini isteriz. 
Bunu nasıl başarabileceğimizi göstermek için, GUI araçları için yaygın bir teknik olan, bir öğe listesini yineleyerek her birini ekrana 
çizmek için bir <code>draw</code> yöntemini çağıran örnek bir grafik kullanıcı arayüzü (GUI) aracı oluşturacağız. 
GUI kütüphanesinin yapısını içeren <code>gui</code> adında bir kütüphane kasası oluşturacağız. Bu kasa insanların kullanması için 
<code>Button</code> veya <code>TextField</code> gibi bazı türler içerebilir. Buna ek olarak, gui kullanıcıları çizilebilecek kendi türlerini 
oluşturmak isteyeceklerdir: örneğin, bir programcı bir <code>Image</code> ekleyebilir ve bir diğeri bir <code>SelectBox</code> ekleyebilir.</p>
<p>Bu örnek için tam teşekküllü bir GUI kütüphanesi uygulamayacağız ancak parçaların birbirine nasıl uyacağını göstereceğiz. 
Kütüphaneyi yazarken, diğer programcıların oluşturmak isteyebileceği tüm türleri bilemeyiz ve tanımlayamayız. 
Ancak <code>gui</code>'nin farklı tiplerdeki birçok değeri takip etmesi gerektiğini ve bu farklı tipteki değerlerin her biri için bir 
<code>draw</code> metodu çağırması gerektiğini biliyoruz. <code>draw</code> metodunu çağırdığımızda tam olarak ne olacağını bilmesine gerek yoktur, 
sadece değerin çağırmamız için bu metoda sahip olması yeterlidir.</p>
<p>Bunu kalıtımın olduğu bir dilde yapmak için, üzerinde <code>draw</code> adında bir yöntem bulunan <code>Component</code> adında bir sınıf tanımlayabiliriz. 
<code>Button</code>, <code>Image</code> ve <code>SelectBox</code> gibi diğer sınıflar <code>Component</code>'ten miras alır ve böylece <code>draw</code> yöntemini miras alır. 
Her biri kendi özel davranışlarını tanımlamak için <code>draw</code> yöntemini geçersiz kılabilir, ancak çerçeve tüm türlere <code>Component</code> örneğiymiş 
gibi davranabilir ve <code>draw</code> yöntemini çağırabilir. Ancak Rust'ta kalıtım olmadığı için, kullanıcıların yeni türlerle genişletmesine 
izin vermek üzere <code>gui</code> kütüphanesini yapılandırmak için başka bir yola ihtiyacımız var.</p>
<h3 id="ortak-davranış-için-bir-Özellik-tanımlama"><a class="header" href="#ortak-davranış-için-bir-Özellik-tanımlama">Ortak Davranış için Bir Özellik Tanımlama</a></h3>
<p><code>gui</code>'nin sahip olmasını istediğimiz davranışı uygulamak için, <code>draw</code> adında bir metoda sahip olacak <code>Draw</code> adında bir <code>trait</code> tanımlayacağız. 
Daha sonra bir <code>trait</code> nesnesi alan bir vektör tanımlayabiliriz. Bir <code>trait</code> nesnesi, hem belirttiğimiz <code>trait</code>'i uygulayan bir türün 
örneğine hem de çalışma zamanında bu türdeki <code>trait</code> yöntemlerini aramak için kullanılan bir tabloya işaret eder. 
Bir <code>&amp;</code> referansı veya <code>Box&lt;T&gt;</code> akıllı işaretçisi gibi bir tür işaretçi, ardından dyn anahtar sözcüğü ve ardından ilgili özelliği 
belirterek bir <code>trait</code> nesnesi oluştururuz. (Özellik nesnelerinin neden bir işaretçi kullanması gerektiğinden Bölüm 19'da 
<a href="ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait">“Dinamik Olarak Boyutlandırılmış Türler ve <code>Sized</code> Tanımı”</a><!-- ignore --> bölümünde bahsedeceğiz). Tanım nesnelerini 
yaygın veya somut bir tip yerine kullanabiliriz. Bir <code>trait</code> nesnesi kullandığımız her yerde, Rust'ın tür sistemi derleme zamanında bu 
bağlamda kullanılan herhangi bir değerin <code>trait</code> nesnesinin özelliğini uygulamasını sağlayacaktır. Sonuç olarak, derleme zamanında tüm 
olası türleri bilmemize gerek yoktur.</p>
<p>Rust'ta <code>struct</code> ve <code>enum</code>'ları diğer dillerin nesnelerinden ayırmak için “nesne” olarak adlandırmaktan kaçındığımızdan bahsetmiştik. 
Bir <code>struct</code> veya <code>enum</code>'da, <code>struct</code> alanlarındaki veri ve <code>impl</code> bloklarındaki davranış birbirinden ayrılırken, diğer dillerde veri ve 
davranış tek bir kavramda birleştirilir ve genellikle bir nesne olarak etiketlenir. Bununla birlikte, tanım nesneleri, 
veri ve davranışı birleştirmeleri açısından diğer dillerdeki nesnelere daha çok benzemektedir. Ancak <code>trait</code> nesneleri, 
bir <code>trait</code> nesnesine veri ekleyemediğimiz için geleneksel nesnelerden farklıdır. Özellik nesneleri diğer dillerdeki nesneler kadar 
genel olarak kullanışlı değildir: özel amaçları ortak davranışlar arasında soyutlamaya izin vermektir.</p>
<p>Liste 17-3, <code>draw</code> adında bir yöntemle <code>Draw</code> adında bir özelliğin nasıl tanımlanacağını gösterir:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Draw {
    fn draw(&amp;self);
}
</code></pre>
<p><span class="caption">Liste 17-3: <code>Draw</code> tanımının tanımı</span></p>
<p>This syntax should look familiar from our discussions on how to define traits
in Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct named
<code>Screen</code> that holds a vector named <code>components</code>. This vector is of type
<code>Box&lt;dyn Draw&gt;</code>, which is a trait object; it’s a stand-in for any type inside
a <code>Box</code> that implements the <code>Draw</code> trait.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}
</code></pre>
<p><span class="caption">Liste 17-4: <code>Draw</code> tanımını uygulayan tanım nesnelerinden oluşan bir vektörü tutan 
<code>components</code> alanına sahip <code>Screen</code> yapısının tanımı</span></p>
<p><code>Screen</code> yapısında, Liste 17-5'te gösterildiği gibi, <code>components</code>'in her birinde <code>draw</code> yöntemini çağıracak <code>run</code> adında bir 
yöntem tanımlayacağız:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
</code></pre>
<p><span class="caption">Liste 17-5: Her bileşende <code>draw</code> yöntemini çağıran <code>Screen</code> üzerinde bir <code>run</code> yöntemi</span></p>
<p>Bu, özellik sınırları olan genel bir tür parametresi kullanan bir <code>struct</code> tanımlamaktan farklı çalışır. 
Bir yaygın tür parametresi bir seferde yalnızca bir somut tiple değiştirilebilirken, 
tanım nesneleri çalışma zamanında birden fazla somut tipin özellik nesnesinin yerini doldurmasına izin verir. 
Örneğin, <code>Screen</code> yapısını Liste 17-6'daki gibi bir yaygın tip ve bir tanım bağı kullanarak tanımlayabilirdik:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
</code></pre>
<p><span class="caption">Liste 17-6: Yaygınlar ve tanım sınırlarını kullanarak <code>Screen</code> yapısının ve <code>run</code> yönteminin alternatif bir uygulaması</span></p>
<p>Bu, bizi, tümü <code>Button</code> türünden veya tümü <code>TextField</code> türünden bileşenlerin bir listesini içeren bir <code>Screen</code> örneğiyle sınırlar. 
Yalnızca homojen koleksiyonlarınız olacaksa, yaygınlar ve özellik sınırlarının kullanılması tercih edilir, çünkü somut türleri kullanmak 
için tanımlar derleme zamanında monomorfize edilecektir.</p>
<p>Öte yandan, özellik nesnelerini kullanan yöntemle, bir <code>Screen</code> örneği, <code>Box&lt;Button&gt;</code> ve <code>Box&lt;TextField&gt;</code> içeren bir <code>Vec&lt;T&gt;</code> içerebilir. 
Bunun nasıl çalıştığına bakalım ve ardından çalışma zamanı performans sonuçları hakkında konuşacağız.</p>
<h3 id="tanımı-uygulamak"><a class="header" href="#tanımı-uygulamak">Tanımı Uygulamak</a></h3>
<p>Şimdi <code>Draw</code> özelliğini uygulayan bazı türleri ekleyeceğiz. <code>Button</code> türünü sağlayacağız. Yine, aslında bir GUI kütüphanesini 
uygulamak bu kitabın kapsamı dışındadır, bu nedenle <code>draw</code> yönteminin gövdesinde herhangi bir çalışan süreklemesi olmayacaktır. 
Uygulamanın nasıl görünebileceğini hayal etmek için, bir <code>Button</code> yapısında Liste 17-7'de 
gösterildiği gibi <code>width</code>, <code>height</code> ve <code>label</code> alanları olabilir:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Screen {
</span><span class="boring">    pub fn run(&amp;self) {
</span><span class="boring">        for component in self.components.iter() {
</span><span class="boring">            component.draw();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
    }
}
</code></pre>
<p><span class="caption">Liste 17-7: <code>Draw</code> tanımını uygulayan bir <code>Button</code> 
yapısı</span></p>
<p><code>Button</code>'daki <code>width</code>, <code>height</code> ve <code>label</code> alanları diğer bileşenlerdeki alanlardan farklı olacaktır; 
örneğin, bir <code>TextField</code> türü aynı alanlara ve bir yer tutucu alana sahip olabilir. Ekranda çizmek istediğimiz türlerin her 
biri <code>Draw</code> tanımını uygular, ancak burada <code>Button</code>'da olduğu gibi (belirtildiği gibi gerçek GUI kodu olmadan) 
söz konusu türün nasıl çizileceğini tanımlamak için draw yönteminde farklı kod kullanır. 
Örneğin <code>Button</code> tipi, kullanıcı düğmeye tıkladığında ne olacağıyla ilgili metotları içeren ek bir <code>impl</code> bloğuna sahip olabilir. 
Bu tür yöntemler <code>TextField</code> gibi türler için geçerli olmayacaktır.</p>
<p>Kütüphanemizi kullanan biri <code>width</code>, <code>height</code> ve <code>options</code> alanları olan bir <code>SelectBox</code> yapısını uygulamaya karar verirse, 
Liste 17-8'de gösterildiği gibi <code>SelectBox</code> türüne <code>Draw</code> tanımını da uygular:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p><span class="caption">Liste 17-8: Bir <code>SelectBox</code> yapısı üzerinde <code>gui</code> kullanan ve <code>Draw</code> tanımını uygulayan başka bir kasa</span></p>
<p>Kütüphanemizin kullanıcısı artık bir <code>Screen</code> örneği oluşturmak için <code>main</code> fonksiyonunu yazabilir. 
<code>Screen</code> örneğine bir <code>SelectBox</code> ve bir <code>Button</code> ekleyebilir ve her birini bir <code>Box&lt;T&gt;</code> içine koyarak bir <code>trait</code> nesnesi haline getirebilirler. 
Daha sonra <code>Screen</code> örneğinde <code>run</code> metodunu çağırabilirler, bu da her bir bileşen üzerinde <code>draw</code> metodunu çağıracaktır. 
Liste 17-9 bu uygulamayı göstermektedir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use gui::Draw;
</span><span class="boring">
</span><span class="boring">struct SelectBox {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Draw for SelectBox {
</span><span class="boring">    fn draw(&amp;self) {
</span><span class="boring">        // code to actually draw a select box
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">Liste 17-9: Aynı özelliği uygulayan farklı türlerin değerlerini depolamak için tanım 
nesnelerini kullanma</span></p>
<p>Kütüphaneyi yazarken, birinin <code>SelectBox</code> türünü ekleyebileceğini bilmiyorduk, 
ancak <code>Screen</code> uygulamamız yeni tür üzerinde çalışabiliyor ve onu çizebiliyordu çünkü <code>SelectBox</code> <code>Draw</code> özelliğini uyguluyor, 
yani <code>draw</code> yöntemini uyguluyor.</p>
<p>Bu kavram - bir değerin somut türünden ziyade yalnızca değerin yanıt verdiği mesajlarla ilgilenmek - dinamik olarak yazılan dillerdeki <em>ördek gibi 
yazma</em> kavramına benzer: ördek gibi yürüyorsa ve ördek gibi vaklıyorsa, o zaman bir ördek olmalıdır! Liste 17-5'teki <code>run on Screen</code> 
uygulamasında, <code>run</code>'ın her bir bileşenin somut türünün ne olduğunu bilmesine gerek yoktur. Bir bileşenin <code>Button</code> ya da <code>SelectBox</code> örneği 
olup olmadığını kontrol etmez, sadece bileşen üzerindeki <code>draw</code> yöntemini çağırır. Bileşenler vektöründeki değerlerin türü olarak 
<code>Box&lt;dyn Draw&gt;</code> belirterek, <code>Screen</code>'i <code>draw</code> yöntemini çağırabileceğimiz değerlere ihtiyaç duyacak şekilde tanımladık.</p>
<p>Ördek tiplemesi kullanan kodlara benzer kod yazmak için <code>trait</code> nesnelerini ve Rust'ın tür sistemini kullanmanın avantajı, 
çalışma zamanında bir değerin belirli bir yöntemi uygulayıp uygulamadığını kontrol etmek zorunda kalmamamız veya bir değer bir yöntemi 
uygulamıyorsa ancak yine de çağırırsak hata alma konusunda endişelenmememizdir. Değerler, özellik nesnelerinin ihtiyaç duyduğu özellikleri 
uygulamıyorsa Rust kodumuzu derlemeyecektir.</p>
<p>Örneğin, Liste 17-10, bileşen olarak <code>String</code> içeren bir <code>Screen</code> oluşturmaya çalıştığımızda ne olacağını gösterir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from(&quot;Hi&quot;))],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">Liste 17-10: Tanım nesnesinin özelliğini uygulamayan bir tür kullanmaya çalışmak</span></p>
<p><code>String</code>, <code>Draw</code> özelliğini uygulamadığı için bu hatayı alıyoruz:</p>
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `String: Draw` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from(&quot;Hi&quot;))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`
  |
  = note: required for the cast to the object type `dyn Draw`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui` due to previous error
</code></pre>
<p>Bu hata bize ya <code>Screen</code>'e geçmek istemediğimiz bir şey geçirdiğimizi ve bu nedenle farklı bir tür geçirmemiz gerektiğini 
ya da <code>Screen</code>'in üzerinde <code>draw</code> çağrısı yapabilmesi için <code>Draw on String</code>'i uygulamamız gerektiğini bildirir.</p>
<h3 id="tanım-nesneleri-dinamik-gönderim-gerçekleştirir"><a class="header" href="#tanım-nesneleri-dinamik-gönderim-gerçekleştirir">Tanım Nesneleri Dinamik Gönderim Gerçekleştirir</a></h3>
<p>Bölüm 10'daki <a href="ch10-01-syntax.html#performance-of-code-using-generics">“Yaygınları Kullanan Kodun Performansı”</a><!-- ignore --> bölümünde, 
yaygınlarda özellik sınırları kullandığımızda derleyici tarafından gerçekleştirilen monomorfizasyon işlemi hakkındaki tartışmamızı 
hatırlayın: derleyici, yaygın tür parametresi yerine kullandığımız her somut tip için fonksiyonların ve metodların yaygın olmayan 
uygulamalarını üretir. Monomorfizasyondan kaynaklanan kod, derleyicinin derleme zamanında hangi yöntemi çağırdığınızı bildiği 
statik gönderim yapıyor. Bu, derleyicinin derleme sırasında hangi yöntemi çağırdığınızı bilemediği dinamik gönderime zıttır. 
Dinamik gönderim durumlarında, derleyici çalışma zamanında hangi yöntemin çağrılacağını belirleyecek kodu yayınlar.</p>
<p>Tanım nesnelerini kullandığımızda, Rust dinamik gönderim kullanacaktır. Derleyici, <code>trait</code> nesnelerini kullanan kodla kullanılabilecek tüm 
türleri bilmez, bu nedenle hangi türde hangi yöntemin uygulanacağını bilemez. Bunun yerine, çalışma zamanında Rust, hangi yöntemin çağrılacağını 
bilmek için <code>trait</code> nesnesinin içindeki işaretçileri kullanır. Bu arama, statik gönderim ile oluşmayan bir çalışma zamanı maliyetine neden olur. 
Dinamik gönderim ayrıca derleyicinin bir yöntemin kodunu satır içi yapmayı seçmesini engeller ve bu da bazı optimizasyonları önler. 
Ancak, Liste 17-5'te yazdığımız ve Liste 17-9'da destekleyebildiğimiz kodda ekstra esneklik elde ettik, 
bu nedenle dikkate alınması gereken bir değiş tokuş.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nesneye-yönelik-tasarım-modeli-uygulamak"><a class="header" href="#nesneye-yönelik-tasarım-modeli-uygulamak">Nesneye Yönelik Tasarım Modeli Uygulamak</a></h2>
<p><em>Durum kalıbı</em>, nesne yönelimli bir tasarım kalıbıdır. Desenin özü, bir değerin dahili olarak sahip olabileceği bir dizi durum tanımlamamızdır. 
Durumlar bir dizi durum nesnesi ile temsil edilir ve değerin davranışı durumuna bağlı olarak değişir. &quot;draft&quot;, &quot;review&quot; veya &quot;published&quot; 
kümesinden bir durum nesnesi olacak şekilde durumunu tutmak için bir alana sahip olan bir blog yazısı yapısı örneği üzerinde çalışacağız.</p>
<p>Durum nesneleri işlevselliği paylaşır: Rust'ta elbette nesneler ve kalıtım yerine yapıları ve özellikleri kullanırız. 
Her durum nesnesi kendi davranışından ve ne zaman başka bir duruma geçmesi gerektiğini yönetmekten sorumludur. 
Bir durum nesnesini tutan değer, durumların farklı davranışları veya durumlar arasında ne zaman geçiş yapılacağı hakkında hiçbir şey bilmez.</p>
<p>Durum kalıbını kullanmanın avantajı, programın iş gereksinimleri değiştiğinde, durumu tutan değerin kodunu veya değeri kullanan kodu 
değiştirmemize gerek kalmamasıdır. Kurallarını değiştirmek ya da belki daha fazla durum nesnesi eklemek için yalnızca 
durum nesnelerinden birinin içindeki kodu güncellememiz gerekecektir. Durum modelini kullanarak bir blog yazısı iş akışını aşamalı 
olarak uygulamaya başlayalım.</p>
<p>Nihai işlevsellik şu şekilde görünecektir:</p>
<p>The final functionality will look like this:</p>
<ol>
<li>Bir blog gönderisi boş bir taslak olarak başlar.</li>
<li>Taslak yapıldığında, gönderinin gözden geçirilmesi istenir.</li>
<li>Gönderi onaylandığında yayınlanır.</li>
<li>Yalnızca yayınlanan blog gönderileri, içeriği yazdırılacak şekilde döndürür, bu nedenle 
onaylanmamış gönderiler yanlışlıkla yayınlanamaz.</li>
</ol>
<p>Bir gönderide yapılmaya çalışılan diğer değişikliklerin hiçbir etkisi olmamalıdır. 
Örneğin, inceleme talep etmeden önce taslak bir blog gönderisini onaylamaya çalışırsak, 
gönderi yayınlanmamış bir taslak olarak kalmalıdır.</p>
<p>Liste 17-11 bu iş akışını kod biçiminde göstermektedir: bu, <code>blog</code> adlı bir kütüphane kasasına uygulayacağımız API'nin örnek bir kullanımıdır. 
Bu henüz derlenmeyecektir çünkü <code>blog</code> crate'ini henüz yazmadık.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">Liste 17-11: <code>blog</code> kasamızda olmasını istediğimiz davranışı gösteren kod</span></p>
<p>Kullanıcının <code>Post::new</code> ile yeni bir taslak blog yazısı oluşturmasına izin vermek istiyoruz. Blog yazısına metin eklenmesine izin vermek 
istiyoruz. Onaydan önce yazının içeriğini hemen almaya çalışırsak, yazı hala taslak olduğu için herhangi bir metin almamalıyız. 
Gösterim amacıyla koda <code>assert_eq!</code> ekledik. Bunun için mükemmel bir birim testi, taslak bir blog gönderisinin içerik yönteminden 
boş bir dize döndürdüğünü iddia etmek olurdu, ancak bu örnek için test yazmayacağız.</p>
<p>Daha sonra, yazının incelenmesi için bir isteği etkinleştirmek istiyoruz ve inceleme beklenirken içeriğin boş bir dize döndürmesini 
istiyoruz. Gönderi onay aldığında yayınlanmalıdır, yani content çağrıldığında gönderi metni döndürülecektir.</p>
<p>Kasadan etkileşimde bulunduğumuz tek türün <code>Post</code> türü olduğuna dikkat edin. Bu tür durum kalıbını kullanacak ve bir gönderinin 
taslak halinde, inceleme için bekliyor veya yayınlanmış olabileceği çeşitli durumları temsil eden üç durum nesnesinden biri olacak bir 
değer tutacaktır. Bir durumdan diğerine geçiş <code>Post</code> türü içinde dahili olarak yönetilecektir. Durumlar, kütüphanemizin kullanıcıları 
tarafından <code>Post</code> tanımı üzerinde çağrılan metodlara yanıt olarak değişir, ancak durum değişikliklerini doğrudan yönetmeleri gerekmez. 
Ayrıca kullanıcılar, bir gönderiyi incelenmeden önce yayınlamak gibi durumlarla ilgili bir hata yapamazlar.</p>
<h3 id="postu-tanımlama-ve-taslak-durumunda-yeni-bir-Örnek-oluşturma"><a class="header" href="#postu-tanımlama-ve-taslak-durumunda-yeni-bir-Örnek-oluşturma">Post'u Tanımlama ve Taslak Durumunda Yeni Bir Örnek Oluşturma</a></h3>
<p>Kütüphanenin yazılmasına başlayalım! Bazı içerikleri tutan genel bir <code>Post</code> yapısına ihtiyacımız olduğunu biliyoruz, 
bu nedenle yapının tanımı ve bir <code>Post</code> tanımı oluşturmak için ilişkili bir genel <code>new</code> fonksiyonu ile başlayacağız, 
Liste 17-12'de gösterildiği gibi. Ayrıca bir <code>Post için</code> tüm durum nesnelerinin sahip olması gereken davranışı tanımlayacak özel bir 
<code>State</code> tanımı oluşturacağız.</p>
<p>Ardından <code>Post</code>, durum nesnesini tutmak için <code>state</code> adlı özel bir alanda bir <code>Option&lt;T&gt;</code> içinde <code>Box&lt;dyn State&gt;</code>'in <code>trait</code> nesnesini 
tutacaktır. <code>Option&lt;T&gt;</code>'nin neden gerekli olduğunu birazdan göreceksiniz.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
</code></pre>
<p><span class="caption">Liste 17-12: Yeni bir <code>Post</code> örneği, bir <code>State</code> tanımı ve bir <code>Draft</code> yapısı oluşturan <code>Post</code> yapısının ve 
<code>new</code> fonksiyonunun tanımı</span></p>
<p><code>State</code> özelliği, farklı posta durumları tarafından paylaşılan davranışı tanımlar. <code>State</code> nesneleri <code>Draft</code>, <code>PendingReview</code> ve <code>Published</code>'dir 
ve hepsi <code>State</code> tanımını uygular. Şimdilik, tanımın herhangi bir metodu yoktur ve sadece <code>Draft</code> durumunu tanımlayarak başlayacağız 
çünkü bir gönderinin başlamasını istediğimiz durum budur.</p>
<p>Yeni bir <code>Post</code> oluşturduğumuzda, <code>state</code> alanını bir <code>Box</code> tutan <code>Some</code> değerine ayarlarız. Bu <code>Box</code>, <code>Draft</code> yapısının yeni bir 
örneğine işaret eder. Bu, yeni bir <code>Post</code> örneği oluşturduğumuzda, taslak olarak başlamasını sağlar. <code>Post</code>'un durum alanı özel olduğu için, 
başka bir durumda bir <code>Post</code> oluşturmanın hiçbir yolu yoktur! <code>Post::new</code> fonksiyonunda, <code>content</code> alanını yeni, boş bir <code>String</code> olarak ayarlarız.</p>
<h3 id="gönderi-İçeriği-metnini-saklama"><a class="header" href="#gönderi-İçeriği-metnini-saklama">Gönderi İçeriği Metnini Saklama</a></h3>
<p>Liste 17-11'de <code>add_text</code> adlı bir metodu çağırabilmek ve ona blog yazısının metin içeriği olarak eklenecek bir <code>&amp;str</code> iletebilmek istediğimizi 
gördük. Bunu, içerik alanını <code>pub</code> olarak göstermek yerine bir metod olarak uyguluyoruz, böylece daha sonra içerik alanının 
verilerinin nasıl okunacağını kontrol edecek bir metod uygulayabiliriz. <code>add_text</code> metodu oldukça basittir, bu nedenle Liste 17-13'teki 
uygulamayı <code>impl Post</code> bloğuna ekleyelim:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}
</span></code></pre>
<p><span class="caption">Liste 17-13: Bir gönderinin <code>content</code>'ine metin eklemek için <code>add_text</code> metodunu
süreklemek</span></p>
<p><code>add_text</code> metodu <code>self</code> öğesine değişebilir bir referans alır, çünkü <code>add_text</code> öğesini çağırdığımız <code>Post</code> tanımını değiştiriyoruz. 
Daha sonra <code>content</code>'teki <code>String</code> üzerinde <code>push_str</code>'yi çağırıyoruz ve kaydedilen içeriğe eklemek için metin argümanını iletiyoruz. 
Bu davranış, gönderinin içinde bulunduğu duruma bağlı değildir, bu nedenle durum modelinin bir parçası değildir. 
<code>add_text</code> yöntemi <code>state</code> alanıyla hiç etkileşime girmez, ancak desteklemek istediğimiz davranışın bir parçasıdır.</p>
<h3 id="taslak-gönderinin-İçeriğinin-boş-olmasını-sağlama"><a class="header" href="#taslak-gönderinin-İçeriğinin-boş-olmasını-sağlama">Taslak Gönderinin İçeriğinin Boş Olmasını Sağlama</a></h3>
<p><code>add_text</code> öğesini çağırdıktan ve gönderimize bir miktar içerik ekledikten sonra bile, Liste 17-11'in 7. satırında gösterildiği gibi, 
gönderi hala taslak durumunda olduğu için <code>content</code> metodunun boş bir dizgi dilimi döndürmesini istiyoruz. Şimdilik, <code>content</code> 
metodunu bu gereksinimi karşılayacak en basit şeyle uygulayalım: her zaman boş bir dizgi dilimi döndürmek. Bunu daha sonra bir gönderinin 
durumunu değiştirip yayınlanabilmesini sağladığımızda değiştireceğiz. Şimdiye kadar, yazılar yalnızca taslak durumunda olabilir, 
bu nedenle yazı içeriği her zaman boş olmalıdır. Liste 17-14 bu yer tutucu uygulamasını göstermektedir:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}
</span></code></pre>
<p><span class="caption">Liste 17-14: <code>Post</code>'a <code>content</code> metodu için her zaman boş bir dizgi dilimi 
döndüren bir yer tutucu süreklemesi ekleme</span></p>
<p>Bu eklenen <code>content</code> metoduyla, Liste 17-11'den 7. satıra kadar her şey amaçlandığı gibi çalışır.</p>
<h3 id="gönderinin-durumu-değişikliklerinin-gözden-geçirilmesini-talep-etme"><a class="header" href="#gönderinin-durumu-değişikliklerinin-gözden-geçirilmesini-talep-etme">Gönderinin Durumu Değişikliklerinin Gözden Geçirilmesini Talep Etme</a></h3>
<p>Ardından, durumunu <code>Draft</code>'tan <code>PendingReview</code> olarak değiştirmesi gereken bir gönderinin gözden geçirilmesini istemek 
için işlevsellik eklememiz gerekiyor. Liste 17-15 bu kodu gösterir:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
</code></pre>
<p><span class="caption">Liste 17-15: <code>Post</code> ve <code>State</code> tanımı üzerinde <code>request_review</code> metodlarının 
yazılması</span></p>
<p><code>Post</code>'a, <code>self</code> öğesine değişken bir referans alacak <code>request_review</code> adında bir genel metod veriyoruz. 
Ardından <code>Post</code>'un mevcut durumu üzerinde dahili bir <code>request_review</code> metodunu çağırıyoruz ve bu ikinci <code>request_review</code> metodu 
mevcut durumu tüketip yeni bir durum döndürüyor.</p>
<p><code>request_review</code> metodunu <code>State</code> tanımını ekliyoruz; tanımı uygulayan tüm türlerin artık <code>request_review</code> metodunu uygulaması gerekecektir. 
Metodun ilk parametresinin <code>self</code>, <code>&amp;self</code> veya <code>&amp;mut self</code> yerine <code>self</code> olduğuna dikkat edin: <code>Box&lt;Self&gt;</code>. Bu söz dizimi, 
yöntemin yalnızca türü taşıyan bir <code>Box</code> üzerinde çağrıldığında geçerli olduğu anlamına gelir. Bu söz dizimi <code>Box&lt;Self&gt;</code>'in sahipliğini 
alarak eski durumu geçersiz kılar, böylece <code>Post</code>'un durum değeri yeni bir duruma dönüşebilir.</p>
<p>Eski durumu kullanmak için <code>request_review</code> yönteminin durum değerinin sahipliğini alması gerekir. <code>Post</code>'un <code>state</code> alanındaki 
<code>Option</code> burada devreye girer: <code>take</code> metodunu çağırarak <code>Some</code> değerini <code>state</code> alanından çıkarırız ve yerine <code>None</code> değerini bırakırız, 
çünkü Rust yapılarda doldurulmamış alanlar olmasına izin vermez. Bu, <code>state</code> değerini ödünç almak yerine <code>Post</code>'un dışına taşımamızı sağlar. 
Daha sonra <code>post</code>'un <code>state</code> değerini bu işlemin sonucuna ayarlayacağız.</p>
<p><code>State</code> değerinin sahipliğini almak için <code>self.state = self.state.request_review();</code> gibi bir kodla doğrudan ayarlamak yerine 
<code>state</code> değerini geçici olarak <code>None</code> olarak ayarlamamız gerekir. Bu, <code>Post</code>'un biz onu yeni bir duruma dönüştürdükten sonra 
eski durum değerini kullanamamasını sağlar.</p>
<p><code>Draft</code> üzerindeki <code>request_review</code> yöntemi, bir gönderinin inceleme için beklediği durumu temsil eden yeni bir <code>PendingReview</code> yapısının yeni, 
<code>Box</code>'un bir örneğini döndürür. <code>PendingReview</code> <code>struct</code>'ı da <code>request_review</code> yöntemini uygular ancak herhangi bir dönüştürme yapmaz. 
Bunun yerine, kendisini döndürür, çünkü zaten <code>PendingReview</code> durumunda olan bir gönderi için inceleme istediğimizde, gönderi <code>PendingReview</code> 
durumunda kalmalıdır.</p>
<p>Şimdi <code>state</code> modelinin avantajlarını görmeye başlayabiliriz: <code>Post</code> üzerindeki <code>request_review</code> yöntemi, <code>state</code> değeri ne olursa olsun aynıdır. 
Her <code>state</code> kendi kurallarından sorumludur.</p>
<p><code>Post</code> üzerindeki <code>content</code> metodunu olduğu gibi bırakacağız ve boş bir dizgi dilimi döndüreceğiz. Artık hem <code>PendingReview</code> durumunda hem de 
<code>Draft</code> durumunda bir <code>Post</code>'a sahip olabiliriz, ancak <code>PendingReview</code> durumunda aynı davranışı istiyoruz. 
Liste 17-11 artık 10. satıra kadar çalışıyor!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a></p>
<h3 id="contentin-davranışını-değiştirmek-için-approve-ekleme"><a class="header" href="#contentin-davranışını-değiştirmek-için-approve-ekleme"><code>content</code>'in Davranışını Değiştirmek için <code>approve</code> Ekleme</a></h3>
<p><code>approve</code> metodu <code>request_review</code> metoduna benzer olacaktır: <code>state</code>'i, mevcut <code>state</code>'in onaylandığında sahip olması 
gerektiğini söylediği değere ayarlayacaktır, Liste 17-16'da gösterildiği gibi:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
</code></pre>
<p><span class="caption">Liste 17-16: <code>Post</code> ve <code>State</code> tanımı üzerinde <code>approve</code> metodunu uygulama</span></p>
<p><code>State</code> tanımına <code>approve</code> metodunu ekliyoruz ve <code>Published</code> durum olan <code>State</code>'i uygulayan yeni bir <code>struct</code> ekliyoruz.</p>
<p><code>PendingReview</code> üzerinde <code>request_review</code> metodunun çalışmasına benzer şekilde, bir <code>Draft</code> üzerinde <code>approve</code> yöntemini çağırırsak, 
<code>approve</code> <code>self</code> değerini döndüreceği için hiçbir etkisi olmayacaktır. <code>PendingReview</code> üzerinde <code>approve</code> yöntemini çağırdığımızda, 
<code>Published</code> yapısının yeni, <code>Box</code>'un bir tanımını döndürür. <code>Published</code> <code>struct</code>'ı, <code>State</code> tanımını uygular ve 
hem <code>request_review</code> yöntemi hem de <code>approve</code> yöntemi için kendini döndürür, çünkü bu durumlarda gönderi <code>Published</code> durumunda kalmalıdır.</p>
<p>Şimdi <code>Post</code> üzerindeki <code>content</code> metodunu güncellememiz gerekiyor. <code>Content</code>'ten döndürülen değerin <code>Post</code>'un mevcut durumuna 
bağlı olmasını istiyoruz, bu nedenle <code>Post</code>'un Liste 17-17'de gösterildiği gibi durumuna göre tanımlanmış bir <code>content</code> metoduna 
temsilci göndermesini sağlayacağız:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 17-17: <code>State</code>'de bir <code>content</code> metoduna yetki vermek için 
<code>Post</code> üzerindeki <code>content</code> metodunu güncelleme</span></p>
<p>Amaç tüm bu kuralları <code>State</code>'i uygulayan yapıların içinde tutmak olduğundan, <code>state</code>'teki değer üzerinde bir <code>content</code> yöntemi 
çağırıyoruz ve <code>post</code> örneğini (yani <code>self</code>'i) bir argüman olarak geçiriyoruz. Daha sonra <code>state</code> değeri üzerinde <code>content</code> metodunu 
kullanarak döndürülen değeri döndürüyoruz.</p>
<p><code>Option</code> üzerinde <code>as_ref</code> yöntemini çağırıyoruz çünkü değerin sahibi olmak yerine <code>Option</code> içindeki değere bir referans istiyoruz. 
<code>state</code> bir <code>Option&lt;Box&lt;dyn State&gt;&gt;</code> olduğu için, <code>as_ref</code> yöntemini çağırdığımızda bir <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code> döndürülür. 
Eğer <code>as_ref</code>'i çağırmasaydık, <code>state</code>'i fonksiyon parametresinin ödünç alınan <code>&amp;self</code>'inin dışına taşıyamayacağımız için bir hata alırdık.</p>
<p>Daha sonra <code>unwrap</code> metodunu çağırıyoruz, ki bu metodun asla panik yaratmayacağını biliyoruz, çünkü <code>Post</code> üzerindeki metodların, 
bu metodlar tamamlandığında <code>state</code>'in her zaman <code>Some</code> değeri içereceğini garanti ettiğini biliyoruz. 
Bu, Bölüm 9'un <a href="ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler">“Derleyiciden Daha Fazla Bilgiye Sahip Olduğunuz Durumlar”</a><!-- ignore --> kısmında bahsettiğimiz, 
derleyici bunu anlayamasa da None değerinin asla mümkün olmadığını bildiğimiz durumlardan biridir.</p>
<p>Bu noktada, <code>&amp;Box&lt;dyn State&gt;</code> üzerinde <code>content</code>'i çağırdığımızda, <em>deref zorlaması</em> <code>&amp;</code> ve <code>Box</code> üzerinde etkili olacak, 
böylece <code>content</code> yöntemi sonuçta <code>State</code> tanımını uygulayan tür üzerinde çağrılacaktır. 
Bu, <code>State</code> özellik tanımına içerik eklememiz gerektiği anlamına gelir ve Liste 17-18'de gösterildiği gibi, hangi duruma sahip 
olduğumuza bağlı olarak hangi içeriğin döndürüleceğine ilişkin mantığı buraya koyacağız:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
</code></pre>
<p><span class="caption">Liste 17-18: <code>State</code> tanımına <code>content</code> yöntemini ekleme</span></p>
<p><code>content</code> yöntemi için boş bir dizgi dilimi döndüren varsayılan bir uygulama ekliyoruz. 
Bu, <code>Draft</code> ve <code>PendingReview</code> yapılarında içerik uygulamamıza gerek olmadığı anlamına gelir. <code>Published</code> <code>struct</code>'ı, 
<code>content</code> yöntemini geçersiz kılacak ve <code>post.content</code> içindeki değeri döndürecektir.</p>
<p>Bölüm 10'da tartıştığımız gibi, bu yöntem üzerinde yaşam süresi ek açıklamalarına ihtiyacımız olduğunu unutmayın. 
Argüman olarak bir gönderiye referans alıyoruz ve bu gönderinin bir kısmına referans döndürüyoruz, 
bu nedenle döndürülen referansın yaşam süresi post argümanının yaşam süresiyle ilişkilidir.</p>
<p>Ve işimiz bitti - Liste 17-11'in tamamı artık çalışıyor! <code>State</code> modelini blog yazısı iş akışı kurallarıyla uyguladık. 
Kurallarla ilgili mantık, <code>Post</code>'un içine dağılmak yerine <code>state</code> nesnelerinde yaşıyor.</p>
<h3 id="durum-kalıbının-Ödünleşimleri"><a class="header" href="#durum-kalıbının-Ödünleşimleri">Durum Kalıbının Ödünleşimleri</a></h3>
<p>Rust'ın, bir gönderinin her bir durumda sahip olması gereken farklı davranış türlerini kapsüllemek için nesne 
yönelimli durum modelini uygulayabildiğini gösterdik. Post üzerindeki yöntemler çeşitli davranışlar hakkında hiçbir şey bilmiyor. 
Kodu düzenlediğimiz şekilde, yayınlanan bir gönderinin farklı davranış biçimlerini öğrenmek için tek bir yere bakmamız gerekiyor: 
<code>Published</code> yapısındaki <code>State</code> özelliğinin uygulanması.</p>
<p><code>State</code> kalıbını kullanmayan alternatif bir uygulama oluşturacak olsaydık, bunun yerine <code>Post</code> üzerindeki yöntemlerde veya hatta 
gönderinin durumunu kontrol eden ve bu yerlerde davranışı değiştiren ana kodda eşleşme ifadeleri kullanabilirdik. 
Bu, bir gönderinin yayınlanmış durumda olmasının tüm sonuçlarını anlamak için birkaç yere bakmamız gerektiği anlamına gelirdi! 
Bu, ne kadar çok durum eklersek o kadar artacaktır: bu <code>match</code> ifadelerinin her biri başka bir kola ihtiyaç duyacaktır.</p>
<p><code>State</code> kalıbı ile <code>Post</code> metodları ve <code>Post</code>'u kullandığımız yerler eşleşme ifadelerine ihtiyaç duymaz ve yeni bir 
<code>state</code> eklemek için sadece yeni bir <code>struct</code> eklememiz ve <code>trait</code> metodlarını bu <code>struct</code> üzerinde uygulamamız gerekir.</p>
<p><code>State</code> kalıbını kullanan uygulamanın daha fazla işlevsellik eklemek için genişletilmesi kolaydır. 
<code>State</code> kalıbını kullanan kodu korumanın basitliğini görmek için bu önerilerden birkaçını deneyin:</p>
<ul>
<li>Gönderinin durumunu PendingReview'den Draft'a değiştiren bir reddetme yöntemi ekleyin.</li>
<li><code>State</code> <code>Published</code> olarak değiştirilmeden önce onaylamak için iki çağrı yapılmasını zorunlu kılın.</li>
<li>Kullanıcıların yalnızca bir gönderi <code>Draft</code> durumundayken metin içeriği eklemesine izin verin. 
İpucu: <code>state</code> nesnesinin içerikle ilgili değişebilecek şeylerden sorumlu olmasını ancak <code>Post</code>'u değiştirmekten sorumlu olmamasını sağlayın.</li>
<li><code>State</code> modelinin bir dezavantajı, durumlar arasındaki geçişleri durumlar gerçekleştirdiği için bazı durumların birbirine bağlı olmasıdır.
<code>PendingReview</code> ile <code>Published</code> arasına <code>Scheduled</code> gibi başka bir <code>state</code> eklersek, <code>PendingReview</code>'daki kodu <code>Scheduled</code>'a geçiş yapacak 
şekilde değiştirmemiz gerekir. <code>PendingReview</code>'in yeni bir durum eklendiğinde değişmesi gerekmeseydi daha az iş olurdu, 
ancak bu başka bir tasarım modeline geçmek anlamına gelir.</li>
</ul>
<p>Diğer bir dezavantajı ise bazı mantıkları tekrarlamış olmamızdır. Yinelemenin bir kısmını ortadan kaldırmak için, 
<code>State</code> özelliğindeki <code>request_review</code> ve <code>approve</code> yöntemleri için <code>self</code> döndüren varsayılan uygulamalar yapmayı deneyebiliriz; 
ancak bu, nesne güvenliğini ihlal eder, çünkü özellik somut <code>self</code>'in tam olarak ne olacağını bilmez. <code>State</code>'i bir özellik nesnesi olarak 
kullanabilmek istiyoruz, bu nedenle yöntemlerinin nesne güvenli olmasına ihtiyacımız var.</p>
<p>Diğer tekrarlar, <code>Post</code> üzerindeki <code>request_review</code> ve <code>approve</code> yöntemlerinin benzer uygulamalarını içerir. 
Her iki yöntem de <code>Option</code>'ın state alanındaki değer üzerinde aynı yöntemin uygulanmasına delege eder ve <code>state</code> alanının yeni 
değerini sonuca ayarlar. <code>Post</code> üzerinde bu kalıbı izleyen çok sayıda yöntemimiz olsaydı, tekrarı ortadan kaldırmak için bir makro 
tanımlamayı düşünebilirdik (Bölüm 19'daki &quot;Makrolar&quot; bölümüne bakın).</p>
<p><code>State</code> kalıbını tam olarak nesne yönelimli diller için tanımlandığı gibi uygulayarak, Rust'ın güçlü yanlarından olabildiğince 
yararlanamıyoruz. Geçersiz durumları ve geçişleri derleme zamanı hatalarına dönüştürebilecek <code>blog</code> kasasında yapabileceğimiz 
bazı değişikliklere bakalım.</p>
<h4 id="durumları-ve-davranışları-tür-olarak-kodlama"><a class="header" href="#durumları-ve-davranışları-tür-olarak-kodlama">Durumları ve Davranışları Tür Olarak Kodlama</a></h4>
<p>Farklı bir dizi ödünleşim elde etmek için durum modelini nasıl yeniden düşüneceğinizi göstereceğiz. 
Durumları ve geçişleri tamamen kapsüllemek yerine, dış kodun bunlar hakkında hiçbir bilgiye sahip olmaması için 
durumları farklı türlere kodlayacağız. Sonuç olarak, Rust'ın tür kontrol sistemi, yalnızca yayınlanmış gönderilere izin 
verilen taslak gönderileri kullanma girişimlerini bir derleyici hatası vererek önleyecektir.</p>
<p>Liste 17-11'deki <code>main</code>'in ilk bölümünü ele alalım:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!(&quot;&quot;, post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
</span>}
</code></pre>
<p><code>Post::new</code> kullanarak taslak durumunda yeni gönderilerin oluşturulmasını ve gönderinin içeriğine metin ekleme özelliğini hala etkinleştiriyoruz. 
Ancak taslak bir gönderide boş bir dize döndüren bir <code>content</code> yöntemine sahip olmak yerine, taslak gönderilerin içerik yöntemine 
hiç sahip olmamasını sağlayacağız. Bu şekilde, bir taslak gönderinin içeriğini almaya çalışırsak, bize yöntemin mevcut 
olmadığını söyleyen bir derleyici hatası alırız. Sonuç olarak, taslak gönderi içeriğini üretimde yanlışlıkla görüntülememiz imkansız olacaktır, 
çünkü bu kod derlenmeyecektir bile. Liste 17-19, bir <code>Post</code> yapısının ve bir <code>DraftPost</code> yapısının tanımının yanı sıra her birindeki 
yöntemleri gösterir:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
</code></pre>
<p><span class="caption">Liste 17-19: <code>content</code> yöntemine sahip bir <code>Post</code> ve <code>content</code> 
metodu olmayan bir <code>DraftPost</code></span></p>
<p>Hem <code>Post</code> hem de <code>DraftPost</code> yapıları, blog yazısı metnini saklayan özel bir içerik alanına sahiptir. 
Yapılar artık <code>state</code> alanına sahip değildir çünkü <code>state</code> kodlamasını yapıların türlerine taşıyoruz. 
<code>Post</code> yapısı yayınlanmış bir gönderiyi temsil edecektir ve içeriği döndüren bir içerik yöntemine sahiptir.</p>
<p>Hala bir <code>Post::new</code> fonksiyonumuz var, ancak <code>Post</code>'un bir örneğini döndürmek yerine <code>DraftPost</code>'un bir örneğini döndürüyor. <code>content</code>
gizli olduğundan ve <code>Post</code> döndüren herhangi bir fonksiyon bulunmadığından, şu anda bir <code>Post</code> tanımı oluşturmak mümkün değildir.</p>
<p><code>DraftPost</code> yapısının bir <code>add_text</code> yöntemi vardır, bu nedenle daha önce olduğu gibi içeriğe metin ekleyebiliriz, ancak 
<code>DraftPost</code>'un tanımlanmış bir <code>content</code> yöntemi olmadığını unutmayın! Böylece program tüm gönderilerin taslak gönderiler olarak 
başlamasını sağlar ve taslak gönderilerin içerikleri görüntülenemez. Bu kısıtlamaları aşmaya yönelik herhangi bir girişim derleyici hatasıyla sonuçlanacaktır.</p>
<h4 id="geçişleri-farklı-türlere-dönüşümler-olarak-uygulama"><a class="header" href="#geçişleri-farklı-türlere-dönüşümler-olarak-uygulama">Geçişleri Farklı Türlere Dönüşümler Olarak Uygulama</a></h4>
<p>Peki yayınlanmış bir gönderiyi nasıl alacağız? Bir taslak gönderinin yayınlanmadan önce gözden geçirilmesi ve 
onaylanması gerektiği kuralını uygulamak istiyoruz. Bekleyen inceleme durumundaki bir gönderi hala herhangi bir içerik 
göstermemelidir. Bu kısıtlamaları, <code>PendingReviewPost</code> adında başka bir yapı ekleyerek, bir <code>PendingReviewPost</code> döndürmek için 
<code>DraftPost</code> üzerinde <code>request_review</code> yöntemini tanımlayarak ve bir <code>Post</code> döndürmek için <code>PendingReviewPost</code> üzerinde bir <code>approve</code> yöntemi
tanımlayarak, Liste 17-20'de gösterildiği gibi yazalım:</p>
<h4 id="geçişleri-farklı-türlere-dönüştürme-olarak-uygulama"><a class="header" href="#geçişleri-farklı-türlere-dönüştürme-olarak-uygulama">Geçişleri Farklı Türlere Dönüştürme Olarak Uygulama</a></h4>
<p>Peki yayınlanmış bir gönderiyi nasıl alacağız? Bir taslak gönderinin yayınlanmadan önce gözden geçirilmesi ve 
onaylanması gerektiği kuralını uygulamak istiyoruz. Bekleyen inceleme durumundaki bir gönderi hala herhangi bir içerik göstermemelidir. 
Bu kısıtlamaları, <code>PendingReviewPost</code> adında başka bir yapı ekleyerek, bir <code>PendingReviewPost</code> döndürmek için <code>DraftPost</code> üzerinde 
<code>request_review</code> yöntemini tanımlayarak ve bir <code>Post</code> döndürmek için <code>PendingReviewPost</code> üzerinde bir <code>approve</code> yöntemi tanımlayarak, 
Liste 17-20'de gösterildiği gibi uygulayalım:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --snip--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}
</code></pre>
<p><span class="caption">Liste 17-20: <code>DraftPost</code>'ta <code>request_review</code> çağrılarak oluşturulan bir 
<code>PendingReviewPost</code> ve <code>PendingReviewPost</code>'u yayınlanmış bir <code>Post</code>'a dönüştüren bir <code>approve</code> yöntemi</span></p>
<p><code>request_review</code> ve <code>approve</code> yöntemleri <code>self</code>'in sahipliğini alır, böylece <code>DraftPost</code> ve <code>PendingReviewPost</code> örneklerini 
tüketir ve bunları sırasıyla bir <code>PendingReviewPost</code>'a ve yayınlanmış bir <code>Post</code>'a dönüştürür. Bu şekilde, üzerlerinde <code>request_review</code> çağrısı
yaptıktan sonra kalan <code>DraftPost</code> örneklerimiz olmayacaktır. <code>PendingReviewPost</code> yapısının üzerinde tanımlanmış bir <code>content</code> yöntemi yoktur, 
bu nedenle içeriğini okumaya çalışmak <code>DraftPost</code>'ta olduğu gibi bir derleyici hatasıyla sonuçlanır. Tanımlanmış bir <code>content</code> yöntemi olan
yayınlanmış bir <code>Post</code> örneği almanın tek yolu bir <code>PendingReviewPost</code> üzerinde <code>approve</code> yöntemini çağırmak olduğundan ve bir 
<code>PendingReviewPost</code> almanın tek yolu bir <code>DraftPost</code> üzerinde <code>request_review</code> yöntemini çağırmak olduğundan, artık blog yazısı 
iş akışını tür sistemine kodladık.</p>
<p>Ancak <code>main</code>'de de bazı küçük değişiklikler yapmamız gerekiyor. <code>request_review</code> ve <code>approve</code> yöntemleri, çağrıldıkları yapıyı 
değiştirmek yerine yeni örnekler döndürür, bu nedenle döndürülen örnekleri kaydetmek için daha fazla <code>let post =</code> <em>gölgeleme</em> ataması eklememiz 
gerekir. Ayrıca, taslak ve bekleyen inceleme gönderilerinin içerikleriyle ilgili iddiaların boş dizgiler olmasını sağlayamayız ve 
bunlara ihtiyacımız da yok: artık bu durumlardaki gönderilerin içeriğini kullanmaya çalışan kodu derleyemeyiz. 
<code>main</code>'deki güncellenmiş kod Liste 17-21'de gösterilmektedir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">Liste 17-21: Blog gönderisi iş akışının yeni süreklemesinin kullanmak için 
<code>main</code>'deki değişiklikler</span></p>
<p><code>Post</code>'u yeniden atamak için <code>main</code>'de yapmamız gereken değişiklikler, bu uygulamanın artık nesne yönelimli durum modeline 
tam olarak uymadığı anlamına geliyor: durumlar arasındaki dönüşümler artık tamamen <code>Post</code> uygulaması içinde kapsüllenmiyor. 
Bununla birlikte, kazancımız, tür sistemi ve derleme zamanında gerçekleşen tür denetimi nedeniyle geçersiz durumların artık 
imkansız olmasıdır! Bu, yayınlanmamış bir gönderinin içeriğinin görüntülenmesi gibi belirli hataların üretime geçmeden önce 
keşfedilmesini sağlar.</p>
<p>Kodun bu versiyonunun tasarımı hakkında ne düşündüğünüzü görmek için bu bölümün başında önerilen görevleri 
Liste 17-21'den sonra olduğu gibi blog sandığı üzerinde deneyin. Bazı görevlerin bu tasarımda zaten tamamlanmış 
olabileceğini unutmayın.</p>
<p>Rust'ın nesne yönelimli tasarım kalıplarını uygulama yeteneğine sahip olmasına rağmen, durumu tür sistemine kodlamak gibi 
diğer kalıpların da Rust'ta mevcut olduğunu gördük. Bu kalıpların farklı ödünleşimleri vardır. Nesne yönelimli kalıplara 
çok aşina olsanız da, Rust'ın özelliklerinden yararlanmak için sorunu yeniden düşünmek, derleme zamanında bazı hataları önlemek 
gibi faydalar sağlayabilir. Nesne yönelimli kalıplar, nesne yönelimli dillerin sahip olmadığı sahiplik gibi bazı özellikler 
nedeniyle Rust'ta her zaman en iyi çözüm olmayacaktır.</p>
<h2 id="Özet-12"><a class="header" href="#Özet-12">Özet</a></h2>
<p>Bu bölümü okuduktan sonra Rust'ın nesne yönelimli bir dil olduğunu düşünseniz de düşünmeseniz de, artık Rust'ta bazı nesne 
yönelimli özellikler elde etmek için <code>trait</code> nesnelerini kullanabileceğinizi biliyorsunuz. Dinamik gönderim, kodunuza biraz çalışma 
zamanı performansı karşılığında biraz esneklik sağlayabilir. Bu esnekliği, kodunuzun sürdürülebilirliğine yardımcı olabilecek nesne yönelimli 
kalıpları uygulamak için kullanabilirsiniz. Rust ayrıca sahiplik gibi nesne yönelimli dillerin sahip olmadığı başka özelliklere de sahiptir. 
Nesne yönelimli bir kalıp, Rust'ın güçlü yönlerinden yararlanmanın her zaman en iyi yolu olmayacaktır, ancak kullanılabilir bir seçenektir.</p>
<p>Daha sonra, Rust'ın çok fazla esneklik sağlayan bir başka özelliği olan kalıplara bakacağız. 
Kitap boyunca bunlara kısaca baktık ancak henüz tam kapasitelerini görmedik. Hadi başlayalım!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modeller-ve-eşleştirme"><a class="header" href="#modeller-ve-eşleştirme">Modeller ve Eşleştirme</a></h1>
<p><em>Modeller</em>, hem karmaşık hem de basit türleri yapısıyla eşleştirmek 
için bir özellik sağlar. Modelleri eşleştirmede <code>match</code>'i ifadelerle ve diğer yapılarla birlikte kullanmak, bir programın kontrol 
akışı üzerinde size daha fazla kontrol sağlar. Bir model, aşağıdakilerin bazı kombinasyonlarından oluşur:</p>
<ul>
<li>Değişmezler</li>
<li>Bozulmuş diziler, numaralandırılmış yapılar, yapılar veya demetler</li>
<li>Değişkenler</li>
<li>Joker dizgiler</li>
<li>Yer tutucular</li>
</ul>
<p>Bu bileşenler, birlikte çalıştığımız verilerin şeklini tanımlar ve daha sonra programımızın belirli 
bir kod parçasını çalıştırmaya devam etmek için doğru verilere sahip olup olmadığını belirlemek için değerlerle eşleştiririz.</p>
<p>Bir model kullanmak için, onu bir değerle karşılaştırırız. Model, değerle eşleşirse kodumuzda değer 
kısımlarını kullanırız. Madeni para sıralama makinesi örneği gibi; Bölüm 6'daki, modelleri kullanan eşleşme ifadelerini hatırlayın. </p>
<p>Bu bölüm, modellerle ilgili her şey için bir referanstır. 
Modelleri kullanmak için geçerli yerleri, reddedilebilir ve reddedilemez modeller arasındaki 
farkı ve görebileceğiniz farklı model söz dizimi türlerini ele alacağız. 
Bölümün sonunda, birçok kavramı açık bir şekilde ifade etmek için modelleri nasıl kullanacağınızı öğreneceksiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="all-the-places-patterns-can-be-used"><a class="header" href="#all-the-places-patterns-can-be-used">All the Places Patterns Can Be Used</a></h2>
<p>Patterns pop up in a number of places in Rust, and you’ve been using them a lot
without realizing it! This section discusses all the places where patterns are
valid.</p>
<h3 id="match-arms"><a class="header" href="#match-arms"><code>match</code> Arms</a></h3>
<p>As discussed in Chapter 6, we use patterns in the arms of <code>match</code> expressions.
Formally, <code>match</code> expressions are defined as the keyword <code>match</code>, a value to
match on, and one or more match arms that consist of a pattern and an
expression to run if the value matches that arm’s pattern, like this:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p>For example, here's the <code>match</code> expression from Listing 6-5 that matches on an
<code>Option&lt;i32&gt;</code> value in the variable <code>x</code>:</p>
<pre><code class="language-rust ignore">match x {
    None =&gt; None,
    Some(i) =&gt; Some(i + 1),
}
</code></pre>
<p>The patterns in this <code>match</code> expression are the <code>None</code> and <code>Some(i)</code> on the
left of each arrow.</p>
<p>One requirement for <code>match</code> expressions is that they need to be <em>exhaustive</em> in
the sense that all possibilities for the value in the <code>match</code> expression must
be accounted for. One way to ensure you’ve covered every possibility is to have
a catchall pattern for the last arm: for example, a variable name matching any
value can never fail and thus covers every remaining case.</p>
<p>The particular pattern <code>_</code> will match anything, but it never binds to a
variable, so it’s often used in the last match arm. The <code>_</code> pattern can be
useful when you want to ignore any value not specified, for example. We’ll
cover the <code>_</code> pattern in more detail in the <a href="ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern">“Ignoring Values in a
Pattern”</a><!-- ignore --> section later in this
chapter.</p>
<h3 id="conditional-if-let-expressions"><a class="header" href="#conditional-if-let-expressions">Conditional <code>if let</code> Expressions</a></h3>
<p>In Chapter 6 we discussed how to use <code>if let</code> expressions mainly as a shorter
way to write the equivalent of a <code>match</code> that only matches one case.
Optionally, <code>if let</code> can have a corresponding <code>else</code> containing code to run if
the pattern in the <code>if let</code> doesn’t match.</p>
<p>Listing 18-1 shows that it’s also possible to mix and match <code>if let</code>, <code>else if</code>, and <code>else if let</code> expressions. Doing so gives us more flexibility than a
<code>match</code> expression in which we can express only one value to compare with the
patterns. Also, Rust doesn't require that the conditions in a series of <code>if let</code>, <code>else if</code>, <code>else if let</code> arms relate to each other.</p>
<p>The code in Listing 18-1 determines what color to make your background based on
a series of checks for several conditions. For this example, we’ve created
variables with hardcoded values that a real program might receive from user
input.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        println!(&quot;Using your favorite color, {}, as the background&quot;, color);
    } else if is_tuesday {
        println!(&quot;Tuesday is green day!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Using purple as the background color&quot;);
        } else {
            println!(&quot;Using orange as the background color&quot;);
        }
    } else {
        println!(&quot;Using blue as the background color&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-1: Mixing <code>if let</code>, <code>else if</code>, <code>else if let</code>,
and <code>else</code></span></p>
<p>If the user specifies a favorite color, that color is used as the background.
If no favorite color is specified and today is Tuesday, the background color is
green. Otherwise, if the user specifies their age as a string and we can parse
it as a number successfully, the color is either purple or orange depending on
the value of the number. If none of these conditions apply, the background
color is blue.</p>
<p>This conditional structure lets us support complex requirements. With the
hardcoded values we have here, this example will print <code>Using purple as the background color</code>.</p>
<p>You can see that <code>if let</code> can also introduce shadowed variables in the same way
that <code>match</code> arms can: the line <code>if let Ok(age) = age</code> introduces a new
shadowed <code>age</code> variable that contains the value inside the <code>Ok</code> variant. This
means we need to place the <code>if age &gt; 30</code> condition within that block: we can’t
combine these two conditions into <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>. The
shadowed <code>age</code> we want to compare to 30 isn’t valid until the new scope starts
with the curly bracket.</p>
<p>The downside of using <code>if let</code> expressions is that the compiler doesn’t check
for exhaustiveness, whereas with <code>match</code> expressions it does. If we omitted the
last <code>else</code> block and therefore missed handling some cases, the compiler would
not alert us to the possible logic bug.</p>
<h3 id="while-let-conditional-loops"><a class="header" href="#while-let-conditional-loops"><code>while let</code> Conditional Loops</a></h3>
<p>Similar in construction to <code>if let</code>, the <code>while let</code> conditional loop allows a
<code>while</code> loop to run for as long as a pattern continues to match. In Listing
18-2 we code a <code>while let</code> loop that uses a vector as a stack and prints the
values in the vector in the opposite order in which they were pushed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!(&quot;{}&quot;, top);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-2: Using a <code>while let</code> loop to print values
for as long as <code>stack.pop()</code> returns <code>Some</code></span></p>
<p>This example prints 3, 2, and then 1. The <code>pop</code> method takes the last element
out of the vector and returns <code>Some(value)</code>. If the vector is empty, <code>pop</code>
returns <code>None</code>. The <code>while</code> loop continues running the code in its block as
long as <code>pop</code> returns <code>Some</code>. When <code>pop</code> returns <code>None</code>, the loop stops. We can
use <code>while let</code> to pop every element off our stack.</p>
<h3 id="for-loops"><a class="header" href="#for-loops"><code>for</code> Loops</a></h3>
<p>In a <code>for</code> loop, the value that directly follows the keyword <code>for</code> is a
pattern. For example, in <code>for x in y</code> the <code>x</code> is the pattern. Listing 18-3
demonstrates how to use a pattern in a <code>for</code> loop to destructure, or break
apart, a tuple as part of the <code>for</code> loop.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!(&quot;{} is at index {}&quot;, value, index);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-3: Using a pattern in a <code>for</code> loop to
destructure a tuple</span></p>
<p>The code in Listing 18-3 will print the following:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
</code></pre>
<p>We adapt an iterator using the <code>enumerate</code> method so it produces a value and
the index for that value, placed into a tuple. The first value produced is the
tuple <code>(0, 'a')</code>. When this value is matched to the pattern <code>(index, value)</code>,
<code>index</code> will be <code>0</code> and <code>value</code> will be <code>'a'</code>, printing the first line of the
output.</p>
<h3 id="let-statements"><a class="header" href="#let-statements"><code>let</code> Statements</a></h3>
<p>Prior to this chapter, we had only explicitly discussed using patterns with
<code>match</code> and <code>if let</code>, but in fact, we’ve used patterns in other places as well,
including in <code>let</code> statements. For example, consider this straightforward
variable assignment with <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>Every time you've used a <code>let</code> statement like this you've been using patterns,
although you might not have realized it! More formally, a <code>let</code> statement looks
like this:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>In statements like <code>let x = 5;</code> with a variable name in the <code>PATTERN</code> slot, the
variable name is just a particularly simple form of a pattern. Rust compares
the expression against the pattern and assigns any names it finds. So in the
<code>let x = 5;</code> example, <code>x</code> is a pattern that means “bind what matches here to
the variable <code>x</code>.” Because the name <code>x</code> is the whole pattern, this pattern
effectively means “bind everything to the variable <code>x</code>, whatever the value is.”</p>
<p>To see the pattern matching aspect of <code>let</code> more clearly, consider Listing
18-4, which uses a pattern with <code>let</code> to destructure a tuple.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-4: Using a pattern to destructure a tuple and
create three variables at once</span></p>
<p>Here, we match a tuple against a pattern. Rust compares the value <code>(1, 2, 3)</code>
to the pattern <code>(x, y, z)</code> and sees that the value matches the pattern, so Rust
binds <code>1</code> to <code>x</code>, <code>2</code> to <code>y</code>, and <code>3</code> to <code>z</code>. You can think of this tuple
pattern as nesting three individual variable patterns inside it.</p>
<p>If the number of elements in the pattern doesn’t match the number of elements
in the tuple, the overall type won’t match and we’ll get a compiler error. For
example, Listing 18-5 shows an attempt to destructure a tuple with three
elements into two variables, which won’t work.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 18-5: Incorrectly constructing a pattern whose
variables don’t match the number of elements in the tuple</span></p>
<p>Attempting to compile this code results in this type error:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^ expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` due to previous error
</code></pre>
<p>To fix the error, we could ignore one or more of the values in the tuple using
<code>_</code> or <code>..</code>, as you’ll see in the <a href="ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern">“Ignoring Values in a
Pattern”</a><!-- ignore --> section. If the problem
is that we have too many variables in the pattern, the solution is to make the
types match by removing variables so the number of variables equals the number
of elements in the tuple.</p>
<h3 id="function-parameters"><a class="header" href="#function-parameters">Function Parameters</a></h3>
<p>Function parameters can also be patterns. The code in Listing 18-6, which
declares a function named <code>foo</code> that takes one parameter named <code>x</code> of type
<code>i32</code>, should by now look familiar.</p>
<pre><pre class="playground"><code class="language-rust">fn foo(x: i32) {
    // code goes here
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 18-6: A function signature uses patterns in the
parameters</span></p>
<p>The <code>x</code> part is a pattern! As we did with <code>let</code>, we could match a tuple in a
function’s arguments to the pattern. Listing 18-7 splits the values in a tuple
as we pass it to a function.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}
</code></pre></pre>
<p><span class="caption">Listing 18-7: A function with parameters that destructure
a tuple</span></p>
<p>This code prints <code>Current location: (3, 5)</code>. The values <code>&amp;(3, 5)</code> match the
pattern <code>&amp;(x, y)</code>, so <code>x</code> is the value <code>3</code> and <code>y</code> is the value <code>5</code>.</p>
<p>We can also use patterns in closure parameter lists in the same way as in
function parameter lists, because closures are similar to functions, as
discussed in Chapter 13.</p>
<p>At this point, you’ve seen several ways of using patterns, but patterns don’t
work the same in every place we can use them. In some places, the patterns must
be irrefutable; in other circumstances, they can be refutable. We’ll discuss
these two concepts next.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="reddedilebilirlik-bir-model-eşleşmede-başarısız-olabilir-mi"><a class="header" href="#reddedilebilirlik-bir-model-eşleşmede-başarısız-olabilir-mi">Reddedilebilirlik: Bir Model; Eşleşmede Başarısız Olabilir mi?</a></h2>
<p>Modeller iki biçimde gelir: reddedilebilir ve reddedilemez. 
Geçilen herhangi bir olası değer için eşleşecek kalıplar reddedilemez. 
Bir örnek, <code>let x = 5</code> ifade yapısındaki <code>x</code> olabilir; çünkü <code>x</code> herhangi bir şeyle eşleşir 
ve bu nedenle eşleşme başarısız olamaz. Bazı olası değerler için eşleşmeyen kalıplar reddedilebilir. </p>
<p>Fonksiyon parametreleri, <code>let</code> deyimleri ve <code>for</code> döngüleri yalnızca reddedilemez kalıpları kabul edebilir, 
çünkü değerler eşleşmediğinde program anlamlı bir şey yapamaz. <code>if let</code> ve <code>while let</code> ifadeleri reddedilemez ve reddedilemez 
modelleri kabul eder, ancak derleyici reddedilemez kalıplara karşı uyarır çünkü tanımları gereği olası başarısızlığı ele almayı amaçlarlar: 
bir koşulun işlevselliği, başarıya veya başarısızlığa bağlı olarak farklı performans gösterme yeteneğindedir.</p>
<p>Genel olarak, reddedilebilir ve reddedilemez modeller arasındaki ayrım hakkında endişelenmenize gerek yoktur; 
ancak, bir hata mesajında gördüğünüzde yanıt verebilmeniz için reddedilebilirlik kavramına aşina olmanız gerekir. 
Bu durumlarda, kodun amaçlanan davranışına bağlı olarak, modeli veya modeli kullandığınız yapıyı değiştirmeniz gerekir.</p>
<p>Rust'ın reddedilemez bir model gerektirdiği ve bunun tersi olduğu halde, 
çürütülebilir bir model kullanmaya çalıştığımızda ne olduğuna dair bir örneğe bakalım. Liste 18-8, 
bir <code>let</code> ifade yapısını gösterir, ancak <code>Some(x)</code> belirttiğimiz model için reddedilebilir bir modeldir. 
Tahmin edebileceğiniz gibi, bu kod derlenmeyecektir:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value;
<span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 18-8: <code>let</code> ile çürütülebilir bir 
model kullanmaya çalışmak</span></p>
<p><code>some_option_value</code>, <code>None</code> değerinde olsaydı, <code>Some(x)</code> modeliyle eşleşmezdi, bu da kalıbın reddedilebilir olduğu anlamına gelir. 
Ancak, <code>let</code> ifade yapısı yalnızca reddedilemez bir kalıbı kabul edebilir, çünkü kodun <code>None</code> değeriyle yapabileceği geçerli hiçbir şey yoktur. 
Derleme zamanında; Rust, reddedilemez bir modelin gerekli olduğu durumlarda reddedilebilir bir model kullanmaya çalıştığımızdan şikayet edecektir:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding: `None` not covered
   --&gt; src/main.rs:3:9
    |
3   |     let Some(x) = some_option_value;
    |         ^^^^^^^ pattern `None` not covered
    |
    = note: `let` bindings require an &quot;irrefutable pattern&quot;, like a `struct` or an `enum` with only one variant
    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
    = note: the matched value is of type `Option&lt;i32&gt;`
help: you might want to use `if let` to ignore the variant that isn't matched
    |
3   |     if let Some(x) = some_option_value { /* */ }
    |

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns` due to previous error
</code></pre>
<p><code>Some(x)</code> modeliyle geçerli her değeri kapsamadığımız (ve kapsayamadığımız) için, Rust haklı olarak bir derleyici hatası üretir.</p>
<p>Çürütülemez bir modele ihtiyaç duyulan bir çürütülebilir modelimiz varsa, modeli kullanan kodu değiştirerek düzeltebiliriz: 
<code>let</code> yerine <code>if let</code> kullanabiliriz. Ardından, model eşleşmezse, kod, süslü parantezler arasındaki kodu 
atlayarak geçerli bir şekilde devam etmesinin bir yolunu sunar. 
Liste 18-9, Liste 18-8'deki kodun nasıl düzeltileceğini gösterir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    if let Some(x) = some_option_value {
        println!(&quot;{}&quot;, x);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 18-9: <code>let</code> yerine <code>if let</code> kullanan ve reddedilebilir modellere sahip 
bir blok kullanma</span></p>
<p>Kodu bir çıkış verdik! Bu kod tamamen geçerlidir, ancak bir hata almadan reddedilemez bir model kullanamayacağımız 
anlamına gelir. Liste 18-10'da gösterildiği gibi <code>x</code> gibi her zaman eşleşecek bir model verirsek, derleyici bir uyarı verecektir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    if let x = 5 {
        println!(&quot;{}&quot;, x);
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 18-10: <code>if let</code> ile reddedilemez bir model
kullanmaya çalışmak</span></p>
<p>Rust, reddedilemez bir modelle <code>if let</code> kullanmanın mantıklı olmadığından şikayet ediyor:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable `if let` pattern
 --&gt; src/main.rs:2:8
  |
2 |     if let x = 5 {
  |        ^^^^^^^^^
  |
  = note: `#[warn(irrefutable_let_patterns)]` on by default
  = note: this pattern will always match, so the `if let` is useless
  = help: consider replacing the `if let` with a `let`

warning: `patterns` (bin &quot;patterns&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
</code></pre>
<p>Bu nedenle, eşleşme kolları, kalan değerleri reddedilemez bir modelle eşleştirmesi gereken son kol hariç, 
reddedilebilir modeller kullanmalıdır. Rust, tek kollu bir eşleşmede reddedilemez bir model kullanmamıza izin verir, 
ancak bu söz dizimi çok kullanışlı değildir ve daha basit bir <code>let</code> ifade yapısı ile değiştirilebilir.</p>
<p>Artık modeleri nerede kullanacağınızı ve reddedilebilir ve reddedilemez modeller arasındaki farkı 
bildiğinize göre, model oluşturmak için kullanabileceğimiz söz dizimini ele alalım.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pattern-syntax"><a class="header" href="#pattern-syntax">Pattern Syntax</a></h2>
<p>In this section, we gather all the syntax valid in patterns and discuss why and
when you might want to use each one.</p>
<h3 id="matching-literals"><a class="header" href="#matching-literals">Matching Literals</a></h3>
<p>As you saw in Chapter 6, you can match patterns against literals directly. The
following code gives some examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!(&quot;one&quot;),
        2 =&gt; println!(&quot;two&quot;),
        3 =&gt; println!(&quot;three&quot;),
        _ =&gt; println!(&quot;anything&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>This code prints <code>one</code> because the value in <code>x</code> is 1. This syntax is useful
when you want your code to take an action if it gets a particular concrete
value.</p>
<h3 id="matching-named-variables"><a class="header" href="#matching-named-variables">Matching Named Variables</a></h3>
<p>Named variables are irrefutable patterns that match any value, and we’ve used
them many times in the book. However, there is a complication when you use
named variables in <code>match</code> expressions. Because <code>match</code> starts a new scope,
variables declared as part of a pattern inside the <code>match</code> expression will
shadow those with the same name outside the <code>match</code> construct, as is the case
with all variables. In Listing 18-11, we declare a variable named <code>x</code> with the
value <code>Some(5)</code> and a variable <code>y</code> with the value <code>10</code>. We then create a
<code>match</code> expression on the value <code>x</code>. Look at the patterns in the match arms and
<code>println!</code> at the end, and try to figure out what the code will print before
running this code or reading further.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {:?}&quot;, y),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-11: A <code>match</code> expression with an arm that
introduces a shadowed variable <code>y</code></span></p>
<p>Let’s walk through what happens when the <code>match</code> expression runs. The pattern
in the first match arm doesn’t match the defined value of <code>x</code>, so the code
continues.</p>
<p>The pattern in the second match arm introduces a new variable named <code>y</code> that
will match any value inside a <code>Some</code> value. Because we’re in a new scope inside
the <code>match</code> expression, this is a new <code>y</code> variable, not the <code>y</code> we declared at
the beginning with the value 10. This new <code>y</code> binding will match any value
inside a <code>Some</code>, which is what we have in <code>x</code>. Therefore, this new <code>y</code> binds to
the inner value of the <code>Some</code> in <code>x</code>. That value is <code>5</code>, so the expression for
that arm executes and prints <code>Matched, y = 5</code>.</p>
<p>If <code>x</code> had been a <code>None</code> value instead of <code>Some(5)</code>, the patterns in the first
two arms wouldn’t have matched, so the value would have matched to the
underscore. We didn’t introduce the <code>x</code> variable in the pattern of the
underscore arm, so the <code>x</code> in the expression is still the outer <code>x</code> that hasn’t
been shadowed. In this hypothetical case, the <code>match</code> would print <code>Default case, x = None</code>.</p>
<p>When the <code>match</code> expression is done, its scope ends, and so does the scope of
the inner <code>y</code>. The last <code>println!</code> produces <code>at the end: x = Some(5), y = 10</code>.</p>
<p>To create a <code>match</code> expression that compares the values of the outer <code>x</code> and
<code>y</code>, rather than introducing a shadowed variable, we would need to use a match
guard conditional instead. We’ll talk about match guards later in the <a href="ch18-03-pattern-syntax.html#extra-conditionals-with-match-guards">“Extra
Conditionals with Match Guards”</a><!--
ignore --> section.</p>
<h3 id="multiple-patterns"><a class="header" href="#multiple-patterns">Multiple Patterns</a></h3>
<p>In <code>match</code> expressions, you can match multiple patterns using the <code>|</code> syntax,
which is the pattern <em>or</em> operator. For example, in the following code we match
the value of <code>x</code> against the match arms, the first of which has an <em>or</em> option,
meaning if the value of <code>x</code> matches either of the values in that arm, that
arm’s code will run:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!(&quot;one or two&quot;),
        3 =&gt; println!(&quot;three&quot;),
        _ =&gt; println!(&quot;anything&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>This code prints <code>one or two</code>.</p>
<h3 id="matching-ranges-of-values-with-"><a class="header" href="#matching-ranges-of-values-with-">Matching Ranges of Values with <code>..=</code></a></h3>
<p>The <code>..=</code> syntax allows us to match to an inclusive range of values. In the
following code, when a pattern matches any of the values within the given
range, that arm will execute:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!(&quot;one through five&quot;),
        _ =&gt; println!(&quot;something else&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>If <code>x</code> is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more
convenient for multiple match values than using the <code>|</code> operator to express the
same idea; if we were to use <code>|</code> we would have to specify <code>1 | 2 | 3 | 4 | 5</code>.
Specifying a range is much shorter, especially if we want to match, say, any
number between 1 and 1,000!</p>
<p>The compiler checks that the range isn’t empty at compile time, and because the
only types for which Rust can tell if a range is empty or not are <code>char</code> and
numeric values, ranges are only allowed with numeric or <code>char</code> values.</p>
<p>Here is an example using ranges of <code>char</code> values:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!(&quot;early ASCII letter&quot;),
        'k'..='z' =&gt; println!(&quot;late ASCII letter&quot;),
        _ =&gt; println!(&quot;something else&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>Rust can tell that <code>'c'</code> is within the first pattern’s range and prints <code>early ASCII letter</code>.</p>
<h3 id="destructuring-to-break-apart-values"><a class="header" href="#destructuring-to-break-apart-values">Destructuring to Break Apart Values</a></h3>
<p>We can also use patterns to destructure structs, enums, and tuples to use
different parts of these values. Let’s walk through each value.</p>
<h4 id="destructuring-structs"><a class="header" href="#destructuring-structs">Destructuring Structs</a></h4>
<p>Listing 18-12 shows a <code>Point</code> struct with two fields, <code>x</code> and <code>y</code>, that we can
break apart using a pattern with a <code>let</code> statement.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<p><span class="caption">Listing 18-12: Destructuring a struct’s fields into
separate variables</span></p>
<p>This code creates the variables <code>a</code> and <code>b</code> that match the values of the <code>x</code>
and <code>y</code> fields of the <code>p</code> struct. This example shows that the names of the
variables in the pattern don’t have to match the field names of the struct.
However, it’s common to match the variable names to the field names to make it
easier to remember which variables came from which fields. Because of this
common usage, and because writing <code>let Point { x: x, y: y } = p;</code> contains a
lot of duplication, Rust has a shorthand for patterns that match struct fields:
you only need to list the name of the struct field, and the variables created
from the pattern will have the same names. Listing 18-13 behaves in the same
way as the code in Listing 18-12, but the variables created in the <code>let</code>
pattern are <code>x</code> and <code>y</code> instead of <code>a</code> and <code>b</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<p><span class="caption">Listing 18-13: Destructuring struct fields using struct
field shorthand</span></p>
<p>This code creates the variables <code>x</code> and <code>y</code> that match the <code>x</code> and <code>y</code> fields
of the <code>p</code> variable. The outcome is that the variables <code>x</code> and <code>y</code> contain the
values from the <code>p</code> struct.</p>
<p>We can also destructure with literal values as part of the struct pattern
rather than creating variables for all the fields. Doing so allows us to test
some of the fields for particular values while creating variables to
destructure the other fields.</p>
<p>In Listing 18-14, we have a <code>match</code> expression that separates <code>Point</code> values
into three cases: points that lie directly on the <code>x</code> axis (which is true when
<code>y = 0</code>), on the <code>y</code> axis (<code>x = 0</code>), or neither.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-14: Destructuring and matching literal values
in one pattern</span></p>
<p>The first arm will match any point that lies on the <code>x</code> axis by specifying that
the <code>y</code> field matches if its value matches the literal <code>0</code>. The pattern still
creates an <code>x</code> variable that we can use in the code for this arm.</p>
<p>Similarly, the second arm matches any point on the <code>y</code> axis by specifying that
the <code>x</code> field matches if its value is <code>0</code> and creates a variable <code>y</code> for the
value of the <code>y</code> field. The third arm doesn’t specify any literals, so it
matches any other <code>Point</code> and creates variables for both the <code>x</code> and <code>y</code> fields.</p>
<p>In this example, the value <code>p</code> matches the second arm by virtue of <code>x</code>
containing a 0, so this code will print <code>On the y axis at 7</code>.</p>
<h4 id="destructuring-enums"><a class="header" href="#destructuring-enums">Destructuring Enums</a></h4>
<p>We've destructured enums in this book (for example, Listing 6-5 in Chapter 6),
but haven’t yet explicitly discussed that the pattern to destructure an enum
corresponds to the way the data stored within the enum is defined. As an
example, in Listing 18-15 we use the <code>Message</code> enum from Listing 6-2 and write
a <code>match</code> with patterns that will destructure each inner value.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;)
        }
        Message::Move { x, y } =&gt; {
            println!(
                &quot;Move in the x direction {} and in the y direction {}&quot;,
                x, y
            );
        }
        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; println!(
            &quot;Change the color to red {}, green {}, and blue {}&quot;,
            r, g, b
        ),
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-15: Destructuring enum variants that hold
different kinds of values</span></p>
<p>This code will print <code>Change the color to red 0, green 160, and blue 255</code>. Try
changing the value of <code>msg</code> to see the code from the other arms run.</p>
<p>For enum variants without any data, like <code>Message::Quit</code>, we can’t destructure
the value any further. We can only match on the literal <code>Message::Quit</code> value,
and no variables are in that pattern.</p>
<p>For struct-like enum variants, such as <code>Message::Move</code>, we can use a pattern
similar to the pattern we specify to match structs. After the variant name, we
place curly brackets and then list the fields with variables so we break apart
the pieces to use in the code for this arm. Here we use the shorthand form as
we did in Listing 18-13.</p>
<p>For tuple-like enum variants, like <code>Message::Write</code> that holds a tuple with one
element and <code>Message::ChangeColor</code> that holds a tuple with three elements, the
pattern is similar to the pattern we specify to match tuples. The number of
variables in the pattern must match the number of elements in the variant we’re
matching.</p>
<h4 id="destructuring-nested-structs-and-enums"><a class="header" href="#destructuring-nested-structs-and-enums">Destructuring Nested Structs and Enums</a></h4>
<p>So far, our examples have all been matching structs or enums one level deep,
but matching can work on nested items too! For example, we can refactor the
code in Listing 18-15 to support RGB and HSV colors in the <code>ChangeColor</code>
message, as shown in Listing 18-16.</p>
<pre><pre class="playground"><code class="language-rust">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; println!(
            &quot;Change the color to red {}, green {}, and blue {}&quot;,
            r, g, b
        ),
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; println!(
            &quot;Change the color to hue {}, saturation {}, and value {}&quot;,
            h, s, v
        ),
        _ =&gt; (),
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-16: Matching on nested enums</span></p>
<p>The pattern of the first arm in the <code>match</code> expression matches a
<code>Message::ChangeColor</code> enum variant that contains a <code>Color::Rgb</code> variant; then
the pattern binds to the three inner <code>i32</code> values. The pattern of the second
arm also matches a <code>Message::ChangeColor</code> enum variant, but the inner enum
matches <code>Color::Hsv</code> instead. We can specify these complex conditions in one
<code>match</code> expression, even though two enums are involved.</p>
<h4 id="destructuring-structs-and-tuples"><a class="header" href="#destructuring-structs-and-tuples">Destructuring Structs and Tuples</a></h4>
<p>We can mix, match, and nest destructuring patterns in even more complex ways.
The following example shows a complicated destructure where we nest structs and
tuples inside a tuple and destructure all the primitive values out:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}
</span></code></pre></pre>
<p>This code lets us break complex types into their component parts so we can use
the values we’re interested in separately.</p>
<p>Destructuring with patterns is a convenient way to use pieces of values, such
as the value from each field in a struct, separately from each other.</p>
<h3 id="ignoring-values-in-a-pattern"><a class="header" href="#ignoring-values-in-a-pattern">Ignoring Values in a Pattern</a></h3>
<p>You’ve seen that it’s sometimes useful to ignore values in a pattern, such as
in the last arm of a <code>match</code>, to get a catchall that doesn’t actually do
anything but does account for all remaining possible values. There are a few
ways to ignore entire values or parts of values in a pattern: using the <code>_</code>
pattern (which you’ve seen), using the <code>_</code> pattern within another pattern,
using a name that starts with an underscore, or using <code>..</code> to ignore remaining
parts of a value. Let’s explore how and why to use each of these patterns.</p>
<h4 id="ignoring-an-entire-value-with-_"><a class="header" href="#ignoring-an-entire-value-with-_">Ignoring an Entire Value with <code>_</code></a></h4>
<p>We’ve used the underscore as a wildcard pattern that will match any value but
not bind to the value. This is especially useful as the last arm in a <code>match</code>
expression, but we can also use it in any pattern, including function
parameters, as shown in Listing 18-17.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;This code only uses the y parameter: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}
</code></pre></pre>
<p><span class="caption">Listing 18-17: Using <code>_</code> in a function signature</span></p>
<p>This code will completely ignore the value <code>3</code> passed as the first argument,
and will print <code>This code only uses the y parameter: 4</code>.</p>
<p>In most cases when you no longer need a particular function parameter, you
would change the signature so it doesn’t include the unused parameter. Ignoring
a function parameter can be especially useful in cases when, for example,
you're implementing a trait when you need a certain type signature but the
function body in your implementation doesn’t need one of the parameters. You
then avoid getting a compiler warning about unused function parameters, as you
would if you used a name instead.</p>
<h4 id="ignoring-parts-of-a-value-with-a-nested-_"><a class="header" href="#ignoring-parts-of-a-value-with-a-nested-_">Ignoring Parts of a Value with a Nested <code>_</code></a></h4>
<p>We can also use <code>_</code> inside another pattern to ignore just part of a value, for
example, when we want to test for only part of a value but have no use for the
other parts in the corresponding code we want to run. Listing 18-18 shows code
responsible for managing a setting’s value. The business requirements are that
the user should not be allowed to overwrite an existing customization of a
setting but can unset the setting and give it a value if it is currently unset.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!(&quot;Can't overwrite an existing customized value&quot;);
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!(&quot;setting is {:?}&quot;, setting_value);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-18: Using an underscore within patterns that
match <code>Some</code> variants when we don’t need to use the value inside the
<code>Some</code></span></p>
<p>This code will print <code>Can't overwrite an existing customized value</code> and then
<code>setting is Some(5)</code>. In the first match arm, we don’t need to match on or use
the values inside either <code>Some</code> variant, but we do need to test for the case
when <code>setting_value</code> and <code>new_setting_value</code> are the <code>Some</code> variant. In that
case, we print the reason for not changing <code>setting_value</code>, and it doesn’t get
changed.</p>
<p>In all other cases (if either <code>setting_value</code> or <code>new_setting_value</code> are
<code>None</code>) expressed by the <code>_</code> pattern in the second arm, we want to allow
<code>new_setting_value</code> to become <code>setting_value</code>.</p>
<p>We can also use underscores in multiple places within one pattern to ignore
particular values. Listing 18-19 shows an example of ignoring the second and
fourth values in a tuple of five items.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!(&quot;Some numbers: {}, {}, {}&quot;, first, third, fifth)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-19: Ignoring multiple parts of a tuple</span></p>
<p>This code will print <code>Some numbers: 2, 8, 32</code>, and the values 4 and 16 will be
ignored.</p>
<h4 id="ignoring-an-unused-variable-by-starting-its-name-with-_"><a class="header" href="#ignoring-an-unused-variable-by-starting-its-name-with-_">Ignoring an Unused Variable by Starting Its Name with <code>_</code></a></h4>
<p>If you create a variable but don’t use it anywhere, Rust will usually issue a
warning because an unused variable could be a bug. However, sometimes it’s
useful to be able to create a variable you won’t use yet, such as when you’re
prototyping or just starting a project. In this situation, you can tell Rust
not to warn you about the unused variable by starting the name of the variable
with an underscore. In Listing 18-20, we create two unused variables, but when
we compile this code, we should only get a warning about one of them.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<p><span class="caption">Listing 18-20: Starting a variable name with an
underscore to avoid getting unused variable warnings</span></p>
<p>Here we get a warning about not using the variable <code>y</code>, but we don’t get a
warning about not using <code>_x</code>.</p>
<p>Note that there is a subtle difference between using only <code>_</code> and using a name
that starts with an underscore. The syntax <code>_x</code> still binds the value to the
variable, whereas <code>_</code> doesn’t bind at all. To show a case where this
distinction matters, Listing 18-21 will provide us with an error.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hello!&quot;));

    if let Some(_s) = s {
        println!(&quot;found a string&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 18-21: An unused variable starting with an
underscore still binds the value, which might take ownership of the value</span></p>
<p>We’ll receive an error because the <code>s</code> value will still be moved into <code>_s</code>,
which prevents us from using <code>s</code> again. However, using the underscore by itself
doesn’t ever bind to the value. Listing 18-22 will compile without any errors
because <code>s</code> doesn’t get moved into <code>_</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hello!&quot;));

    if let Some(_) = s {
        println!(&quot;found a string&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-22: Using an underscore does not bind the
value</span></p>
<p>This code works just fine because we never bind <code>s</code> to anything; it isn’t moved.</p>
<h4 id="ignoring-remaining-parts-of-a-value-with-"><a class="header" href="#ignoring-remaining-parts-of-a-value-with-">Ignoring Remaining Parts of a Value with <code>..</code></a></h4>
<p>With values that have many parts, we can use the <code>..</code> syntax to use specific
parts and ignore the rest, avoiding the need to list underscores for each
ignored value. The <code>..</code> pattern ignores any parts of a value that we haven’t
explicitly matched in the rest of the pattern. In Listing 18-23, we have a
<code>Point</code> struct that holds a coordinate in three-dimensional space. In the
<code>match</code> expression, we want to operate only on the <code>x</code> coordinate and ignore
the values in the <code>y</code> and <code>z</code> fields.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-23: Ignoring all fields of a <code>Point</code> except
for <code>x</code> by using <code>..</code></span></p>
<p>We list the <code>x</code> value and then just include the <code>..</code> pattern. This is quicker
than having to list <code>y: _</code> and <code>z: _</code>, particularly when we’re working with
structs that have lots of fields in situations where only one or two fields are
relevant.</p>
<p>The syntax <code>..</code> will expand to as many values as it needs to be. Listing 18-24
shows how to use <code>..</code> with a tuple.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {}, {}&quot;, first, last);
        }
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-24: Matching only the first and last values in
a tuple and ignoring all other values</span></p>
<p>In this code, the first and last value are matched with <code>first</code> and <code>last</code>. The
<code>..</code> will match and ignore everything in the middle.</p>
<p>However, using <code>..</code> must be unambiguous. If it is unclear which values are
intended for matching and which should be ignored, Rust will give us an error.
Listing 18-25 shows an example of using <code>..</code> ambiguously, so it will not
compile.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {}&quot;, second)
        },
    }
}
</code></pre>
<p><span class="caption">Listing 18-25: An attempt to use <code>..</code> in an ambiguous
way</span></p>
<p>When we compile this example, we get this error:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` due to previous error
</code></pre>
<p>It’s impossible for Rust to determine how many values in the tuple to ignore
before matching a value with <code>second</code> and then how many further values to
ignore thereafter. This code could mean that we want to ignore <code>2</code>, bind
<code>second</code> to <code>4</code>, and then ignore <code>8</code>, <code>16</code>, and <code>32</code>; or that we want to ignore
<code>2</code> and <code>4</code>, bind <code>second</code> to <code>8</code>, and then ignore <code>16</code> and <code>32</code>; and so forth.
The variable name <code>second</code> doesn’t mean anything special to Rust, so we get a
compiler error because using <code>..</code> in two places like this is ambiguous.</p>
<h3 id="extra-conditionals-with-match-guards"><a class="header" href="#extra-conditionals-with-match-guards">Extra Conditionals with Match Guards</a></h3>
<p>A <em>match guard</em> is an additional <code>if</code> condition, specified after the pattern in
a <code>match</code> arm, that must also match for that arm to be chosen. Match guards are
useful for expressing more complex ideas than a pattern alone allows.</p>
<p>The condition can use variables created in the pattern. Listing 18-26 shows a
<code>match</code> where the first arm has the pattern <code>Some(x)</code> and also has a match
guard of <code>if x % 2 == 0</code> (which will be true if the number is even).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!(&quot;The number {} is even&quot;, x),
        Some(x) =&gt; println!(&quot;The number {} is odd&quot;, x),
        None =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-26: Adding a match guard to a pattern</span></p>
<p>This example will print <code>The number 4 is even</code>. When <code>num</code> is compared to the
pattern in the first arm, it matches, because <code>Some(4)</code> matches <code>Some(x)</code>. Then
the match guard checks whether the remainder of dividing <code>x</code> by 2 is equal to
0, and because it is, the first arm is selected.</p>
<p>If <code>num</code> had been <code>Some(5)</code> instead, the match guard in the first arm would
have been false because the remainder of 5 divided by 2 is 1, which is not
equal to 0. Rust would then go to the second arm, which would match because the
second arm doesn’t have a match guard and therefore matches any <code>Some</code> variant.</p>
<p>There is no way to express the <code>if x % 2 == 0</code> condition within a pattern, so
the match guard gives us the ability to express this logic. The downside of
this additional expressiveness is that the compiler doesn't try to check for
exhaustiveness when match guard expressions are involved.</p>
<p>In Listing 18-11, we mentioned that we could use match guards to solve our
pattern-shadowing problem. Recall that we created a new variable inside the
pattern in the <code>match</code> expression instead of using the variable outside the
<code>match</code>. That new variable meant we couldn’t test against the value of the
outer variable. Listing 18-27 shows how we can use a match guard to fix this
problem.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Matched, n = {}&quot;, n),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">Listing 18-27: Using a match guard to test for equality
with an outer variable</span></p>
<p>This code will now print <code>Default case, x = Some(5)</code>. The pattern in the second
match arm doesn’t introduce a new variable <code>y</code> that would shadow the outer <code>y</code>,
meaning we can use the outer <code>y</code> in the match guard. Instead of specifying the
pattern as <code>Some(y)</code>, which would have shadowed the outer <code>y</code>, we specify
<code>Some(n)</code>. This creates a new variable <code>n</code> that doesn’t shadow anything because
there is no <code>n</code> variable outside the <code>match</code>.</p>
<p>The match guard <code>if n == y</code> is not a pattern and therefore doesn’t introduce
new variables. This <code>y</code> <em>is</em> the outer <code>y</code> rather than a new shadowed <code>y</code>, and
we can look for a value that has the same value as the outer <code>y</code> by comparing
<code>n</code> to <code>y</code>.</p>
<p>You can also use the <em>or</em> operator <code>|</code> in a match guard to specify multiple
patterns; the match guard condition will apply to all the patterns. Listing
18-28 shows the precedence when combining a pattern that uses <code>|</code> with a match
guard. The important part of this example is that the <code>if y</code> match guard
applies to <code>4</code>, <code>5</code>, <em>and</em> <code>6</code>, even though it might look like <code>if y</code> only
applies to <code>6</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
        _ =&gt; println!(&quot;no&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-28: Combining multiple patterns with a match
guard</span></p>
<p>The match condition states that the arm only matches if the value of <code>x</code> is
equal to <code>4</code>, <code>5</code>, or <code>6</code> <em>and</em> if <code>y</code> is <code>true</code>. When this code runs, the
pattern of the first arm matches because <code>x</code> is <code>4</code>, but the match guard <code>if y</code>
is false, so the first arm is not chosen. The code moves on to the second arm,
which does match, and this program prints <code>no</code>. The reason is that the <code>if</code>
condition applies to the whole pattern <code>4 | 5 | 6</code>, not only to the last value
<code>6</code>. In other words, the precedence of a match guard in relation to a pattern
behaves like this:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>rather than this:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>After running the code, the precedence behavior is evident: if the match guard
were applied only to the final value in the list of values specified using the
<code>|</code> operator, the arm would have matched and the program would have printed
<code>yes</code>.</p>
<h3 id="-bindings"><a class="header" href="#-bindings"><code>@</code> Bindings</a></h3>
<p>The <em>at</em> operator <code>@</code> lets us create a variable that holds a value at the same
time as we’re testing that value for a pattern match. In Listing 18-29, we want
to test that a <code>Message::Hello</code> <code>id</code> field is within the range <code>3..=7</code>. We also
want to bind the value to the variable <code>id_variable</code> so we can use it in the
code associated with the arm. We could name this variable <code>id</code>, the same as the
field, but for this example we’ll use a different name.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!(&quot;Found an id in range: {}&quot;, id_variable),
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&quot;Found an id in another range&quot;)
        }
        Message::Hello { id } =&gt; println!(&quot;Found some other id: {}&quot;, id),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-29: Using <code>@</code> to bind to a value in a pattern
while also testing it</span></p>
<p>This example will print <code>Found an id in range: 5</code>. By specifying <code>id_variable @</code> before the range <code>3..=7</code>, we’re capturing whatever value matched the range
while also testing that the value matched the range pattern.</p>
<p>In the second arm, where we only have a range specified in the pattern, the code
associated with the arm doesn’t have a variable that contains the actual value
of the <code>id</code> field. The <code>id</code> field’s value could have been 10, 11, or 12, but
the code that goes with that pattern doesn’t know which it is. The pattern code
isn’t able to use the value from the <code>id</code> field, because we haven’t saved the
<code>id</code> value in a variable.</p>
<p>In the last arm, where we’ve specified a variable without a range, we do have
the value available to use in the arm’s code in a variable named <code>id</code>. The
reason is that we’ve used the struct field shorthand syntax. But we haven’t
applied any test to the value in the <code>id</code> field in this arm, as we did with the
first two arms: any value would match this pattern.</p>
<p>Using <code>@</code> lets us test a value and save it in a variable within one pattern.</p>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>Rust’s patterns are very useful in distinguishing between different kinds of
data. When used in <code>match</code> expressions, Rust ensures your patterns cover every
possible value, or your program won’t compile. Patterns in <code>let</code> statements and
function parameters make those constructs more useful, enabling the
destructuring of values into smaller parts at the same time as assigning to
variables. We can create simple or complex patterns to suit our needs.</p>
<p>Next, for the penultimate chapter of the book, we’ll look at some advanced
aspects of a variety of Rust’s features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gelişmiş-Özellikler"><a class="header" href="#gelişmiş-Özellikler">Gelişmiş Özellikler</a></h1>
<p>Şimdiye kadar Rust programlama dilinin en sık kullanılan kısımlarını öğrendiniz. 
Bölüm 20'de bir proje daha yapmadan önce, arada bir karşılaşabileceğiniz, ancak her gün kullanmayabileceğiniz dilin birkaç farklı yönüne bakacağız. 
Herhangi bir bilmediğiniz özelliklerle karşılaştığınızda bu bölümü referans olarak kullanabilirsiniz. 
Burada kapsanan özellikler, <em>adı gibi</em> özel durumlarda faydalıdır. Bunlara sık sık ulaşamasanız da, Rust'ın sunduğu tüm özellikleri kavradığınızdan emin olmak istiyoruz.</p>
<p>Bu bölümde şunları ele alacağız:</p>
<ul>
<li>Güvensiz Rust: Rust'ın bellek garantilerinin bazılarından nasıl vazgeçilir ve bu garantilerin manuel olarak desteklenmesi için gerekli sorumluluk nasıl alınır</li>
<li>Gelişmiş özellikler: ilişkili türler, varsayılan tür parametreleri, tam nitelikli söz dizimi, süper özellikler ve özelliklerle ilgili yeni tür modeli</li>
<li>Gelişmiş türler: hakkında daha fazla bilgi yeni tip desen, tür takma adları ve dinamik olarak boyutlandırılmış türler </li>
<li>Gelişmiş işlevler ve kapatmalar: fonksiyon işaretçileri ve dönüşlü kapanış ifadeleri </li>
<li>Makrolar: derleme zamanında çalıştırılan daha fazla kod tanımlamanın yolları</li>
</ul>
<p>Bu, herkes için bir şeyler içeren bir dizi Rust özelliğidir! Hadi dalalım!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unsafe-rust"><a class="header" href="#unsafe-rust">Unsafe Rust</a></h2>
<p>All the code we’ve discussed so far has had Rust’s memory safety guarantees
enforced at compile time. However, Rust has a second language hidden inside it
that doesn’t enforce these memory safety guarantees: it’s called <em>unsafe Rust</em>
and works just like regular Rust, but gives us extra superpowers.</p>
<p>Unsafe Rust exists because, by nature, static analysis is conservative. When
the compiler tries to determine whether or not code upholds the guarantees,
it’s better for it to reject some valid programs than to accept some invalid
programs. Although the code <em>might</em> be okay, if the Rust compiler doesn’t have
enough information to be confident, it will reject the code. In these cases,
you can use unsafe code to tell the compiler, “Trust me, I know what I’m
doing.” Be warned, however, that you use unsafe Rust at your own risk: if you
use unsafe code incorrectly, problems can occur due to memory unsafety, such as
null pointer dereferencing.</p>
<p>Another reason Rust has an unsafe alter ego is that the underlying computer
hardware is inherently unsafe. If Rust didn’t let you do unsafe operations, you
couldn’t do certain tasks. Rust needs to allow you to do low-level systems
programming, such as directly interacting with the operating system or even
writing your own operating system. Working with low-level systems programming
is one of the goals of the language. Let’s explore what we can do with unsafe
Rust and how to do it.</p>
<h3 id="unsafe-superpowers"><a class="header" href="#unsafe-superpowers">Unsafe Superpowers</a></h3>
<p>To switch to unsafe Rust, use the <code>unsafe</code> keyword and then start a new block
that holds the unsafe code. You can take five actions in unsafe Rust that you
can’t in safe Rust, which we call <em>unsafe superpowers</em>. Those superpowers
include the ability to:</p>
<ul>
<li>Dereference a raw pointer</li>
<li>Call an unsafe function or method</li>
<li>Access or modify a mutable static variable</li>
<li>Implement an unsafe trait</li>
<li>Access fields of <code>union</code>s</li>
</ul>
<p>It’s important to understand that <code>unsafe</code> doesn’t turn off the borrow checker
or disable any other of Rust’s safety checks: if you use a reference in unsafe
code, it will still be checked. The <code>unsafe</code> keyword only gives you access to
these five features that are then not checked by the compiler for memory
safety. You’ll still get some degree of safety inside of an unsafe block.</p>
<p>In addition, <code>unsafe</code> does not mean the code inside the block is necessarily
dangerous or that it will definitely have memory safety problems: the intent is
that as the programmer, you’ll ensure the code inside an <code>unsafe</code> block will
access memory in a valid way.</p>
<p>People are fallible, and mistakes will happen, but by requiring these five
unsafe operations to be inside blocks annotated with <code>unsafe</code> you’ll know that
any errors related to memory safety must be within an <code>unsafe</code> block. Keep
<code>unsafe</code> blocks small; you’ll be thankful later when you investigate memory
bugs.</p>
<p>To isolate unsafe code as much as possible, it’s best to enclose unsafe code
within a safe abstraction and provide a safe API, which we’ll discuss later in
the chapter when we examine unsafe functions and methods. Parts of the standard
library are implemented as safe abstractions over unsafe code that has been
audited. Wrapping unsafe code in a safe abstraction prevents uses of <code>unsafe</code>
from leaking out into all the places that you or your users might want to use
the functionality implemented with <code>unsafe</code> code, because using a safe
abstraction is safe.</p>
<p>Let’s look at each of the five unsafe superpowers in turn. We’ll also look at
some abstractions that provide a safe interface to unsafe code.</p>
<h3 id="dereferencing-a-raw-pointer"><a class="header" href="#dereferencing-a-raw-pointer">Dereferencing a Raw Pointer</a></h3>
<p>In Chapter 4, in the <a href="ch04-02-references-and-borrowing.html#dangling-references">“Dangling References”</a><!-- ignore
--> section, we mentioned that the compiler ensures references are always
valid. Unsafe Rust has two new types called <em>raw pointers</em> that are similar to
references. As with references, raw pointers can be immutable or mutable and
are written as <code>*const T</code> and <code>*mut T</code>, respectively. The asterisk isn’t the
dereference operator; it’s part of the type name. In the context of raw
pointers, <em>immutable</em> means that the pointer can’t be directly assigned to
after being dereferenced.</p>
<p>Different from references and smart pointers, raw pointers:</p>
<ul>
<li>Are allowed to ignore the borrowing rules by having both immutable and
mutable pointers or multiple mutable pointers to the same location</li>
<li>Aren’t guaranteed to point to valid memory</li>
<li>Are allowed to be null</li>
<li>Don’t implement any automatic cleanup</li>
</ul>
<p>By opting out of having Rust enforce these guarantees, you can give up
guaranteed safety in exchange for greater performance or the ability to
interface with another language or hardware where Rust’s guarantees don’t apply.</p>
<p>Listing 19-1 shows how to create an immutable and a mutable raw pointer from
references.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-1: Creating raw pointers from references</span></p>
<p>Notice that we don’t include the <code>unsafe</code> keyword in this code. We can create
raw pointers in safe code; we just can’t dereference raw pointers outside an
unsafe block, as you’ll see in a bit.</p>
<p>We’ve created raw pointers by using <code>as</code> to cast an immutable and a mutable
reference into their corresponding raw pointer types. Because we created them
directly from references guaranteed to be valid, we know these particular raw
pointers are valid, but we can’t make that assumption about just any raw
pointer.</p>
<p>To demonstrate this, next we’ll create a raw pointer whose validity we can’t be
so certain of. Listing 19-2 shows how to create a raw pointer to an arbitrary
location in memory. Trying to use arbitrary memory is undefined: there might be
data at that address or there might not, the compiler might optimize the code
so there is no memory access, or the program might error with a segmentation
fault. Usually, there is no good reason to write code like this, but it is
possible.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-2: Creating a raw pointer to an arbitrary
memory address</span></p>
<p>Recall that we can create raw pointers in safe code, but we can’t <em>dereference</em>
raw pointers and read the data being pointed to. In Listing 19-3, we use the
dereference operator <code>*</code> on a raw pointer that requires an <code>unsafe</code> block.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;

    unsafe {
        println!(&quot;r1 is: {}&quot;, *r1);
        println!(&quot;r2 is: {}&quot;, *r2);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-3: Dereferencing raw pointers within an
<code>unsafe</code> block</span></p>
<p>Creating a pointer does no harm; it’s only when we try to access the value that
it points at that we might end up dealing with an invalid value.</p>
<p>Note also that in Listing 19-1 and 19-3, we created <code>*const i32</code> and <code>*mut i32</code>
raw pointers that both pointed to the same memory location, where <code>num</code> is
stored. If we instead tried to create an immutable and a mutable reference to
<code>num</code>, the code would not have compiled because Rust’s ownership rules don’t
allow a mutable reference at the same time as any immutable references. With
raw pointers, we can create a mutable pointer and an immutable pointer to the
same location and change data through the mutable pointer, potentially creating
a data race. Be careful!</p>
<p>With all of these dangers, why would you ever use raw pointers? One major use
case is when interfacing with C code, as you’ll see in the next section,
<a href="ch19-01-unsafe-rust.html#calling-an-unsafe-function-or-method">“Calling an Unsafe Function or
Method.”</a><!-- ignore --> Another case is
when building up safe abstractions that the borrow checker doesn’t understand.
We’ll introduce unsafe functions and then look at an example of a safe
abstraction that uses unsafe code.</p>
<h3 id="calling-an-unsafe-function-or-method"><a class="header" href="#calling-an-unsafe-function-or-method">Calling an Unsafe Function or Method</a></h3>
<p>The second type of operation you can perform in an unsafe block is calling
unsafe functions. Unsafe functions and methods look exactly like regular
functions and methods, but they have an extra <code>unsafe</code> before the rest of the
definition. The <code>unsafe</code> keyword in this context indicates the function has
requirements we need to uphold when we call this function, because Rust can’t
guarantee we’ve met these requirements. By calling an unsafe function within an
<code>unsafe</code> block, we’re saying that we’ve read this function’s documentation and
take responsibility for upholding the function’s contracts.</p>
<p>Here is an unsafe function named <code>dangerous</code> that doesn’t do anything in its
body:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}
</span></code></pre></pre>
<p>We must call the <code>dangerous</code> function within a separate <code>unsafe</code> block. If we
try to call <code>dangerous</code> without the <code>unsafe</code> block, we’ll get an error:</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` due to previous error
</code></pre>
<p>With the <code>unsafe</code> block, we’re asserting to Rust that we’ve read the function’s
documentation, we understand how to use it properly, and we’ve verified that
we’re fulfilling the contract of the function.</p>
<p>Bodies of unsafe functions are effectively <code>unsafe</code> blocks, so to perform other
unsafe operations within an unsafe function, we don’t need to add another
<code>unsafe</code> block.</p>
<h4 id="creating-a-safe-abstraction-over-unsafe-code"><a class="header" href="#creating-a-safe-abstraction-over-unsafe-code">Creating a Safe Abstraction over Unsafe Code</a></h4>
<p>Just because a function contains unsafe code doesn’t mean we need to mark the
entire function as unsafe. In fact, wrapping unsafe code in a safe function is
a common abstraction. As an example, let’s study the <code>split_at_mut</code> function
from the standard library, which requires some unsafe code. We’ll explore how
we might implement it. This safe method is defined on mutable slices: it takes
one slice and makes it two by splitting the slice at the index given as an
argument. Listing 19-4 shows how to use <code>split_at_mut</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-4: Using the safe <code>split_at_mut</code>
function</span></p>
<p>We can’t implement this function using only safe Rust. An attempt might look
something like Listing 19-5, which won’t compile. For simplicity, we’ll
implement <code>split_at_mut</code> as a function rather than a method and only for slices
of <code>i32</code> values rather than for a generic type <code>T</code>.</p>
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 19-5: An attempted implementation of
<code>split_at_mut</code> using only safe Rust</span></p>
<p>This function first gets the total length of the slice. Then it asserts that
the index given as a parameter is within the slice by checking whether it’s
less than or equal to the length. The assertion means that if we pass an index
that is greater than the length to split the slice at, the function will panic
before it attempts to use that index.</p>
<p>Then we return two mutable slices in a tuple: one from the start of the
original slice to the <code>mid</code> index and another from <code>mid</code> to the end of the
slice.</p>
<p>When we try to compile the code in Listing 19-5, we’ll get an error.</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:31
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` due to previous error
</code></pre>
<p>Rust’s borrow checker can’t understand that we’re borrowing different parts of
the slice; it only knows that we’re borrowing from the same slice twice.
Borrowing different parts of a slice is fundamentally okay because the two
slices aren’t overlapping, but Rust isn’t smart enough to know this. When we
know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.</p>
<p>Listing 19-6 shows how to use an <code>unsafe</code> block, a raw pointer, and some calls
to unsafe functions to make the implementation of <code>split_at_mut</code> work.</p>
<pre><pre class="playground"><code class="language-rust">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-6: Using unsafe code in the implementation of
the <code>split_at_mut</code> function</span></p>
<p>Recall from <a href="ch04-03-slices.html#the-slice-type">“The Slice Type”</a><!-- ignore --> section in
Chapter 4 that slices are a pointer to some data and the length of the slice.
We use the <code>len</code> method to get the length of a slice and the <code>as_mut_ptr</code>
method to access the raw pointer of a slice. In this case, because we have a
mutable slice to <code>i32</code> values, <code>as_mut_ptr</code> returns a raw pointer with the type
<code>*mut i32</code>, which we’ve stored in the variable <code>ptr</code>.</p>
<p>We keep the assertion that the <code>mid</code> index is within the slice. Then we get to
the unsafe code: the <code>slice::from_raw_parts_mut</code> function takes a raw pointer
and a length, and it creates a slice. We use this function to create a slice
that starts from <code>ptr</code> and is <code>mid</code> items long. Then we call the <code>add</code>
method on <code>ptr</code> with <code>mid</code> as an argument to get a raw pointer that starts at
<code>mid</code>, and we create a slice using that pointer and the remaining number of
items after <code>mid</code> as the length.</p>
<p>The function <code>slice::from_raw_parts_mut</code> is unsafe because it takes a raw
pointer and must trust that this pointer is valid. The <code>add</code> method on raw
pointers is also unsafe, because it must trust that the offset location is also
a valid pointer. Therefore, we had to put an <code>unsafe</code> block around our calls to
<code>slice::from_raw_parts_mut</code> and <code>add</code> so we could call them. By looking at
the code and by adding the assertion that <code>mid</code> must be less than or equal to
<code>len</code>, we can tell that all the raw pointers used within the <code>unsafe</code> block
will be valid pointers to data within the slice. This is an acceptable and
appropriate use of <code>unsafe</code>.</p>
<p>Note that we don’t need to mark the resulting <code>split_at_mut</code> function as
<code>unsafe</code>, and we can call this function from safe Rust. We’ve created a safe
abstraction to the unsafe code with an implementation of the function that uses
<code>unsafe</code> code in a safe way, because it creates only valid pointers from the
data this function has access to.</p>
<p>In contrast, the use of <code>slice::from_raw_parts_mut</code> in Listing 19-7 would
likely crash when the slice is used. This code takes an arbitrary memory
location and creates a slice 10,000 items long.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-7: Creating a slice from an arbitrary memory
location</span></p>
<p>We don’t own the memory at this arbitrary location, and there is no guarantee
that the slice this code creates contains valid <code>i32</code> values. Attempting to use
<code>values</code> as though it’s a valid slice results in undefined behavior.</p>
<h4 id="using-extern-functions-to-call-external-code"><a class="header" href="#using-extern-functions-to-call-external-code">Using <code>extern</code> Functions to Call External Code</a></h4>
<p>Sometimes, your Rust code might need to interact with code written in another
language. For this, Rust has the keyword <code>extern</code> that facilitates the creation
and use of a <em>Foreign Function Interface (FFI)</em>. An FFI is a way for a
programming language to define functions and enable a different (foreign)
programming language to call those functions.</p>
<p>Listing 19-8 demonstrates how to set up an integration with the <code>abs</code> function
from the C standard library. Functions declared within <code>extern</code> blocks are
always unsafe to call from Rust code. The reason is that other languages don’t
enforce Rust’s rules and guarantees, and Rust can’t check them, so
responsibility falls on the programmer to ensure safety.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<p><span class="caption">Listing 19-8: Declaring and calling an <code>extern</code> function
defined in another language</span></p>
<p>Within the <code>extern &quot;C&quot;</code> block, we list the names and signatures of external
functions from another language we want to call. The <code>&quot;C&quot;</code> part defines which
<em>application binary interface (ABI)</em> the external function uses: the ABI
defines how to call the function at the assembly level. The <code>&quot;C&quot;</code> ABI is the
most common and follows the C programming language’s ABI.</p>
<blockquote>
<h4 id="calling-rust-functions-from-other-languages"><a class="header" href="#calling-rust-functions-from-other-languages">Calling Rust Functions from Other Languages</a></h4>
<p>We can also use <code>extern</code> to create an interface that allows other languages
to call Rust functions. Instead of an creating a whole <code>extern</code> block, we add
the <code>extern</code> keyword and specify the ABI to use just before the <code>fn</code> keyword
for the relevant function. We also need to add a <code>#[no_mangle]</code> annotation to
tell the Rust compiler not to mangle the name of this function. <em>Mangling</em> is
when a compiler changes the name we’ve given a function to a different name
that contains more information for other parts of the compilation process to
consume but is less human readable. Every programming language compiler
mangles names slightly differently, so for a Rust function to be nameable by
other languages, we must disable the Rust compiler’s name mangling.</p>
<p>In the following example, we make the <code>call_from_c</code> function accessible from
C code, after it’s compiled to a shared library and linked from C:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>This usage of <code>extern</code> does not require <code>unsafe</code>.</p>
</blockquote>
<h3 id="accessing-or-modifying-a-mutable-static-variable"><a class="header" href="#accessing-or-modifying-a-mutable-static-variable">Accessing or Modifying a Mutable Static Variable</a></h3>
<p>In this book, we’ve not yet talked about <em>global variables</em>, which Rust does
support but can be problematic with Rust’s ownership rules. If two threads are
accessing the same mutable global variable, it can cause a data race.</p>
<p>In Rust, global variables are called <em>static</em> variables. Listing 19-9 shows an
example declaration and use of a static variable with a string slice as a
value.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name is: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<p><span class="caption">Listing 19-9: Defining and using an immutable static
variable</span></p>
<p>Static variables are similar to constants, which we discussed in the
<a href="ch03-01-variables-and-mutability.html#constants">“Differences Between Variables and
Constants”</a><!-- ignore --> section
in Chapter 3. The names of static variables are in <code>SCREAMING_SNAKE_CASE</code> by
convention. Static variables can only store references with the <code>'static</code>
lifetime, which means the Rust compiler can figure out the lifetime and we
aren’t required to annotate it explicitly. Accessing an immutable static
variable is safe.</p>
<p>A subtle difference between constants and immutable static variables is that
values in a static variable have a fixed address in memory. Using the value
will always access the same data. Constants, on the other hand, are allowed to
duplicate their data whenever they’re used. Another difference is that static
variables can be mutable. Accessing and modifying mutable static variables is
<em>unsafe</em>. Listing 19-10 shows how to declare, access, and modify a mutable
static variable named <code>COUNTER</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 19-10: Reading from or writing to a mutable
static variable is unsafe</span></p>
<p>As with regular variables, we specify mutability using the <code>mut</code> keyword. Any
code that reads or writes from <code>COUNTER</code> must be within an <code>unsafe</code> block. This
code compiles and prints <code>COUNTER: 3</code> as we would expect because it’s single
threaded. Having multiple threads access <code>COUNTER</code> would likely result in data
races.</p>
<p>With mutable data that is globally accessible, it’s difficult to ensure there
are no data races, which is why Rust considers mutable static variables to be
unsafe. Where possible, it’s preferable to use the concurrency techniques and
thread-safe smart pointers we discussed in Chapter 16 so the compiler checks
that data accessed from different threads is done safely.</p>
<h3 id="implementing-an-unsafe-trait"><a class="header" href="#implementing-an-unsafe-trait">Implementing an Unsafe Trait</a></h3>
<p>We can use <code>unsafe</code> to implement an unsafe trait. A trait is unsafe when at
least one of its methods has some invariant that the compiler can’t verify. We
declare that a trait is <code>unsafe</code> by adding the <code>unsafe</code> keyword before <code>trait</code>
and marking the implementation of the trait as <code>unsafe</code> too, as shown in
Listing 19-11.</p>
<pre><pre class="playground"><code class="language-rust">unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}
</code></pre></pre>
<p><span class="caption">Listing 19-11: Defining and implementing an unsafe
trait</span></p>
<p>By using <code>unsafe impl</code>, we’re promising that we’ll uphold the invariants that
the compiler can’t verify.</p>
<p>As an example, recall the <code>Sync</code> and <code>Send</code> marker traits we discussed in the
<a href="ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits">“Extensible Concurrency with the <code>Sync</code> and <code>Send</code>
Traits”</a><!-- ignore -->
section in Chapter 16: the compiler implements these traits automatically if
our types are composed entirely of <code>Send</code> and <code>Sync</code> types. If we implement a
type that contains a type that is not <code>Send</code> or <code>Sync</code>, such as raw pointers,
and we want to mark that type as <code>Send</code> or <code>Sync</code>, we must use <code>unsafe</code>. Rust
can’t verify that our type upholds the guarantees that it can be safely sent
across threads or accessed from multiple threads; therefore, we need to do
those checks manually and indicate as such with <code>unsafe</code>.</p>
<h3 id="accessing-fields-of-a-union"><a class="header" href="#accessing-fields-of-a-union">Accessing Fields of a Union</a></h3>
<p>The final action that works only with <code>unsafe</code> is accessing fields of a
<em>union</em>. A <code>union</code> is similar to a <code>struct</code>, but only one declared field is
used in a particular instance at one time. Unions are primarily used to
interface with unions in C code. Accessing union fields is unsafe because Rust
can’t guarantee the type of the data currently being stored in the union
instance. You can learn more about unions in <a href="../reference/items/unions.html">the Rust Reference</a>.</p>
<h3 id="when-to-use-unsafe-code"><a class="header" href="#when-to-use-unsafe-code">When to Use Unsafe Code</a></h3>
<p>Using <code>unsafe</code> to take one of the five actions (superpowers) just discussed
isn’t wrong or even frowned upon. But it is trickier to get <code>unsafe</code> code
correct because the compiler can’t help uphold memory safety. When you have a
reason to use <code>unsafe</code> code, you can do so, and having the explicit <code>unsafe</code>
annotation makes it easier to track down the source of problems when they occur.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="advanced-traits"><a class="header" href="#advanced-traits">Advanced Traits</a></h2>
<p>We first covered traits in the <a href="ch10-02-traits.html#traits-defining-shared-behavior">“Traits: Defining Shared
Behavior”</a><!-- ignore --> section of Chapter
10, but we didn’t discuss the more advanced details. Now that you know more
about Rust, we can get into the nitty-gritty.</p>
<h3 id="specifying-placeholder-types-in-trait-definitions-with-associated-types"><a class="header" href="#specifying-placeholder-types-in-trait-definitions-with-associated-types">Specifying Placeholder Types in Trait Definitions with Associated Types</a></h3>
<p><em>Associated types</em> connect a type placeholder with a trait such that the trait
method definitions can use these placeholder types in their signatures. The
implementor of a trait will specify the concrete type to be used instead of the
placeholder type for the particular implementation. That way, we can define a
trait that uses some types without needing to know exactly what those types are
until the trait is implemented.</p>
<p>We’ve described most of the advanced features in this chapter as being rarely
needed. Associated types are somewhere in the middle: they’re used more rarely
than features explained in the rest of the book but more commonly than many of
the other features discussed in this chapter.</p>
<p>One example of a trait with an associated type is the <code>Iterator</code> trait that the
standard library provides. The associated type is named <code>Item</code> and stands in
for the type of the values the type implementing the <code>Iterator</code> trait is
iterating over. The definition of the <code>Iterator</code> trait is as shown in Listing
19-12.</p>
<pre><code class="language-rust noplayground">pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
</code></pre>
<p><span class="caption">Listing 19-12: The definition of the <code>Iterator</code> trait
that has an associated type <code>Item</code></span></p>
<p>The type <code>Item</code> is a placeholder, and the <code>next</code> method’s definition shows that
it will return values of type <code>Option&lt;Self::Item&gt;</code>. Implementors of the
<code>Iterator</code> trait will specify the concrete type for <code>Item</code>, and the <code>next</code>
method will return an <code>Option</code> containing a value of that concrete type.</p>
<p>Associated types might seem like a similar concept to generics, in that the
latter allow us to define a function without specifying what types it can
handle. To examine the difference between the two concepts, we’ll look at an
implementation of the <code>Iterator</code> trait on a type named <code>Counter</code> that specifies
the <code>Item</code> type is <code>u32</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>This syntax seems comparable to that of generics. So why not just define the
<code>Iterator</code> trait with generics, as shown in Listing 19-13?</p>
<pre><code class="language-rust noplayground">pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
</code></pre>
<p><span class="caption">Listing 19-13: A hypothetical definition of the
<code>Iterator</code> trait using generics</span></p>
<p>The difference is that when using generics, as in Listing 19-13, we must
annotate the types in each implementation; because we can also implement
<code>Iterator&lt;String&gt; for Counter</code> or any other type, we could have multiple
implementations of <code>Iterator</code> for <code>Counter</code>. In other words, when a trait has a
generic parameter, it can be implemented for a type multiple times, changing
the concrete types of the generic type parameters each time. When we use the
<code>next</code> method on <code>Counter</code>, we would have to provide type annotations to
indicate which implementation of <code>Iterator</code> we want to use.</p>
<p>With associated types, we don’t need to annotate types because we can’t
implement a trait on a type multiple times. In Listing 19-12 with the
definition that uses associated types, we can only choose what the type of
<code>Item</code> will be once, because there can only be one <code>impl Iterator for Counter</code>.
We don’t have to specify that we want an iterator of <code>u32</code> values everywhere
that we call <code>next</code> on <code>Counter</code>.</p>
<h3 id="default-generic-type-parameters-and-operator-overloading"><a class="header" href="#default-generic-type-parameters-and-operator-overloading">Default Generic Type Parameters and Operator Overloading</a></h3>
<p>When we use generic type parameters, we can specify a default concrete type for
the generic type. This eliminates the need for implementors of the trait to
specify a concrete type if the default type works. You specify a default type
when declaring a generic type with the <code>&lt;PlaceholderType=ConcreteType&gt;</code> syntax.</p>
<p>A great example of a situation where this technique is useful is with <em>operator
overloading</em>, in which you customize the behavior of an operator (such as <code>+</code>)
in particular situations.</p>
<p>Rust doesn’t allow you to create your own operators or overload arbitrary
operators. But you can overload the operations and corresponding traits listed
in <code>std::ops</code> by implementing the traits associated with the operator. For
example, in Listing 19-14 we overload the <code>+</code> operator to add two <code>Point</code>
instances together. We do this by implementing the <code>Add</code> trait on a <code>Point</code>
struct:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}
</code></pre></pre>
<p><span class="caption">Listing 19-14: Implementing the <code>Add</code> trait to overload
the <code>+</code> operator for <code>Point</code> instances</span></p>
<p>The <code>add</code> method adds the <code>x</code> values of two <code>Point</code> instances and the <code>y</code>
values of two <code>Point</code> instances to create a new <code>Point</code>. The <code>Add</code> trait has an
associated type named <code>Output</code> that determines the type returned from the <code>add</code>
method.</p>
<p>The default generic type in this code is within the <code>Add</code> trait. Here is its
definition:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p>This code should look generally familiar: a trait with one method and an
associated type. The new part is <code>Rhs=Self</code>: this syntax is called <em>default
type parameters</em>. The <code>Rhs</code> generic type parameter (short for “right hand
side”) defines the type of the <code>rhs</code> parameter in the <code>add</code> method. If we don’t
specify a concrete type for <code>Rhs</code> when we implement the <code>Add</code> trait, the type
of <code>Rhs</code> will default to <code>Self</code>, which will be the type we’re implementing
<code>Add</code> on.</p>
<p>When we implemented <code>Add</code> for <code>Point</code>, we used the default for <code>Rhs</code> because we
wanted to add two <code>Point</code> instances. Let’s look at an example of implementing
the <code>Add</code> trait where we want to customize the <code>Rhs</code> type rather than using the
default.</p>
<p>We have two structs, <code>Millimeters</code> and <code>Meters</code>, holding values in different
units. This thin wrapping of an existing type in another struct is known as the
<em>newtype pattern</em>, which we describe in more detail in the <a href="ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">“Using the Newtype
Pattern to Implement External Traits on External Types”</a><!-- ignore
--> section. We want to add values in millimeters to values in meters and have
the implementation of <code>Add</code> do the conversion correctly. We can implement <code>Add</code>
for <code>Millimeters</code> with <code>Meters</code> as the <code>Rhs</code>, as shown in Listing 19-15.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
</code></pre>
<p><span class="caption">Listing 19-15: Implementing the <code>Add</code> trait on
<code>Millimeters</code> to add <code>Millimeters</code> to <code>Meters</code></span></p>
<p>To add <code>Millimeters</code> and <code>Meters</code>, we specify <code>impl Add&lt;Meters&gt;</code> to set the
value of the <code>Rhs</code> type parameter instead of using the default of <code>Self</code>.</p>
<p>You’ll use default type parameters in two main ways:</p>
<ul>
<li>To extend a type without breaking existing code</li>
<li>To allow customization in specific cases most users won’t need</li>
</ul>
<p>The standard library’s <code>Add</code> trait is an example of the second purpose:
usually, you’ll add two like types, but the <code>Add</code> trait provides the ability to
customize beyond that. Using a default type parameter in the <code>Add</code> trait
definition means you don’t have to specify the extra parameter most of the
time. In other words, a bit of implementation boilerplate isn’t needed, making
it easier to use the trait.</p>
<p>The first purpose is similar to the second but in reverse: if you want to add a
type parameter to an existing trait, you can give it a default to allow
extension of the functionality of the trait without breaking the existing
implementation code.</p>
<h3 id="fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name"><a class="header" href="#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name</a></h3>
<p>Nothing in Rust prevents a trait from having a method with the same name as
another trait’s method, nor does Rust prevent you from implementing both traits
on one type. It’s also possible to implement a method directly on the type with
the same name as methods from traits.</p>
<p>When calling methods with the same name, you’ll need to tell Rust which one you
want to use. Consider the code in Listing 19-16 where we’ve defined two traits,
<code>Pilot</code> and <code>Wizard</code>, that both have a method called <code>fly</code>. We then implement
both traits on a type <code>Human</code> that already has a method named <code>fly</code> implemented
on it. Each <code>fly</code> method does something different.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;This is your captain speaking.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;Up!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*waving arms furiously*&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 19-16: Two traits are defined to have a <code>fly</code>
method and are implemented on the <code>Human</code> type, and a <code>fly</code> method is
implemented on <code>Human</code> directly</span></p>
<p>When we call <code>fly</code> on an instance of <code>Human</code>, the compiler defaults to calling
the method that is directly implemented on the type, as shown in Listing 19-17.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}
</code></pre></pre>
<p><span class="caption">Listing 19-17: Calling <code>fly</code> on an instance of
<code>Human</code></span></p>
<p>Running this code will print <code>*waving arms furiously*</code>, showing that Rust
called the <code>fly</code> method implemented on <code>Human</code> directly.</p>
<p>To call the <code>fly</code> methods from either the <code>Pilot</code> trait or the <code>Wizard</code> trait,
we need to use more explicit syntax to specify which <code>fly</code> method we mean.
Listing 19-18 demonstrates this syntax.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}
</code></pre></pre>
<p><span class="caption">Listing 19-18: Specifying which trait’s <code>fly</code> method we
want to call</span></p>
<p>Specifying the trait name before the method name clarifies to Rust which
implementation of <code>fly</code> we want to call. We could also write
<code>Human::fly(&amp;person)</code>, which is equivalent to the <code>person.fly()</code> that we used
in Listing 19-18, but this is a bit longer to write if we don’t need to
disambiguate.</p>
<p>Running this code prints the following:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<p>Because the <code>fly</code> method takes a <code>self</code> parameter, if we had two <em>types</em> that
both implement one <em>trait</em>, Rust could figure out which implementation of a
trait to use based on the type of <code>self</code>.</p>
<p>However, associated functions that are not methods don’t have a <code>self</code>
parameter. When there are multiple types or traits that define non-method
functions with the same function name, Rust doesn't always know which type you
mean unless you use <em>fully qualified syntax</em>. For example, in Listing 19-19 we
create a trait for an animal shelter that wants to name all baby dogs <em>Spot</em>.
We make an <code>Animal</code> trait with an associated non-method function <code>baby_name</code>.
The <code>Animal</code> trait is implemented for the struct <code>Dog</code>, on which we also
provide an associated non-method function <code>baby_name</code> directly.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;puppy&quot;)
    }
}

fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name());
}
</code></pre></pre>
<p><span class="caption">Listing 19-19: A trait with an associated function and a
type with an associated function of the same name that also implements the
trait</span></p>
<p>We implement the code for naming all puppies Spot in the <code>baby_name</code> associated
function that is defined on <code>Dog</code>. The <code>Dog</code> type also implements the trait
<code>Animal</code>, which describes characteristics that all animals have. Baby dogs are
called puppies, and that is expressed in the implementation of the <code>Animal</code>
trait on <code>Dog</code> in the <code>baby_name</code> function associated with the <code>Animal</code> trait.</p>
<p>In <code>main</code>, we call the <code>Dog::baby_name</code> function, which calls the associated
function defined on <code>Dog</code> directly. This code prints the following:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
</code></pre>
<p>This output isn’t what we wanted. We want to call the <code>baby_name</code> function that
is part of the <code>Animal</code> trait that we implemented on <code>Dog</code> so the code prints
<code>A baby dog is called a puppy</code>. The technique of specifying the trait name that
we used in Listing 19-18 doesn’t help here; if we change <code>main</code> to the code in
Listing 19-20, we’ll get a compilation error.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;puppy&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
}
</code></pre>
<p><span class="caption">Listing 19-20: Attempting to call the <code>baby_name</code>
function from the <code>Animal</code> trait, but Rust doesn’t know which implementation to
use</span></p>
<p>Because <code>Animal::baby_name</code> doesn’t have a <code>self</code> parameter, and there could be
other types that implement the <code>Animal</code> trait, Rust can’t figure out which
implementation of <code>Animal::baby_name</code> we want. We’ll get this compiler error:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0283]: type annotations needed
  --&gt; src/main.rs:20:43
   |
20 |     println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^ cannot infer type
   |
   = note: cannot satisfy `_: Animal`

For more information about this error, try `rustc --explain E0283`.
error: could not compile `traits-example` due to previous error
</code></pre>
<p>To disambiguate and tell Rust that we want to use the implementation of
<code>Animal</code> for <code>Dog</code> as opposed to the implementation of <code>Animal</code> for some other
type, we need to use fully qualified syntax. Listing 19-21 demonstrates how to
use fully qualified syntax.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;puppy&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
}
</code></pre></pre>
<p><span class="caption">Listing 19-21: Using fully qualified syntax to specify
that we want to call the <code>baby_name</code> function from the <code>Animal</code> trait as
implemented on <code>Dog</code></span></p>
<p>We’re providing Rust with a type annotation within the angle brackets, which
indicates we want to call the <code>baby_name</code> method from the <code>Animal</code> trait as
implemented on <code>Dog</code> by saying that we want to treat the <code>Dog</code> type as an
<code>Animal</code> for this function call. This code will now print what we want:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
A baby dog is called a puppy
</code></pre>
<p>In general, fully qualified syntax is defined as follows:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre>
<p>For associated functions that aren’t methods, there would not be a <code>receiver</code>:
there would only be the list of other arguments. You could use fully qualified
syntax everywhere that you call functions or methods. However, you’re allowed
to omit any part of this syntax that Rust can figure out from other information
in the program. You only need to use this more verbose syntax in cases where
there are multiple implementations that use the same name and Rust needs help
to identify which implementation you want to call.</p>
<h3 id="using-supertraits-to-require-one-traits-functionality-within-another-trait"><a class="header" href="#using-supertraits-to-require-one-traits-functionality-within-another-trait">Using Supertraits to Require One Trait’s Functionality Within Another Trait</a></h3>
<p>Sometimes, you might write a trait definition that depends on another trait:
for a type to implement the first trait, you want to require that type to also
implement the second trait. You would do this so that your trait definition can
make use of the associated items of the second trait. The trait your trait
definition is relying on is called a <em>supertrait</em> of your trait.</p>
<p>For example, let’s say we want to make an <code>OutlinePrint</code> trait with an
<code>outline_print</code> method that will print a given value formatted so that it's
framed in asterisks. That is, given a <code>Point</code> struct that implements <code>Display</code>
to result in <code>(x, y)</code>, when we call <code>outline_print</code> on a <code>Point</code> instance that
has <code>1</code> for <code>x</code> and <code>3</code> for <code>y</code>, it should print the following:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>In the implementation of the <code>outline_print</code> method, we want to use the
<code>Display</code> trait’s functionality. Therefore, we need to specify that the
<code>OutlinePrint</code> trait will work only for types that also implement <code>Display</code> and
provide the functionality that <code>OutlinePrint</code> needs. We can do that in the
trait definition by specifying <code>OutlinePrint: Display</code>. This technique is
similar to adding a trait bound to the trait. Listing 19-22 shows an
implementation of the <code>OutlinePrint</code> trait.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 19-22: Implementing the <code>OutlinePrint</code> trait that
requires the functionality from <code>Display</code></span></p>
<p>Because we’ve specified that <code>OutlinePrint</code> requires the <code>Display</code> trait, we
can use the <code>to_string</code> function that is automatically implemented for any type
that implements <code>Display</code>. If we tried to use <code>to_string</code> without adding a
colon and specifying the <code>Display</code> trait after the trait name, we’d get an
error saying that no method named <code>to_string</code> was found for the type <code>&amp;Self</code> in
the current scope.</p>
<p>Let’s see what happens when we try to implement <code>OutlinePrint</code> on a type that
doesn’t implement <code>Display</code>, such as the <code>Point</code> struct:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, output);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}
</span></code></pre>
<p>We get an error saying that <code>Display</code> is required but not implemented:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` due to previous error
</code></pre>
<p>To fix this, we implement <code>Display</code> on <code>Point</code> and satisfy the constraint that
<code>OutlinePrint</code> requires, like so:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, output);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}
</span></code></pre></pre>
<p>Then implementing the <code>OutlinePrint</code> trait on <code>Point</code> will compile
successfully, and we can call <code>outline_print</code> on a <code>Point</code> instance to display
it within an outline of asterisks.</p>
<h3 id="using-the-newtype-pattern-to-implement-external-traits-on-external-types"><a class="header" href="#using-the-newtype-pattern-to-implement-external-traits-on-external-types">Using the Newtype Pattern to Implement External Traits on External Types</a></h3>
<p>In Chapter 10 in the <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">“Implementing a Trait on a
Type”</a><!-- ignore --> section, we mentioned the
orphan rule that states we’re only allowed to implement a trait on a type if
either the trait or the type are local to our crate. It’s possible to get
around this restriction using the <em>newtype pattern</em>, which involves creating a
new type in a tuple struct. (We covered tuple structs in the <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">“Using Tuple
Structs without Named Fields to Create Different Types”</a><!--
ignore --> section of Chapter 5.) The tuple struct will have one field and be a
thin wrapper around the type we want to implement a trait for. Then the wrapper
type is local to our crate, and we can implement the trait on the wrapper.
<em>Newtype</em> is a term that originates from the Haskell programming language.
There is no runtime performance penalty for using this pattern, and the wrapper
type is elided at compile time.</p>
<p>As an example, let’s say we want to implement <code>Display</code> on <code>Vec&lt;T&gt;</code>, which the
orphan rule prevents us from doing directly because the <code>Display</code> trait and the
<code>Vec&lt;T&gt;</code> type are defined outside our crate. We can make a <code>Wrapper</code> struct
that holds an instance of <code>Vec&lt;T&gt;</code>; then we can implement <code>Display</code> on
<code>Wrapper</code> and use the <code>Vec&lt;T&gt;</code> value, as shown in Listing 19-23.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<p><span class="caption">Listing 19-23: Creating a <code>Wrapper</code> type around
<code>Vec&lt;String&gt;</code> to implement <code>Display</code></span></p>
<p>The implementation of <code>Display</code> uses <code>self.0</code> to access the inner <code>Vec&lt;T&gt;</code>,
because <code>Wrapper</code> is a tuple struct and <code>Vec&lt;T&gt;</code> is the item at index 0 in the
tuple. Then we can use the functionality of the <code>Display</code> type on <code>Wrapper</code>.</p>
<p>The downside of using this technique is that <code>Wrapper</code> is a new type, so it
doesn’t have the methods of the value it’s holding. We would have to implement
all the methods of <code>Vec&lt;T&gt;</code> directly on <code>Wrapper</code> such that the methods
delegate to <code>self.0</code>, which would allow us to treat <code>Wrapper</code> exactly like a
<code>Vec&lt;T&gt;</code>. If we wanted the new type to have every method the inner type has,
implementing the <code>Deref</code> trait (discussed in Chapter 15 in the <a href="ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">“Treating Smart
Pointers Like Regular References with the <code>Deref</code>
Trait”</a><!-- ignore --> section) on the <code>Wrapper</code> to return
the inner type would be a solution. If we don’t want the <code>Wrapper</code> type to have
all the methods of the inner type—for example, to restrict the <code>Wrapper</code> type’s
behavior—we would have to implement just the methods we do want manually.</p>
<p>This newtype pattern is also useful even when traits are not involved. Let’s
switch focus and look at some advanced ways to interact with Rust’s type system.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="advanced-types"><a class="header" href="#advanced-types">Advanced Types</a></h2>
<p>The Rust type system has some features that we’ve so far mentioned but haven’t
yet discussed. We’ll start by discussing newtypes in general as we examine why
newtypes are useful as types. Then we’ll move on to type aliases, a feature
similar to newtypes but with slightly different semantics. We’ll also discuss
the <code>!</code> type and dynamically sized types.</p>
<h3 id="using-the-newtype-pattern-for-type-safety-and-abstraction"><a class="header" href="#using-the-newtype-pattern-for-type-safety-and-abstraction">Using the Newtype Pattern for Type Safety and Abstraction</a></h3>
<blockquote>
<p>Note: This section assumes you’ve read the earlier section <a href="ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">“Using the
Newtype Pattern to Implement External Traits on External
Types.”</a><!-- ignore --></p>
</blockquote>
<p>The newtype pattern is also useful for tasks beyond those we’ve discussed so
far, including statically enforcing that values are never confused and
indicating the units of a value. You saw an example of using newtypes to
indicate units in Listing 19-15: recall that the <code>Millimeters</code> and <code>Meters</code>
structs wrapped <code>u32</code> values in a newtype. If we wrote a function with a
parameter of type <code>Millimeters</code>, we couldn’t compile a program that
accidentally tried to call that function with a value of type <code>Meters</code> or a
plain <code>u32</code>.</p>
<p>We can also use the newtype pattern to abstract away some implementation
details of a type: the new type can expose a public API that is different from
the API of the private inner type.</p>
<p>Newtypes can also hide internal implementation. For example, we could provide a
<code>People</code> type to wrap a <code>HashMap&lt;i32, String&gt;</code> that stores a person’s ID
associated with their name. Code using <code>People</code> would only interact with the
public API we provide, such as a method to add a name string to the <code>People</code>
collection; that code wouldn’t need to know that we assign an <code>i32</code> ID to names
internally. The newtype pattern is a lightweight way to achieve encapsulation
to hide implementation details, which we discussed in the <a href="ch17-01-what-is-oo.html#encapsulation-that-hides-implementation-details">“Encapsulation that
Hides Implementation
Details”</a><!-- ignore -->
section of Chapter 17.</p>
<h3 id="creating-type-synonyms-with-type-aliases"><a class="header" href="#creating-type-synonyms-with-type-aliases">Creating Type Synonyms with Type Aliases</a></h3>
<p>Rust provides the ability to declare a <em>type alias</em> to give an existing type
another name. For this we use the <code>type</code> keyword. For example, we can create
the alias <code>Kilometers</code> to <code>i32</code> like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!(&quot;x + y = {}&quot;, x + y);
</span><span class="boring">}
</span></code></pre></pre>
<p>Now, the alias <code>Kilometers</code> is a <em>synonym</em> for <code>i32</code>; unlike the <code>Millimeters</code>
and <code>Meters</code> types we created in Listing 19-15, <code>Kilometers</code> is not a separate,
new type. Values that have the type <code>Kilometers</code> will be treated the same as
values of type <code>i32</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<p>Because <code>Kilometers</code> and <code>i32</code> are the same type, we can add values of both
types and we can pass <code>Kilometers</code> values to functions that take <code>i32</code>
parameters. However, using this method, we don’t get the type checking benefits
that we get from the newtype pattern discussed earlier.</p>
<p>The main use case for type synonyms is to reduce repetition. For example, we
might have a lengthy type like this:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;
</code></pre>
<p>Writing this lengthy type in function signatures and as type annotations all
over the code can be tiresome and error prone. Imagine having a project full of
code like that in Listing 19-24.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --snip--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-24: Using a long type in many places</span></p>
<p>A type alias makes this code more manageable by reducing the repetition. In
Listing 19-25, we’ve introduced an alias named <code>Thunk</code> for the verbose type and
can replace all uses of the type with the shorter alias <code>Thunk</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

    fn takes_long_type(f: Thunk) {
        // --snip--
    }

    fn returns_long_type() -&gt; Thunk {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-25: Introducing a type alias <code>Thunk</code> to reduce
repetition</span></p>
<p>This code is much easier to read and write! Choosing a meaningful name for a
type alias can help communicate your intent as well (<em>thunk</em> is a word for code
to be evaluated at a later time, so it’s an appropriate name for a closure that
gets stored).</p>
<p>Type aliases are also commonly used with the <code>Result&lt;T, E&gt;</code> type for reducing
repetition. Consider the <code>std::io</code> module in the standard library. I/O
operations often return a <code>Result&lt;T, E&gt;</code> to handle situations when operations
fail to work. This library has a <code>std::io::Error</code> struct that represents all
possible I/O errors. Many of the functions in <code>std::io</code> will be returning
<code>Result&lt;T, E&gt;</code> where the <code>E</code> is <code>std::io::Error</code>, such as these functions in
the <code>Write</code> trait:</p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
</code></pre>
<p>The <code>Result&lt;..., Error&gt;</code> is repeated a lot. As such, <code>std::io</code> has this type
alias declaration:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}
</span></code></pre>
<p>Because this declaration is in the <code>std::io</code> module, we can use the fully
qualified alias <code>std::io::Result&lt;T&gt;</code>; that is, a <code>Result&lt;T, E&gt;</code> with the <code>E</code>
filled in as <code>std::io::Error</code>. The <code>Write</code> trait function signatures end up
looking like this:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}
</code></pre>
<p>The type alias helps in two ways: it makes code easier to write <em>and</em> it gives
us a consistent interface across all of <code>std::io</code>. Because it’s an alias, it’s
just another <code>Result&lt;T, E&gt;</code>, which means we can use any methods that work on
<code>Result&lt;T, E&gt;</code> with it, as well as special syntax like the <code>?</code> operator.</p>
<h3 id="the-never-type-that-never-returns"><a class="header" href="#the-never-type-that-never-returns">The Never Type that Never Returns</a></h3>
<p>Rust has a special type named <code>!</code> that’s known in type theory lingo as the
<em>empty type</em> because it has no values. We prefer to call it the <em>never type</em>
because it stands in the place of the return type when a function will never
return. Here is an example:</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --snip--
<span class="boring">    panic!();
</span>}
</code></pre>
<p>This code is read as “the function <code>bar</code> returns never.” Functions that return
never are called <em>diverging functions</em>. We can’t create values of the type <code>!</code>
so <code>bar</code> can never possibly return.</p>
<p>But what use is a type you can never create values for? Recall the code from
Listing 2-5, part of the number guessing game; we’ve reproduced a bit of it
here in Listing 19-26.</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {guess}&quot;);
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 19-26: A <code>match</code> with an arm that ends in
<code>continue</code></span></p>
<p>At the time, we skipped over some details in this code. In Chapter 6 in <a href="ch06-02-match.html#the-match-control-flow-operator">“The
<code>match</code> Control Flow Operator”</a><!-- ignore -->
section, we discussed that <code>match</code> arms must all return the same type. So, for
example, the following code doesn’t work:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = &quot;3&quot;;
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; &quot;hello&quot;,
    };
<span class="boring">}
</span></code></pre>
<p>The type of <code>guess</code> in this code would have to be an integer <em>and</em> a string,
and Rust requires that <code>guess</code> have only one type. So what does <code>continue</code>
return? How were we allowed to return a <code>u32</code> from one arm and have another arm
that ends with <code>continue</code> in Listing 19-26?</p>
<p>As you might have guessed, <code>continue</code> has a <code>!</code> value. That is, when Rust
computes the type of <code>guess</code>, it looks at both match arms, the former with a
value of <code>u32</code> and the latter with a <code>!</code> value. Because <code>!</code> can never have a
value, Rust decides that the type of <code>guess</code> is <code>u32</code>.</p>
<p>The formal way of describing this behavior is that expressions of type <code>!</code> can
be coerced into any other type. We’re allowed to end this <code>match</code> arm with
<code>continue</code> because <code>continue</code> doesn’t return a value; instead, it moves control
back to the top of the loop, so in the <code>Err</code> case, we never assign a value to
<code>guess</code>.</p>
<p>The never type is useful with the <code>panic!</code> macro as well. Recall the <code>unwrap</code>
function that we call on <code>Option&lt;T&gt;</code> values to produce a value or panic with
this definition:</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<p>In this code, the same thing happens as in the <code>match</code> in Listing 19-26: Rust
sees that <code>val</code> has the type <code>T</code> and <code>panic!</code> has the type <code>!</code>, so the result
of the overall <code>match</code> expression is <code>T</code>. This code works because <code>panic!</code>
doesn’t produce a value; it ends the program. In the <code>None</code> case, we won’t be
returning a value from <code>unwrap</code>, so this code is valid.</p>
<p>One final expression that has the type <code>!</code> is a <code>loop</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!(&quot;forever &quot;);

    loop {
        print!(&quot;and ever &quot;);
    }
<span class="boring">}
</span></code></pre>
<p>Here, the loop never ends, so <code>!</code> is the value of the expression. However, this
wouldn’t be true if we included a <code>break</code>, because the loop would terminate
when it got to the <code>break</code>.</p>
<h3 id="dynamically-sized-types-and-the-sized-trait"><a class="header" href="#dynamically-sized-types-and-the-sized-trait">Dynamically Sized Types and the <code>Sized</code> Trait</a></h3>
<p>Rust needs to know certain details about its types, such as how much space to
allocate for a value of a particular type. This leaves one corner of its type
system a little confusing at first: the concept of <em>dynamically sized types</em>.
Sometimes referred to as <em>DSTs</em> or <em>unsized types</em>, these types let us write
code using values whose size we can know only at runtime.</p>
<p>Let’s dig into the details of a dynamically sized type called <code>str</code>, which
we’ve been using throughout the book. That’s right, not <code>&amp;str</code>, but <code>str</code> on
its own, is a DST. We can’t know how long the string is until runtime, meaning
we can’t create a variable of type <code>str</code>, nor can we take an argument of type
<code>str</code>. Consider the following code, which does not work:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = &quot;Hello there!&quot;;
    let s2: str = &quot;How's it going?&quot;;
<span class="boring">}
</span></code></pre>
<p>Rust needs to know how much memory to allocate for any value of a particular
type, and all values of a type must use the same amount of memory. If Rust
allowed us to write this code, these two <code>str</code> values would need to take up the
same amount of space. But they have different lengths: <code>s1</code> needs 12 bytes of
storage and <code>s2</code> needs 15. This is why it’s not possible to create a variable
holding a dynamically sized type.</p>
<p>So what do we do? In this case, you already know the answer: we make the types
of <code>s1</code> and <code>s2</code> a <code>&amp;str</code> rather than a <code>str</code>. Recall from the <a href="ch04-03-slices.html#string-slices">“String
Slices”</a><!-- ignore --> section of Chapter 4 that the slice data
structure just stores the starting position and the length of the slice. So
although a <code>&amp;T</code> is a single value that stores the memory address of where the
<code>T</code> is located, a <code>&amp;str</code> is <em>two</em> values: the address of the <code>str</code> and its
length. As such, we can know the size of a <code>&amp;str</code> value at compile time: it’s
twice the length of a <code>usize</code>. That is, we always know the size of a <code>&amp;str</code>, no
matter how long the string it refers to is. In general, this is the way in
which dynamically sized types are used in Rust: they have an extra bit of
metadata that stores the size of the dynamic information. The golden rule of
dynamically sized types is that we must always put values of dynamically sized
types behind a pointer of some kind.</p>
<p>We can combine <code>str</code> with all kinds of pointers: for example, <code>Box&lt;str&gt;</code> or
<code>Rc&lt;str&gt;</code>. In fact, you’ve seen this before but with a different dynamically
sized type: traits. Every trait is a dynamically sized type we can refer to by
using the name of the trait. In Chapter 17 in the <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Using Trait Objects That
Allow for Values of Different
Types”</a><!--
ignore --> section, we mentioned that to use traits as trait objects, we must
put them behind a pointer, such as <code>&amp;dyn Trait</code> or <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> would work too).</p>
<p>To work with DSTs, Rust provides the <code>Sized</code> trait to determine whether or not
a type’s size is known at compile time. This trait is automatically implemented
for everything whose size is known at compile time. In addition, Rust
implicitly adds a bound on <code>Sized</code> to every generic function. That is, a
generic function definition like this:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}
</code></pre>
<p>is actually treated as though we had written this:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}
</code></pre>
<p>By default, generic functions will work only on types that have a known size at
compile time. However, you can use the following special syntax to relax this
restriction:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}
</code></pre>
<p>A trait bound on <code>?Sized</code> means “<code>T</code> may or may not be <code>Sized</code>” and this
notation overrides the default that generic types must have a known size at
compile time. The <code>?Trait</code> syntax with this meaning is only available for
<code>Sized</code>, not any other traits.</p>
<p>Also note that we switched the type of the <code>t</code> parameter from <code>T</code> to <code>&amp;T</code>.
Because the type might not be <code>Sized</code>, we need to use it behind some kind of
pointer. In this case, we’ve chosen a reference.</p>
<p>Next, we’ll talk about functions and closures!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gelişmiş-fonksiyonlar-ve-kapanış-İfadeleri"><a class="header" href="#gelişmiş-fonksiyonlar-ve-kapanış-İfadeleri">Gelişmiş Fonksiyonlar ve Kapanış İfadeleri</a></h2>
<p>Bu bölümde, fonksiyon işaretçileri ve dönen kapanışlar da dahil olmak üzere fonksiyonlar ve kapanışlarla 
ilgili bazı gelişmiş özellikler incelenmektedir.</p>
<h3 id="fonksiyon-İşaretçileri"><a class="header" href="#fonksiyon-İşaretçileri">Fonksiyon İşaretçileri</a></h3>
<p>Fonksiyonlara kapanışların nasıl aktarılacağından bahsetmiştik; normal fonksiyonları da fonksiyonlara aktarabilirsiniz! 
Bu teknik, yeni bir kapanış tanımlamak yerine daha önce tanımladığınız bir fonksiyonu geçirmek istediğinizde kullanışlıdır. 
Fonksiyonlar, <code>Fn</code> kapanış tanımı ile karıştırılmaması gereken <code>fn</code> (küçük <code>f</code> harfi ile) türüne zorlanır. <code>fn</code> türüne fonksiyon işaretçisi 
denir. Fonksiyonları fonksiyon işaretçileriyle geçirmek, fonksiyonları diğer fonksiyonlara argüman olarak kullanmanızı sağlar.</p>
<p>Bir parametrenin bir fonksiyon işaretçisi olduğunu belirtmek için kullanılan söz dizimi, parametresine bir ekleyen <code>add_one</code> 
fonksiyonunu tanımladığımız Liste 19-27'de gösterildiği gibi, kapanışlarınkine benzer. <code>do_twice</code> fonksiyonu iki parametre alır: 
bir <code>i32</code> parametresi alan ve bir <code>i32</code> döndüren herhangi bir fonksiyonun fonksiyon işaretçisi ve bir <code>i32</code> değeri. <code>do_twice</code> fonksiyonu
<code>f</code> işlevini iki kez çağırır, <code>arg</code> değerini geçirir ve ardından iki fonksiyon çağrısı sonucunu birbirine ekler. <code>main</code> fonksiyonu <code>do_twice</code>
fonksiyonunu <code>add_one</code> ve <code>5</code> argümanlarıyla çağırır.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&quot;The answer is: {}&quot;, answer);
}
</code></pre></pre>
<p><span class="caption">Liste 19-27: Bir fonksiyon işaretçisini argüman olarak kabul etmek için <code>fn</code> türünü kullanma</span></p>
<p>Bu kod çıktısı <code>The answer is: 12</code> olur. <code>do_twice</code> içindeki <code>f</code> parametresinin, <code>i32</code> türünde bir parametre alan ve bir 
<code>i32</code> döndüren bir <code>fn</code> olduğunu belirtiriz. Daha sonra <code>f</code>'i <code>do_twice</code>'ın gövdesinden çağırabiliriz. <code>main</code> içinde, 
<code>add_one</code> fonksiyon adını <code>do_twice</code>'a ilk argüman olarak aktarabiliriz.</p>
<p>Kapanışların aksine, <code>fn</code> bir özellikten ziyade bir türdür, bu nedenle <code>Fn</code> tanımlarından birine sahip yaygın tür parametresini bir 
tanım bağı olarak bildirmek yerine <code>fn</code>'yi doğrudan parametre türü olarak belirtiriz.</p>
<p>Fonksiyon işaretçileri, kapanış tanımlarının (<code>Fn</code>, <code>FnMut</code> ve <code>FnOnce</code>) üçünü de uygular, yani bir kapanış bekleyen bir fonksiyona argüman 
olarak her zaman bir fonksiyon işaretçisi aktarabilirsiniz. Fonksiyonlarınızı yaygın tür ve kapanış tanımlarından birini kullanarak yazmak en iyisidir,
böylece fonksiyonlarınız hem fonksiyonları hem de kapanışları kabul edebilir.</p>
<p>Bununla birlikte, kapanışları değil de yalnızca <code>fn</code>'leri kabul etmek isteyeceğiniz bir örnek, kapanışları olmayan harici kodlarla 
arayüz oluştururken ortaya çıkar: C fonksiyonları argüman olarak fonksiyon kabul edebilir, ancak C'de kapanış yoktur.</p>
<p>Satır içi tanımlanmış bir kapanış ya da adlandırılmış bir fonksiyon kullanabileceğiniz bir örnek olarak, standart kütüphanedeki <code>Iterator</code> tanımı
tarafından sağlanan <code>map</code> metodunun kullanımına bakalım. Sayılardan oluşan bir vektörü dizelerden oluşan bir vektöre dönüştürmek üzere <code>map</code> 
fonksiyonunu kullanmak için aşağıdaki gibi bir kapanış kullanabiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}
</span></code></pre></pre>
<p>Veya kapanış yerine <code>map</code> argümanı olarak bir fonksiyonu şöyle adlandırabiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}
</span></code></pre></pre>
<p>Daha önce <a href="ch19-03-advanced-traits.html#advanced-traits">“Gelişmiş Özellikler”</a><!-- ignore --> bölümünde bahsettiğimiz tam nitelikli söz dizimini kullanmamız 
gerektiğini unutmayın çünkü <code>to_string</code> adında birden fazla fonksiyon mevcuttur. Burada, standart kütüphanenin <code>Display</code>'i sürekleyen 
tüm türler için süreklediği <code>ToString</code> tanımında tanımlanan <code>to_string</code> fonksiyonunu kullanıyoruz.</p>
<p>Bölüm 6'daki <a href="ch06-01-defining-an-enum.html#enum-values">“<code>enum</code> değerleri”</a><!-- ignore --> bölümünde tanımladığımız her <code>enum</code> varyantının adının aynı 
zamanda bir başlatıcı fonksiyon olduğunu hatırlayın. Bu başlatıcı fonksiyonları, kapanış tanımlarını sürekleyen fonksiyon işaretçileri 
olarak kullanabiliriz; yani başlatıcı fonksiyonları, kapanışları alan metodlar için argüman olarak belirtebiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}
</span></code></pre></pre>
<p>Burada, <code>Status::Value</code>'nun başlatıcı fonksiyonunu kullanarak <code>map</code>'in çağrıldığı aralıktaki her <code>u32</code> değerini kullanarak 
<code>Status::Value</code> örnekleri oluşturuyoruz. Bazı insanlar bu stili tercih ederken bazıları da kapanışları kullanmayı tercih eder. 
Her ikisi de aynı koda derlenir, bu nedenle hangi stil sizin için daha iyiyse onu kullanın.</p>
<h3 id="dönen-kapanışlar"><a class="header" href="#dönen-kapanışlar">Dönen Kapanışlar</a></h3>
<p>Kapanışlar tanımlar tarafından temsil edilir, bu da kapanışları doğrudan iade edemeyeceğiniz anlamına gelir. 
Bir tanım döndürmek isteyebileceğiniz çoğu durumda, bunun yerine fonksiyonun dönüş değeri olarak <code>trait</code>'i sürekleyen somut tipi kullanabilirsiniz.
Ancak, kapanışlarda bunu yapamazsınız çünkü döndürülebilir somut bir tipleri yoktur; örneğin, <code>fn</code> fonksiyon işaretçisini bir dönüş 
tipi olarak kullanmanıza izin verilmez.</p>
<p>Aşağıdaki kod doğrudan bir kapanış döndürmeye çalışır, ancak derlenmez:</p>
<p>Here we create <code>Status::Value</code> instances using each <code>u32</code> value in the range
that <code>map</code> is called on by using the initializer function of <code>Status::Value</code>.
Some people prefer this style, and some people prefer to use closures. They
compile to the same code, so use whichever style is clearer to you.</p>
<pre><code class="language-rust ignore does_not_compile">fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
    |x| x + 1
}
</code></pre>
<p>Derleyici hatası aşağıdaki gibidir:</p>
<pre><code class="language-console">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0746]: return type cannot have an unboxed trait object
 --&gt; src/lib.rs:1:25
  |
1 | fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |
  = note: for information on `impl Trait`, see &lt;https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits&gt;
help: use `impl Fn(i32) -&gt; i32` as the return type, as all return paths are of type `[closure@src/lib.rs:2:5: 2:14]`, which implements `Fn(i32) -&gt; i32`
  |
1 | fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
  |                         ~~~~~~~~~~~~~~~~~~~

For more information about this error, try `rustc --explain E0746`.
error: could not compile `functions-example` due to previous error
</code></pre>
<p>Hata yine <code>Sized</code> tanımına atıfta bulunuyor! Rust, kapanışı depolamak için ne kadar alana ihtiyaç duyacağını bilmiyor. 
Bu sorunun çözümünü daha önce görmüştük. Bir <code>trait</code> nesnesi kullanabiliriz:</p>
<pre><code class="language-rust noplayground">fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
</code></pre>
<p>Bu kod sorunsuz derlenecektir. <code>trait</code> nesneleri hakkında daha fazla bilgi edinmek için 
Bölüm 17'deki  <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Farklı Türlerdeki Değerlere
İzin Veren <code>trait</code> Nesnelerini Kullanma”</a><!--
ignore --> başlığına bakabilirsiniz.</p>
<p>Şimdi devam edelim ve makrolara bakalım!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>We’ve used macros like <code>println!</code> throughout this book, but we haven’t fully
explored what a macro is and how it works. The term <em>macro</em> refers to a family
of features in Rust: <em>declarative</em> macros with <code>macro_rules!</code> and three kinds
of <em>procedural</em> macros:</p>
<ul>
<li>Custom <code>#[derive]</code> macros that specify code added with the <code>derive</code> attribute
used on structs and enums</li>
<li>Attribute-like macros that define custom attributes usable on any item</li>
<li>Function-like macros that look like function calls but operate on the tokens
specified as their argument</li>
</ul>
<p>We’ll talk about each of these in turn, but first, let’s look at why we even
need macros when we already have functions.</p>
<h3 id="the-difference-between-macros-and-functions"><a class="header" href="#the-difference-between-macros-and-functions">The Difference Between Macros and Functions</a></h3>
<p>Fundamentally, macros are a way of writing code that writes other code, which
is known as <em>metaprogramming</em>. In Appendix C, we discuss the <code>derive</code>
attribute, which generates an implementation of various traits for you. We’ve
also used the <code>println!</code> and <code>vec!</code> macros throughout the book. All of these
macros <em>expand</em> to produce more code than the code you’ve written manually.</p>
<p>Metaprogramming is useful for reducing the amount of code you have to write and
maintain, which is also one of the roles of functions. However, macros have
some additional powers that functions don’t.</p>
<p>A function signature must declare the number and type of parameters the
function has. Macros, on the other hand, can take a variable number of
parameters: we can call <code>println!(&quot;hello&quot;)</code> with one argument or
<code>println!(&quot;hello {}&quot;, name)</code> with two arguments. Also, macros are expanded
before the compiler interprets the meaning of the code, so a macro can, for
example, implement a trait on a given type. A function can’t, because it gets
called at runtime and a trait needs to be implemented at compile time.</p>
<p>The downside to implementing a macro instead of a function is that macro
definitions are more complex than function definitions because you’re writing
Rust code that writes Rust code. Due to this indirection, macro definitions are
generally more difficult to read, understand, and maintain than function
definitions.</p>
<p>Another important difference between macros and functions is that you must
define macros or bring them into scope <em>before</em> you call them in a file, as
opposed to functions you can define anywhere and call anywhere.</p>
<h3 id="declarative-macros-with-macro_rules-for-general-metaprogramming"><a class="header" href="#declarative-macros-with-macro_rules-for-general-metaprogramming">Declarative Macros with <code>macro_rules!</code> for General Metaprogramming</a></h3>
<p>The most widely used form of macros in Rust is the <em>declarative macro</em>. These
are also sometimes referred to as “macros by example,” “<code>macro_rules!</code> macros,”
or just plain “macros.” At their core, declarative macros allow you to write
something similar to a Rust <code>match</code> expression. As discussed in Chapter 6,
<code>match</code> expressions are control structures that take an expression, compare the
resulting value of the expression to patterns, and then run the code associated
with the matching pattern. Macros also compare a value to patterns that are
associated with particular code: in this situation, the value is the literal
Rust source code passed to the macro; the patterns are compared with the
structure of that source code; and the code associated with each pattern, when
matched, replaces the code passed to the macro. This all happens during
compilation.</p>
<p>To define a macro, you use the <code>macro_rules!</code> construct. Let’s explore how to
use <code>macro_rules!</code> by looking at how the <code>vec!</code> macro is defined. Chapter 8
covered how we can use the <code>vec!</code> macro to create a new vector with particular
values. For example, the following macro creates a new vector containing three
integers:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p>We could also use the <code>vec!</code> macro to make a vector of two integers or a vector
of five string slices. We wouldn’t be able to use a function to do the same
because we wouldn’t know the number or type of values up front.</p>
<p>Listing 19-28 shows a slightly simplified definition of the <code>vec!</code> macro.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
</code></pre>
<p><span class="caption">Listing 19-28: A simplified version of the <code>vec!</code> macro
definition</span></p>
<blockquote>
<p>Note: The actual definition of the <code>vec!</code> macro in the standard library
includes code to preallocate the correct amount of memory up front. That code
is an optimization that we don’t include here to make the example simpler.</p>
</blockquote>
<p>The <code>#[macro_export]</code> annotation indicates that this macro should be made
available whenever the crate in which the macro is defined is brought into
scope. Without this annotation, the macro can’t be brought into scope.</p>
<p>We then start the macro definition with <code>macro_rules!</code> and the name of the
macro we’re defining <em>without</em> the exclamation mark. The name, in this case
<code>vec</code>, is followed by curly brackets denoting the body of the macro definition.</p>
<p>The structure in the <code>vec!</code> body is similar to the structure of a <code>match</code>
expression. Here we have one arm with the pattern <code>( $( $x:expr ),* )</code>,
followed by <code>=&gt;</code> and the block of code associated with this pattern. If the
pattern matches, the associated block of code will be emitted. Given that this
is the only pattern in this macro, there is only one valid way to match; any
other pattern will result in an error. More complex macros will have more than
one arm.</p>
<p>Valid pattern syntax in macro definitions is different than the pattern syntax
covered in Chapter 18 because macro patterns are matched against Rust code
structure rather than values. Let’s walk through what the pattern pieces in
Listing 19-28 mean; for the full macro pattern syntax, see the <a href="../reference/macros-by-example.html">Rust
Reference</a>.</p>
<p>First, we use a set of parentheses to encompass the whole pattern. We use a
dollar sign (<code>$</code>) to declare a variable in the macro system that will contain
the Rust code matching the pattern. The dollar sign makes it clear this is a
macro variable as opposed to a regular Rust variable. Next comes a set of
parentheses that captures values that match the pattern within the parentheses
for use in the replacement code. Within <code>$()</code> is <code>$x:expr</code>, which matches any
Rust expression and gives the expression the name <code>$x</code>.</p>
<p>The comma following <code>$()</code> indicates that a literal comma separator character
could optionally appear after the code that matches the code in <code>$()</code>. The <code>*</code>
specifies that the pattern matches zero or more of whatever precedes the <code>*</code>.</p>
<p>When we call this macro with <code>vec![1, 2, 3];</code>, the <code>$x</code> pattern matches three
times with the three expressions <code>1</code>, <code>2</code>, and <code>3</code>.</p>
<p>Now let’s look at the pattern in the body of the code associated with this arm:
<code>temp_vec.push()</code> within <code>$()*</code> is generated for each part that matches <code>$()</code>
in the pattern zero or more times depending on how many times the pattern
matches. The <code>$x</code> is replaced with each expression matched. When we call this
macro with <code>vec![1, 2, 3];</code>, the code generated that replaces this macro call
will be the following:</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
</code></pre>
<p>We’ve defined a macro that can take any number of arguments of any type and can
generate code to create a vector containing the specified elements.</p>
<p>There are some strange edge cases with <code>macro_rules!</code>. In the future, Rust will
have a second kind of declarative macro that will work in a similar fashion but
fix some of these edge cases. After that update, <code>macro_rules!</code> will be
effectively deprecated. With this in mind, as well as the fact that most Rust
programmers will <em>use</em> macros more than <em>write</em> macros, we won’t discuss
<code>macro_rules!</code> any further. To learn more about how to write macros, consult
the online documentation or other resources, such as <a href="https://veykril.github.io/tlborm/">“The Little Book of Rust
Macros”</a> started by Daniel Keep and continued by Lukas Wirth.</p>
<h3 id="procedural-macros-for-generating-code-from-attributes"><a class="header" href="#procedural-macros-for-generating-code-from-attributes">Procedural Macros for Generating Code from Attributes</a></h3>
<p>The second form of macros is the <em>procedural macro</em>, which acts more like a
function (and is a type of procedure). Procedural macros accept some code as an
input, operate on that code, and produce some code as an output rather than
matching against patterns and replacing the code with other code as declarative
macros do. The three kinds of procedural macros are custom derive,
attribute-like, and function-like, and all work in a similar fashion.</p>
<p>When creating procedural macros, the definitions must reside in their own crate
with a special crate type. This is for complex technical reasons that we hope
to eliminate in the future. In Listing 19-29, we show how to define a
procedural macro, where <code>some_attribute</code> is a placeholder for using a specific
macro variety.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}
</code></pre>
<p><span class="caption">Listing 19-29: An example of defining a procedural
macro</span></p>
<p>The function that defines a procedural macro takes a <code>TokenStream</code> as an input
and produces a <code>TokenStream</code> as an output. The <code>TokenStream</code> type is defined by
the <code>proc_macro</code> crate that is included with Rust and represents a sequence of
tokens. This is the core of the macro: the source code that the macro is
operating on makes up the input <code>TokenStream</code>, and the code the macro produces
is the output <code>TokenStream</code>. The function also has an attribute attached to it
that specifies which kind of procedural macro we’re creating. We can have
multiple kinds of procedural macros in the same crate.</p>
<p>Let’s look at the different kinds of procedural macros. We’ll start with a
custom derive macro and then explain the small dissimilarities that make the
other forms different.</p>
<h3 id="how-to-write-a-custom-derive-macro"><a class="header" href="#how-to-write-a-custom-derive-macro">How to Write a Custom <code>derive</code> Macro</a></h3>
<p>Let’s create a crate named <code>hello_macro</code> that defines a trait named
<code>HelloMacro</code> with one associated function named <code>hello_macro</code>. Rather than
making our users implement the <code>HelloMacro</code> trait for each of their types,
we’ll provide a procedural macro so users can annotate their type with
<code>#[derive(HelloMacro)]</code> to get a default implementation of the <code>hello_macro</code>
function. The default implementation will print <code>Hello, Macro! My name is TypeName!</code> where <code>TypeName</code> is the name of the type on which this trait has
been defined. In other words, we’ll write a crate that enables another
programmer to write code like Listing 19-30 using our crate.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p><span class="caption">Listing 19-30: The code a user of our crate will be able
to write when using our procedural macro</span></p>
<p>This code will print <code>Hello, Macro! My name is Pancakes!</code> when we’re done. The
first step is to make a new library crate, like this:</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>Next, we’ll define the <code>HelloMacro</code> trait and its associated function:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait HelloMacro {
    fn hello_macro();
}
</code></pre>
<p>We have a trait and its function. At this point, our crate user could implement
the trait to achieve the desired functionality, like so:</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro! My name is Pancakes!&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p>However, they would need to write the implementation block for each type they
wanted to use with <code>hello_macro</code>; we want to spare them from having to do this
work.</p>
<p>Additionally, we can’t yet provide the <code>hello_macro</code> function with default
implementation that will print the name of the type the trait is implemented
on: Rust doesn’t have reflection capabilities, so it can’t look up the type’s
name at runtime. We need a macro to generate code at compile time.</p>
<p>The next step is to define the procedural macro. At the time of this writing,
procedural macros need to be in their own crate. Eventually, this restriction
might be lifted. The convention for structuring crates and macro crates is as
follows: for a crate named <code>foo</code>, a custom derive procedural macro crate is
called <code>foo_derive</code>. Let’s start a new crate called <code>hello_macro_derive</code> inside
our <code>hello_macro</code> project:</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Our two crates are tightly related, so we create the procedural macro crate
within the directory of our <code>hello_macro</code> crate. If we change the trait
definition in <code>hello_macro</code>, we’ll have to change the implementation of the
procedural macro in <code>hello_macro_derive</code> as well. The two crates will need to
be published separately, and programmers using these crates will need to add
both as dependencies and bring them both into scope. We could instead have the
<code>hello_macro</code> crate use <code>hello_macro_derive</code> as a dependency and re-export the
procedural macro code. However, the way we’ve structured the project makes it
possible for programmers to use <code>hello_macro</code> even if they don’t want the
<code>derive</code> functionality.</p>
<p>We need to declare the <code>hello_macro_derive</code> crate as a procedural macro crate.
We’ll also need functionality from the <code>syn</code> and <code>quote</code> crates, as you’ll see
in a moment, so we need to add them as dependencies. Add the following to the
<em>Cargo.toml</em> file for <code>hello_macro_derive</code>:</p>
<p><span class="filename">Filename: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;1.0&quot;
quote = &quot;1.0&quot;
</code></pre>
<p>To start defining the procedural macro, place the code in Listing 19-31 into
your <em>src/lib.rs</em> file for the <code>hello_macro_derive</code> crate. Note that this code
won’t compile until we add a definition for the <code>impl_hello_macro</code> function.</p>
<p><span class="filename">Filename: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&amp;ast)
}
</code></pre>
<p><span class="caption">Listing 19-31: Code that most procedural macro crates
will require in order to process Rust code</span></p>
<p>Notice that we’ve split the code into the <code>hello_macro_derive</code> function, which
is responsible for parsing the <code>TokenStream</code>, and the <code>impl_hello_macro</code>
function, which is responsible for transforming the syntax tree: this makes
writing a procedural macro more convenient. The code in the outer function
(<code>hello_macro_derive</code> in this case) will be the same for almost every
procedural macro crate you see or create. The code you specify in the body of
the inner function (<code>impl_hello_macro</code> in this case) will be different
depending on your procedural macro’s purpose.</p>
<p>We’ve introduced three new crates: <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a>, and <a href="https://crates.io/crates/quote"><code>quote</code></a>. The
<code>proc_macro</code> crate comes with Rust, so we didn’t need to add that to the
dependencies in <em>Cargo.toml</em>. The <code>proc_macro</code> crate is the compiler’s API that
allows us to read and manipulate Rust code from our code.</p>
<p>The <code>syn</code> crate parses Rust code from a string into a data structure that we
can perform operations on. The <code>quote</code> crate turns <code>syn</code> data structures back
into Rust code. These crates make it much simpler to parse any sort of Rust
code we might want to handle: writing a full parser for Rust code is no simple
task.</p>
<p>The <code>hello_macro_derive</code> function will be called when a user of our library
specifies <code>#[derive(HelloMacro)]</code> on a type. This is possible because we’ve
annotated the <code>hello_macro_derive</code> function here with <code>proc_macro_derive</code> and
specified the name <code>HelloMacro</code>, which matches our trait name; this is the
convention most procedural macros follow.</p>
<p>The <code>hello_macro_derive</code> function first converts the <code>input</code> from a
<code>TokenStream</code> to a data structure that we can then interpret and perform
operations on. This is where <code>syn</code> comes into play. The <code>parse</code> function in
<code>syn</code> takes a <code>TokenStream</code> and returns a <code>DeriveInput</code> struct representing the
parsed Rust code. Listing 19-32 shows the relevant parts of the <code>DeriveInput</code>
struct we get from parsing the <code>struct Pancakes;</code> string:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
</code></pre>
<p><span class="caption">Listing 19-32: The <code>DeriveInput</code> instance we get when
parsing the code that has the macro’s attribute in Listing 19-30</span></p>
<p>The fields of this struct show that the Rust code we’ve parsed is a unit struct
with the <code>ident</code> (identifier, meaning the name) of <code>Pancakes</code>. There are more
fields on this struct for describing all sorts of Rust code; check the <a href="https://docs.rs/syn/1.0/syn/struct.DeriveInput.html"><code>syn</code>
documentation for <code>DeriveInput</code></a> for more information.</p>
<p>Soon we’ll define the <code>impl_hello_macro</code> function, which is where we’ll build
the new Rust code we want to include. But before we do, note that the output
for our derive macro is also a <code>TokenStream</code>. The returned <code>TokenStream</code> is
added to the code that our crate users write, so when they compile their crate,
they’ll get the extra functionality that we provide in the modified
<code>TokenStream</code>.</p>
<p>You might have noticed that we’re calling <code>unwrap</code> to cause the
<code>hello_macro_derive</code> function to panic if the call to the <code>syn::parse</code> function
fails here. It’s necessary for our procedural macro to panic on errors because
<code>proc_macro_derive</code> functions must return <code>TokenStream</code> rather than <code>Result</code> to
conform to the procedural macro API. We’ve simplified this example by using
<code>unwrap</code>; in production code, you should provide more specific error messages
about what went wrong by using <code>panic!</code> or <code>expect</code>.</p>
<p>Now that we have the code to turn the annotated Rust code from a <code>TokenStream</code>
into a <code>DeriveInput</code> instance, let’s generate the code that implements the
<code>HelloMacro</code> trait on the annotated type, as shown in Listing 19-33.</p>
<p><span class="filename">Filename: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">use syn;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construct a representation of Rust code as a syntax tree
</span><span class="boring">    // that we can manipulate
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Build the trait implementation
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hello, Macro! My name is {}!&quot;, stringify!(#name));
            }
        }
    };
    gen.into()
}
</code></pre>
<p><span class="caption">Listing 19-33: Implementing the <code>HelloMacro</code> trait using
the parsed Rust code</span></p>
<p>We get an <code>Ident</code> struct instance containing the name (identifier) of the
annotated type using <code>ast.ident</code>. The struct in Listing 19-32 shows that when
we run the <code>impl_hello_macro</code> function on the code in Listing 19-30, the
<code>ident</code> we get will have the <code>ident</code> field with a value of <code>&quot;Pancakes&quot;</code>. Thus,
the <code>name</code> variable in Listing 19-33 will contain an <code>Ident</code> struct instance
that, when printed, will be the string <code>&quot;Pancakes&quot;</code>, the name of the struct in
Listing 19-30.</p>
<p>The <code>quote!</code> macro lets us define the Rust code that we want to return. The
compiler expects something different to the direct result of the <code>quote!</code>
macro’s execution, so we need to convert it to a <code>TokenStream</code>. We do this by
calling the <code>into</code> method, which consumes this intermediate representation and
returns a value of the required <code>TokenStream</code> type.</p>
<p>The <code>quote!</code> macro also provides some very cool templating mechanics: we can
enter <code>#name</code>, and <code>quote!</code> will replace it with the value in the variable
<code>name</code>. You can even do some repetition similar to the way regular macros work.
Check out <a href="https://docs.rs/quote">the <code>quote</code> crate’s docs</a> for a thorough introduction.</p>
<p>We want our procedural macro to generate an implementation of our <code>HelloMacro</code>
trait for the type the user annotated, which we can get by using <code>#name</code>. The
trait implementation has the one function <code>hello_macro</code>, whose body contains the
functionality we want to provide: printing <code>Hello, Macro! My name is</code> and then
the name of the annotated type.</p>
<p>The <code>stringify!</code> macro used here is built into Rust. It takes a Rust
expression, such as <code>1 + 2</code>, and at compile time turns the expression into a
string literal, such as <code>&quot;1 + 2&quot;</code>. This is different than <code>format!</code> or
<code>println!</code>, macros which evaluate the expression and then turn the result into
a <code>String</code>. There is a possibility that the <code>#name</code> input might be an
expression to print literally, so we use <code>stringify!</code>. Using <code>stringify!</code> also
saves an allocation by converting <code>#name</code> to a string literal at compile time.</p>
<p>At this point, <code>cargo build</code> should complete successfully in both <code>hello_macro</code>
and <code>hello_macro_derive</code>. Let’s hook up these crates to the code in Listing
19-30 to see the procedural macro in action! Create a new binary project in
your <em>projects</em> directory using <code>cargo new pancakes</code>. We need to add
<code>hello_macro</code> and <code>hello_macro_derive</code> as dependencies in the <code>pancakes</code>
crate’s <em>Cargo.toml</em>. If you’re publishing your versions of <code>hello_macro</code> and
<code>hello_macro_derive</code> to <a href="https://crates.io/">crates.io</a>, they would be regular
dependencies; if not, you can specify them as <code>path</code> dependencies as follows:</p>
<pre><code class="language-toml">hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<p>Put the code in Listing 19-30 into <em>src/main.rs</em>, and run <code>cargo run</code>: it
should print <code>Hello, Macro! My name is Pancakes!</code> The implementation of the
<code>HelloMacro</code> trait from the procedural macro was included without the
<code>pancakes</code> crate needing to implement it; the <code>#[derive(HelloMacro)]</code> added the
trait implementation.</p>
<p>Next, let’s explore how the other kinds of procedural macros differ from custom
derive macros.</p>
<h3 id="attribute-like-macros"><a class="header" href="#attribute-like-macros">Attribute-like macros</a></h3>
<p>Attribute-like macros are similar to custom derive macros, but instead of
generating code for the <code>derive</code> attribute, they allow you to create new
attributes. They’re also more flexible: <code>derive</code> only works for structs and
enums; attributes can be applied to other items as well, such as functions.
Here’s an example of using an attribute-like macro: say you have an attribute
named <code>route</code> that annotates functions when using a web application framework:</p>
<pre><code class="language-rust ignore">#[route(GET, &quot;/&quot;)]
fn index() {
</code></pre>
<p>This <code>#[route]</code> attribute would be defined by the framework as a procedural
macro. The signature of the macro definition function would look like this:</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
</code></pre>
<p>Here, we have two parameters of type <code>TokenStream</code>. The first is for the
contents of the attribute: the <code>GET, &quot;/&quot;</code> part. The second is the body of the
item the attribute is attached to: in this case, <code>fn index() {}</code> and the rest
of the function’s body.</p>
<p>Other than that, attribute-like macros work the same way as custom derive
macros: you create a crate with the <code>proc-macro</code> crate type and implement a
function that generates the code you want!</p>
<h3 id="function-like-macros"><a class="header" href="#function-like-macros">Function-like macros</a></h3>
<p>Function-like macros define macros that look like function calls. Similarly to
<code>macro_rules!</code> macros, they’re more flexible than functions; for example, they
can take an unknown number of arguments. However, <code>macro_rules!</code> macros can be
defined only using the match-like syntax we discussed in the section
<a href="ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming">“Declarative Macros with <code>macro_rules!</code> for General
Metaprogramming”</a><!-- ignore --> earlier. Function-like macros take a
<code>TokenStream</code> parameter and their definition manipulates that <code>TokenStream</code>
using Rust code as the other two types of procedural macros do. An example of a
function-like macro is an <code>sql!</code> macro that might be called like so:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);
</code></pre>
<p>This macro would parse the SQL statement inside it and check that it’s
syntactically correct, which is much more complex processing than a
<code>macro_rules!</code> macro can do. The <code>sql!</code> macro would be defined like this:</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {
</code></pre>
<p>This definition is similar to the custom derive macro’s signature: we receive
the tokens that are inside the parentheses and return the code we wanted to
generate.</p>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>Whew! Now you have some Rust features in your toolbox that you likely won’t use
often, but you’ll know they’re available in very particular circumstances.
We’ve introduced several complex topics so that when you encounter them in
error message suggestions or in other peoples’ code, you’ll be able to
recognize these concepts and syntax. Use this chapter as a reference to guide
you to solutions.</p>
<p>Next, we’ll put everything we’ve discussed throughout the book into practice
and do one more project!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitirme-projesi-Çok-İş-parçacıklı-bir-web-sunucusu-oluşturma"><a class="header" href="#bitirme-projesi-Çok-İş-parçacıklı-bir-web-sunucusu-oluşturma">Bitirme Projesi: Çok İş Parçacıklı Bir Web Sunucusu Oluşturma</a></h1>
<p>Uzun bir yolculuk oldu ama kitabın sonuna geldik. 
Bu bölümde, son bölümlerde ele aldığımız bazı kavramları göstermek ve daha önceki bazı bölümleri
özetlemek için birlikte bir proje daha oluşturacağız.</p>
<p>Bitirme projemiz için, bir web tarayıcısına “hello” yazan ve 
Şekil 20-1'dekine benzeyen bir web sunucusu yapacağız.</p>
<p><img src="img/trpl20-01.png" alt="rust'tan bir merhaba" /></p>
<p><span class="caption">Şekil 20-1: Nihai bitirme projemiz</span></p>
<p>İşte web sunucusunu oluşturma planı:</p>
<ol>
<li>TCP ve HTTP hakkında biraz bilgi edinmek.</li>
<li>Bir soketteki TCP bağlantılarını dinlemek.</li>
<li>Az sayıdaki HTTP isteklerini ayrıştırmak.</li>
<li>Uygun bir HTTP yanıtı oluşturmak.</li>
<li>Bir iş parçacığı havuzuyla sunucunun verimini iyileştirmek.</li>
</ol>
<p>Ancak başlamadan önce bir ayrıntıdan bahsetmeliyiz: 
Kullanacağımız yöntem Rust ile bir web sunucusu oluşturmanın en iyi yolu olmayacak. </p>
<p><a href="https://crates.io/">crates.io</a>'da, oluşturacağımızdan daha eksiksiz web sunucusu ve 
iş parçacığı havuzu süreklemelerini sağlayan üretime hazır bir dizi kasa mevcuttur.</p>
<p>Ancak bu bölümdeki amacımız, kolay yolu seçmek değil, 
öğrenmenize yardımcı olmaktır. Rust bir sistem programlama dili olduğu için, 
çalışmak istediğimiz soyutlama seviyesini seçebilir ve diğer dillerde mümkün olan 
veya pratik olandan daha düşük bir seviyeye gidebiliriz. Gelecekte kullanabileceğiniz kasaların 
arkasındaki genel fikirleri ve teknikleri öğrenebilmeniz için temel HTTP sunucusunu ve 
iş parçacığı havuzunu kendimiz yazacağız.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="building-a-single-threaded-web-server"><a class="header" href="#building-a-single-threaded-web-server">Building a Single-Threaded Web Server</a></h2>
<p>We’ll start by getting a single-threaded web server working. Before we begin,
let’s look at a quick overview of the protocols involved in building web
servers. The details of these protocols are beyond the scope of this book, but
a brief overview will give you the information you need.</p>
<p>The two main protocols involved in web servers are the <em>Hypertext Transfer
Protocol</em> <em>(HTTP)</em> and the <em>Transmission Control Protocol</em> <em>(TCP)</em>. Both
protocols are <em>request-response</em> protocols, meaning a <em>client</em> initiates
requests and a <em>server</em> listens to the requests and provides a response to the
client. The contents of those requests and responses are defined by the
protocols.</p>
<p>TCP is the lower-level protocol that describes the details of how information
gets from one server to another but doesn’t specify what that information is.
HTTP builds on top of TCP by defining the contents of the requests and
responses. It’s technically possible to use HTTP with other protocols, but in
the vast majority of cases, HTTP sends its data over TCP. We’ll work with the
raw bytes of TCP and HTTP requests and responses.</p>
<h3 id="listening-to-the-tcp-connection"><a class="header" href="#listening-to-the-tcp-connection">Listening to the TCP Connection</a></h3>
<p>Our web server needs to listen to a TCP connection, so that’s the first part
we’ll work on. The standard library offers a <code>std::net</code> module that lets us do
this. Let’s make a new project in the usual fashion:</p>
<pre><code class="language-console">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Now enter the code in Listing 20-1 in <em>src/main.rs</em> to start. This code will
listen at the address <code>127.0.0.1:7878</code> for incoming TCP streams. When it gets
an incoming stream, it will print <code>Connection established!</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!(&quot;Connection established!&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 20-1: Listening for incoming streams and printing
a message when we receive a stream</span></p>
<p>Using <code>TcpListener</code>, we can listen for TCP connections at the address
<code>127.0.0.1:7878</code>. In the address, the section before the colon is an IP address
representing your computer (this is the same on every computer and doesn’t
represent the authors’ computer specifically), and <code>7878</code> is the port. We’ve
chosen this port for two reasons: HTTP isn’t normally accepted on this port, and
7878 is <em>rust</em> typed on a telephone.</p>
<p>The <code>bind</code> function in this scenario works like the <code>new</code> function in that it
will return a new <code>TcpListener</code> instance. The reason the function is called
<code>bind</code> is that in networking, connecting to a port to listen to is known as
“binding to a port.”</p>
<p>The <code>bind</code> function returns a <code>Result&lt;T, E&gt;</code>, which indicates that binding
might fail. For example, connecting to port 80 requires administrator
privileges (nonadministrators can listen only on ports higher than 1023), so if
we tried to connect to port 80 without being an administrator, binding wouldn’t
work. As another example, binding wouldn’t work if we ran two instances of our
program and so had two programs listening to the same port. Because we’re
writing a basic server just for learning purposes, we won’t worry about
handling these kinds of errors; instead, we use <code>unwrap</code> to stop the program if
errors happen.</p>
<p>The <code>incoming</code> method on <code>TcpListener</code> returns an iterator that gives us a
sequence of streams (more specifically, streams of type <code>TcpStream</code>). A single
<em>stream</em> represents an open connection between the client and the server. A
<em>connection</em> is the name for the full request and response process in which a
client connects to the server, the server generates a response, and the server
closes the connection. As such, we will read from the <code>TcpStream</code> to see what
the client sent and then write our response to the stream to send data back to
the client. Overall, this <code>for</code> loop will process each connection in turn and
produce a series of streams for us to handle.</p>
<p>For now, our handling of the stream consists of calling <code>unwrap</code> to terminate
our program if the stream has any errors; if there aren’t any errors, the
program prints a message. We’ll add more functionality for the success case in
the next listing. The reason we might receive errors from the <code>incoming</code> method
when a client connects to the server is that we’re not actually iterating over
connections. Instead, we’re iterating over <em>connection attempts</em>. The
connection might not be successful for a number of reasons, many of them
operating system specific. For example, many operating systems have a limit to
the number of simultaneous open connections they can support; new connection
attempts beyond that number will produce an error until some of the open
connections are closed.</p>
<p>Let’s try running this code! Invoke <code>cargo run</code> in the terminal and then load
<em>127.0.0.1:7878</em> in a web browser. The browser should show an error message
like “Connection reset,” because the server isn’t currently sending back any
data. But when you look at your terminal, you should see several messages that
were printed when the browser connected to the server!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>Sometimes, you’ll see multiple messages printed for one browser request; the
reason might be that the browser is making a request for the page as well as a
request for other resources, like the <em>favicon.ico</em> icon that appears in the
browser tab.</p>
<p>It could also be that the browser is trying to connect to the server multiple
times because the server isn’t responding with any data. When <code>stream</code> goes out
of scope and is dropped at the end of the loop, the connection is closed as
part of the <code>drop</code> implementation. Browsers sometimes deal with closed
connections by retrying, because the problem might be temporary. The important
factor is that we’ve successfully gotten a handle to a TCP connection!</p>
<p>Remember to stop the program by pressing <span class="keystroke">ctrl-c</span>
when you’re done running a particular version of the code. Then restart the
program by invoking the <code>cargo run</code> command after you’ve made each set of code
changes to make sure you’re running the newest code.</p>
<h3 id="reading-the-request"><a class="header" href="#reading-the-request">Reading the Request</a></h3>
<p>Let’s implement the functionality to read the request from the browser! To
separate the concerns of first getting a connection and then taking some action
with the connection, we’ll start a new function for processing connections. In
this new <code>handle_connection</code> function, we’ll read data from the TCP stream and
print it so we can see the data being sent from the browser. Change the code to
look like Listing 20-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!(&quot;Request: {:#?}&quot;, http_request);
}
</code></pre></pre>
<p><span class="caption">Listing 20-2: Reading from the <code>TcpStream</code> and printing
the data</span></p>
<p>We bring <code>std::io::prelude</code> and <code>std::io::BufReader</code> into scope to get access
to traits and types that let us read from and write to the stream. In the <code>for</code>
loop in the <code>main</code> function, instead of printing a message that says we made a
connection, we now call the new <code>handle_connection</code> function and pass the
<code>stream</code> to it.</p>
<p>In the <code>handle_connection</code> function, we create a new <code>BufReader</code> instance that
wraps a mutable reference to the <code>stream</code>. <code>BufReader</code> adds buffering by
managing calls to the <code>std::io::Read</code> trait methods for us.</p>
<p>We create a variable named <code>http_request</code> to collect the lines of the request
the browser sends to our server. We indicate that we want to collect these
lines in a vector by adding the <code>Vec&lt;_&gt;</code> type annotation.</p>
<p><code>BufReader</code> implements the <code>std::io::BufRead</code> trait, which provides the <code>lines</code>
method. The <code>lines</code> method returns an iterator of <code>Result&lt;String, std::io::Error&gt;</code> by splitting the stream of data whenever it sees a newline
byte. To get each <code>String</code>, we map and <code>unwrap</code> each <code>Result</code>. The <code>Result</code>
might be an error if the data isn’t valid UTF-8 or if there was a problem
reading from the stream. Again, a production program should handle these errors
more gracefully, but we’re choosing to stop the program in the error case for
simplicity.</p>
<p>The browser signals the end of an HTTP request by sending two newline
characters in a row, so to get one request from the stream, we take lines while
they’re not the empty string. Once we’ve collected the lines into the vector,
we’re printing them out using pretty debug formatting so we can take a look at
the instructions the web browser is sending to our server.</p>
<p>Let’s try this code! Start the program and make a request in a web browser
again. Note that we’ll still get an error page in the browser, but our
program’s output in the terminal will now look similar to this:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    &quot;GET / HTTP/1.1&quot;,
    &quot;Host: 127.0.0.1:7878&quot;,
    &quot;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0&quot;,
    &quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8&quot;,
    &quot;Accept-Language: en-US,en;q=0.5&quot;,
    &quot;Accept-Encoding: gzip, deflate, br&quot;,
    &quot;DNT: 1&quot;,
    &quot;Connection: keep-alive&quot;,
    &quot;Upgrade-Insecure-Requests: 1&quot;,
    &quot;Sec-Fetch-Dest: document&quot;,
    &quot;Sec-Fetch-Mode: navigate&quot;,
    &quot;Sec-Fetch-Site: none&quot;,
    &quot;Sec-Fetch-User: ?1&quot;,
    &quot;Cache-Control: max-age=0&quot;,
]
</code></pre>
<p>Depending on your browser, you might get slightly different output. Now that
we’re printing the request data, we can see why we get multiple connections
from one browser request by looking at the path after <code>GET</code> in the first line
of the request. If the repeated connections are all requesting <em>/</em>, we know the
browser is trying to fetch <em>/</em> repeatedly because it’s not getting a response
from our program.</p>
<p>Let’s break down this request data to understand what the browser is asking of
our program.</p>
<h3 id="a-closer-look-at-an-http-request"><a class="header" href="#a-closer-look-at-an-http-request">A Closer Look at an HTTP Request</a></h3>
<p>HTTP is a text-based protocol, and a request takes this format:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is the <em>request line</em> that holds information about what the
client is requesting. The first part of the request line indicates the <em>method</em>
being used, such as <code>GET</code> or <code>POST</code>, which describes how the client is making
this request. Our client used a <code>GET</code> request.</p>
<p>The next part of the request line is <em>/</em>, which indicates the <em>Uniform Resource
Identifier</em> <em>(URI)</em> the client is requesting: a URI is almost, but not quite,
the same as a <em>Uniform Resource Locator</em> <em>(URL)</em>. The difference between URIs
and URLs isn’t important for our purposes in this chapter, but the HTTP spec
uses the term URI, so we can just mentally substitute URL for URI here.</p>
<p>The last part is the HTTP version the client uses, and then the request line
ends in a <em>CRLF sequence</em>. (CRLF stands for <em>carriage return</em> and <em>line feed</em>,
which are terms from the typewriter days!) The CRLF sequence can also be
written as <code>\r\n</code>, where <code>\r</code> is a carriage return and <code>\n</code> is a line feed. The
CRLF sequence separates the request line from the rest of the request data.
Note that when the CRLF is printed, we see a new line start rather than <code>\r\n</code>.</p>
<p>Looking at the request line data we received from running our program so far,
we see that <code>GET</code> is the method, <em>/</em> is the request URI, and <code>HTTP/1.1</code> is the
version.</p>
<p>After the request line, the remaining lines starting from <code>Host:</code> onward are
headers. <code>GET</code> requests have no body.</p>
<p>Try making a request from a different browser or asking for a different
address, such as <em>127.0.0.1:7878/test</em>, to see how the request data changes.</p>
<p>Now that we know what the browser is asking for, let’s send back some data!</p>
<h3 id="writing-a-response"><a class="header" href="#writing-a-response">Writing a Response</a></h3>
<p>We’re going to implement sending data in response to a client request.
Responses have the following format:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is a <em>status line</em> that contains the HTTP version used in the
response, a numeric status code that summarizes the result of the request, and
a reason phrase that provides a text description of the status code. After the
CRLF sequence are any headers, another CRLF sequence, and the body of the
response.</p>
<p>Here is an example response that uses HTTP version 1.1, has a status code of
200, an OK reason phrase, no headers, and no body:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>The status code 200 is the standard success response. The text is a tiny
successful HTTP response. Let’s write this to the stream as our response to a
successful request! From the <code>handle_connection</code> function, remove the
<code>println!</code> that was printing the request data and replace it with the code in
Listing 20-3.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    stream.write_all(response.as_bytes()).unwrap();
}
</code></pre></pre>
<p><span class="caption">Listing 20-3: Writing a tiny successful HTTP response to
the stream</span></p>
<p>The first new line defines the <code>response</code> variable that holds the success
message’s data. Then we call <code>as_bytes</code> on our <code>response</code> to convert the string
data to bytes. The <code>write_all</code> method on <code>stream</code> takes a <code>&amp;[u8]</code> and sends
those bytes directly down the connection. Because the <code>write_all</code> operation
could fail, we use <code>unwrap</code> on any error result as before. Again, in a real
application you would add error handling here.</p>
<p>With these changes, let’s run our code and make a request. We’re no longer
printing any data to the terminal, so we won’t see any output other than the
output from Cargo. When you load <em>127.0.0.1:7878</em> in a web browser, you should
get a blank page instead of an error. You’ve just hand-coded receiving an HTTP
request and sending a response!</p>
<h3 id="returning-real-html"><a class="header" href="#returning-real-html">Returning Real HTML</a></h3>
<p>Let’s implement the functionality for returning more than a blank page. Create
a new file, <em>hello.html</em>, in the root of your project directory, not in the
<em>src</em> directory. You can input any HTML you want; Listing 20-4 shows one
possibility.</p>
<p><span class="filename">Filename: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listing 20-4: A sample HTML file to return in a
response</span></p>
<p>This is a minimal HTML5 document with a heading and some text. To return this
from the server when a request is received, we’ll modify <code>handle_connection</code> as
shown in Listing 20-5 to read the HTML file, add it to the response as a body,
and send it.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};
// --snip--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = &quot;HTTP/1.1 200 OK&quot;;
    let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
    let length = contents.len();

    let response =
        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);

    stream.write_all(response.as_bytes()).unwrap();
}
</code></pre></pre>
<p><span class="caption">Listing 20-5: Sending the contents of <em>hello.html</em> as the
body of the response</span></p>
<p>We’ve added <code>fs</code> to the <code>use</code> statement to bring the standard library’s
filesystem module into scope. The code for reading the contents of a file to a
string should look familiar; we used it in Chapter 12 when we read the contents
of a file for our I/O project in Listing 12-4.</p>
<p>Next, we use <code>format!</code> to add the file’s contents as the body of the success
response. To ensure a valid HTTP response, we add the <code>Content-Length</code> header
which is set to the size of our response body, in this case the size of
<code>hello.html</code>.</p>
<p>Run this code with <code>cargo run</code> and load <em>127.0.0.1:7878</em> in your browser; you
should see your HTML rendered!</p>
<p>Currently, we’re ignoring the request data in <code>http_request</code> and just sending
back the contents of the HTML file unconditionally. That means if you try
requesting <em>127.0.0.1:7878/something-else</em> in your browser, you’ll still get
back this same HTML response. Our server is very limited and is not what most
web servers do. We want to customize our responses depending on the request and
only send back the HTML file for a well-formed request to <em>/</em>.</p>
<h3 id="validating-the-request-and-selectively-responding"><a class="header" href="#validating-the-request-and-selectively-responding">Validating the Request and Selectively Responding</a></h3>
<p>Right now, our web server will return the HTML in the file no matter what the
client requested. Let’s add functionality to check that the browser is
requesting <em>/</em> before returning the HTML file and return an error if the
browser requests anything else. For this we need to modify <code>handle_connection</code>,
as shown in Listing 20-6. This new code checks the content of the request
received against what we know a request for <em>/</em> looks like and adds <code>if</code> and
<code>else</code> blocks to treat requests differently.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == &quot;GET / HTTP/1.1&quot; {
        let status_line = &quot;HTTP/1.1 200 OK&quot;;
        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
        let length = contents.len();

        let response = format!(
            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // some other request
    }
}
</code></pre></pre>
<p><span class="caption">Listing 20-6: Looking at the request line and handling
requests to <em>/</em> differently from other requests</span></p>
<p>We’re only going to be looking at the first line of the HTTP request, so rather
than reading the entire request into a vector, we’re calling <code>next</code> to get the
first item from the iterator. The first <code>unwrap</code> takes care of the <code>Option</code> and
stops the program if the iterator has no items. The second <code>unwrap</code> handles the
<code>Result</code> and has the same effect as the <code>unwrap</code> that was in the <code>map</code> added in
Listing 20-2.</p>
<p>Next, we check the <code>request_line</code> to see if it equals the request line of a GET
request to the <em>/</em> path. If it does, the <code>if</code> block returns the contents of our
HTML file.</p>
<p>If the <code>request_line</code> does <em>not</em> equal the GET request to the <em>/</em> path, it
means we’ve received some other request. We’ll add code to the <code>else</code> block in
a moment to respond to all other requests.</p>
<p>Run this code now and request <em>127.0.0.1:7878</em>; you should get the HTML in
<em>hello.html</em>. If you make any other request, such as
<em>127.0.0.1:7878/something-else</em>, you’ll get a connection error like those you
saw when running the code in Listing 20-1 and Listing 20-2.</p>
<p>Now let’s add the code in Listing 20-7 to the <code>else</code> block to return a response
with the status code 404, which signals that the content for the request was
not found. We’ll also return some HTML for a page to render in the browser
indicating the response to the end user.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    if request_line == &quot;GET / HTTP/1.1&quot; {
</span><span class="boring">        let status_line = &quot;HTTP/1.1 200 OK&quot;;
</span><span class="boring">        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
</span><span class="boring">        let length = contents.len();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write_all(response.as_bytes()).unwrap();
</span>    // --snip--
    } else {
        let status_line = &quot;HTTP/1.1 404 NOT FOUND&quot;;
        let contents = fs::read_to_string(&quot;404.html&quot;).unwrap();
        let length = contents.len();

        let response = format!(
            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 20-7: Responding with status code 404 and an
error page if anything other than <em>/</em> was requested</span></p>
<p>Here, our response has a status line with status code 404 and the reason phrase
<code>NOT FOUND</code>. The body of the response will be the HTML in the file <em>404.html</em>.
You’ll need to create a <em>404.html</em> file next to <em>hello.html</em> for the error
page; again feel free to use any HTML you want or use the example HTML in
Listing 20-8.</p>
<p><span class="filename">Filename: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listing 20-8: Sample content for the page to send back
with any 404 response</span></p>
<p>With these changes, run your server again. Requesting <em>127.0.0.1:7878</em> should
return the contents of <em>hello.html</em>, and any other request, like
<em>127.0.0.1:7878/foo</em>, should return the error HTML from <em>404.html</em>.</p>
<h3 id="a-touch-of-refactoring"><a class="header" href="#a-touch-of-refactoring">A Touch of Refactoring</a></h3>
<p>At the moment the <code>if</code> and <code>else</code> blocks have a lot of repetition: they’re both
reading files and writing the contents of the files to the stream. The only
differences are the status line and the filename. Let’s make the code more
concise by pulling out those differences into separate <code>if</code> and <code>else</code> lines
that will assign the values of the status line and the filename to variables;
we can then use those variables unconditionally in the code to read the file
and write the response. Listing 20-9 shows the resulting code after replacing
the large <code>if</code> and <code>else</code> blocks.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--
<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span>
    let (status_line, filename) = if request_line == &quot;GET / HTTP/1.1&quot; {
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);

    stream.write_all(response.as_bytes()).unwrap();
}
</code></pre></pre>
<p><span class="caption">Listing 20-9: Refactoring the <code>if</code> and <code>else</code> blocks to
contain only the code that differs between the two cases</span></p>
<p>Now the <code>if</code> and <code>else</code> blocks only return the appropriate values for the
status line and filename in a tuple; we then use destructuring to assign these
two values to <code>status_line</code> and <code>filename</code> using a pattern in the <code>let</code>
statement, as discussed in Chapter 18.</p>
<p>The previously duplicated code is now outside the <code>if</code> and <code>else</code> blocks and
uses the <code>status_line</code> and <code>filename</code> variables. This makes it easier to see
the difference between the two cases, and it means we have only one place to
update the code if we want to change how the file reading and response writing
work. The behavior of the code in Listing 20-9 will be the same as that in
Listing 20-8.</p>
<p>Awesome! We now have a simple web server in approximately 40 lines of Rust code
that responds to one request with a page of content and responds to all other
requests with a 404 response.</p>
<p>Currently, our server runs in a single thread, meaning it can only serve one
request at a time. Let’s examine how that can be a problem by simulating some
slow requests. Then we’ll fix it so our server can handle multiple requests at
once.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="turning-our-single-threaded-server-into-a-multithreaded-server"><a class="header" href="#turning-our-single-threaded-server-into-a-multithreaded-server">Turning Our Single-Threaded Server into a Multithreaded Server</a></h2>
<p>Right now, the server will process each request in turn, meaning it won’t
process a second connection until the first is finished processing. If the
server received more and more requests, this serial execution would be less and
less optimal. If the server receives a request that takes a long time to
process, subsequent requests will have to wait until the long request is
finished, even if the new requests can be processed quickly. We’ll need to fix
this, but first, we’ll look at the problem in action.</p>
<h3 id="simulating-a-slow-request-in-the-current-server-implementation"><a class="header" href="#simulating-a-slow-request-in-the-current-server-implementation">Simulating a Slow Request in the Current Server Implementation</a></h3>
<p>We’ll look at how a slow-processing request can affect other requests made to
our current server implementation. Listing 20-10 implements handling a request
to <em>/sleep</em> with a simulated slow response that will cause the server to sleep
for 5 seconds before responding.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn handle_connection(mut stream: TcpStream) {
    // --snip--

<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span>    let (status_line, filename) = match &amp;request_line[..] {
        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
            thread::sleep(Duration::from_secs(5));
            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
        }
        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
    };

    // --snip--
<span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span>}
</code></pre></pre>
<p><span class="caption">Listing 20-10: Simulating a slow request by recognizing
<em>/sleep</em> and sleeping for 5 seconds</span></p>
<p>We switched from <code>if</code> to <code>match</code> now that we have three cases. We need to
explicitly match on a slice of <code>request_line</code> to pattern match against the
string literal values; <code>match</code> doesn’t do automatic referencing and
dereferencing like the equality method does.</p>
<p>The first arm is the same as the <code>if</code> block from Listing 20-9. The second arm
matches a request to <em>/sleep</em>. When that request is received, the server will
sleep for 5 seconds before rendering the successful HTML page. The third arm is
the same as the <code>else</code> block from Listing 20-9.</p>
<p>You can see how primitive our server is: real libraries would handle the
recognition of multiple requests in a much less verbose way!</p>
<p>Start the server using <code>cargo run</code>. Then open two browser windows: one for
<em>http://127.0.0.1:7878/</em> and the other for <em>http://127.0.0.1:7878/sleep</em>. If
you enter the <em>/</em> URI a few times, as before, you’ll see it respond quickly.
But if you enter <em>/sleep</em> and then load <em>/</em>, you’ll see that <em>/</em> waits until
<code>sleep</code> has slept for its full 5 seconds before loading.</p>
<p>There are multiple ways we could change how our web server works to avoid
having more requests back up behind a slow request; the one we’ll implement is
a thread pool.</p>
<h3 id="improving-throughput-with-a-thread-pool"><a class="header" href="#improving-throughput-with-a-thread-pool">Improving Throughput with a Thread Pool</a></h3>
<p>A <em>thread pool</em> is a group of spawned threads that are waiting and ready to
handle a task. When the program receives a new task, it assigns one of the
threads in the pool to the task, and that thread will process the task. The
remaining threads in the pool are available to handle any other tasks that come
in while the first thread is processing. When the first thread is done
processing its task, it’s returned to the pool of idle threads, ready to handle
a new task. A thread pool allows you to process connections concurrently,
increasing the throughput of your server.</p>
<p>We’ll limit the number of threads in the pool to a small number to protect us
from Denial of Service (DoS) attacks; if we had our program create a new thread
for each request as it came in, someone making 10 million requests to our
server could create havoc by using up all our server’s resources and grinding
the processing of requests to a halt.</p>
<p>Rather than spawning unlimited threads, we’ll have a fixed number of threads
waiting in the pool. As requests come in, they’ll be sent to the pool for
processing. The pool will maintain a queue of incoming requests. Each of the
threads in the pool will pop off a request from this queue, handle the request,
and then ask the queue for another request. With this design, we can process
<code>N</code> requests concurrently, where <code>N</code> is the number of threads. If each thread
is responding to a long-running request, subsequent requests can still back up
in the queue, but we’ve increased the number of long-running requests we can
handle before reaching that point.</p>
<p>This technique is just one of many ways to improve the throughput of a web
server. Other options you might explore are the fork/join model and the
single-threaded async I/O model. If you’re interested in this topic, you can
read more about other solutions and try to implement them; with a low-level
language like Rust, all of these options are possible.</p>
<p>Before we begin implementing a thread pool, let’s talk about what using the
pool should look like. When you’re trying to design code, writing the client
interface first can help guide your design. Write the API of the code so it’s
structured in the way you want to call it; then implement the functionality
within that structure rather than implementing the functionality and then
designing the public API.</p>
<p>Similar to how we used test-driven development in the project in Chapter 12,
we’ll use compiler-driven development here. We’ll write the code that calls the
functions we want, and then we’ll look at errors from the compiler to determine
what we should change next to get the code to work.</p>
<h4 id="code-structure-if-we-could-spawn-a-thread-for-each-request"><a class="header" href="#code-structure-if-we-could-spawn-a-thread-for-each-request">Code Structure If We Could Spawn a Thread for Each Request</a></h4>
<p>First, let’s explore how our code might look if it did create a new thread for
every connection. As mentioned earlier, this isn’t our final plan due to the
problems with potentially spawning an unlimited number of threads, but it is a
starting point. Listing 20-11 shows the changes to make to <code>main</code> to spawn a
new thread to handle each stream within the <code>for</code> loop.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 20-11: Spawning a new thread for each
stream</span></p>
<p>As you learned in Chapter 16, <code>thread::spawn</code> will create a new thread and then
run the code in the closure in the new thread. If you run this code and load
<em>/sleep</em> in your browser, then <em>/</em> in two more browser tabs, you’ll indeed see
that the requests to <em>/</em> don’t have to wait for <em>/sleep</em> to finish. But as we
mentioned, this will eventually overwhelm the system because you’d be making
new threads without any limit.</p>
<h4 id="creating-a-similar-interface-for-a-finite-number-of-threads"><a class="header" href="#creating-a-similar-interface-for-a-finite-number-of-threads">Creating a Similar Interface for a Finite Number of Threads</a></h4>
<p>We want our thread pool to work in a similar, familiar way so switching from
threads to a thread pool doesn’t require large changes to the code that uses
our API. Listing 20-12 shows the hypothetical interface for a <code>ThreadPool</code>
struct we want to use instead of <code>thread::spawn</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 20-12: Our ideal <code>ThreadPool</code> interface</span></p>
<p>We use <code>ThreadPool::new</code> to create a new thread pool with a configurable number
of threads, in this case four. Then, in the <code>for</code> loop, <code>pool.execute</code> has a
similar interface as <code>thread::spawn</code> in that it takes a closure the pool should
run for each stream. We need to implement <code>pool.execute</code> so it takes the
closure and gives it to a thread in the pool to run. This code won’t yet
compile, but we’ll try so the compiler can guide us in how to fix it.</p>
<h4 id="building-the-threadpool-struct-using-compiler-driven-development"><a class="header" href="#building-the-threadpool-struct-using-compiler-driven-development">Building the <code>ThreadPool</code> Struct Using Compiler Driven Development</a></h4>
<p>Make the changes in Listing 20-12 to <em>src/main.rs</em>, and then let’s use the
compiler errors from <code>cargo check</code> to drive our development. Here is the first
error we get:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --&gt; src/main.rs:10:16
   |
10 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` due to previous error
</code></pre>
<p>Great! This error tells us we need a <code>ThreadPool</code> type or module, so we’ll
build one now. Our <code>ThreadPool</code> implementation will be independent of the kind
of work our web server is doing. So, let’s switch the <code>hello</code> crate from a
binary crate to a library crate to hold our <code>ThreadPool</code> implementation. After
we change to a library crate, we could also use the separate thread pool
library for any work we want to do using a thread pool, not just for serving
web requests.</p>
<p>Create a <em>src/lib.rs</em> that contains the following, which is the simplest
definition of a <code>ThreadPool</code> struct that we can have for now:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct ThreadPool;
</code></pre>
<p>Then edit <em>main.rs</em> file to bring <code>ThreadPool</code> into scope from the library
crate by adding the following code to the top of <em>src/main.rs</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
<span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">    let pool = ThreadPool::new(4);
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        pool.execute(|| {
</span><span class="boring">            handle_connection(stream);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}
</span></code></pre>
<p>This code still won’t work, but let’s check it again to get the next error that
we need to address:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --&gt; src/bin/main.rs:11:28
   |
11 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
</code></pre>
<p>This error indicates that next we need to create an associated function named
<code>new</code> for <code>ThreadPool</code>. We also know that <code>new</code> needs to have one parameter
that can accept <code>4</code> as an argument and should return a <code>ThreadPool</code> instance.
Let’s implement the simplest <code>new</code> function that will have those
characteristics:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}
</code></pre>
<p>We chose <code>usize</code> as the type of the <code>size</code> parameter, because we know that a
negative number of threads doesn’t make any sense. We also know we’ll use this
4 as the number of elements in a collection of threads, which is what the
<code>usize</code> type is for, as discussed in the <a href="ch03-02-data-types.html#integer-types">“Integer Types”</a><!--
ignore --> section of Chapter 3.</p>
<p>Let’s check the code again:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --&gt; src/bin/main.rs:16:14
   |
16 |         pool.execute(|| {
   |              ^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
</code></pre>
<p>Now the error occurs because we don’t have an <code>execute</code> method on <code>ThreadPool</code>.
Recall from the <a href="ch20-02-multithreaded.html#creating-a-similar-interface-for-a-finite-number-of-threads">“Creating a Similar Interface for a Finite Number of
Threads”</a><!--
ignore --> section that we decided our thread pool should have an interface
similar to <code>thread::spawn</code>. In addition, we’ll implement the <code>execute</code> function
so it takes the closure it’s given and gives it to an idle thread in the pool
to run.</p>
<p>We’ll define the <code>execute</code> method on <code>ThreadPool</code> to take a closure as a
parameter. Recall from the <a href="ch13-01-closures.html#moving-captured-values-out-of-the-closure-and-the-fn-traits">“Moving Captured Values Out of the Closure and the
<code>Fn</code> Traits”</a><!-- ignore --> section in Chapter 13 that we can take
closures as parameters with three different traits: <code>Fn</code>, <code>FnMut</code>, and
<code>FnOnce</code>. We need to decide which kind of closure to use here. We know we’ll
end up doing something similar to the standard library <code>thread::spawn</code>
implementation, so we can look at what bounds the signature of <code>thread::spawn</code>
has on its parameter. The documentation shows us the following:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,
</code></pre>
<p>The <code>F</code> type parameter is the one we’re concerned with here; the <code>T</code> type
parameter is related to the return value, and we’re not concerned with that. We
can see that <code>spawn</code> uses <code>FnOnce</code> as the trait bound on <code>F</code>. This is probably
what we want as well, because we’ll eventually pass the argument we get in
<code>execute</code> to <code>spawn</code>. We can be further confident that <code>FnOnce</code> is the trait we
want to use because the thread for running a request will only execute that
request’s closure one time, which matches the <code>Once</code> in <code>FnOnce</code>.</p>
<p>The <code>F</code> type parameter also has the trait bound <code>Send</code> and the lifetime bound
<code>'static</code>, which are useful in our situation: we need <code>Send</code> to transfer the
closure from one thread to another and <code>'static</code> because we don’t know how long
the thread will take to execute. Let’s create an <code>execute</code> method on
<code>ThreadPool</code> that will take a generic parameter of type <code>F</code> with these bounds:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        ThreadPool
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}
</code></pre>
<p>We still use the <code>()</code> after <code>FnOnce</code> because this <code>FnOnce</code> represents a closure
that takes no parameters and returns the unit type <code>()</code>. Just like function
definitions, the return type can be omitted from the signature, but even if we
have no parameters, we still need the parentheses.</p>
<p>Again, this is the simplest implementation of the <code>execute</code> method: it does
nothing, but we’re trying only to make our code compile. Let’s check it again:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<p>It compiles! But note that if you try <code>cargo run</code> and make a request in the
browser, you’ll see the errors in the browser that we saw at the beginning of
the chapter. Our library isn’t actually calling the closure passed to <code>execute</code>
yet!</p>
<blockquote>
<p>Note: A saying you might hear about languages with strict compilers, such as
Haskell and Rust, is “if the code compiles, it works.” But this saying is not
universally true. Our project compiles, but it does absolutely nothing! If we
were building a real, complete project, this would be a good time to start
writing unit tests to check that the code compiles <em>and</em> has the behavior we
want.</p>
</blockquote>
<h4 id="validating-the-number-of-threads-in-new"><a class="header" href="#validating-the-number-of-threads-in-new">Validating the Number of Threads in <code>new</code></a></h4>
<p>We aren’t doing anything with the parameters to <code>new</code> and <code>execute</code>. Let’s
implement the bodies of these functions with the behavior we want. To start,
let’s think about <code>new</code>. Earlier we chose an unsigned type for the <code>size</code>
parameter, because a pool with a negative number of threads makes no sense.
However, a pool with zero threads also makes no sense, yet zero is a perfectly
valid <code>usize</code>. We’ll add code to check that <code>size</code> is greater than zero before
we return a <code>ThreadPool</code> instance and have the program panic if it receives a
zero by using the <code>assert!</code> macro, as shown in Listing 20-13.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --snip--
<span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
</code></pre>
<p><span class="caption">Listing 20-13: Implementing <code>ThreadPool::new</code> to panic if
<code>size</code> is zero</span></p>
<p>We’ve also added some documentation for our <code>ThreadPool</code> with doc comments.
Note that we followed good documentation practices by adding a section that
calls out the situations in which our function can panic, as discussed in
Chapter 14. Try running <code>cargo doc --open</code> and clicking the <code>ThreadPool</code> struct
to see what the generated docs for <code>new</code> look like!</p>
<p>Instead of adding the <code>assert!</code> macro as we’ve done here, we could make <code>new</code>
return a <code>Result</code> like we did with <code>Config::new</code> in the I/O project in Listing
12-9. But we’ve decided in this case that trying to create a thread pool
without any threads should be an unrecoverable error. If you’re feeling
ambitious, try to write a version of <code>new</code> with the following signature to
compare both versions:</p>
<pre><code class="language-rust ignore">pub fn new(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {
</code></pre>
<h4 id="creating-space-to-store-the-threads"><a class="header" href="#creating-space-to-store-the-threads">Creating Space to Store the Threads</a></h4>
<p>Now that we have a way to know we have a valid number of threads to store in
the pool, we can create those threads and store them in the <code>ThreadPool</code> struct
before returning it. But how do we “store” a thread? Let’s take another look at
the <code>thread::spawn</code> signature:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,
</code></pre>
<p>The <code>spawn</code> function returns a <code>JoinHandle&lt;T&gt;</code>, where <code>T</code> is the type that the
closure returns. Let’s try using <code>JoinHandle</code> too and see what happens. In our
case, the closures we’re passing to the thread pool will handle the connection
and not return anything, so <code>T</code> will be the unit type <code>()</code>.</p>
<p>The code in Listing 20-14 will compile but doesn’t create any threads yet.
We’ve changed the definition of <code>ThreadPool</code> to hold a vector of
<code>thread::JoinHandle&lt;()&gt;</code> instances, initialized the vector with a capacity of
<code>size</code>, set up a <code>for</code> loop that will run some code to create the threads, and
returned a <code>ThreadPool</code> instance containing them.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
</code></pre>
<p><span class="caption">Listing 20-14: Creating a vector for <code>ThreadPool</code> to hold
the threads</span></p>
<p>We’ve brought <code>std::thread</code> into scope in the library crate, because we’re
using <code>thread::JoinHandle</code> as the type of the items in the vector in
<code>ThreadPool</code>.</p>
<p>Once a valid size is received, our <code>ThreadPool</code> creates a new vector that can
hold <code>size</code> items. We haven’t used the <code>with_capacity</code> function in this book
yet, which performs the same task as <code>Vec::new</code> but with an important
difference: it preallocates space in the vector. Because we know we need to
store <code>size</code> elements in the vector, doing this allocation up front is slightly
more efficient than using <code>Vec::new</code>, which resizes itself as elements are
inserted.</p>
<p>When you run <code>cargo check</code> again, it should succeed.</p>
<h4 id="a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread"><a class="header" href="#a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread">A <code>Worker</code> Struct Responsible for Sending Code from the <code>ThreadPool</code> to a Thread</a></h4>
<p>We left a comment in the <code>for</code> loop in Listing 20-14 regarding the creation of
threads. Here, we’ll look at how we actually create threads. The standard
library provides <code>thread::spawn</code> as a way to create threads, and
<code>thread::spawn</code> expects to get some code the thread should run as soon as the
thread is created. However, in our case, we want to create the threads and have
them <em>wait</em> for code that we’ll send later. The standard library’s
implementation of threads doesn’t include any way to do that; we have to
implement it manually.</p>
<p>We’ll implement this behavior by introducing a new data structure between the
<code>ThreadPool</code> and the threads that will manage this new behavior. We’ll call
this data structure <code>Worker</code>, which is a common term in pooling
implementations. Think of people working in the kitchen at a restaurant: the
workers wait until orders come in from customers, and then they’re responsible
for taking those orders and filling them.</p>
<p>Instead of storing a vector of <code>JoinHandle&lt;()&gt;</code> instances in the thread pool,
we’ll store instances of the <code>Worker</code> struct. Each <code>Worker</code> will store a single
<code>JoinHandle&lt;()&gt;</code> instance. Then we’ll implement a method on <code>Worker</code> that will
take a closure of code to run and send it to the already running thread for
execution. We’ll also give each worker an <code>id</code> so we can distinguish between
the different workers in the pool when logging or debugging.</p>
<p>Let’s make the following changes to what happens when we create a <code>ThreadPool</code>.
We’ll implement the code that sends the closure to the thread after we have
<code>Worker</code> set up in this way:</p>
<ol>
<li>Define a <code>Worker</code> struct that holds an <code>id</code> and a <code>JoinHandle&lt;()&gt;</code>.</li>
<li>Change <code>ThreadPool</code> to hold a vector of <code>Worker</code> instances.</li>
<li>Define a <code>Worker::new</code> function that takes an <code>id</code> number and returns a
<code>Worker</code> instance that holds the <code>id</code> and a thread spawned with an empty
closure.</li>
<li>In <code>ThreadPool::new</code>, use the <code>for</code> loop counter to generate an <code>id</code>, create
a new <code>Worker</code> with that <code>id</code>, and store the worker in the vector.</li>
</ol>
<p>If you’re up for a challenge, try implementing these changes on your own before
looking at the code in Listing 20-15.</p>
<p>Ready? Here is Listing 20-15 with one way to make the preceding modifications.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}
</code></pre>
<p><span class="caption">Listing 20-15: Modifying <code>ThreadPool</code> to hold <code>Worker</code>
instances instead of holding threads directly</span></p>
<p>We’ve changed the name of the field on <code>ThreadPool</code> from <code>threads</code> to <code>workers</code>
because it’s now holding <code>Worker</code> instances instead of <code>JoinHandle&lt;()&gt;</code>
instances. We use the counter in the <code>for</code> loop as an argument to
<code>Worker::new</code>, and we store each new <code>Worker</code> in the vector named <code>workers</code>.</p>
<p>External code (like our server in <em>src/main.rs</em>) doesn’t need to know the
implementation details regarding using a <code>Worker</code> struct within <code>ThreadPool</code>,
so we make the <code>Worker</code> struct and its <code>new</code> function private. The
<code>Worker::new</code> function uses the <code>id</code> we give it and stores a <code>JoinHandle&lt;()&gt;</code>
instance that is created by spawning a new thread using an empty closure.</p>
<p>This code will compile and will store the number of <code>Worker</code> instances we
specified as an argument to <code>ThreadPool::new</code>. But we’re <em>still</em> not processing
the closure that we get in <code>execute</code>. Let’s look at how to do that next.</p>
<h4 id="sending-requests-to-threads-via-channels"><a class="header" href="#sending-requests-to-threads-via-channels">Sending Requests to Threads via Channels</a></h4>
<p>Now we’ll tackle the problem that the closures given to <code>thread::spawn</code> do
absolutely nothing. Currently, we get the closure we want to execute in the
<code>execute</code> method. But we need to give <code>thread::spawn</code> a closure to run when we
create each <code>Worker</code> during the creation of the <code>ThreadPool</code>.</p>
<p>We want the <code>Worker</code> structs that we just created to fetch code to run from a
queue held in the <code>ThreadPool</code> and send that code to its thread to run.</p>
<p>In Chapter 16, you learned about <em>channels</em>—a simple way to communicate between
two threads—that would be perfect for this use case. We’ll use a channel to
function as the queue of jobs, and <code>execute</code> will send a job from the
<code>ThreadPool</code> to the <code>Worker</code> instances, which will send the job to its thread.
Here is the plan:</p>
<ol>
<li>The <code>ThreadPool</code> will create a channel and hold on to the sender.</li>
<li>Each <code>Worker</code> will hold on to the receiver.</li>
<li>We’ll create a new <code>Job</code> struct that will hold the closures we want to send
down the channel.</li>
<li>The <code>execute</code> method will send the job it wants to execute through the
sender.</li>
<li>In its thread, the <code>Worker</code> will loop over its receiver and execute the
closures of any jobs it receives.</li>
</ol>
<p>Let’s start by creating a channel in <code>ThreadPool::new</code> and holding the sender
in the <code>ThreadPool</code> instance, as shown in Listing 20-16. The <code>Job</code> struct
doesn’t hold anything for now but will be the type of item we’re sending down
the channel.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 20-16: Modifying <code>ThreadPool</code> to store the
sender of a channel that transmits <code>Job</code> instances</span></p>
<p>In <code>ThreadPool::new</code>, we create our new channel and have the pool hold the
sender. This will successfully compile.</p>
<p>Let’s try passing a receiver of the channel into each worker as the thread pool
creates the channel. We know we want to use the receiver in the thread that the
workers spawn, so we’ll reference the <code>receiver</code> parameter in the closure. The
code in Listing 20-17 won’t quite compile yet.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{sync::mpsc, thread};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}
</code></pre>
<p><span class="caption">Listing 20-17: Passing the receiver to the workers</span></p>
<p>We’ve made some small and straightforward changes: we pass the receiver into
<code>Worker::new</code>, and then we use it inside the closure.</p>
<p>When we try to check this code, we get this error:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:27:42
   |
22 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
27 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` due to previous error
</code></pre>
<p>The code is trying to pass <code>receiver</code> to multiple <code>Worker</code> instances. This
won’t work, as you’ll recall from Chapter 16: the channel implementation that
Rust provides is multiple <em>producer</em>, single <em>consumer</em>. This means we can’t
just clone the consuming end of the channel to fix this code. We also don’t
want to send a message multiple times to multiple consumers; we want one list
of messages with multiple workers such that each message gets processed once.</p>
<p>Additionally, taking a job off the channel queue involves mutating the
<code>receiver</code>, so the threads need a safe way to share and modify <code>receiver</code>;
otherwise, we might get race conditions (as covered in Chapter 16).</p>
<p>Recall the thread-safe smart pointers discussed in Chapter 16: to share
ownership across multiple threads and allow the threads to mutate the value, we
need to use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. The <code>Arc</code> type will let multiple workers own the
receiver, and <code>Mutex</code> will ensure that only one worker gets a job from the
receiver at a time. Listing 20-18 shows the changes we need to make.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};
// --snip--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span>    }
}
</code></pre>
<p><span class="caption">Listing 20-18: Sharing the receiver among the workers
using <code>Arc</code> and <code>Mutex</code></span></p>
<p>In <code>ThreadPool::new</code>, we put the receiver in an <code>Arc</code> and a <code>Mutex</code>. For each
new worker, we clone the <code>Arc</code> to bump the reference count so the workers can
share ownership of the receiver.</p>
<p>With these changes, the code compiles! We’re getting there!</p>
<h4 id="implementing-the-execute-method"><a class="header" href="#implementing-the-execute-method">Implementing the <code>execute</code> Method</a></h4>
<p>Let’s finally implement the <code>execute</code> method on <code>ThreadPool</code>. We’ll also change
<code>Job</code> from a struct to a type alias for a trait object that holds the type of
closure that <code>execute</code> receives. As discussed in the <a href="ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases">“Creating Type Synonyms
with Type Aliases”</a><!-- ignore -->
section of Chapter 19, type aliases allow us to make long types shorter. Look
at Listing 20-19.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span>
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Listing 20-19: Creating a <code>Job</code> type alias for a <code>Box</code>
that holds each closure and then sending the job down the channel</span></p>
<p>After creating a new <code>Job</code> instance using the closure we get in <code>execute</code>, we
send that job down the sending end of the channel. We’re calling <code>unwrap</code> on
<code>send</code> for the case that sending fails. This might happen if, for example, we
stop all our threads from executing, meaning the receiving end has stopped
receiving new messages. At the moment, we can’t stop our threads from
executing: our threads continue executing as long as the pool exists. The
reason we use <code>unwrap</code> is that we know the failure case won’t happen, but the
compiler doesn’t know that.</p>
<p>But we’re not quite done yet! In the worker, our closure being passed to
<code>thread::spawn</code> still only <em>references</em> the receiving end of the channel.
Instead, we need the closure to loop forever, asking the receiving end of the
channel for a job and running the job when it gets one. Let’s make the change
shown in Listing 20-20 to <code>Worker::new</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!(&quot;Worker {id} got a job; executing.&quot;);

            job();
        });

        Worker { id, thread }
    }
}
</code></pre>
<p><span class="caption">Listing 20-20: Receiving and executing the jobs in the
worker’s thread</span></p>
<p>Here, we first call <code>lock</code> on the <code>receiver</code> to acquire the mutex, and then we
call <code>unwrap</code> to panic on any errors. Acquiring a lock might fail if the mutex
is in a <em>poisoned</em> state, which can happen if some other thread panicked while
holding the lock rather than releasing the lock. In this situation, calling
<code>unwrap</code> to have this thread panic is the correct action to take. Feel free to
change this <code>unwrap</code> to an <code>expect</code> with an error message that is meaningful to
you.</p>
<p>If we get the lock on the mutex, we call <code>recv</code> to receive a <code>Job</code> from the
channel. A final <code>unwrap</code> moves past any errors here as well, which might occur
if the thread holding the sender has shut down, similar to how the <code>send</code>
method returns <code>Err</code> if the receiver shuts down.</p>
<p>The call to <code>recv</code> blocks, so if there is no job yet, the current thread will
wait until a job becomes available. The <code>Mutex&lt;T&gt;</code> ensures that only one
<code>Worker</code> thread at a time is trying to request a job.</p>
<p>Our thread pool is now in a working state! Give it a <code>cargo run</code> and make some
requests:</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never read: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  --&gt; src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `thread`
  --&gt; src/lib.rs:49:5
   |
49 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: `hello` (lib) generated 3 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>Success! We now have a thread pool that executes connections asynchronously.
There are never more than four threads created, so our system won’t get
overloaded if the server receives a lot of requests. If we make a request to
<em>/sleep</em>, the server will be able to serve other requests by having another
thread run them.</p>
<blockquote>
<p>Note: if you open <em>/sleep</em> in multiple browser windows simultaneously, they
might load one at a time in 5 second intervals. Some web browsers execute
multiple instances of the same request sequentially for caching reasons. This
limitation is not caused by our web server.</p>
</blockquote>
<p>After learning about the <code>while let</code> loop in Chapter 18, you might be wondering
why we didn’t write the worker thread code as shown in Listing 20-21.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!(&quot;Worker {id} got a job; executing.&quot;);

                job();
            }
        });

        Worker { id, thread }
    }
}
</code></pre>
<p><span class="caption">Listing 20-21: An alternative implementation of
<code>Worker::new</code> using <code>while let</code></span></p>
<p>This code compiles and runs but doesn’t result in the desired threading
behavior: a slow request will still cause other requests to wait to be
processed. The reason is somewhat subtle: the <code>Mutex</code> struct has no public
<code>unlock</code> method because the ownership of the lock is based on the lifetime of
the <code>MutexGuard&lt;T&gt;</code> within the <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> that the <code>lock</code>
method returns. At compile time, the borrow checker can then enforce the rule
that a resource guarded by a <code>Mutex</code> cannot be accessed unless we hold the
lock. But this implementation can also result in the lock being held longer
than intended if we don’t think carefully about the lifetime of the
<code>MutexGuard&lt;T&gt;</code>.</p>
<p>The code in Listing 20-20 that uses <code>let job = receiver.lock().unwrap().recv().unwrap();</code> works because with <code>let</code>, any
temporary values used in the expression on the right hand side of the equals
sign are immediately dropped when the <code>let</code> statement ends. However, <code>while let</code> (and <code>if let</code> and <code>match</code>) does not drop temporary values until the end of
the associated block. In Listing 20-21, the lock remains held for the duration
of the call to <code>job()</code>, meaning other workers cannot receive jobs.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="zarifçe-kapatma-ve-temizleme"><a class="header" href="#zarifçe-kapatma-ve-temizleme">Zarifçe Kapatma ve Temizleme</a></h2>
<p>Liste 20-20'deki kod, amaçladığımız gibi bir iş parçacığı havuzu kullanarak isteklere eşzamansız olarak yanıt veriyor. 
Doğrudan kullanmadığımız <code>workers</code>, <code>id</code> ve <code>thread</code> alanları hakkında bize hiçbir şeyi temizlemediğimizi hatırlatan bazı uyarılar alıyoruz. 
Ana iş parçacığını durdurmak için daha az zarif olan <span class="keystroke">ctrl-c</span> yöntemini kullandığımızda, bir isteği sunmanın ortasında olsalar bile diğer tüm iş parçacıkları da hemen durdurulur. </p>
<p>Şimdi, havuzdaki (thread) her bir iş parçacığına katılmak için Drop tanımını uygulayacağız, böylece onlar kapanmadan önce üzerinde çalıştıkları istekleri tamamlayabilirler. 
Ardından, ileti dizilerine yeni istekleri kabul etmeyi bırakmaları ve kapatmaları gerektiğini söylemenin bir yolunu uygulayacağız. 
Bu kodu çalışırken görmek için, iş parçacığı havuzunu zarif bir şekilde kapatmadan önce sunucumuzu yalnızca iki isteği kabul edecek şekilde değiştireceğiz.</p>
<h3 id="threadpoolda-drop-tanımını-süreklemek"><a class="header" href="#threadpoolda-drop-tanımını-süreklemek"><code>ThreadPool</code>'da <code>Drop</code> Tanımını Süreklemek</a></h3>
<p>Hadi havuzumuz için <code>Drop</code> tanımını sürekleyelim. Her ne zaman havuz bırakılırsa,
iş parçacıklarımızın tamamı işlerini bitirmelidir. Liste 20-22 bize <code>Drop</code> süreklemesinin
ilk girişimini gösteriyor. Tabii bu kod henüz tam anlamıyla çalışmıyor.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 20-22: Havuz alandan ayrıldığında her iş parçacığına girmek</span></p>
<p>İlk olarak, iş parçacığı havuzunun <code>workers</code> alanı arasında döngü yaparız. 
Bunun için <code>&amp;mut</code> kullanıyoruz çünkü <code>self</code> değişken bir referanstır ve ayrıca <code>worker</code>'ı değiştirebiliyor olmamız gerekir. 
Her çalışan için, bu belirli çalışanın kapatıldığını söyleyen bir mesaj yazdırırız ve ardından o çalışanın iş parçacığına katılmayı çağırırız. 
Katılma çağrısı (<code>join</code>) başarısız olursa, Rust'ı paniğe sürüklemek ve uygunsuz bir kapatmaya gitmek için paketi açarız (<code>unwrap</code>).</p>
<p>Bu kodu derlediğimizde aldığımız hata:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
  --&gt; src/lib.rs:52:13
   |
52 |             worker.thread.join().unwrap();
   |             ^^^^^^^^^^^^^ move occurs because `worker.thread` has type `JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` due to previous error
</code></pre>
<p>Hata bize, her bir çalışanın yalnızca değişken bir referansını almaya sahip olduğumuz ve <code>join</code> argümanının sahipliğini üstlendiği için <code>join</code> diyemeyeceğimizi söylüyor. Bu sorunu çözmek için, <code>join</code>'in <code>thread</code>'i tüketebilmesi için <code>thread</code>'i <code>thread</code>'in sahibi olan <code>Worker</code> örneğinin dışına taşımamız gerekiyor. 
Bunu Liste 17-15'te yaptık: 
<code>Worker</code> bunun yerine bir <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code> tutarsa, değeri <code>Some</code> değişkeninin dışına taşımak ve içinde bir <code>None</code> değişkeni bırakmak için <code>Option</code> üzerindeki <code>take</code> fonksiyonunu çağırabiliriz. Başka bir deyişle, çalışan bir <code>Worker</code>'ın iş parçacığında <code>Some</code> varyantı olacaktır ve bir <code>Worker</code>'ı temizlemek istediğimizde, <code>Worker</code>'ın çalıştıracak bir iş parçacığı olmaması için <code>Some</code>'yi <code>None</code> ile değiştiririz.</p>
<p>Dolayısıyla, <code>Worker</code> tanımını şu şekilde güncellemek istediğimizi biliyoruz:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
<span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Şimdi değişmesi gereken diğer yerleri bulmak için derleyiciye bakalım. 
Bu kodu kontrol ederken iki hata alıyoruz:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `join` found for enum `Option` in the current scope
  --&gt; src/lib.rs:52:27
   |
52 |             worker.thread.join().unwrap();
   |                           ^^^^ method not found in `Option&lt;JoinHandle&lt;()&gt;&gt;`

error[E0308]: mismatched types
  --&gt; src/lib.rs:72:22
   |
72 |         Worker { id, thread }
   |                      ^^^^^^ expected enum `Option`, found struct `JoinHandle`
   |
   = note: expected enum `Option&lt;JoinHandle&lt;()&gt;&gt;`
            found struct `JoinHandle&lt;_&gt;`
help: try wrapping the expression in `Some`
   |
72 |         Worker { id, Some(thread) }
   |                      +++++      +

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.
error: could not compile `hello` due to 2 previous errors
</code></pre>
<p><code>Worker::new</code>'in sonundaki koda işaret eden ikinci hatayı ele alalım; yeni bir <code>Worker</code> oluşturduğumuzda, 
iş parçacığı (<code>thread</code>) değerini <code>Some</code> içine sarmamız gerekir. Bu hatayı düzeltmek için aşağıdaki değişiklikleri yapın:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--

<span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span>        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p>İlk hata <code>Drop</code> süreklemesindedir. <code>thread</code>'i <code>worker</code>'ın dışına taşımak için <code>Option</code> değerini alabilmek için <code>take</code> 
fonksiyonunu çağırmayı amaçladığımızdan daha önce bahsetmiştik. </p>
<p>Aşağıdaki değişiklikler bunu yapacaktır:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Bölüm 17'de söylendiği gibi, <code>Option</code> üzerindeki <code>take</code> fonksiyonu <code>Some</code> değişkenini çıkarır ve onun yerine <code>None</code>'u bırakır. 
<code>Some</code>'ı yok etmek ve ipliği almak için <code>if let</code>'i kullanıyoruz; sonra iplik üzerinde <code>join</code>'i çağırıyoruz. 
Bir işçinin iş parçacığı zaten <code>None</code> ise, işçinin iş parçacığını zaten temizlediğini biliyoruz, 
bu nedenle bu durumda hiçbir şey değişmeyecektir.</p>
<h3 id="İşleri-dinlemeyi-durdurmak-İçin-İpliklere-sinyal-vermek"><a class="header" href="#İşleri-dinlemeyi-durdurmak-İçin-İpliklere-sinyal-vermek">İşleri Dinlemeyi Durdurmak İçin İpliklere Sinyal Vermek</a></h3>
<p>Yaptığımız tüm değişikliklerle kodumuz herhangi bir uyarı olmadan derleniyor.
Ancak kötü haber şu ki, bu kod henüz istediğimiz gibi çalışmıyor. Anahtar, <code>Worker</code> örneklerinin 
iş parçacıkları tarafından çalıştırılan kapatmalardaki mantıktır: şu anda buna <code>join</code> diyoruz, ancak bu, iş aramak için sonsuza kadar döngü yaptıkları için iş parçacıklarını kapatmaz. Mevcut drop uygulamamızla ThreadPool'umuzu düşürmeye çalışırsak, ana iş parçacığı sonsuza kadar ilk iş parçacığının bitmesini bekleyecek. Bu sorunu çözmek için <code>ThreadPool</code> <code>drop</code> süreklemesinde bir değişikliğe ve ardından <code>Worker</code> döngüsünde (<code>loop</code>) bir değişikliğe ihtiyacımız olacak. </p>
<p>İlk olarak, <code>ThreadPool</code> <code>drop</code> süreklemesini, ileti dizilerinin bitmesini beklemeden önce göndereni açıkça bırakacak şekilde değiştireceğiz.</p>
<p>Liste 20-23, göndereni açıkça bırakmak (<code>drop</code>) için <code>ThreadPool</code>'daki değişiklikleri gösterir. Göndericiyi (<code>sender</code>) <code>ThreadPool</code>'un dışına taşıyabilmek için aynı <code>Option</code>u kullanıyoruz ve iş parçacığında yaptığımız gibi tekniği alıyoruz:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span>pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}
// --snip--
<span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>impl ThreadPool {
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        // --snip--

<span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span>        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 20-23: Çalışan iş parçacıklarına katılmadan önce <code>sender</code>'ı açıkça bırakın</span></p>
<p><code>sender</code>'ı bırakmak, kanalı kapatır, bu da daha fazla mesaj gönderilmeyeceğini gösterir. Bu olduğunda, 
işçilerin sonsuz döngüde yaptığı tüm <code>recv</code> çağrıları bir hata döndürür. Liste 20-24'te, bu durumda 
döngüden zarif bir şekilde çıkmak için <code>Worker</code> döngüsünü değiştiriyoruz; bu, <code>ThreadPool</code> <code>drop</code> süreklemesi, <code>join</code> çağrısı yaptığında iş parçacıklarının biteceği anlamına geliyor.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool {
</span><span class="boring">            workers,
</span><span class="boring">            sender: Some(sender),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.as_ref().unwrap().send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        drop(self.sender.take());
</span><span class="boring">
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            if let Some(thread) = worker.thread.take() {
</span><span class="boring">                thread.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            match receiver.lock().unwrap().recv() {
                Ok(job) =&gt; {
                    println!(&quot;Worker {id} got a job; executing.&quot;);

                    job();
                }
                Err(_) =&gt; {
                    println!(&quot;Worker {id} disconnected; shutting down.&quot;);
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p><span class="caption">Liste 20-24: &quot;recv&quot; bir hata döndürdüğünde açıkça döngüden çıkar</span></p>
<p>Bu kodu çalışırken görmek için, Liste 20-25'te gösterildiği gibi, 
sunucuyu düzgün bir şekilde kapatmadan önce <code>main</code>'i yalnızca iki isteği kabul edecek şekilde değiştirelim.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use hello::ThreadPool;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = if buffer.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if buffer.starts_with(sleep) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">
</span><span class="boring">    let response = format!(
</span><span class="boring">        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
</span><span class="boring">        status_line,
</span><span class="boring">        contents.len(),
</span><span class="boring">        contents
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">    stream.flush().unwrap();
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 20-25: Döngüden çıkıp iki istek sunduktan sonra sunucuyu kapatır</span></p>
<p>Gerçek dünya uygulamasında bir web sunucusunun yalnızca iki istek sunduktan sonra kapanmasını istemezsiniz. 
Bu kod, yalnızca zarif kapatma ve temizlemenin çalışır durumda olduğunu gösterir. </p>
<p><code>take</code> metodu, <code>Iterator</code> tanımında tanımlanır ve yinelemeyi en fazla ilk iki öğeyle sınırlar. 
<code>ThreadPool</code>, <code>main</code> sonunda kapsam dışına çıkacak ve <code>drop</code> süreklemesi çalışacaktır. </p>
<p>Sunucuyu <code>cargo run</code> ile başlatın ve üç istekte bulunun. 
Üçüncü istek hata vermeli ve uçbiriminizde buna benzer bir çıktı görmelisiniz:</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Shutting down.
Shutting down worker 0
Worker 3 got a job; executing.
Worker 1 disconnected; shutting down.
Worker 2 disconnected; shutting down.
Worker 3 disconnected; shutting down.
Worker 0 disconnected; shutting down.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>Farklı bir çalışan sıralaması ve yazdırılan mesajlar görebilirsiniz. 
Bu kodun nasıl çalıştığını mesajlardan görebiliriz: 
0 ve 3 numaralı işçiler ilk iki isteği aldı. Sunucu, ikinci bağlantıdan sonra bağlantıları kabul etmeyi durdurdu ve <code>ThreadPool</code>'daki 
<code>Drop</code> süreklemesi, işçi 3 daha işine başlamadan önce yürütülmeye başladı. <code>sender</code>'ı bırakmak, tüm çalışanların bağlantısını keser ve onlara kapatmalarını söyler. </p>
<p>Çalışanların her biri, bağlantıyı kestiklerinde bir mesaj yazdırır ve ardından iş parçacığı havuzu, her bir çalışan iş parçacığının bitmesini beklemek için birleştirme çağırır. </p>
<p>Bu uygulamanın ilginç bir yönüne dikkat edin: <code>ThreadPool</code> <code>sender</code>'ı bıraktı (<code>drop</code>) ve herhangi bir çalışan bir hata almadan önce, 
işçi 0'a girmeye çalıştık. </p>
<p>İşçi 0, <code>recv</code>'den henüz bir hata almamıştı, bu nedenle ana iş parçacığı, işçi 0'ı beklemeyi engelledi. bitirmek için. Bu arada, işçi 3 bir iş aldı ve ardından tüm iş parçacıkları bir hata aldı. İşçi 0 bittiğinde, ana iş parçacığı diğer işçilerin bitirmesini bekledi. 
Bu noktada, hepsi döngülerinden çıkmış ve durmuşlardı. Tebrikler! Artık projemizi tamamladık; zaman uyumsuz olarak yanıt vermek için bir iş parçacığı havuzu kullanan temel bir web sunucumuz var. Havuzdaki tüm iş parçacıklarını temizleyen sunucunun zarif bir şekilde kapatılmasını gerçekleştirebiliyoruz. </p>
<p>Referans için tam kod:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(
        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
        status_line,
        contents.len(),
        contents
    );

    stream.write_all(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</code></pre>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender: Some(sender) }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!(&quot;Worker {id} got a job; executing.&quot;);

                    job();
                }
                Err(_) =&gt; {
                    println!(&quot;Worker {id} disconnected; shutting down.&quot;);
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p>Daha fazlasını da yapabilirdik! Eğer bu projeyi geliştirmeye devam etmek istiyorsanız, burada
size yardımcı olacak bazı fikirler var:</p>
<ul>
<li><code>ThreadPool</code>'a ve genel yöntemlerine daha fazla belge ekleyin.</li>
<li>Kütüphanenin işlevselliğine ilişkin testler ekleyin</li>
<li>Daha kararlı hata işleme için fonksiyon çağrılarına <code>unwrap</code> ekleyin.</li>
<li>Web isteklerini sunmaktan başka bir görevi gerçekleştirmek için <code>ThreadPool</code>'u kullanın.</li>
<li><a href="https://crates.io/">crates.io</a>'da iş parçacığı havuzu arayın ve
yaptığımız web sunucusunu bulduğunuz kasayda sürekleyin.
Daha sonra süreklediğimizle arasındaki API kararlılığını karşılaştırın.</li>
</ul>
<h2 id="Özet-13"><a class="header" href="#Özet-13">Özet</a></h2>
<p>Bravo! 
Kitabın sonuna geldiniz! 
Rust'un bu turuna katıldığınız için size teşekkür etmek istiyoruz. 
Artık kendi Rust projelerinizi uygulamaya ve diğer insanların projelerine yardım etmeye hazırsınız. 
Rust yolculuğunuzda karşılaştığınız her türlü zorlukta size yardım etmeyi sevecek diğer Rustseverlerden 
oluşan hoş bir topluluk olduğunu unutmayın.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eklemeler"><a class="header" href="#eklemeler">Eklemeler</a></h1>
<p>Aşağıdaki bölümlerde Rust yolculuğunuzda işinize yarayabilecek referans materyalleri yer almaktadır.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ekleme-a-anahtar-sözcükler"><a class="header" href="#ekleme-a-anahtar-sözcükler">Ekleme A: Anahtar Sözcükler</a></h2>
<p>Aşağıdaki listede bulunan anahtar sözcükler Rust dilinde şu anda ya da gelecekte kullanılacağı 
için rezerve edilmiştir. Bu nedenle tanımlayıcı olarak kullanılamazlar. (“<a href="appendix-01-keywords.html#raw-identifiers">Ham Tanımlayıcılar</a><!-- ignore -->” kısmında tartışacağımız tanımlayıcılar hariç), isimleri dahil olmak üzere
fonksiyonlar, değişkenler, parametreler, yapı girdileri, modüller, kasalar, değişmezler, makrolar,
statik değerler, öznitelikler, türler, tanımlar ya da ömürlükleri kapsar.</p>
<h3 id="Şu-anda-kullanılan-anahtar-sözcükler"><a class="header" href="#Şu-anda-kullanılan-anahtar-sözcükler">Şu anda Kullanılan Anahtar Sözcükler</a></h3>
<p>Aşağıdaki anahtar sözcükler açıklanan işlevselliklere sahiptir. </p>
<ul>
<li><code>as</code> - ilkel dönüşüm yapmak, belirli özelliğin türünün belirsizliğini gidermek, 
ya da kullanımdaki <code>use</code> ve <code>extern crate</code> ifadelerini yeniden adlandırmak için kullanılır</li>
<li><code>async</code> - şu andaki ipliği bloklamak yerine <code>Future</code> döndürür</li>
<li><code>await</code> - <code>Future</code>'ın sonucu hazır olana kadar çağrıları susturur</li>
<li><code>break</code> - döngüden çıkar</li>
<li><code>const</code> - değişmez öğeleri veya sabit işaretçileri tanımlar</li>
<li><code>continue</code> - sonraki döngü yineleyiciyle devam ettirir</li>
<li><code>crate</code> - makroda tanımlanan bir kasa değişkenini ya da harici kasayı bağlar</li>
<li><code>dyn</code> - bir tanım nesnesine dinamik olarak gönderir</li>
<li><code>else</code> - <code>if</code> ya da <code>if let</code> kontrol akış yapılarının B planını uygular</li>
<li><code>enum</code> - numaralandırılmış yapı tanımlar</li>
<li><code>extern</code> - harici bir kasayı, fonksiyonu ya da değişkeni bağlar</li>
<li><code>false</code> - Boole yanlış değişmezi</li>
<li><code>fn</code> - fonksiyon ya da fonksiyon işaretçi türünü tanımlar</li>
<li><code>for</code> - bir yineleyici üzerinde öğeler kadar döngü yapar, tanım uygular ya da yüksek dereceli
ömürlüğü belirtir</li>
<li><code>if</code> - koşullu bir ifadenin sonucuna dayalı dal oluşturur</li>
<li><code>impl</code> - var olan veya tanımsal işlevselliğini sürekler</li>
<li><code>in</code> - <code>for</code> döngüsünün söz diziminin bir parçası</li>
<li><code>let</code> - değişken atar</li>
<li><code>loop</code> - koşulsuz döngüye girer</li>
<li><code>match</code> - modelleri kullanarak değer eşleştirir</li>
<li><code>mod</code> - modül tanımlar</li>
<li><code>move</code> - bir kapanış yaparak tüm yakalamalarının sahipliğini alır</li>
<li><code>mut</code> - referanslarda, işaretçilerde ya da model atamalarında değişmemezliği belirtir</li>
<li><code>pub</code> - yapı alanlarında, <code>impl</code> bloklarında ya da modüllerde genel görünümlüğü belirtir</li>
<li><code>ref</code> - referansla atar</li>
<li><code>return</code> - fonksiyondan döndürür</li>
<li><code>Self</code> - tanımladığımız ya da süreklediğimiz bir tür için takma ad</li>
<li><code>self</code> - halihazırdaki modül belirteci</li>
<li><code>static</code> - program çalıştığından beri tutulan genel değişken ya da ömürlük</li>
<li><code>struct</code> - yapı tanımlar</li>
<li><code>super</code> - halihazırdaki modülün bulunduğu ana modül belirteci</li>
<li><code>trait</code> - tanım tanımlar</li>
<li><code>true</code> - Boole doğru değişmezi</li>
<li><code>type</code> - bir tür takma adı veya ilişkili tür tanımlar</li>
<li><code>union</code> - <a href="../reference/items/unions.html">birlik</a> tanımlar ve sadece birlik tanımlarken bir anahtar sözcük görevi görür</li>
<li><code>unsafe</code> - güvensiz kodlar, fonksiyonlar, tanımlar ya da süreklemeleri belirtir</li>
<li><code>use</code> - sembolleri kapsama alır</li>
<li><code>where</code> - bir türü sınırlayan tümceleri belirtir</li>
<li><code>while</code> - bir ifadenin sonucuna göre çalışan koşullu döngü tanımlar</li>
</ul>
<h3 id="gelecekte-kullanım-için-ayrılmış-anahtar-kelimeler"><a class="header" href="#gelecekte-kullanım-için-ayrılmış-anahtar-kelimeler">Gelecekte Kullanım için Ayrılmış Anahtar Kelimeler</a></h3>
<p>Aşağıdaki anahtar kelimelerin herhangi bir işlevi yoktur, 
ancak gelecekteki potansiyel kullanımdan dolayı Rust tarafından ayrılmıştır.</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3 id="ham-tanımlayıcılar"><a class="header" href="#ham-tanımlayıcılar">Ham Tanımlayıcılar</a></h3>
<p><em>Ham tanımlayıcılar</em> normalde kullanılmayacakları yerlerde kullanmanıza izin veren söz dizimidir özelliğidir. 
Anahtar sözcüğünüzün başına <code>r#</code> koyarak ham işaretçileri kullanabilirsiniz.</p>
<p>Örneğin, <code>match</code> bir anahtar sözcüktür. Eğer fonksiyonunuz ad olarak <code>match</code> kullandığında onu derlemeye çalışırsanız:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
</code></pre>
<p>şu hatayı alırsınız:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>Bu hata size <code>match</code>'i fonksiyon adı olarak kullanamayacağınızı gösterir.
<code>match</code>'i fonksiyon adı kullanmak için ham tanımlayıcı söz dizimini kullanmanız gerekir, aynı bunun gibi:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}
</code></pre></pre>
<p>Bu kod hatasız derlenir. Not olaraktan, <code>r#</code> öneki <code>main</code> adıyla anılan 
özel fonksiyon için de kullanılabilir.</p>
<p>Ham tanımlayıcılar sizi hangi sözcüğü kullanacağınız konusunda özgür tutar. Ekleme olaraktan,
ham işaretçiler kasanızın kullandığından farklı Rust sürümünü kullanan kütüphaneleri kullanmanıza izin verir.
Örnek olarak, <code>try</code> 2015 sürümünde bir anahtar sözcük değildi, 2018 sürümünde geldi.
Eğer 2015 sürümünü kullanan bir kütüphaneniz varsa ve bu kütüphane <code>try</code> diye bir fonksiyona sahipse, 2018
sürümünde bu fonksiyonu çağırabilmeniz için ham tanımlayıcılar kullanmanız gerekir.
Sürümler hakkında daha fazla bilgiye erişmek için <a href="appendix-05-editions.html">Ekleme
E</a><!-- ignore --> bölümüne göz atabilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ekleme-b-operatörler-ve-semboller"><a class="header" href="#ekleme-b-operatörler-ve-semboller">Ekleme B: Operatörler ve Semboller</a></h2>
<p>Bu ekleme, Rust'ın yaygınlar, tanım sınırları, makrolar, nitelikler, yorum satırları, demetler ve parantezler 
bağlamında beliren operatörlerini ve diğer sembollerini dahil eden bir sözlüğü içerir.</p>
<h3 id="operatörler"><a class="header" href="#operatörler">Operatörler</a></h3>
<p>Tablo B-1 Rust'taki operatörleri, kodda nasıl belireceğini, kısa özetini, 
nasıl aşırı yüklenilebileceğini gösterir.</p>
<p><span class="caption">Tablo B-1: Operatörler</span></p>
<table><thead><tr><th>Operatör</th><th>Örnek</th><th>Açıklama</th><th>Aşırı Yüklenilebilir mi?</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Makro genişlemesi</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>Bitsel veya mantıksal tamamlayıcı</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>var != expr</code></td><td>Eşitsizlik karşılaştırıcı</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>Modu</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>Modu ve eşitlemesi</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>Referans</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>Referans işaretçi türü</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>Bitsel VE</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>Bitsel VE ve eşitlemesi</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>Kısa devre mantıksal VE</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>Aritmetik çarpma</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>Aritmetik çarpma ve eşitlemesi</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>Referansı kaldırma</td><td><code>Deref</code></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>Ham işaretçi</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>Bileşik tür kısıtlaması</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>Aritmetik toplama</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>Aritmetik toplama ve eşitlemesi</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>Argüman ve öğe ayırıcı</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>Aritmetik olumsuzlama</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>Aritmetik çıkarma</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>Aritmetik çıkarma ve eşitlemesi</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code></td><td>Fonksiyon ve dönüş tipi</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>Üye erişimi</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>Sağa özgü aralık değişmezi</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>Sağ dahil aralık değişmezi</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>Yapı değişmezini güncelleme söz dizimi</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>Model atama</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>(Kaldırıldı, yerine <code>..=</code> kullanın) Bir modelde: kapsayıcı aralık modeli</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>Aritmetik bölme</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>Aritmetik bölme ve eşitleme</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>Kısıtlama</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>Yapı alanı oluşturucusu</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>Döngü adı</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>Koşul ve öğe sonlandırıcı</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>Sabit boyutlu dizi söz diziminin bir parçası</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>Sola kaydırma</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>Sola kaydırma ve eşitleme</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>Daha az karşılaştırması</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>Daha az ya da eşit karşılaştırması</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>Atama/eşitlik</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>Eşitlik karşılaştırması</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>match söz diziminin bir parçası</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>Daha fazla karşılaştırması</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>Daha fazla ya da eşit karşılaştırması</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>Sağa kaydırma</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>Sağa kaydırma ve eşitleme</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>Model atama</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>Bitsel Dışlayıcı VEYA işlevi</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>Bitsel Dışlayıcı VEYA işlevi ve eşitleme</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>Model alternatifleri</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>Bitsel YA DA</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>Bitsel YA DA ve eşitleme</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>Kısa devre yapan mantıksal YA DA</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>Hata yayılımı</td><td></td></tr>
</tbody></table>
<h3 id="operatör-dışı-semboller"><a class="header" href="#operatör-dışı-semboller">Operatör dışı Semboller</a></h3>
<p>Aşağıdaki liste, operatör işlevi görmeyen tüm harfleri içerir. Yani, bir işlev veya yöntem çağrısı gibi davranmazlar</p>
<p>Tablo B-2, kendi başlarına görünen ve çeşitli şekillerde geçerli olan sembolleri göstermektedir.</p>
<p><span class="caption">Tablo B-2: Kendi Başına Söz Dizimi</span></p>
<table><thead><tr><th>Sembol</th><th>Açıklama</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>Adlandırılmış ömürlük ya da döngü adı</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, vs.</td><td>Belirli bir türün sayısal değişmezi</td></tr>
<tr><td><code>&quot;...&quot;</code></td><td>Dizgi değişmezi</td></tr>
<tr><td><code>r&quot;...&quot;</code>, <code>r#&quot;...&quot;#</code>, <code>r##&quot;...&quot;##</code>, vs.</td><td>Ham dizgi değişmezi, kaçış karakterleri işlenmez</td></tr>
<tr><td><code>b&quot;...&quot;</code></td><td>Bitsel dizgi değişmezi; dizgi yerine bitlerden oluşan dizi oluşturur</td></tr>
<tr><td><code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, <code>br##&quot;...&quot;##</code>, vs.</td><td>Ham bitsel dizgi değişmezi, ham ve bitsel dizgi değişmezi kombinasyonu</td></tr>
<tr><td><code>'...'</code></td><td>Karakter değişmezi</td></tr>
<tr><td><code>b'...'</code></td><td>ASCII bit değişmezi</td></tr>
<tr><td><code>|...| expr</code></td><td>Kapanış ifadeleri</td></tr>
<tr><td><code>!</code></td><td>Farklı fonksiyonlar için her zaman boş alt tür</td></tr>
<tr><td><code>_</code></td><td>“Ignored” model atama, ayrıca tam sayı değişmezlerini okunuşlu kılmak için de kullanılır</td></tr>
</tbody></table>
<p>Tablo B-3 modül hiyerarşisinden bir öğeye giden yol bağlamında görünen tüm sembolleri gösterir.</p>
<p><span class="caption">Tablo B-3: Yol Bağlamlı Söz Dizimi</span></p>
<table><thead><tr><th>Sembol</th><th>Açıklama</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>Ad alanı yolu</td></tr>
<tr><td><code>::path</code></td><td>Sandığın köküne giden yol</td></tr>
<tr><td><code>self::path</code></td><td>Halihazırdaki modüle giden yol</td></tr>
<tr><td><code>super::path</code></td><td>Ana modüle giden yol</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>İlişkili sabitler, fonksiyonlar ve türler</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>Doğrudan adlandırılamayan bir tür için ilişkili bir öğe (örneğin, <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code> vs.)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>Bir metod çağrısını tanımlayan özelliği adlandırarak belirsizliği giderme</td></tr>
<tr><td><code>type::method(...)</code></td><td>Tanımlandığı türü adlandırarak bir metod çağrısının belirsizliğini giderme</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>Tanımını ve türünü adlandırarak bir metod çağrısının belirsizliğini giderme</td></tr>
</tbody></table>
<p>Tablo B-4 yaygın türü kullanma bağlamında görünen sembolleri gösterir</p>
<p><span class="caption">Tablo B-4: Yaygınlar</span></p>
<table><thead><tr><th>Sembol</th><th>Açıklama</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>Bir türdeki yaygın tür için parametreleri belirtir (örneğin, <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>Bir ifadede yaygın türe, fonksiyona veya metoda ilişkin parametreleri belirtir; genellikle turbofish olarak anılır (örneğin, <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>Yaygın fonksiyon tanımlar</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>Yaygın yapı tanımlar</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>Yaygın numaralandırılmış yapı tanımlar</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>Yaygın süreklemesini tanımlar</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>Daha yüksek dereceli şekilde ömürlük sınırlar</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>Bir veya daha fazla ilişkili türün belirli atamalara sahip olduğu yaygın bir tür (örneğin, <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
<p>Tablo B-5 tanım sınırlamalarıyla yaygın tür parametrelerinin kısıtlanması bağlamında görünen sembolleri gösterir.</p>
<p><span class="caption">Tablo B-5: Tanıma Bağlı Kısıtlamalar</span></p>
<table><thead><tr><th>Sembol</th><th>Açıklama</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td><code>T</code> yaygın parametresini <code>U</code>'yu uygulayan türlerle sınırlar</td></tr>
<tr><td><code>T: 'a</code></td><td><code>T</code> yaygın parametresi, <code>a</code>'nın ömründen daha uzun ömürlü olmalıdır</td></tr>
<tr><td><code>T: 'static</code></td><td><code>T</code> yaygın parametresi, <code>static</code> olanlar dışında referansı alınmış başka bir referansı içeremez</td></tr>
<tr><td><code>'b: 'a</code></td><td><code>'b</code> yaygın parametresi, <code>'a</code>'nın ömründen daha uzun ömürlü olmalıdır</td></tr>
<tr><td><code>T: ?Sized</code></td><td>Yaygın tür parametresinin dinamik olarak boyutlandırılmış bir tür olmasına izin ver</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>Bileşik tür kısıtlaması</td></tr>
</tbody></table>
<p>Tablo B-6 makroları çağırma veya tanımlama ve bir öğedeki nitelikleri belirleme 
bağlamında görünen sembolleri gösterir.</p>
<p><span class="caption">Tablo B-6: Makrolar ve Özellikler</span></p>
<table><thead><tr><th>Sembol</th><th>Açıklama</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>Dış özellik</td></tr>
<tr><td><code>#![meta]</code></td><td>İç özellik</td></tr>
<tr><td><code>$ident</code></td><td>Makro belirteci</td></tr>
<tr><td><code>$ident:kind</code></td><td>Makro yakalama</td></tr>
<tr><td><code>$(…)…</code></td><td>Makro yineleme</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Makro çağırma</td></tr>
</tbody></table>
<p>Tablo B-7 yorum satırı olarak yorumlanan sembolleri gösterir.</p>
<p><span class="caption">Tablo B-7: Yorum Satırları</span></p>
<table><thead><tr><th>Sembol</th><th>Açıklama</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>Yorum satırı</td></tr>
<tr><td><code>//!</code></td><td>İç doküman yorum satırı</td></tr>
<tr><td><code>///</code></td><td>Dış doküman yorum satırı</td></tr>
<tr><td><code>/*...*/</code></td><td>Yorum bloğu</td></tr>
<tr><td><code>/*!...*/</code></td><td>İç doküman yorum bloğu</td></tr>
<tr><td><code>/**...*/</code></td><td>Dış doküman yorum bloğu</td></tr>
</tbody></table>
<p>Tablo B-8 demet yapısı kullanımı bağlamında görünen sembolleri gösterir.</p>
<p><span class="caption">Tablo B-8: Demet Yapısı</span></p>
<table><thead><tr><th>Bağlam</th><th>Açıklama</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>Boş demet, hem değişmez hem tür</td></tr>
<tr><td><code>(expr)</code></td><td>Parantezli ifade</td></tr>
<tr><td><code>(expr,)</code></td><td>Tek elemanlı demet ifadesi</td></tr>
<tr><td><code>(type,)</code></td><td>Tek elemanlı demet türü</td></tr>
<tr><td><code>(expr, ...)</code></td><td>Demet ifadesi</td></tr>
<tr><td><code>(type, ...)</code></td><td>Demet türü</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>Fonksiyon çağrı ifadesi; ayrıca <code>struct</code> ve <code>enum</code> varyantlarını çağırmak için kullanılır</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, etc.</td><td>Demet elemanı göstergeci</td></tr>
</tbody></table>
<p>Tablo B-9 süslü parantezlerin kullanıldığı bağlamları gösterir.</p>
<p><span class="caption">Tablo B-9: Süslü Parantezler</span></p>
<table><thead><tr><th>Bağlam</th><th>Açıklama</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>Blok ifade</td></tr>
<tr><td><code>Type {...}</code></td><td><code>struct</code> değişmezi</td></tr>
</tbody></table>
<p>Tablo B-10 köşeli parantezlerin kullanıldığı bağlamları gösterir.</p>
<p><span class="caption">Tablo B-10: Köşeli Parantezler</span></p>
<table><thead><tr><th>Bağlam</th><th>Açıklama</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>Dize değişmezi</td></tr>
<tr><td><code>[expr; len]</code></td><td><code>expr</code>'i <code>len</code> kadar kopyalayan dize değişmezi</td></tr>
<tr><td><code>[type; len]</code></td><td><code>type</code>'ı <code>len</code> kadar tutan dize türü ifadesi</td></tr>
<tr><td><code>expr[expr]</code></td><td>Koleksiyon elemanı göstergeci. (<code>Index</code>, <code>IndexMut</code>) aşırı yüklenebilir</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td><code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code> ya da <code>RangeFull</code> kullanarak koleksiyon dilimleyici gibi davranan koleksiyon elemanı göstergeci</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ekleme-c-türetilebilir-tanımlar"><a class="header" href="#ekleme-c-türetilebilir-tanımlar">Ekleme C: Türetilebilir Tanımlar</a></h2>
<p>Kıtabın farklı bölümlerinde yapıya ya da numaralandırılmış yapıya dahil edebileceğiniz <code>derive</code> tanımını anlatmıştık.
<code>derive</code> tanımı, yazdığınız <code>derive</code> süreklemesini sürekleyerek kod üretir.</p>
<p>Bu ekte, <code>derive</code> ile kullanabileceğiniz standart kütüphanedeki tüm 
tanımların bir referansını sunuyoruz. Her bölüm şunları kapsar:</p>
<ul>
<li>Bu tanımı türeten hangi operatörler ve yöntemler etkinleştirilecek</li>
<li><code>derive</code> tarafından sağlanan tanımın süreklenmesi ne iş yapar</li>
<li>Tanımın süreklenmesi, tür için ne anlama gelir</li>
<li>Tanımı süreklemenize izin verilen ve verilmeyen koşullar</li>
<li>Tanımı gerektirecek operasyonların örnekleri</li>
</ul>
<p><code>derive</code> tarafından sağlanandan farklı bir davranış istiyorsanız, 
bunların manuel olarak nasıl sürekleneceğine ilişkin ayrıntılar için <a href="../std/index.html">standart kütüphanenin dokümantasyonuna</a><!-- ignore --> bakın. 
Standart kütüphanede tanımlanan özelliklerin geri kalanı <code>derive</code> kullanılarak türlerinize uygulanamaz. 
Bu özelliklerin mantıklı varsayılan davranışları yoktur, bu nedenle bunları başarmaya çalıştığınız şey için anlamlı olacak şekilde süreklemek size kalmıştır. Son kullanıcılar için biçimlendirmeyi yöneten <code>Display</code>, türetilemeyen bir tanıma örnektir. Her zaman bir türü son kullanıcıya göstermenin uygun yolunu düşünmelisiniz. Bir son kullanıcının türün hangi kısımlarını görmesine izin verilmelidir? Hangi kısımları alakalı bulacaklar? Hangi veri formatı onlar için en uygun olur? Rust derleyicisi bu içgörüye sahip değildir, bu nedenle sizin için uygun varsayılan davranışı sağlayamaz. Bu ekte sağlanan türetilebilir tanımların listesi kapsamlı değildir: kütüphaneler, türetmeyi kendi tanımları için sürekleyebilir ve kullanabileceğiniz özelliklerin listesini gerçekten açık uçlu olarak türetebilir. <code>derive</code>'ın süreklemesi, Bölüm 19'un <a href="ch19-06-macros.html#macros">“Makrolar”</a><!-- ignore --> bölümünde ele alınan prosedürel bir makro kullanmayı içerir.</p>
<h3 id="programcı-Çıktısı-için-debug-tanımı"><a class="header" href="#programcı-Çıktısı-için-debug-tanımı">Programcı Çıktısı için <code>Debug</code> Tanımı</a></h3>
<p><code>Debug</code> tanımı <code>{}</code>'ın içine <code>:?</code> koyarak kullanabileceğiniz hata ayıklama formatlaması için dizgi düzenlemesini aktifleştirir. </p>
<p><code>Debug</code> tanımı nesnelerin türlerini hata ayıklamanız için yazdırmaya izin verir.</p>
<p><code>assert_eq!</code> makrosunun kullanımında <code>Debug</code> tanımını kullanmak gereklidir. Bu makro eğer her iki nesne de birbirine
eşit değilse bir hata göndererek yazılımcıların nerede hata olduğunu görmelerine yardımcı olur.</p>
<h3 id="eşitlik-kıyaslamaları-için-partialeq-ve-eq-tanımları"><a class="header" href="#eşitlik-kıyaslamaları-için-partialeq-ve-eq-tanımları">Eşitlik Kıyaslamaları için <code>PartialEq</code> ve <code>Eq</code> Tanımları</a></h3>
<p><code>PartialEq</code> tanımı <code>==</code> ve <code>!=</code> operatörlerini herhangi bir nesne türünde kullanmanız için gerekli olan tanımdır.</p>
<p><code>PartialEq</code>'ı tanımlamak <code>eq</code> metodunu otomatik olarak sürekler. Her ne zaman <code>PartialEq</code> yapılarda
tanımlanırsa, her iki nesnenin her alt üyesi eşitse nesnelerin eşitliğine karar verir. Numaralandırılmış
yapılar için her varyant kendi içinde eşittir ve diğer varyantlarla eşitlik söz konusu değildir.</p>
<p>Her iki nesnenin eşitliğinin kontrolü için <code>assert_eq!</code> makrosunda <code>PartialEq</code>'i tanımlamak gereklidir.</p>
<p><code>Eq</code> tanımı herhangi bir metoda sahip değildir. Asıl amacı verilen türün her değeri için eşitliğinin kontrolüdür.
<code>Eq</code> tanımı sadece <code>PartialEq</code>'i de tanımlayan tanımlar için geçerlidir. Ayrıca <code>PartialEq</code>'i sürekleyebilen her tür
<code>Eq</code>'i de sürekleyebileceği anlamına gelmez. Bir örnek olarak, kayan nokta sayı türleri örnek verilebilir. Bu türün süreklemesi
her iki nesnenin de birbirine eşit olmadığı durumlarda sayı-değili (<code>NaN</code>) döndürür.</p>
<p>Örneğin her ne zaman <code>Eq</code>, <code>HashMap&lt;K, V&gt;</code> için gerekirse bize her iki nesnenin de eşit olup olmadığını söyleyebilecek bir 
tanımı belirtmiş olur.</p>
<h3 id="sıralama-kıyaslamaları-için-partialord-ve-ord-tanımları"><a class="header" href="#sıralama-kıyaslamaları-için-partialord-ve-ord-tanımları">Sıralama Kıyaslamaları için <code>PartialOrd</code> ve <code>Ord</code> Tanımları</a></h3>
<p><code>PartialOrd</code> tanımı, sıralama amaçları için türleri kıyaslamaya izin verir. <code>PartialOrd</code>'ı sürekleyen bir tür,
<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, ve <code>&gt;=</code> operatörlerini de aynı tür için kullanabilir hale gelir. <code>PartialOrd</code> tanımını ancak <code>PartialEq</code>'i de
tanımlayan tanımlar için kullanabilirsiniz.</p>
<p><code>PartialOrd</code>'ı tanımlamak ayrıca eğer verilen değerler herhangi bir sıralamaya tabii tutulamadığı durumlarda
<code>None</code>, diğer durumlarda <code>Option&lt;Ordering&gt;</code> döndüren <code>partial_cmp</code> metodunu da sürekler.
Bir örnek olaraktan, <code>partial_cmp</code>'ı herhangi bir kayan noktasal sayı ile kullanmak <code>None</code> döndürecektir.</p>
<p>Her ne zaman yapılar için tanımlanmışsa, <code>PartialOrd</code> her iki nesnenin her üye içindeki her değerini kıyaslar.
Numaralandırılmış yapılar için tanımlandığında, tüm varyantları önceden tanımlanandan sonradan tanımlanana şeklinde sıralar.</p>
<p><code>PartialOrd</code> tanımı bu durumlar için gereklidir; örneğin <code>rand</code> kasasındaki <code>gen_range</code> metodu, verilen aralıkta
ve ifadede sözde rastgele bir değer üretir.</p>
<p><code>Ord</code> tanımı ayrıca verilen iki değer arasında doğru bir sıralamanın olup olmadığını da 
size belirtir. <code>Ord</code> tanımı, <code>Option&lt;Ordering&gt;</code> yerine <code>Ordering</code> tanımını döndüren <code>cmp</code> metodunu sürekler. <code>Ordering</code>
tanımını döndürmesinin asıl sebebi, doğru bir sıralamanın her zaman olabileceği ihtimalindendir.</p>
<p><code>Ord</code> tanımını türlere ancak <code>PartialOrd</code> ve <code>Eq</code>'i (ayrıca <code>Eq</code> de <code>PartialEq</code>'i tanımlamayı zorunlu kılar) de sürekleyen tanımlar için uygulayabilirsiniz. Yapılar ve numaralandırılmış yapılar üzerinde uygulandığında <code>cmp</code> <code>partial_cmp</code>'in <code>PartialOrd</code>'u süreklerken
yaptığı gibi aynı yolu uygular.</p>
<p><code>BTreeSet&lt;T&gt;</code>'de veriler tutmanız gerektiğinde <code>Ord</code> tanımını kullanmanız gerekir çünkü bu veri yapısı
verileri sıralanmış olarak tutar.</p>
<h3 id="değerleri-Çoğaltmak-için-clone-ve-copy-tanımları"><a class="header" href="#değerleri-Çoğaltmak-için-clone-ve-copy-tanımları">Değerleri Çoğaltmak için <code>Clone</code> ve <code>Copy</code> Tanımları</a></h3>
<p><code>Clone</code> tanımı değerin derin bir kopyasını oluşturmanıza izin verir ve bu çoğaltma işlemi <em>rastgele</em> kod
çalıştırmayı ve yığın verisi kopyalamasına sebep olabilir.
<code>Clone</code> hakkında daha fazla bilgi için <a href="ch04-01-what-is-ownership.html#ways-variables-and-data-interact-clone">“Değişkenler ve Veri Etkileşiminin Yolları: Clone”</a><!-- ignore --> 
bölümüne göz atabilirsiniz.</p>
<p><code>Clone</code>'i tanımlamak ayrıca tüm türler için kullanılabilecek <code>clone</code> metodunu da sürekler.</p>
<p>Örneğin bir dilim üzerinde <code>to_vec</code> metodunu çalıştırmak için <code>Clone</code>'un tanımlanması gerekir.</p>
<p><code>Copy</code> tanımı yığında tutulan bitleri çoğaltmanıza izin verir. 
<code>Copy</code> hakkında daha fazla bilgi için <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">“Yığın Öncelikli Veri Tanımı: Copy”</a><!-- ignore --> 
bölümüne göz atabilirsiniz.</p>
<p><code>Copy</code> tanımı herhangi bir rastgele kod çağırma konusunda yapıyı istismar etmeyi önlemek için herhangi bir metod tanımlamaz.
Bu yönüyle yazılımcılar bu şekilde veriyi kopyalamanın aşırı hızlı olduğunu düşüneceklerdir.</p>
<p><code>Copy</code>'i tüm yapı üyeleri <code>Copy</code>'i tanımlayan yapılar için de kullanabilirsiniz. 
<code>Copy</code>'i tanımlayan bir nesne ayrıca <code>Clone</code>'u da tanımlamak zorundadır çünkü,
<code>Copy</code>'i tanımlayan bir tür önemsiz bir <code>Clone</code> tanımlamasına da sahiptir, yani <code>Copy</code> ile benzer görevi yapar.</p>
<p><code>Copy</code> tanımı çoğu zaman gerekmez; <code>Copy</code>'i tanımlayan türler ayrıca optimizasyonlara da sahiptir yani 
<code>clone</code> kullanmamanız kodunuzu daha yalın ve öz yapacaktır.</p>
<p><code>Copy</code> ile mümkün olan her şey <code>Clone</code> ile de mümkündür fakat <code>clone</code> metodunun kullanılması bazı yerlerde
kodunuzu yavaşlatabilmektedir.</p>
<h3 id="değerleri-birleştirmek-için-hash-tanımı"><a class="header" href="#değerleri-birleştirmek-için-hash-tanımı">Değerleri Birleştirmek için <code>Hash</code> Tanımı</a></h3>
<p><code>Hash</code> tanımı sabit değerli bir türün örneğini almanıza izin verir.
<code>Hash</code>'i tanımlamak ayrıca <code>hash</code> metodunu da sürekler.</p>
<h3 id="varsayılan-değerler-için-default-tanımı"><a class="header" href="#varsayılan-değerler-için-default-tanımı">Varsayılan Değerler için <code>Default</code> Tanımı</a></h3>
<p><code>Default</code> tanımı bir türe varsayılan bir değer atamanıza izin verir. <code>Default</code>'u tanımlamak
<code>default</code> fonksiyonunu da sürekler.</p>
<p><code>Default::default</code> fonksiyonu çoğunlukla <a href="ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">“Yapı Güncelleme Söz Dizimi ile Diğer Örneklerden Örnekler Oluşturma”</a><!-- ignore -->
bölümünde de belirtildiği şekliyle yapı güncelleme söz dizimiyle birlikte kullanılır. Yapının üyelerini
düzenleyebilir ve daha sonra geri kalan üyeler için varsayılan tür değerlerini <code>..Default::default()</code> ile atayabilirsiniz.</p>
<p><code>Option&lt;T&gt;</code> örnekleri üzerinde  <code>unwrap_or_default</code> metodunu kullanabilmeniz için <code>Default</code> tanımınının da tanımlanmış olması
gerekir. Örneğin, <code>Option&lt;T&gt;</code> <code>None</code> ise , <code>unwrap_or_default</code> metodu <code>Option&lt;T&gt;</code>'de depolanan <code>T</code> türü için <code>Default::default</code>'un
sonucunu döndürecektir.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ekleme-d---kullanışlı-geliştirme-araçları"><a class="header" href="#ekleme-d---kullanışlı-geliştirme-araçları">Ekleme D - Kullanışlı Geliştirme Araçları</a></h2>
<p>Bu eklemede, Rust projesinin bize sağladığı bazı kullanışlı geliştirme araçlarından
bahsedeceğiz. Otomatik düzenleyici, hata ve uyarı çözücü, kod düzenleyici ve nasıl 
TGO'lar (IDE) ile kullanabileceğinizi göstereceğiz.</p>
<h3 id="rustfmt-ile-otomatik-düzenleme"><a class="header" href="#rustfmt-ile-otomatik-düzenleme"><code>rustfmt</code> ile Otomatik Düzenleme</a></h3>
<p><code>rustfmt</code> aracı kodunuzu topluluk kodu stili şeklinde düzenler. Çoğu proje <code>rustfmt</code>'yi hangi Rust stilini 
kullanmakta kararsız kalındığı vakit kullanır: herkes bu aracı kullanarak kodunu düzenler.</p>
<p><code>rustfmt</code>'i yüklemek için şu komutu girin:</p>
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<p>Bu komut size <code>rustfmt</code> ve <code>cargo-fmt</code> araçlarını verir, nasıl Rust'ın <code>rustc</code> ve <code>cargo</code>'yu birlikte
dağıttığı gibi. Herhangi bir Cargo projesini düzenlemek için, şunu girin:</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>Bu komudu çalıştırmak halihazırdaki kasada bulunan tüm Rust kodlarınızı düzenler. 
Kodunuzun çalışma şeklini ve mantığını değiştirmez sadece kod stilini değiştirir. 
<code>rustfmt</code> hakkında daha fazla bilgi almak için <a href="https://github.com/rust-lang/rustfmt">dokümantasyonunu</a> kullanabilirsiniz.</p>
<h3 id="rustfix-ile-kodunuzu-Çözümleme"><a class="header" href="#rustfix-ile-kodunuzu-Çözümleme"><code>rustfix</code> ile Kodunuzu Çözümleme</a></h3>
<p>rustfix aracı Rust'ın yüklemelerine dahil edilmiş, bazı derleyici hatalarını otomatik olarak
çözümleyen bir araçtır. Eğer Rust'ta kod yazmışsanız, büyük ihtimalle derleyici hatalarını ve 
uyarılarını da görmüşsünüzdür. Örnek olaraktan, şu koda odaklanın:</p>
<p><span class="filename">Dosya: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p>Burada, <code>do_something</code> adlı fonksiyonu 100 kez çağırıyoruz ama hiçbir zaman <code>i</code> değerini döngü içinde kullanmıyoruz.
İşte bu yüzden Rust bizi bunun hakkında uyaracaktır:</p>
<pre><code class="language-console">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 --&gt; src/main.rs:4:9
  |
4 |     for i in 0..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<p>Bu uyarı bize <code>i</code> yerine <code>_i</code> kullanmamız gerektiğini sunar: bu alt çizgi ile
bu değerin kullanılmayacağını söylemiş oluyoruz. Bu öneriyi otomatik olarak eklemek istiyorsanız
<code>cargo fix</code> komutu vasıtasıyla <code>rustfix</code> aracını kullanın:</p>
<pre><code class="language-console">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p><em>src/main.rs</em> koduna tekrar baktığımızda, <code>cargo fix</code>'in bazı yerleri değiştirdiğini görüyoruz:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p><code>for</code> döngüsü değeri artık <code>_i</code> şekliyle adlandırıldı, artık uyarı çıkmayacak.</p>
<p><code>cargo fix</code> komutunu ayrıca farklı Rust sürümleri arasında kodunuzu güncelleştirmek
için kullanabilirsiniz. Sürümler Ekleme E'de açıklanacak.</p>
<h3 id="clippy-ile-daha-fazla-düzenleme"><a class="header" href="#clippy-ile-daha-fazla-düzenleme">Clippy ile Daha Fazla Düzenleme</a></h3>
<p>Clippy aracı düzenleme tavsiyelerinin bir koleksiyonunu tutan ve bunlar vasıtasıyla
kodunuzu analiz eden ve size kodunuz hakkında bilgiler ve öneriler veren bir araçtır.</p>
<p>Clippy'i indirmek için, şu komutu girin:</p>
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<p>Herhangi bir Cargo projesinde Clippy’nin düzenlemelerini kullanmak için, şunu girin:</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>Örnek olaraktan, diyelim ki bir matematik sabitini yakınsayarak hesaplamak istiyorsunuz,
mesela pi olsun, bu program onu yapar:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}
</code></pre></pre>
<p><code>cargo clippy</code>'i bu projede çalıştırmak bize şu hatayı verir:</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found. Consider using it directly
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: #[deny(clippy::approx_constant)] on by default
  = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>Bu hata, Rust'ın bu sabiti daha kesin olarak tanımladığını 
ve bunun yerine sabiti kullanırsanız programınızın daha doğru olacağını belirtir. 
Rust'ın sunduğu PI sabitini kullandığınızda, aşağıdaki kod herhangi bir hata ya da uyarı
vermeden düzenlenir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}
</code></pre></pre>
<p>Clippy hakkında daha fazla bilgi almak için <a href="https://github.com/rust-lang/rust-clippy">dokümantasyonunu</a> kullanabilirsiniz.</p>
<h3 id="rust-analyzer-kullanarak-tgo-ide-entegrasyonu"><a class="header" href="#rust-analyzer-kullanarak-tgo-ide-entegrasyonu"><code>rust-analyzer</code> Kullanarak TGO (IDE) Entegrasyonu</a></h3>
<p>TGO entegrasyonu için Rust topluluğu
<a href="https://rust-analyzer.github.io"><code>rust-analyzer</code></a><!-- ignore --> kullanmanızı öneriyor.
Bu araç bazı TGO'lar ve dillerin birbirleri arasındaki iletişimi sağlayan <a href="http://langserver.org/">Dil Sunucu Protokolü</a><!-- ignore -->, 
vasıtasıyla derleyici tabanlı bir iletişim ağı oluşturur. Farklı editörler <code>rust-analyzer</code>'i kullanabilir, mesela
<a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">Visual Studio Code için Rust analyzer eklentisi</a> kullanılabilir.</p>
<p>Kurulum yönergeleri için <code>rust-analyzer</code> projesinin <a href="https://rust-analyzer.github.io">ana sayfasına</a> gidebilir, daha sonra
TGO'nuz için desteklenen dil sunucusunu kurabilirsiniz. TGO'nuz bazı yenilikler edinecektir, mesela
otomatik tamamlama, tanıma yönlendirme, satır içi hata ve uyarılar vs.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ekleme-e---sürümler"><a class="header" href="#ekleme-e---sürümler">Ekleme E - Sürümler</a></h2>
<p>Bölüm 1'de <code>cargo new</code> komutunun <em>Cargo.toml</em> dosyasına sürümle alakalı bilgiler
eklediğini gördünüz. Bu eklemede bunun ne anlama geldiğini konuşacağız!</p>
<p>Rust dili ve derleyicisi altı-haftalık yeni özellikler içeren değişmez bir sürüm döngüsüne sahiptir.
Diğer programlama dilleri yeni sürümleri fazla değişikliklerle seyrek sıklıklarla yayınlarlar,
Rust ise küçük değişikliklerle sıklıkla yayınlar. Daha sonra, tüm küçük değişiklikler toplanır ve yayınlandıktan sonra
geriye bakıp şunu demek zor olabilir: “Vay be, Rust 1.10 ve Rust 1.31'ındaki farka bak, Rust ne kadar da değişmiş!”</p>
<p>Her iki ya da üç yılda bir Rust takımı yeni Rust <em>sürümü</em> yayınlar. Her sürüm yeni özellikleri tamamıyla 
dokümantasyonlaşmış ve araç gereçleri tam halde getirir. Yeni özellikler her altı-haftalık yayınlama işleminin
bir parçasıdır.</p>
<p>Yeni sürümler farkli kişiler için farklı işlemlere hizmet eder:</p>
<ul>
<li>Aktif Rust kullanıcıları için yeni sürüm kolayca anlaşılabilir paketlere büyük değişiklikler getirir.</li>
<li>Kullanıcı olmayanlar için yeni sürüm Rust'ı farklı bir bakışta baktıracak önemli yenilikler getirdiğinin sinyalidir.</li>
<li>Rust'ı geliştirenler için yeni sürüm projenin bütünü için bir dönüm noktasıdır.</li>
</ul>
<p>Bu yazının zamanında, üç Rust sürümü ulaşılabilirdir: Rust 2015, Rust 2018, Rust 2021. 
Bu kitap Rust 2021 sürümünün kuralları ve deyimleri kullanılarak yazılmıştır.</p>
<p><em>Cargo.toml</em>'daki <code>edition</code> anahtarı, kodunuzun hangi derleyici sürümüyle derleneceğini belirtir.
Eğer anahtar bulunmuyorsa, Rust geriye dönük uyumluluktan dolayı <code>2015</code> sürümünü kullanır.</p>
<p>Her proje varsayılan olan 2015 sürümünden başka sürümü kullanabilir. Sürümler uyumsuz değişiklikler
barındırabilir, örneğin yeni bir anahtar sözcük kodunuzun derlenememesine yol açabilir. Ancak, bu
değişiklikleri seçmediğiniz sürece, kodunuz yeni Rust derleyici sürümlerini kullansanız bile 
derlenmeye devam edecektir.</p>
<p>Tüm Rust derleyici sürümleri var olan önceki sürümleri destekleyecek şekildedir. Ve farklı
sürümdeki kasaları desteklenen herhangi sürümlerle bağlayabilirsiniz. Sürüm değişiklikleri
sadece derleyicinin ayrıştırdığı kodu etkiler. Öyleyse, eğer Rust 2015 kullanıyorsanız ve kullandığınız
bağımlılık Rust 2018 sürümünü kullanıyorsa, kodunuz bu bağımlılığı kullanarak derlenecektir. Aynı şekilde
tam tersi durumda da derlenecektir.</p>
<p>Açık olmak gerekirse: çoğu özellik tüm sürümlerde ulaşılabilecek Geliştiriciler herhangi bir Rust
sürümünü kullandıklarında dahi, yeni stabil sürümlerin gelişimlerini göreceklerdir. ANcak, bazı
durumlarda, özellikle yeni anahtar sözcükler eklendiğinde bazı yeni özellikler sadece sonraki sürümlerde
ulaşılabilir olmaktadır. Eğer özelliklerin avantajlarını edinmek istiyorsanız, yeni sürümlere geçmeniz gerekmektedir.</p>
<p>Daha fazla detay için, <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Sürüm Kılavuzu</em></a> kitabını inceleyerek sürümler arasındaki
farkı görebilir ve yeni sürümlere kodunuzu nasıl is <code>cargo fix</code> komutuyla güncelleyebileceğinizi öğrenebilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ekleme-f-kitabın-Çevirileri"><a class="header" href="#ekleme-f-kitabın-Çevirileri">Ekleme F: Kitabın Çevirileri</a></h2>
<p>Şu anda da bulunduğunuz bu çeviri gibi, İngilizceden farklı diller için çevrilmiş halleri de bulunmaktadır.
Bunların çoğu halen çevrilme aşamasındadır; <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">Çeviri kısmına</a> giderek bizi
yeni bir çeviri hakkında bilgilendirebilirsiniz!</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português</a> (PT)</li>
<li><a href="https://github.com/KaiserY/trpl-zh-cn">简体中文</a></li>
<li><a href="https://github.com/rust-tw/book-tw">正體中文</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a>, <a href="https://github.com/ManRR/rust-book-es">alternatif</a></li>
<li><a href="https://github.com/Ciro-Fusco/book_it">Italiano</a></li>
<li><a href="https://github.com/rust-lang-ru/book">Русский</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">한국어</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">日本語</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">Français</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ελληνική</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/pomokhtari/rust-book-fa">Farsi</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a></li>
<li><a href="https://github.com/RustDili/dokuman/tree/master/ceviriler">Türkçe</a>, <a href="https://rustdili.github.io/">sitesi</a></li>
<li><a href="https://github.com/venkatarun95/rust-book-hindi">हिंदी</a></li>
<li><a href="https://github.com/rust-lang-th/book-th">ไทย</a></li>
<li><a href="https://github.com/DanKHansen/book-dk">Danske</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ekleme-g---gecelik-rust-ve-rust-nasıl-yapıldı"><a class="header" href="#ekleme-g---gecelik-rust-ve-rust-nasıl-yapıldı">Ekleme G - “Gecelik Rust” ve Rust Nasıl Yapıldı</a></h2>
<p>Bu ek, Rust'ın nasıl yapıldığı ve bunun bir Rust geliştiricisi olarak sizi nasıl etkilediği hakkındadır.</p>
<h3 id="durgunluk-olmadan-stabilite"><a class="header" href="#durgunluk-olmadan-stabilite">Durgunluk Olmadan Stabilite</a></h3>
<p>Rust, kodunuzun kararlılığına <em>çok</em> önem verir. Rust'ı üzerine inşa edebileceğiniz kaya gibi sağlam bir temel olmasını istiyoruz ve işler sürekli değişiyor olsaydı bu imkansız olurdu. Aynı zamanda, yeni özellikleri deneyemezsek kusurları çözemeyiz. Bu soruna bizim çözümümüz “durgunluk olmadan istikrar” dediğimiz şeydir ve yol gösterici ilkemiz şudur: Asla yeni bir kararlı Rust sürümüne geçmekten korkmamalısınız. Her yükseltme sorunsuz olmalı, ancak size yeni özellikler, daha az hata ve daha hızlı derleme süreleri de getirmelidir.</p>
<h3 id="Çuf-çuf-kanalları-bırakın-ve-yeni-trenlere-binin"><a class="header" href="#Çuf-çuf-kanalları-bırakın-ve-yeni-trenlere-binin">Çuf çuf! Kanalları Bırakın ve Yeni Trenlere Binin</a></h3>
<p>Rust'ın gelişimi, bir <em>tren tarifesine</em> göre çalışır. Yani, tüm geliştirmeler Rust deposunun ana dalında yapılır. Sürümler, Cisco IOS ve diğer yazılım projeleri tarafından kullanılan bir yazılım sürüm dizisi modelini takip eder. </p>
<p>Rust için üç yayın kanalı vardır:</p>
<ul>
<li>Gecelik</li>
<li>Beta</li>
<li>Stabil</li>
</ul>
<p>Çoğu Rust geliştiricisi ana olarak stabil kanalını kullanır fakat deneysel yeni özellikleri denemek isteyen
Rustseverler isterlerse gecelik ya da beta kanallarını da kullanabilirler.</p>
<p>Geliştirme ve sürüm sürecinin nasıl çalıştığına dair bir örnek: 
Rust ekibinin Rust 1.5'in sürümü üzerinde çalıştığını varsayalım. Bu sürüm Aralık 2015'te yayınlandı 
ve Rust'a yeni bir çok özellik eklendi: bunlar eklenirken ana dalda birçok yeni bir taahhüt (commit) gönderilmiş oluyor. 
Her gece, Rust'ın yeni bir gecelik versiyonu üretilir. Her gün bir yayın günüdür ve bu yayınlar yayın altyapımız tarafından otomatik olarak oluşturulur. Zaman geçtikçe, yayınlarımız gecede bir kez şöyle görünür:</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>Her altı haftada bir, bizim için yayın zamanıdır! <code>beta</code> dalı Rust deposundan geceliğin kullandığı <code>master</code> dalını çıkarır. 
Burada artık iki yayın var olmuş olur:</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>Çoğu Rust kullanıcısı beta yayınlarını aktif olarak kullanmaz, ancak Rust'ın olası sorunları keşfetmesine yardımcı olmak için CI sistemlerinde betaya karşı test yapar. Bu arada, her gece gecelik sürümünün yayınlandığını hatırlatmış olalım:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>Diyelim ki bir sorun bulundu. İyi bir şey olacak ki, sorun kararlı bir sürüme girmeden önce <code>beta</code> sürümünü test edebilecek vaktimiz kalıyor.
Düzeltme <code>master</code>'a uygulanır, böylece oluşan sorunlar gece düzeltilir ve ardından düzeltme <code>beta</code> dalına geri aktarılır ve yeni bir <code>beta</code> sürümü üretilir:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>İlk <code>beta</code> oluşturulduktan altı hafta sonra, <code>stable</code> sürümünün zamanı geldi!
<code>stable</code> dalı <code>beta</code> dalından türetilir:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>Yaşasın! Rust 1.5 tamam! Ancak bir şeyi unuttuk: 
altı hafta geçtiği için, Rust'ın bir sonraki sürümü olan 1.6'nın yeni bir <code>beta</code> sürümünün de yayınlanması gerekiyor. Bu nedenle, <code>beta</code>'nın <code>stable</code>'dan dallanmasından sonra, <code>beta</code>'nın bir sonraki sürümü her gece tekrar dallanır ve güncellenir:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>Buna “tren modeli” denir, çünkü her altı haftada bir, bir sürüm ”istasyonu terk eder”, ancak kararlı bir sürüm olarak gelmeden önce yine de beta kanalında bir yolculuğa daha çıkması gerekir. Rust, saat altı gibi haftada bir çıkıyor. Bir Rust sürümünün tarihini biliyorsanız, bir sonrakinin tarihini de bilirsiniz: altı hafta sonra. Her altı haftada bir planlanan yayınlara sahip olmanın güzel bir yönü, bir sonraki trenin yakında gelmesidir. Bir özellik belirli bir sürümü kaçırırsa, endişelenmenize gerek yok: kısa süre içinde bir yenisi daha geliyor! Bu, son teslim tarihine yakın olası cilasız özellikleri gizlice sokma baskısını azaltmaya yardımcı olur. Bu süreç sayesinde, her zaman Rust'ın bir sonraki sürümünü kontrol edebilir ve yükseltmenin kolay olduğunu kendiniz doğrulayabilirsiniz: bir beta sürümü beklendiği gibi çalışmazsa, bunu ekibe bildirebilir ve güncellemeden önce düzeltmesini sağlayabilirsiniz ve sonraki kararlı sürümde çıkabilecek bir sorun çözülmüş olur! Beta sürümünde çökmeler nispeten nadirdir, ancak <code>rustc</code> hala bir yazılım parçasıdır ve sorunlar mevcuttur.</p>
<h3 id="kararsız-Özellikler"><a class="header" href="#kararsız-Özellikler">Kararsız Özellikler</a></h3>
<p>Bu sürüm modeliyle ilgili bir sorun daha var: 
kararsız özellikler. </p>
<p>Rust, belirli bir sürümde hangi özelliklerin etkinleştirildiğini belirlemek için “özellik bayrakları“ adı verilen bir teknik kullanır. </p>
<p>Yeni bir özellik aktif olarak geliştiriliyorsa, o özelliği gerekli özellik bayraklarını kullanarak çağırabilirsiniz. En son değişiklikleri
kullanabilmeniz için <code>nightly</code> de olmanız gerekebilir. Bir kullanıcı olarak, devam eden çalışmaları denemek istiyorsanız, deneyebilirsiniz, ancak Rust'ın her gece yayınlanan sürümünü kullanıyor olmanız ve istenilen özelliği kullanabilmek için kaynak kodunuza uygun bayrakla açıklama eklemeniz gerekir. Son teknolojiyi kullanmak isteyenler bunu yapabilir ve kaya gibi sağlam bir deneyim isteyenler kararlı bir şekilde kalabilir ve kodlarının kırılmayacağını bilir. Durgunluk olmadan istikrar. Bu kitap yalnızca kararlı özellikler hakkında bilgi içerir, çünkü devam eden özellikler hala değişmektedir ve kesinlikle bu kitabın yazıldığı zaman ile kararlı yapılarda etkinleştirildikleri zaman arasında farklı olacaktır. Yalnızca gecelik özelliklerle ilgili belgeleri çevrimiçi olarak bulabilirsiniz.</p>
<h3 id="rustup-ve-rust-nightlynin-rolü"><a class="header" href="#rustup-ve-rust-nightlynin-rolü">Rustup ve Rust Nightly'nin Rolü</a></h3>
<p>Rustup, farklı yayın kanalları arasındaki dönüşümleri sizin için kolaylaştırır.
Varsayılan olarak, stabil Rust sürümünün yüklü olması gerekir. Gecelik sürümünü yükleyebilimeniz için şu
komutu girebilirsiniz:</p>
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<p>Göründüğü gibi tüm araç takımlarını (Rust'ın sürüm yayınlarını ve bileşenlerini)
<code>rustup</code>'la da pekala yükleyebilirsiniz. İşte Windows bilgisayarından bir örnek:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>Gördüğünüz gibi, kararlı araç zinciri varsayılandır. 
Çoğu Rust kullanıcısı çoğu zaman kararlı sürümü kullanır. Kök dizindeyken <code>rustup</code>'un kullanması gereken tek gecelik araç zincirini ayarlamak için o projenin dizininde <code>rustup override</code> komutunu kullanabilirsiniz:</p>
<pre><code class="language-console">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<h3 id="rfc-süreci-ve-ekipler"><a class="header" href="#rfc-süreci-ve-ekipler">RFC Süreci ve Ekipler</a></h3>
<p>Peki bu yeni özellikler hakkında nasıl bilgi edineceksiniz? Rust'ın geliştirme modeli, bir <em>Yorum İsteği</em> (RFC) sürecini takip eder. 
Rust'ta bir iyileştirme istiyorsanız, RFC adlı bir teklif yazabilirsiniz. 
Rust'ı geliştirmek için herkes RFC'ler yazabilir ve öneriler, birçok konu alt ekibinden oluşan Rust ekibi tarafından incelenir ve tartışılır. 
<a href="https://www.rust-lang.org/governance">Rust'ın web sitesinde</a>, dil tasarımı, derleyici uygulaması, altyapı, dokümantasyon ve daha fazlası gibi projenin her alanı için ekipleri içeren tam bir ekip listesi bulunmaktadır. Uygun ekip teklifi ve yorumları okur, kendi yorumlarını yazar ve sonunda özelliği kabul veya reddetme konusunda fikir birliği sağlanır. Özellik kabul edilirse Rust deposunda bir sorun açılır ve birisi bunu . Bunu çok iyi uygulayan kişi, özelliği ilk etapta öneren kişi olmayabilir! Uygulama hazır olduğunda, <a href="appendix-07-nightly-rust.html#unstable-features">“Kararsız Özellikler”</a><!-- ignore --> bölümünde tartıştığımız gibi, bir özellik kapısının arkasındaki ana dal üzerine iner. Bir süre sonra, her gece yayınlananları kullanan Rust geliştiricileri yeni özelliği deneyebildiklerinde, ekip üyeleri bu özelliği, her gece nasıl çalıştığını tartışacak ve kararlı Rust'a dönüştürüp dönüştürmeyeceğine karar verecek. Bu da gelecek trenin içinde olabileceği anlamına gelebilir!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
