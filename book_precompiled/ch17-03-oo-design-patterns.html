<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Nesneye Yönelik Tasarım Modelini Süreklemek - Rust Programlama Dili</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Rust Programlama Dili</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Ön söz</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Başlangıç</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Başlarken</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Yükleme</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Merhaba, Dünya!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Merhaba, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Tahmin Oyunu Programlamak</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Yaygın Programlama Kavramları</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Değişkenler ve Değişebilirlik</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Fonksiyonlar</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Yorum Satırları</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrol Akışı</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Sahipliği Anlamak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Sahiplik Nedir?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referanslar ve Ödünç Alma Mekanizması</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Dilim Türü</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> İlintili Verileri Yapılandırmak için Yapıları Kullanmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Yapıları Tanımlamak ve Örneklendirmek</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Yapıları Kullanan Örnek Bir Program</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Metod Söz dizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Numaralandırılmış Yapılar ve Model Eşleme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Numaralandırılmış Yapı Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match Kontrol Akış Yapısı</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let ile Kısa Kontrol Akış Yapısı</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Büyüyen Projeleri Paketler, Kasalar ve Modüllerle Yönetme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paketler ve Kasalar</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Gizlilik ve Kontrol Kapsamı için Modüller Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Modül Ağacındaki bir Öğeyi Referanslama Yolları</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use Kullanarak Yolları Kapsama Getirmek</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Modülleri Farklı Dosyalara Ayırmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Yaygın Koleksiyon Türleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Veri Listelerini Vektörlerle Tutmak</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8 ile Kodlanmış Dizgiyi Tutmak</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> İlişkili Değerlerle Anahtarları Saklamak</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Hata Yönetimi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! ile Kurtarılamayan Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result ile Kurtarılabilir Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!lemek ya da panic!lememek</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Yaygın Türler, Tanımlar ve Ömürlükler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Yaygın Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Tanımlar: Yaygın Davranış Tanımlama</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Ömürlük Yapısıyla Referans Doğrulama</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Otomatikleşmiş Testler Yazma</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Testler Nasıl Yazılır</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Testlerin Nasıl Çalıştığını Kontrol Etmek</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organizasyonu</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Bir G/Ç Projesi: Komut Satırı Programı Yazmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Komut Satırı Argümanlarını Ayrıştırmak</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Dosya Okumak</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Modülerliği ve Hata Yönetimini Geliştirmek için Yeniden Düzenlemek</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Test Odaklı Geliştirme ile Kütüphanenin İşlevliğini Artırmak</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Ortam Değişkenlerini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Hata Mesajlarını Standart Çıktı yerine Standart Hata Akışına Yazdırmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Fonksiyonel Dil Özellikleri: Yineleyiciler ve Kapanış İfadeleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Kapanış İfadeleri: Ortamda Tutulabilen Anonim Fonksiyonlar</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Yineleyicilerle Bir Dizi Öğeyi İşlemek</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> G/Ç Projemizi Geliştirmek</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performans Kıyaslaması: Döngüler vs. Yineleyiciler</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo ve Crates.io Hakkında Daha Fazla Bilgi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Dağıtım Profilleriyle İnşaları Özelleştirmek</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io'da Bir Kasa Paylaşmak</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Çalışma Alanları</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install ile Crates.io'dan Derlenmişleri Yüklemek</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Özel Komutlarla Cargo'yu Genişletmek</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Akıllı İşaretçiler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Yığındaki Verileri İşaretlemek için Box&lt;T&gt; Kullanmak</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Akıllı İşaretçilere Deref ile Normal Referanslar Gibi Tanım Yapmak</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop Tanımlamasıyla Temizlik Aşamasında Kod Çalıştırmak</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Referans Sayaçlı Akıllı İşaretçi</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; ve İç Değişebilirlik Modeli</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referans Döngüleri Bellek Sızdırabilir</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Korkusuz Eşzamanlılık</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Kodu Eşzamanlı Çalıştırmak için İş Parçacıklarını Kullanmak</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Konular Arasında Veri Aktarmak için İleti Geçişini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Paylaşımlı Eşzamanlık</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync ve Send Tanımlarıyla Genişletilebilir Eşzamanlılık</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust'taki Nesne Yönemimli Programlama Özellikleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Nesne Yönelimli Dillerin Karakteristik Özellikleri</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Farklı Türlerdeki Değerlere İzin Veren Özellik Tanımlarını Kullanma</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html" class="active"><strong aria-hidden="true">17.3.</strong> Nesneye Yönelik Tasarım Modelini Süreklemek</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Modeller ve Eşleştirme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Modeller Her Yerde Kullanılabilir</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Reddedilebilirlik: Modelin Eşleştirmede Başarısız Olup Olmayacağı</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Model Söz Dizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Gelişmiş Özellikler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Güvensiz Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Gelişmiş Tanımlar</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Gelişmiş Türler</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Gelimiş Fonksiyonlar ve Kapanış İfadeleri</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makrolar</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Projesi: Çoklu İş Parçacıklı Web Sunucusu İnşa Etmek</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Tek İş Parçacıklı Web Sunucusu İnşa Etmek</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Tek İş Parçacıklı Sunucumuzu Çok Parçacıklı Sunucuya Çevirmek</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Zarifçe Kapatmak ve Temizlemek</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Eklemeler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Anahtar Sözcükler</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatörler ve Semboller</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Türetilebilir Tanımlar</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Kullanışlı Geliştirme Araçları</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Sürümler</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Kitap'ın Çevirileri</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust ve “Gecelik Rust” Nasıl Yapıldı</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Programlama Dili</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ferhatgec/kitap" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="nesneye-yönelik-tasarım-modeli-uygulamak"><a class="header" href="#nesneye-yönelik-tasarım-modeli-uygulamak">Nesneye Yönelik Tasarım Modeli Uygulamak</a></h2>
<p><em>Durum kalıbı</em>, nesne yönelimli bir tasarım kalıbıdır. Desenin özü, bir değerin dahili olarak sahip olabileceği bir dizi durum tanımlamamızdır. 
Durumlar bir dizi durum nesnesi ile temsil edilir ve değerin davranışı durumuna bağlı olarak değişir. &quot;draft&quot;, &quot;review&quot; veya &quot;published&quot; 
kümesinden bir durum nesnesi olacak şekilde durumunu tutmak için bir alana sahip olan bir blog yazısı yapısı örneği üzerinde çalışacağız.</p>
<p>Durum nesneleri işlevselliği paylaşır: Rust'ta elbette nesneler ve kalıtım yerine yapıları ve özellikleri kullanırız. 
Her durum nesnesi kendi davranışından ve ne zaman başka bir duruma geçmesi gerektiğini yönetmekten sorumludur. 
Bir durum nesnesini tutan değer, durumların farklı davranışları veya durumlar arasında ne zaman geçiş yapılacağı hakkında hiçbir şey bilmez.</p>
<p>Durum kalıbını kullanmanın avantajı, programın iş gereksinimleri değiştiğinde, durumu tutan değerin kodunu veya değeri kullanan kodu 
değiştirmemize gerek kalmamasıdır. Kurallarını değiştirmek ya da belki daha fazla durum nesnesi eklemek için yalnızca 
durum nesnelerinden birinin içindeki kodu güncellememiz gerekecektir. Durum modelini kullanarak bir blog yazısı iş akışını aşamalı 
olarak uygulamaya başlayalım.</p>
<p>Nihai işlevsellik şu şekilde görünecektir:</p>
<p>The final functionality will look like this:</p>
<ol>
<li>Bir blog gönderisi boş bir taslak olarak başlar.</li>
<li>Taslak yapıldığında, gönderinin gözden geçirilmesi istenir.</li>
<li>Gönderi onaylandığında yayınlanır.</li>
<li>Yalnızca yayınlanan blog gönderileri, içeriği yazdırılacak şekilde döndürür, bu nedenle 
onaylanmamış gönderiler yanlışlıkla yayınlanamaz.</li>
</ol>
<p>Bir gönderide yapılmaya çalışılan diğer değişikliklerin hiçbir etkisi olmamalıdır. 
Örneğin, inceleme talep etmeden önce taslak bir blog gönderisini onaylamaya çalışırsak, 
gönderi yayınlanmamış bir taslak olarak kalmalıdır.</p>
<p>Liste 17-11 bu iş akışını kod biçiminde göstermektedir: bu, <code>blog</code> adlı bir kütüphane kasasına uygulayacağımız API'nin örnek bir kullanımıdır. 
Bu henüz derlenmeyecektir çünkü <code>blog</code> crate'ini henüz yazmadık.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">Liste 17-11: <code>blog</code> kasamızda olmasını istediğimiz davranışı gösteren kod</span></p>
<p>Kullanıcının <code>Post::new</code> ile yeni bir taslak blog yazısı oluşturmasına izin vermek istiyoruz. Blog yazısına metin eklenmesine izin vermek 
istiyoruz. Onaydan önce yazının içeriğini hemen almaya çalışırsak, yazı hala taslak olduğu için herhangi bir metin almamalıyız. 
Gösterim amacıyla koda <code>assert_eq!</code> ekledik. Bunun için mükemmel bir birim testi, taslak bir blog gönderisinin içerik yönteminden 
boş bir dize döndürdüğünü iddia etmek olurdu, ancak bu örnek için test yazmayacağız.</p>
<p>Daha sonra, yazının incelenmesi için bir isteği etkinleştirmek istiyoruz ve inceleme beklenirken içeriğin boş bir dize döndürmesini 
istiyoruz. Gönderi onay aldığında yayınlanmalıdır, yani content çağrıldığında gönderi metni döndürülecektir.</p>
<p>Kasadan etkileşimde bulunduğumuz tek türün <code>Post</code> türü olduğuna dikkat edin. Bu tür durum kalıbını kullanacak ve bir gönderinin 
taslak halinde, inceleme için bekliyor veya yayınlanmış olabileceği çeşitli durumları temsil eden üç durum nesnesinden biri olacak bir 
değer tutacaktır. Bir durumdan diğerine geçiş <code>Post</code> türü içinde dahili olarak yönetilecektir. Durumlar, kütüphanemizin kullanıcıları 
tarafından <code>Post</code> tanımı üzerinde çağrılan metodlara yanıt olarak değişir, ancak durum değişikliklerini doğrudan yönetmeleri gerekmez. 
Ayrıca kullanıcılar, bir gönderiyi incelenmeden önce yayınlamak gibi durumlarla ilgili bir hata yapamazlar.</p>
<h3 id="postu-tanımlama-ve-taslak-durumunda-yeni-bir-Örnek-oluşturma"><a class="header" href="#postu-tanımlama-ve-taslak-durumunda-yeni-bir-Örnek-oluşturma">Post'u Tanımlama ve Taslak Durumunda Yeni Bir Örnek Oluşturma</a></h3>
<p>Kütüphanenin yazılmasına başlayalım! Bazı içerikleri tutan genel bir <code>Post</code> yapısına ihtiyacımız olduğunu biliyoruz, 
bu nedenle yapının tanımı ve bir <code>Post</code> tanımı oluşturmak için ilişkili bir genel <code>new</code> fonksiyonu ile başlayacağız, 
Liste 17-12'de gösterildiği gibi. Ayrıca bir <code>Post için</code> tüm durum nesnelerinin sahip olması gereken davranışı tanımlayacak özel bir 
<code>State</code> tanımı oluşturacağız.</p>
<p>Ardından <code>Post</code>, durum nesnesini tutmak için <code>state</code> adlı özel bir alanda bir <code>Option&lt;T&gt;</code> içinde <code>Box&lt;dyn State&gt;</code>'in <code>trait</code> nesnesini 
tutacaktır. <code>Option&lt;T&gt;</code>'nin neden gerekli olduğunu birazdan göreceksiniz.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
</code></pre>
<p><span class="caption">Liste 17-12: Yeni bir <code>Post</code> örneği, bir <code>State</code> tanımı ve bir <code>Draft</code> yapısı oluşturan <code>Post</code> yapısının ve 
<code>new</code> fonksiyonunun tanımı</span></p>
<p><code>State</code> özelliği, farklı posta durumları tarafından paylaşılan davranışı tanımlar. <code>State</code> nesneleri <code>Draft</code>, <code>PendingReview</code> ve <code>Published</code>'dir 
ve hepsi <code>State</code> tanımını uygular. Şimdilik, tanımın herhangi bir metodu yoktur ve sadece <code>Draft</code> durumunu tanımlayarak başlayacağız 
çünkü bir gönderinin başlamasını istediğimiz durum budur.</p>
<p>Yeni bir <code>Post</code> oluşturduğumuzda, <code>state</code> alanını bir <code>Box</code> tutan <code>Some</code> değerine ayarlarız. Bu <code>Box</code>, <code>Draft</code> yapısının yeni bir 
örneğine işaret eder. Bu, yeni bir <code>Post</code> örneği oluşturduğumuzda, taslak olarak başlamasını sağlar. <code>Post</code>'un durum alanı özel olduğu için, 
başka bir durumda bir <code>Post</code> oluşturmanın hiçbir yolu yoktur! <code>Post::new</code> fonksiyonunda, <code>content</code> alanını yeni, boş bir <code>String</code> olarak ayarlarız.</p>
<h3 id="gönderi-İçeriği-metnini-saklama"><a class="header" href="#gönderi-İçeriği-metnini-saklama">Gönderi İçeriği Metnini Saklama</a></h3>
<p>Liste 17-11'de <code>add_text</code> adlı bir metodu çağırabilmek ve ona blog yazısının metin içeriği olarak eklenecek bir <code>&amp;str</code> iletebilmek istediğimizi 
gördük. Bunu, içerik alanını <code>pub</code> olarak göstermek yerine bir metod olarak uyguluyoruz, böylece daha sonra içerik alanının 
verilerinin nasıl okunacağını kontrol edecek bir metod uygulayabiliriz. <code>add_text</code> metodu oldukça basittir, bu nedenle Liste 17-13'teki 
uygulamayı <code>impl Post</code> bloğuna ekleyelim:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}
</span></code></pre>
<p><span class="caption">Liste 17-13: Bir gönderinin <code>content</code>'ine metin eklemek için <code>add_text</code> metodunu
süreklemek</span></p>
<p><code>add_text</code> metodu <code>self</code> öğesine değişebilir bir referans alır, çünkü <code>add_text</code> öğesini çağırdığımız <code>Post</code> tanımını değiştiriyoruz. 
Daha sonra <code>content</code>'teki <code>String</code> üzerinde <code>push_str</code>'yi çağırıyoruz ve kaydedilen içeriğe eklemek için metin argümanını iletiyoruz. 
Bu davranış, gönderinin içinde bulunduğu duruma bağlı değildir, bu nedenle durum modelinin bir parçası değildir. 
<code>add_text</code> yöntemi <code>state</code> alanıyla hiç etkileşime girmez, ancak desteklemek istediğimiz davranışın bir parçasıdır.</p>
<h3 id="taslak-gönderinin-İçeriğinin-boş-olmasını-sağlama"><a class="header" href="#taslak-gönderinin-İçeriğinin-boş-olmasını-sağlama">Taslak Gönderinin İçeriğinin Boş Olmasını Sağlama</a></h3>
<p><code>add_text</code> öğesini çağırdıktan ve gönderimize bir miktar içerik ekledikten sonra bile, Liste 17-11'in 7. satırında gösterildiği gibi, 
gönderi hala taslak durumunda olduğu için <code>content</code> metodunun boş bir dizgi dilimi döndürmesini istiyoruz. Şimdilik, <code>content</code> 
metodunu bu gereksinimi karşılayacak en basit şeyle uygulayalım: her zaman boş bir dizgi dilimi döndürmek. Bunu daha sonra bir gönderinin 
durumunu değiştirip yayınlanabilmesini sağladığımızda değiştireceğiz. Şimdiye kadar, yazılar yalnızca taslak durumunda olabilir, 
bu nedenle yazı içeriği her zaman boş olmalıdır. Liste 17-14 bu yer tutucu uygulamasını göstermektedir:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}
</span></code></pre>
<p><span class="caption">Liste 17-14: <code>Post</code>'a <code>content</code> metodu için her zaman boş bir dizgi dilimi 
döndüren bir yer tutucu süreklemesi ekleme</span></p>
<p>Bu eklenen <code>content</code> metoduyla, Liste 17-11'den 7. satıra kadar her şey amaçlandığı gibi çalışır.</p>
<h3 id="gönderinin-durumu-değişikliklerinin-gözden-geçirilmesini-talep-etme"><a class="header" href="#gönderinin-durumu-değişikliklerinin-gözden-geçirilmesini-talep-etme">Gönderinin Durumu Değişikliklerinin Gözden Geçirilmesini Talep Etme</a></h3>
<p>Ardından, durumunu <code>Draft</code>'tan <code>PendingReview</code> olarak değiştirmesi gereken bir gönderinin gözden geçirilmesini istemek 
için işlevsellik eklememiz gerekiyor. Liste 17-15 bu kodu gösterir:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
</code></pre>
<p><span class="caption">Liste 17-15: <code>Post</code> ve <code>State</code> tanımı üzerinde <code>request_review</code> metodlarının 
yazılması</span></p>
<p><code>Post</code>'a, <code>self</code> öğesine değişken bir referans alacak <code>request_review</code> adında bir genel metod veriyoruz. 
Ardından <code>Post</code>'un mevcut durumu üzerinde dahili bir <code>request_review</code> metodunu çağırıyoruz ve bu ikinci <code>request_review</code> metodu 
mevcut durumu tüketip yeni bir durum döndürüyor.</p>
<p><code>request_review</code> metodunu <code>State</code> tanımını ekliyoruz; tanımı uygulayan tüm türlerin artık <code>request_review</code> metodunu uygulaması gerekecektir. 
Metodun ilk parametresinin <code>self</code>, <code>&amp;self</code> veya <code>&amp;mut self</code> yerine <code>self</code> olduğuna dikkat edin: <code>Box&lt;Self&gt;</code>. Bu söz dizimi, 
yöntemin yalnızca türü taşıyan bir <code>Box</code> üzerinde çağrıldığında geçerli olduğu anlamına gelir. Bu söz dizimi <code>Box&lt;Self&gt;</code>'in sahipliğini 
alarak eski durumu geçersiz kılar, böylece <code>Post</code>'un durum değeri yeni bir duruma dönüşebilir.</p>
<p>Eski durumu kullanmak için <code>request_review</code> yönteminin durum değerinin sahipliğini alması gerekir. <code>Post</code>'un <code>state</code> alanındaki 
<code>Option</code> burada devreye girer: <code>take</code> metodunu çağırarak <code>Some</code> değerini <code>state</code> alanından çıkarırız ve yerine <code>None</code> değerini bırakırız, 
çünkü Rust yapılarda doldurulmamış alanlar olmasına izin vermez. Bu, <code>state</code> değerini ödünç almak yerine <code>Post</code>'un dışına taşımamızı sağlar. 
Daha sonra <code>post</code>'un <code>state</code> değerini bu işlemin sonucuna ayarlayacağız.</p>
<p><code>State</code> değerinin sahipliğini almak için <code>self.state = self.state.request_review();</code> gibi bir kodla doğrudan ayarlamak yerine 
<code>state</code> değerini geçici olarak <code>None</code> olarak ayarlamamız gerekir. Bu, <code>Post</code>'un biz onu yeni bir duruma dönüştürdükten sonra 
eski durum değerini kullanamamasını sağlar.</p>
<p><code>Draft</code> üzerindeki <code>request_review</code> yöntemi, bir gönderinin inceleme için beklediği durumu temsil eden yeni bir <code>PendingReview</code> yapısının yeni, 
<code>Box</code>'un bir örneğini döndürür. <code>PendingReview</code> <code>struct</code>'ı da <code>request_review</code> yöntemini uygular ancak herhangi bir dönüştürme yapmaz. 
Bunun yerine, kendisini döndürür, çünkü zaten <code>PendingReview</code> durumunda olan bir gönderi için inceleme istediğimizde, gönderi <code>PendingReview</code> 
durumunda kalmalıdır.</p>
<p>Şimdi <code>state</code> modelinin avantajlarını görmeye başlayabiliriz: <code>Post</code> üzerindeki <code>request_review</code> yöntemi, <code>state</code> değeri ne olursa olsun aynıdır. 
Her <code>state</code> kendi kurallarından sorumludur.</p>
<p><code>Post</code> üzerindeki <code>content</code> metodunu olduğu gibi bırakacağız ve boş bir dizgi dilimi döndüreceğiz. Artık hem <code>PendingReview</code> durumunda hem de 
<code>Draft</code> durumunda bir <code>Post</code>'a sahip olabiliriz, ancak <code>PendingReview</code> durumunda aynı davranışı istiyoruz. 
Liste 17-11 artık 10. satıra kadar çalışıyor!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a></p>
<h3 id="contentin-davranışını-değiştirmek-için-approve-ekleme"><a class="header" href="#contentin-davranışını-değiştirmek-için-approve-ekleme"><code>content</code>'in Davranışını Değiştirmek için <code>approve</code> Ekleme</a></h3>
<p><code>approve</code> metodu <code>request_review</code> metoduna benzer olacaktır: <code>state</code>'i, mevcut <code>state</code>'in onaylandığında sahip olması 
gerektiğini söylediği değere ayarlayacaktır, Liste 17-16'da gösterildiği gibi:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
</code></pre>
<p><span class="caption">Liste 17-16: <code>Post</code> ve <code>State</code> tanımı üzerinde <code>approve</code> metodunu uygulama</span></p>
<p><code>State</code> tanımına <code>approve</code> metodunu ekliyoruz ve <code>Published</code> durum olan <code>State</code>'i uygulayan yeni bir <code>struct</code> ekliyoruz.</p>
<p><code>PendingReview</code> üzerinde <code>request_review</code> metodunun çalışmasına benzer şekilde, bir <code>Draft</code> üzerinde <code>approve</code> yöntemini çağırırsak, 
<code>approve</code> <code>self</code> değerini döndüreceği için hiçbir etkisi olmayacaktır. <code>PendingReview</code> üzerinde <code>approve</code> yöntemini çağırdığımızda, 
<code>Published</code> yapısının yeni, <code>Box</code>'un bir tanımını döndürür. <code>Published</code> <code>struct</code>'ı, <code>State</code> tanımını uygular ve 
hem <code>request_review</code> yöntemi hem de <code>approve</code> yöntemi için kendini döndürür, çünkü bu durumlarda gönderi <code>Published</code> durumunda kalmalıdır.</p>
<p>Şimdi <code>Post</code> üzerindeki <code>content</code> metodunu güncellememiz gerekiyor. <code>Content</code>'ten döndürülen değerin <code>Post</code>'un mevcut durumuna 
bağlı olmasını istiyoruz, bu nedenle <code>Post</code>'un Liste 17-17'de gösterildiği gibi durumuna göre tanımlanmış bir <code>content</code> metoduna 
temsilci göndermesini sağlayacağız:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 17-17: <code>State</code>'de bir <code>content</code> metoduna yetki vermek için 
<code>Post</code> üzerindeki <code>content</code> metodunu güncelleme</span></p>
<p>Amaç tüm bu kuralları <code>State</code>'i uygulayan yapıların içinde tutmak olduğundan, <code>state</code>'teki değer üzerinde bir <code>content</code> yöntemi 
çağırıyoruz ve <code>post</code> örneğini (yani <code>self</code>'i) bir argüman olarak geçiriyoruz. Daha sonra <code>state</code> değeri üzerinde <code>content</code> metodunu 
kullanarak döndürülen değeri döndürüyoruz.</p>
<p><code>Option</code> üzerinde <code>as_ref</code> yöntemini çağırıyoruz çünkü değerin sahibi olmak yerine <code>Option</code> içindeki değere bir referans istiyoruz. 
<code>state</code> bir <code>Option&lt;Box&lt;dyn State&gt;&gt;</code> olduğu için, <code>as_ref</code> yöntemini çağırdığımızda bir <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code> döndürülür. 
Eğer <code>as_ref</code>'i çağırmasaydık, <code>state</code>'i fonksiyon parametresinin ödünç alınan <code>&amp;self</code>'inin dışına taşıyamayacağımız için bir hata alırdık.</p>
<p>Daha sonra <code>unwrap</code> metodunu çağırıyoruz, ki bu metodun asla panik yaratmayacağını biliyoruz, çünkü <code>Post</code> üzerindeki metodların, 
bu metodlar tamamlandığında <code>state</code>'in her zaman <code>Some</code> değeri içereceğini garanti ettiğini biliyoruz. 
Bu, Bölüm 9'un <a href="ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler">“Derleyiciden Daha Fazla Bilgiye Sahip Olduğunuz Durumlar”</a><!-- ignore --> kısmında bahsettiğimiz, 
derleyici bunu anlayamasa da None değerinin asla mümkün olmadığını bildiğimiz durumlardan biridir.</p>
<p>Bu noktada, <code>&amp;Box&lt;dyn State&gt;</code> üzerinde <code>content</code>'i çağırdığımızda, <em>deref zorlaması</em> <code>&amp;</code> ve <code>Box</code> üzerinde etkili olacak, 
böylece <code>content</code> yöntemi sonuçta <code>State</code> tanımını uygulayan tür üzerinde çağrılacaktır. 
Bu, <code>State</code> özellik tanımına içerik eklememiz gerektiği anlamına gelir ve Liste 17-18'de gösterildiği gibi, hangi duruma sahip 
olduğumuza bağlı olarak hangi içeriğin döndürüleceğine ilişkin mantığı buraya koyacağız:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
</code></pre>
<p><span class="caption">Liste 17-18: <code>State</code> tanımına <code>content</code> yöntemini ekleme</span></p>
<p><code>content</code> yöntemi için boş bir dizgi dilimi döndüren varsayılan bir uygulama ekliyoruz. 
Bu, <code>Draft</code> ve <code>PendingReview</code> yapılarında içerik uygulamamıza gerek olmadığı anlamına gelir. <code>Published</code> <code>struct</code>'ı, 
<code>content</code> yöntemini geçersiz kılacak ve <code>post.content</code> içindeki değeri döndürecektir.</p>
<p>Bölüm 10'da tartıştığımız gibi, bu yöntem üzerinde yaşam süresi ek açıklamalarına ihtiyacımız olduğunu unutmayın. 
Argüman olarak bir gönderiye referans alıyoruz ve bu gönderinin bir kısmına referans döndürüyoruz, 
bu nedenle döndürülen referansın yaşam süresi post argümanının yaşam süresiyle ilişkilidir.</p>
<p>Ve işimiz bitti - Liste 17-11'in tamamı artık çalışıyor! <code>State</code> modelini blog yazısı iş akışı kurallarıyla uyguladık. 
Kurallarla ilgili mantık, <code>Post</code>'un içine dağılmak yerine <code>state</code> nesnelerinde yaşıyor.</p>
<h3 id="durum-kalıbının-Ödünleşimleri"><a class="header" href="#durum-kalıbının-Ödünleşimleri">Durum Kalıbının Ödünleşimleri</a></h3>
<p>Rust'ın, bir gönderinin her bir durumda sahip olması gereken farklı davranış türlerini kapsüllemek için nesne 
yönelimli durum modelini uygulayabildiğini gösterdik. Post üzerindeki yöntemler çeşitli davranışlar hakkında hiçbir şey bilmiyor. 
Kodu düzenlediğimiz şekilde, yayınlanan bir gönderinin farklı davranış biçimlerini öğrenmek için tek bir yere bakmamız gerekiyor: 
<code>Published</code> yapısındaki <code>State</code> özelliğinin uygulanması.</p>
<p><code>State</code> kalıbını kullanmayan alternatif bir uygulama oluşturacak olsaydık, bunun yerine <code>Post</code> üzerindeki yöntemlerde veya hatta 
gönderinin durumunu kontrol eden ve bu yerlerde davranışı değiştiren ana kodda eşleşme ifadeleri kullanabilirdik. 
Bu, bir gönderinin yayınlanmış durumda olmasının tüm sonuçlarını anlamak için birkaç yere bakmamız gerektiği anlamına gelirdi! 
Bu, ne kadar çok durum eklersek o kadar artacaktır: bu <code>match</code> ifadelerinin her biri başka bir kola ihtiyaç duyacaktır.</p>
<p><code>State</code> kalıbı ile <code>Post</code> metodları ve <code>Post</code>'u kullandığımız yerler eşleşme ifadelerine ihtiyaç duymaz ve yeni bir 
<code>state</code> eklemek için sadece yeni bir <code>struct</code> eklememiz ve <code>trait</code> metodlarını bu <code>struct</code> üzerinde uygulamamız gerekir.</p>
<p><code>State</code> kalıbını kullanan uygulamanın daha fazla işlevsellik eklemek için genişletilmesi kolaydır. 
<code>State</code> kalıbını kullanan kodu korumanın basitliğini görmek için bu önerilerden birkaçını deneyin:</p>
<ul>
<li>Gönderinin durumunu PendingReview'den Draft'a değiştiren bir reddetme yöntemi ekleyin.</li>
<li><code>State</code> <code>Published</code> olarak değiştirilmeden önce onaylamak için iki çağrı yapılmasını zorunlu kılın.</li>
<li>Kullanıcıların yalnızca bir gönderi <code>Draft</code> durumundayken metin içeriği eklemesine izin verin. 
İpucu: <code>state</code> nesnesinin içerikle ilgili değişebilecek şeylerden sorumlu olmasını ancak <code>Post</code>'u değiştirmekten sorumlu olmamasını sağlayın.</li>
<li><code>State</code> modelinin bir dezavantajı, durumlar arasındaki geçişleri durumlar gerçekleştirdiği için bazı durumların birbirine bağlı olmasıdır.
<code>PendingReview</code> ile <code>Published</code> arasına <code>Scheduled</code> gibi başka bir <code>state</code> eklersek, <code>PendingReview</code>'daki kodu <code>Scheduled</code>'a geçiş yapacak 
şekilde değiştirmemiz gerekir. <code>PendingReview</code>'in yeni bir durum eklendiğinde değişmesi gerekmeseydi daha az iş olurdu, 
ancak bu başka bir tasarım modeline geçmek anlamına gelir.</li>
</ul>
<p>Diğer bir dezavantajı ise bazı mantıkları tekrarlamış olmamızdır. Yinelemenin bir kısmını ortadan kaldırmak için, 
<code>State</code> özelliğindeki <code>request_review</code> ve <code>approve</code> yöntemleri için <code>self</code> döndüren varsayılan uygulamalar yapmayı deneyebiliriz; 
ancak bu, nesne güvenliğini ihlal eder, çünkü özellik somut <code>self</code>'in tam olarak ne olacağını bilmez. <code>State</code>'i bir özellik nesnesi olarak 
kullanabilmek istiyoruz, bu nedenle yöntemlerinin nesne güvenli olmasına ihtiyacımız var.</p>
<p>Diğer tekrarlar, <code>Post</code> üzerindeki <code>request_review</code> ve <code>approve</code> yöntemlerinin benzer uygulamalarını içerir. 
Her iki yöntem de <code>Option</code>'ın state alanındaki değer üzerinde aynı yöntemin uygulanmasına delege eder ve <code>state</code> alanının yeni 
değerini sonuca ayarlar. <code>Post</code> üzerinde bu kalıbı izleyen çok sayıda yöntemimiz olsaydı, tekrarı ortadan kaldırmak için bir makro 
tanımlamayı düşünebilirdik (Bölüm 19'daki &quot;Makrolar&quot; bölümüne bakın).</p>
<p><code>State</code> kalıbını tam olarak nesne yönelimli diller için tanımlandığı gibi uygulayarak, Rust'ın güçlü yanlarından olabildiğince 
yararlanamıyoruz. Geçersiz durumları ve geçişleri derleme zamanı hatalarına dönüştürebilecek <code>blog</code> kasasında yapabileceğimiz 
bazı değişikliklere bakalım.</p>
<h4 id="durumları-ve-davranışları-tür-olarak-kodlama"><a class="header" href="#durumları-ve-davranışları-tür-olarak-kodlama">Durumları ve Davranışları Tür Olarak Kodlama</a></h4>
<p>Farklı bir dizi ödünleşim elde etmek için durum modelini nasıl yeniden düşüneceğinizi göstereceğiz. 
Durumları ve geçişleri tamamen kapsüllemek yerine, dış kodun bunlar hakkında hiçbir bilgiye sahip olmaması için 
durumları farklı türlere kodlayacağız. Sonuç olarak, Rust'ın tür kontrol sistemi, yalnızca yayınlanmış gönderilere izin 
verilen taslak gönderileri kullanma girişimlerini bir derleyici hatası vererek önleyecektir.</p>
<p>Liste 17-11'deki <code>main</code>'in ilk bölümünü ele alalım:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!(&quot;&quot;, post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
</span>}
</code></pre>
<p><code>Post::new</code> kullanarak taslak durumunda yeni gönderilerin oluşturulmasını ve gönderinin içeriğine metin ekleme özelliğini hala etkinleştiriyoruz. 
Ancak taslak bir gönderide boş bir dize döndüren bir <code>content</code> yöntemine sahip olmak yerine, taslak gönderilerin içerik yöntemine 
hiç sahip olmamasını sağlayacağız. Bu şekilde, bir taslak gönderinin içeriğini almaya çalışırsak, bize yöntemin mevcut 
olmadığını söyleyen bir derleyici hatası alırız. Sonuç olarak, taslak gönderi içeriğini üretimde yanlışlıkla görüntülememiz imkansız olacaktır, 
çünkü bu kod derlenmeyecektir bile. Liste 17-19, bir <code>Post</code> yapısının ve bir <code>DraftPost</code> yapısının tanımının yanı sıra her birindeki 
yöntemleri gösterir:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
</code></pre>
<p><span class="caption">Liste 17-19: <code>content</code> yöntemine sahip bir <code>Post</code> ve <code>content</code> 
metodu olmayan bir <code>DraftPost</code></span></p>
<p>Hem <code>Post</code> hem de <code>DraftPost</code> yapıları, blog yazısı metnini saklayan özel bir içerik alanına sahiptir. 
Yapılar artık <code>state</code> alanına sahip değildir çünkü <code>state</code> kodlamasını yapıların türlerine taşıyoruz. 
<code>Post</code> yapısı yayınlanmış bir gönderiyi temsil edecektir ve içeriği döndüren bir içerik yöntemine sahiptir.</p>
<p>Hala bir <code>Post::new</code> fonksiyonumuz var, ancak <code>Post</code>'un bir örneğini döndürmek yerine <code>DraftPost</code>'un bir örneğini döndürüyor. <code>content</code>
gizli olduğundan ve <code>Post</code> döndüren herhangi bir fonksiyon bulunmadığından, şu anda bir <code>Post</code> tanımı oluşturmak mümkün değildir.</p>
<p><code>DraftPost</code> yapısının bir <code>add_text</code> yöntemi vardır, bu nedenle daha önce olduğu gibi içeriğe metin ekleyebiliriz, ancak 
<code>DraftPost</code>'un tanımlanmış bir <code>content</code> yöntemi olmadığını unutmayın! Böylece program tüm gönderilerin taslak gönderiler olarak 
başlamasını sağlar ve taslak gönderilerin içerikleri görüntülenemez. Bu kısıtlamaları aşmaya yönelik herhangi bir girişim derleyici hatasıyla sonuçlanacaktır.</p>
<h4 id="geçişleri-farklı-türlere-dönüşümler-olarak-uygulama"><a class="header" href="#geçişleri-farklı-türlere-dönüşümler-olarak-uygulama">Geçişleri Farklı Türlere Dönüşümler Olarak Uygulama</a></h4>
<p>Peki yayınlanmış bir gönderiyi nasıl alacağız? Bir taslak gönderinin yayınlanmadan önce gözden geçirilmesi ve 
onaylanması gerektiği kuralını uygulamak istiyoruz. Bekleyen inceleme durumundaki bir gönderi hala herhangi bir içerik 
göstermemelidir. Bu kısıtlamaları, <code>PendingReviewPost</code> adında başka bir yapı ekleyerek, bir <code>PendingReviewPost</code> döndürmek için 
<code>DraftPost</code> üzerinde <code>request_review</code> yöntemini tanımlayarak ve bir <code>Post</code> döndürmek için <code>PendingReviewPost</code> üzerinde bir <code>approve</code> yöntemi
tanımlayarak, Liste 17-20'de gösterildiği gibi yazalım:</p>
<h4 id="geçişleri-farklı-türlere-dönüştürme-olarak-uygulama"><a class="header" href="#geçişleri-farklı-türlere-dönüştürme-olarak-uygulama">Geçişleri Farklı Türlere Dönüştürme Olarak Uygulama</a></h4>
<p>Peki yayınlanmış bir gönderiyi nasıl alacağız? Bir taslak gönderinin yayınlanmadan önce gözden geçirilmesi ve 
onaylanması gerektiği kuralını uygulamak istiyoruz. Bekleyen inceleme durumundaki bir gönderi hala herhangi bir içerik göstermemelidir. 
Bu kısıtlamaları, <code>PendingReviewPost</code> adında başka bir yapı ekleyerek, bir <code>PendingReviewPost</code> döndürmek için <code>DraftPost</code> üzerinde 
<code>request_review</code> yöntemini tanımlayarak ve bir <code>Post</code> döndürmek için <code>PendingReviewPost</code> üzerinde bir <code>approve</code> yöntemi tanımlayarak, 
Liste 17-20'de gösterildiği gibi uygulayalım:</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --snip--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}
</code></pre>
<p><span class="caption">Liste 17-20: <code>DraftPost</code>'ta <code>request_review</code> çağrılarak oluşturulan bir 
<code>PendingReviewPost</code> ve <code>PendingReviewPost</code>'u yayınlanmış bir <code>Post</code>'a dönüştüren bir <code>approve</code> yöntemi</span></p>
<p><code>request_review</code> ve <code>approve</code> yöntemleri <code>self</code>'in sahipliğini alır, böylece <code>DraftPost</code> ve <code>PendingReviewPost</code> örneklerini 
tüketir ve bunları sırasıyla bir <code>PendingReviewPost</code>'a ve yayınlanmış bir <code>Post</code>'a dönüştürür. Bu şekilde, üzerlerinde <code>request_review</code> çağrısı
yaptıktan sonra kalan <code>DraftPost</code> örneklerimiz olmayacaktır. <code>PendingReviewPost</code> yapısının üzerinde tanımlanmış bir <code>content</code> yöntemi yoktur, 
bu nedenle içeriğini okumaya çalışmak <code>DraftPost</code>'ta olduğu gibi bir derleyici hatasıyla sonuçlanır. Tanımlanmış bir <code>content</code> yöntemi olan
yayınlanmış bir <code>Post</code> örneği almanın tek yolu bir <code>PendingReviewPost</code> üzerinde <code>approve</code> yöntemini çağırmak olduğundan ve bir 
<code>PendingReviewPost</code> almanın tek yolu bir <code>DraftPost</code> üzerinde <code>request_review</code> yöntemini çağırmak olduğundan, artık blog yazısı 
iş akışını tür sistemine kodladık.</p>
<p>Ancak <code>main</code>'de de bazı küçük değişiklikler yapmamız gerekiyor. <code>request_review</code> ve <code>approve</code> yöntemleri, çağrıldıkları yapıyı 
değiştirmek yerine yeni örnekler döndürür, bu nedenle döndürülen örnekleri kaydetmek için daha fazla <code>let post =</code> <em>gölgeleme</em> ataması eklememiz 
gerekir. Ayrıca, taslak ve bekleyen inceleme gönderilerinin içerikleriyle ilgili iddiaların boş dizgiler olmasını sağlayamayız ve 
bunlara ihtiyacımız da yok: artık bu durumlardaki gönderilerin içeriğini kullanmaya çalışan kodu derleyemeyiz. 
<code>main</code>'deki güncellenmiş kod Liste 17-21'de gösterilmektedir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">Liste 17-21: Blog gönderisi iş akışının yeni süreklemesinin kullanmak için 
<code>main</code>'deki değişiklikler</span></p>
<p><code>Post</code>'u yeniden atamak için <code>main</code>'de yapmamız gereken değişiklikler, bu uygulamanın artık nesne yönelimli durum modeline 
tam olarak uymadığı anlamına geliyor: durumlar arasındaki dönüşümler artık tamamen <code>Post</code> uygulaması içinde kapsüllenmiyor. 
Bununla birlikte, kazancımız, tür sistemi ve derleme zamanında gerçekleşen tür denetimi nedeniyle geçersiz durumların artık 
imkansız olmasıdır! Bu, yayınlanmamış bir gönderinin içeriğinin görüntülenmesi gibi belirli hataların üretime geçmeden önce 
keşfedilmesini sağlar.</p>
<p>Kodun bu versiyonunun tasarımı hakkında ne düşündüğünüzü görmek için bu bölümün başında önerilen görevleri 
Liste 17-21'den sonra olduğu gibi blog sandığı üzerinde deneyin. Bazı görevlerin bu tasarımda zaten tamamlanmış 
olabileceğini unutmayın.</p>
<p>Rust'ın nesne yönelimli tasarım kalıplarını uygulama yeteneğine sahip olmasına rağmen, durumu tür sistemine kodlamak gibi 
diğer kalıpların da Rust'ta mevcut olduğunu gördük. Bu kalıpların farklı ödünleşimleri vardır. Nesne yönelimli kalıplara 
çok aşina olsanız da, Rust'ın özelliklerinden yararlanmak için sorunu yeniden düşünmek, derleme zamanında bazı hataları önlemek 
gibi faydalar sağlayabilir. Nesne yönelimli kalıplar, nesne yönelimli dillerin sahip olmadığı sahiplik gibi bazı özellikler 
nedeniyle Rust'ta her zaman en iyi çözüm olmayacaktır.</p>
<h2 id="Özet"><a class="header" href="#Özet">Özet</a></h2>
<p>Bu bölümü okuduktan sonra Rust'ın nesne yönelimli bir dil olduğunu düşünseniz de düşünmeseniz de, artık Rust'ta bazı nesne 
yönelimli özellikler elde etmek için <code>trait</code> nesnelerini kullanabileceğinizi biliyorsunuz. Dinamik gönderim, kodunuza biraz çalışma 
zamanı performansı karşılığında biraz esneklik sağlayabilir. Bu esnekliği, kodunuzun sürdürülebilirliğine yardımcı olabilecek nesne yönelimli 
kalıpları uygulamak için kullanabilirsiniz. Rust ayrıca sahiplik gibi nesne yönelimli dillerin sahip olmadığı başka özelliklere de sahiptir. 
Nesne yönelimli bir kalıp, Rust'ın güçlü yönlerinden yararlanmanın her zaman en iyi yolu olmayacaktır, ancak kullanılabilir bir seçenektir.</p>
<p>Daha sonra, Rust'ın çok fazla esneklik sağlayan bir başka özelliği olan kalıplara bakacağız. 
Kitap boyunca bunlara kısaca baktık ancak henüz tam kapasitelerini görmedik. Hadi başlayalım!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-02-trait-objects.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch18-00-patterns.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-02-trait-objects.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch18-00-patterns.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>


    </body>
</html>
