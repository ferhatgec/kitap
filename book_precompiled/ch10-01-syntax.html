<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Yaygın Veri Türleri - Rust Programlama Dili</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Rust Programlama Dili</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Ön söz</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Başlangıç</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Başlarken</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Yükleme</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Merhaba, Dünya!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Merhaba, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Tahmin Oyunu Programlamak</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Yaygın Programlama Kavramları</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Değişkenler ve Değişebilirlik</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Fonksiyonlar</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Yorum Satırları</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrol Akışı</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Sahipliği Anlamak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Sahiplik Nedir?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referanslar ve Ödünç Alma Mekanizması</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Dilim Türü</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> İlintili Verileri Yapılandırmak için Yapıları Kullanmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Yapıları Tanımlamak ve Örneklendirmek</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Yapıları Kullanan Örnek Bir Program</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Metod Söz dizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Numaralandırılmış Yapılar ve Model Eşleme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Numaralandırılmış Yapı Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match Kontrol Akış Yapısı</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let ile Kısa Kontrol Akış Yapısı</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Büyüyen Projeleri Paketler, Kasalar ve Modüllerle Yönetme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paketler ve Kasalar</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Gizlilik ve Kontrol Kapsamı için Modüller Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Modül Ağacındaki bir Öğeyi Referanslama Yolları</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use Kullanarak Yolları Kapsama Getirmek</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Modülleri Farklı Dosyalara Ayırmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Yaygın Koleksiyon Türleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Veri Listelerini Vektörlerle Tutmak</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8 ile Kodlanmış Dizgiyi Tutmak</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> İlişkili Değerlerle Anahtarları Saklamak</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Hata Yönetimi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! ile Kurtarılamayan Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result ile Kurtarılabilir Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!lemek ya da panic!lememek</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Yaygın Türler, Tanımlar ve Ömürlükler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html" class="active"><strong aria-hidden="true">10.1.</strong> Yaygın Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Tanımlar: Yaygın Davranış Tanımlama</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Ömürlük Yapısıyla Referans Doğrulama</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Otomatikleşmiş Testler Yazma</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Testler Nasıl Yazılır</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Testlerin Nasıl Çalıştığını Kontrol Etmek</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organizasyonu</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Bir G/Ç Projesi: Komut Satırı Programı Yazmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Komut Satırı Argümanlarını Ayrıştırmak</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Dosya Okumak</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Modülerliği ve Hata Yönetimini Geliştirmek için Yeniden Düzenlemek</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Test Odaklı Geliştirme ile Kütüphanenin İşlevliğini Artırmak</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Ortam Değişkenlerini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Hata Mesajlarını Standart Çıktı yerine Standart Hata Akışına Yazdırmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Fonksiyonel Dil Özellikleri: Yineleyiciler ve Kapanış İfadeleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Kapanış İfadeleri: Ortamda Tutulabilen Anonim Fonksiyonlar</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Yineleyicilerle Bir Dizi Öğeyi İşlemek</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> G/Ç Projemizi Geliştirmek</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performans Kıyaslaması: Döngüler vs. Yineleyiciler</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo ve Crates.io Hakkında Daha Fazla Bilgi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Dağıtım Profilleriyle İnşaları Özelleştirmek</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io'da Bir Kasa Paylaşmak</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Çalışma Alanları</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install ile Crates.io'dan Derlenmişleri Yüklemek</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Özel Komutlarla Cargo'yu Genişletmek</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Akıllı İşaretçiler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Yığındaki Verileri İşaretlemek için Box&lt;T&gt; Kullanmak</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Akıllı İşaretçilere Deref ile Normal Referanslar Gibi Tanım Yapmak</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop Tanımlamasıyla Temizlik Aşamasında Kod Çalıştırmak</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Referans Sayaçlı Akıllı İşaretçi</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; ve İç Değişebilirlik Modeli</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referans Döngüleri Bellek Sızdırabilir</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Korkusuz Eşzamanlılık</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Kodu Eşzamanlı Çalıştırmak için İş Parçacıklarını Kullanmak</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Konular Arasında Veri Aktarmak için İleti Geçişini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Paylaşımlı Eşzamanlık</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync ve Send Tanımlarıyla Genişletilebilir Eşzamanlılık</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust'taki Nesne Yönemimli Programlama Özellikleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Nesne Yönelimli Dillerin Karakteristik Özellikleri</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Farklı Türlerdeki Değerlere İzin Veren Özellik Tanımlarını Kullanma</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Nesneye Yönelik Tasarım Modelini Süreklemek</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Modeller ve Eşleştirme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Modeller Her Yerde Kullanılabilir</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Reddedilebilirlik: Modelin Eşleştirmede Başarısız Olup Olmayacağı</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Model Söz Dizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Gelişmiş Özellikler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Güvensiz Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Gelişmiş Tanımlar</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Gelişmiş Türler</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Gelimiş Fonksiyonlar ve Kapanış İfadeleri</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makrolar</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Projesi: Çoklu İş Parçacıklı Web Sunucusu İnşa Etmek</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Tek İş Parçacıklı Web Sunucusu İnşa Etmek</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Tek İş Parçacıklı Sunucumuzu Çok Parçacıklı Sunucuya Çevirmek</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Zarifçe Kapatmak ve Temizlemek</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Eklemeler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Anahtar Sözcükler</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatörler ve Semboller</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Türetilebilir Tanımlar</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Kullanışlı Geliştirme Araçları</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Sürümler</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Kitap'ın Çevirileri</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust ve “Gecelik Rust” Nasıl Yapıldı</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Programlama Dili</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ferhatgec/kitap" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="yaygın-veri-türleri"><a class="header" href="#yaygın-veri-türleri">Yaygın Veri Türleri</a></h2>
<p>Fonksiyon imzaları veya yapılar gibi öğeler için tanımlar oluşturmak için yaygınları kullanırız ve bunları daha sonra birçok farklı 
somut veri türüyle kullanabiliriz. İlk olarak yaygınları kullanarak fonksiyonları, yapıları, <code>enum</code>'ları ve metodları nasıl tanımlayacağımıza 
bakalım. Daha sonra yaygınların kod performansını nasıl etkilediğini tartışacağız.</p>
<h3 id="fonksiyon-tanımlarında"><a class="header" href="#fonksiyon-tanımlarında">Fonksiyon Tanımlarında</a></h3>
<p>Yaygın kullanan bir fonksiyon tanımlarken, yaygınları fonksiyonun imzasına, genellikle parametrelerin ve dönüş değerinin 
veri tiplerini belirttiğimiz yere yerleştiririz. Bunu yapmak kodumuzu daha esnek hale getirir ve kod tekrarını önlerken 
fonksiyonumuzu çağıranlara daha fazla işlevsellik sağlar.</p>
<p><code>largest</code> fonksiyonumuzla devam edersek, Liste 10-4'te her ikisi de bir dilimdeki en büyük değeri bulan iki fonksiyon gösterilmektedir. 
Daha sonra bunları yaygın kullanan tek bir fonksiyonda birleştireceğiz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">    assert_eq!(result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
<span class="boring">    assert_eq!(result, 'y');
</span>}
</code></pre></pre>
<p><span class="caption">Liste 10-4: Yalnızca adlarında ve imzalarındaki türlerde 
farklılık gösteren iki fonksiyon</span></p>
<p><code>largest_i32</code> fonksiyonu, bir dilimdeki en büyük <code>i32</code>'yi bulan Liste 10-3'te çıkardığımız fonksiyondur. 
<code>largest_char</code> fonksiyonu bir dilimdeki en büyük <code>char</code> değerini bulur. Fonksiyon gövdeleri aynı koda sahiptir, 
bu nedenle tek bir fonksiyona yaygın tür parametresi ekleyerek yinelemeyi ortadan kaldıralım.</p>
<p>Yeni bir tek fonksiyonda türleri parametrelendirmek için, tıpkı bir fonksiyonun değer parametreleri için yaptığımız gibi tür 
parametresini adlandırmamız gerekir. Tür parametresi adı olarak herhangi bir tanımlayıcı kullanabilirsiniz. 
Ancak biz <code>T</code> kullanacağız çünkü Rust'ta parametre adları genellikle sadece bir harf olmak üzere kısadır ve Rust'ın tür adlandırma kuralı 
<code>CamelCase</code>'dir. “tür, type” kelimesinin kısaltması olan <code>T</code>, çoğu Rust programcısının varsayılan tercihidir.</p>
<p>Fonksiyonun gövdesinde bir parametre kullandığımızda, parametre adını imzada bildirmemiz gerekir, böylece derleyici bu adın ne anlama geldiğini 
bilir. Benzer şekilde, bir fonksiyon imzasında bir tür parametre adı kullandığımızda, kullanmadan önce tür parametre adını bildirmemiz gerekir. 
Yaygın <code>largest</code> fonksiyonunu tanımlamak için, tür adı bildirimlerini fonksiyonun adı ile parametre listesi arasına köşeli parantezler 
(<code>&lt;&gt;</code>) içinde yerleştirin, aşağıdaki gibi:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>Bu tanımı şu şekilde okuyabiliriz: <code>largest</code> fonksiyonu bazı <code>T</code> türleri üzerinde yaygındır. Bu fonksiyonun <code>list</code> adında bir 
parametresi vardır ve bu parametre <code>T</code> türünde bir değer dilimidir. <code>largest</code> fonksiyonu aynı <code>T</code> türünde bir değer döndürecektir.</p>
<p>Liste 10-5, imzasında yaygın veri tipini kullanan birleşik <code>largest</code> fonksiyon tanımını gösterir. 
Liste ayrıca, fonksiyonu <code>i32</code> değerlerinden oluşan bir dilim ya da <code>char</code> değerleriyle nasıl çağırabileceğimizi de gösterir. 
Bu kodun henüz derlenmeyeceğini unutmayın, ancak bu bölümün ilerleyen kısımlarında bunu düzelteceğiz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Liste 10-5: Yaygın tür parametreleri kullanan <code>largest</code> fonksiyonu; 
bu henüz derlenmiyor</span></p>
<p>Kodu şimdi derlemeye çalışırsak, şu hatayı alırız:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>Notta bir tanım olan <code>std::cmp::PartialOrd</code>'dan bahsedilmektedir. Tanımlar hakkında bir sonraki bölümde konuşacağız. 
Şimdilik, bu hatanın <code>largest</code>'in gövdesinin <code>T</code>'nin olabileceği tüm olası türler için çalışmayacağını belirttiğini bilin. 
Gövdede <code>T</code> türündeki değerleri karşılaştırmak istediğimiz için, yalnızca değerleri sıralanabilen türleri kullanabiliriz. 
Karşılaştırmaları etkinleştirmek için, standart kütüphanede türler üzerinde uygulayabileceğiniz <code>std::cmp::PartialOrd</code> tanımı vardır 
(bu tanım hakkında daha fazla bilgi için Ekleme C'ye bakın). Yaygın bir türün belirli bir tanıma sahip olduğunu nasıl belirteceğinizi 
<a href="ch10-02-traits.html#traits-as-parameters">“Parametre Olarak Tanımlar”</a><!-- ignore --> bölümünde öğreneceksiniz. 
Bu kodu düzeltmeden önce (<a href="ch10-02-traits.html#fixing-the-largest-function-with-trait-bounds">“Tanım Sınırları ile Fonksiyonu Düzeltme”</a><!-- ignore --> bölümünde), yaygın tür parametrelerini 
kullanmanın diğer yollarını inceleyelim.</p>
<h3 id="struct-tanımlarında"><a class="header" href="#struct-tanımlarında">Struct Tanımlarında</a></h3>
<p>Ayrıca, <code>&lt;&gt;</code> söz dizimini kullanarak bir veya daha fazla alanda yaygın tür parametresi kullanmak için 
<code>struct</code>'ları tanımlayabiliriz. Liste 10-6, herhangi bir türdeki <code>x</code> ve <code>y</code> koordinat değerlerini tutmak için bir 
<code>Point&lt;T&gt;</code> <code>struct</code>'ı tanımlar.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Liste 10-6: <code>T</code> türünde <code>x</code> ve <code>y</code> değerlerini tutan bir <code>Point&lt;T</code> 
yapısı</span></p>
<p>Yapı tanımlarında yaygın türlerin kullanımı için söz dizimi, fonksiyon tanımlarında kullanılan söz dizimine benzer. 
İlk olarak, <code>struct</code> adından hemen sonra köşeli parantezler içinde tür parametresinin adını bildiririz. 
Ardından, <code>struct</code> tanımında somut veri türlerini belirteceğimiz yerde yaygın türü kullanırız.</p>
<p><code>Point&lt;T&gt;</code>'yi tanımlamak için yalnızca bir yaygın tür kullandığımızdan, bu tanımın <code>Point&lt;T&gt;</code> yapısının bazı <code>T</code> türleri üzerinde 
yaygın olduğunu ve <code>x</code> ve <code>y</code> üyelerinin her ikisinin de, bu tür ne olursa olsun, aynı tür olduğunu söylediğine dikkat edin. 
Liste 10-7'de olduğu gibi, farklı türlerde değerlere sahip bir <code>Point&lt;T&gt;</code> tanımı oluşturursak, kodumuz derlenmeyecektir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre>
<p><span class="caption">Liste 10-7: Her ikisi de aynı genel veri türü <code>T</code>'ye sahip olduğundan, 
<code>x</code> ve <code>y</code> üyeleri aynı türde olmalıdır.</span></p>
<p>Bu örnekte, <code>x</code>'e <code>5</code> tam sayı değerini atadığımızda, derleyiciye <code>T</code> yaygın türünün bu <code>Point&lt;T&gt;</code> tanımı için bir tam sayı olacağını bildiririz. 
Daha sonra, <code>x</code> ile aynı türe sahip olacak şekilde tanımladığımız <code>y</code> için <code>4.0</code> değerini belirttiğimizde, aşağıdaki gibi tür 
uyuşmazlığı hatası alırız:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p><code>x</code> ve <code>y</code>'nin her ikisinin de yaygın olduğu ancak farklı türlere sahip olabileceği bir <code>Point</code> yapısını tanımlamak için birden fazla 
yaygın tür parametresi kullanabiliriz. Örneğin, Liste 10-8'de, <code>Point</code> tanımını <code>T</code> ve <code>U</code> türleri üzerinde yaygın olacak şekilde 
değiştiririz; burada <code>x</code> <code>T</code> tipinde ve <code>y</code> <code>U</code> tipindedir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Liste 10-8: İki tür üzerinde yaygın bir <code>Point&lt;T, U&gt;</code>, böylece <code>x</code> ve <code>y</code> farklı türlerin 
değerleri olabilir</span></p>
<p>Artık gösterilen tüm <code>Point</code> tanımlarına izin verilmektedir! Bir tanımda istediğiniz kadar yaygın tür parametresi kullanabilirsiniz, 
ancak birkaç taneden fazla kullanmak kodunuzun okunmasını zorlaştırır. Kodunuzda çok sayıda yaygın türe ihtiyaç duyuyorsanız, 
bu kodunuzun daha küçük parçalar halinde yeniden yapılandırılması gerektiğini gösterebilir.</p>
<h3 id="enum-tanımlarında"><a class="header" href="#enum-tanımlarında"><code>enum</code> Tanımlarında</a></h3>
<p>Yapılarda yaptığımız gibi, yaygın veri türlerini varyantlarında tutmak için <code>enum</code>'ları tanımlayabiliriz. 
Standart kütüphanenin sağladığı ve Bölüm 6'da kullandığımız <code>Option&lt;T&gt;</code> <code>enum</code>'una bir kez daha göz atalım:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>Bu tanım şimdi size daha anlamlı gelecektir. Gördüğünüz gibi <code>Option&lt;T&gt;</code> <code>enum</code>'u <code>T</code> türü üzerinde yaygındır ve iki çeşidi vardır: 
<code>T</code> türünde bir değer tutan <code>Some</code> ve herhangi bir değer tutmayan <code>None</code> varyantı. <code>Option&lt;T&gt;</code> <code>enum</code>'unu kullanarak, 
isteğe bağlı bir değerin soyut kavramını ifade edebiliriz ve <code>Option&lt;T&gt;</code> yaygın olduğu için, isteğe bağlı değerin türü ne olursa 
olsun bu soyutlamayı kullanabiliriz.</p>
<p><code>enum</code>'lar birden fazla yaygın tür de kullanabilir. Bölüm 9'da kullandığımız <code>Result</code> <code>enum</code> tanımı buna bir örnektir:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Result</code> <code>enum</code>'u, <code>T</code> ve <code>E</code> olmak üzere iki tür üzerinde yaygındır ve iki çeşidi vardır: <code>T</code> türünde bir değer tutan <code>Ok</code> ve 
<code>E</code> türünde bir değer tutan <code>Err</code>. Bu tanım, başarılı (<code>T</code> türünde bir değer döndüren) veya başarısız (<code>E</code> türünde bir hata döndüren) 
olabilecek bir işlemimiz olan her yerde <code>Result</code> <code>enum</code>'unu kullanmayı kolaylaştırır. Aslında, Liste 9-3'te bir dosyayı açmak 
için kullandığımız şey buydu; dosya başarıyla açıldığında <code>T</code>, <code>std::fs::File</code> türüyle atandı ve dosyanın açılmasında sorun olduğunda 
<code>E</code>, <code>std::io::Error</code> türüyle atandı.</p>
<p>Kodunuzda, yalnızca tuttukları değerlerin türlerinde farklılık gösteren birden fazla <code>struct</code> veya <code>enum</code> tanımının bulunduğu 
durumları fark ettiğinizde, bunun yerine yaygın türleri kullanarak yinelemeyi önleyebilirsiniz.</p>
<h3 id="metod-tanımlarında"><a class="header" href="#metod-tanımlarında">Metod Tanımlarında</a></h3>
<p>Yapılar ve <code>enum</code>'lar üzerinde metodlar uygulayabilir (Bölüm 5'te yaptığımız gibi) ve tanımlarında yaygın türleri kullanabiliriz. 
Liste 10-9, Liste 10-6'da tanımladığımız <code>Point&lt;T&gt;</code> yapısını ve üzerinde uygulanan <code>x</code> adlı bir metodu göstermektedir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p><span class="caption">Liste 10-9: <code>T</code> türündeki <code>x</code> üyesine bir başvuru döndürecek olan <code>Point&lt;T&gt;</code> yapısında 
<code>x</code> adlı metodun süreklenmesi</span></p>
<p>Burada, <code>x</code> üyesindeki verilere bir referans döndüren <code>Point&lt;T&gt;</code> üzerinde <code>x</code> adında bir metod tanımladık.</p>
<p><code>T</code>'yi <code>impl</code>'den hemen sonra bildirmemiz gerektiğine dikkat edin, böylece <code>T</code>'yi <code>Point&lt;T&gt;</code> türünde metodlar tanımladığımızı belirtmek için
kullanabiliriz. <code>T</code>'yi <code>impl</code>'den sonra yaygın bir tür olarak bildirerek, Rust, <code>Point</code>'teki köşeli parantez içindeki türün somut bir tür 
yerine yaygın bir tür olduğunu belirleyebilir. Bu yaygın parametre için <code>struct</code> tanımında bildirilen yaygın parametreden farklı bir 
isim seçebilirdik, ancak aynı ismi kullanmak gelenekseldir. Yaygın türü bildiren bir <code>impl</code> içinde yazılan metodlar, 
yaygın türün yerine hangi somut tür geçerse geçsin, türün herhangi bir tanımı üzerinde tanımlanacaktır.</p>
<p>Tür üzerinde metod tanımlarken yaygın türler üzerinde kısıtlamalar da belirtebiliriz. 
Örneğin, herhangi bir yaygın türe sahip <code>Point&lt;T&gt;</code> tanımları yerine yalnızca <code>Point&lt;f32&gt;</code> tanımları üzerinde metodlar uygulayabiliriz. 
Liste 10-10'da somut <code>f32</code> türünü kullanıyoruz, yani <code>impl</code>'den sonra herhangi bir tür bildirmiyoruz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!(&quot;p.x = {}&quot;, p.x());
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 10-10: Yaygın tür parametresi <code>T</code> için yalnızca belirli bir somut türe sahip bir 
yapıya tanımlanan bir <code>impl</code> bloğu</span></p>
<p>Bu kod, <code>Point&lt;f32&gt;</code> türünün bir <code>distance_from_origin</code> metoduna sahip olacağı anlamına gelir; 
<code>T</code>'nin <code>f32</code> türünde olmadığı diğer <code>Point&lt;T&gt;</code> örneklerinde bu metod tanımlı olmayacaktır. Metod, noktamızın <code>(0.0, 0.0)</code> 
koordinatlarındaki noktadan ne kadar uzakta olduğunu ölçer ve yalnızca kayan nokta türleri için kullanılabilen matematiksel işlemleri kullanır.</p>
<p>Bir <code>struct</code> tanımındaki yaygın tür parametreleri her zaman aynı <code>struct</code>'ın metod imzalarında kullandıklarınızla aynı değildir. 
Liste 10-11, örneği daha açık hale getirmek için <code>Point</code> <code>struct</code>'ı için <code>X1</code> ve <code>Y1</code> yaygın türlerini ve <code>mixup</code> metod imzası için <code>X2</code> <code>Y2</code>'yi
kullanır. Metod, kendi <code>Point</code>'inden (<code>X1</code> türünde) alınan <code>x</code> değeri ve aktarılan <code>Point</code>'ten (<code>Y2</code> türünde) alınan <code>y</code> değeriyle yeni bir 
<code>Point</code> tanımı oluşturur.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c' };

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p><span class="caption">Liste 10-11: Yapısının tanımından farklı yaygın türleri 
kullanan bir metod</span></p>
<p><code>main</code>'de, <code>x</code> için bir <code>i32</code> (değeri <code>5</code>) ve <code>y</code> için bir <code>f64</code> (değeri <code>10,4</code>) olan bir <code>Point</code> tanımladık. <code>p2</code> değişkeni, 
<code>x</code> için bir dizgi dilimine (<code>&quot;Hello&quot;</code> değeriyle) ve <code>y</code> için bir <code>char</code> değerine (<code>c</code> değeriyle) sahip bir <code>Point</code> <code>struct</code>'tır. 
<code>p1</code> üzerinde <code>p2</code> argümanıyla <code>mixup</code> çağrıldığında, <code>x</code> <code>p1</code>'den geldiği için <code>x</code> için bir <code>i32</code>'ye sahip olan <code>p3</code> elde edilir. 
<code>p3</code> değişkeninde <code>y</code> için bir <code>char</code> olacaktır, çünkü <code>y</code> <code>p2</code>'den gelmiştir. <code>println!</code> makro çağrısı <code>p3.x = 5, p3.y = c</code> yazdıracaktır.</p>
<p>Bu örneğin amacı, bazı yaygın parametrelerin <code>impl</code> ile bildirildiği ve bazılarının metod tanımıyla bildirildiği bir durumu göstermektir. 
Burada, <code>X1</code> ve <code>Y1</code> yaygın parametreleri <code>impl</code>'den sonra bildirilir, çünkü bunlar <code>struct</code> tanımıyla birlikte tanımlanmıştır. 
<code>X2</code> ve <code>Y2</code> yaygın parametreleri <code>fn mixup</code>'tan sonra bildirilir, çünkü bunlar yalnızca metodla ilgilidir.</p>
<h3 id="yaygınları-kullanan-kodun-performansı"><a class="header" href="#yaygınları-kullanan-kodun-performansı">Yaygınları Kullanan Kodun Performansı</a></h3>
<p>Yaygın tür parametrelerini kullanırken bir çalışma zamanı maliyeti olup olmadığını merak ediyor olabilirsiniz. 
İyi haber şu ki, yaygın türleri kullanmak çalışmanızı somut tiplere göre daha yavaş hale getirmeyecektir.</p>
<p>Rust bunu, derleme zamanında yaygınları kullanarak kodun <em>monomorfizasyonunu</em> gerçekleştirerek başarır. 
<em>Monomorfizasyon</em>, derlendiğinde kullanılan somut tiplerin içini doldurarak genel kodu belirli bir koda dönüştürme işlemidir. 
Bu süreçte derleyici, Liste 10-5'teki yaygın fonksiyonu oluşturmak için kullandığımız adımların tersini yapar: 
derleyici, genel kodun çağrıldığı tüm yerlere bakar ve genel kodun çağrıldığı somut türler için kod oluşturur.</p>
<p>Standart kütüphanenin yaygın <code>Option&lt;T&gt;</code> <code>enum</code>'unu kullanarak bunun nasıl çalıştığına bakalım:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}
</span></code></pre></pre>
<p>Rust bu kodu derlediğinde, <em>monomorflaştırma</em> gerçekleştirir. Bu işlem sırasında, derleyici <code>Option&lt;T&gt;</code> tanımlarında kullanılan değerleri 
okur ve iki tür <code>Option&lt;T&gt;</code> tanımlar: biri <code>i32</code> ve diğeri <code>f64</code>. Bu nedenle, <code>Option&lt;T&gt;</code>'nin yaygın tanımını <code>Option_i32</code> ve 
<code>Option_f64</code> olarak genişletir, böylece genel tanımı özel olanlarla değiştirir.</p>
<p>Kodun monomorfize edilmiş versiyonu aşağıdaki gibi görünür:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>Yaygın <code>Option&lt;T&gt;</code>, derleyici tarafından oluşturulan özel tanımlarla değiştirilir. 
Rust, yaygın kodu her örnekte türü belirten koda derlediğinden, yaygınları kullanmak için çalışma zamanı maliyeti ödemeyiz. 
Kod çalıştığında, her bir tanımı elle çoğaltmış olsaydık nasıl çalışacaksa öyle çalışır. Monomorfizasyon süreci, 
Rust'ın yaygınlarını çalışma zamanında son derece verimli hale getirir.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-00-generics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch10-02-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-00-generics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch10-02-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>


    </body>
</html>
