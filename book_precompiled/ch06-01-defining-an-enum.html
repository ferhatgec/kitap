<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Numaralandırılmış Yapı Tanımlamak - Rust Programlama Dili</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Rust Programlama Dili</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Ön söz</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Başlangıç</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Başlarken</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Yükleme</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Merhaba, Dünya!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Merhaba, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Tahmin Oyunu Programlamak</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Yaygın Programlama Kavramları</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Değişkenler ve Değişebilirlik</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Fonksiyonlar</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Yorum Satırları</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrol Akışı</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Sahipliği Anlamak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Sahiplik Nedir?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referanslar ve Ödünç Alma Mekanizması</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Dilim Türü</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> İlintili Verileri Yapılandırmak için Yapıları Kullanmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Yapıları Tanımlamak ve Örneklendirmek</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Yapıları Kullanan Örnek Bir Program</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Metod Söz dizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Numaralandırılmış Yapılar ve Model Eşleme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html" class="active"><strong aria-hidden="true">6.1.</strong> Numaralandırılmış Yapı Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match Kontrol Akış Yapısı</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let ile Kısa Kontrol Akış Yapısı</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Büyüyen Projeleri Paketler, Kasalar ve Modüllerle Yönetme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paketler ve Kasalar</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Gizlilik ve Kontrol Kapsamı için Modüller Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Modül Ağacındaki bir Öğeyi Referanslama Yolları</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use Kullanarak Yolları Kapsama Getirmek</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Modülleri Farklı Dosyalara Ayırmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Yaygın Koleksiyon Türleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Veri Listelerini Vektörlerle Tutmak</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8 ile Kodlanmış Dizgiyi Tutmak</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> İlişkili Değerlerle Anahtarları Saklamak</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Hata Yönetimi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! ile Kurtarılamayan Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result ile Kurtarılabilir Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!lemek ya da panic!lememek</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Yaygın Türler, Tanımlar ve Ömürlükler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Yaygın Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Tanımlar: Yaygın Davranış Tanımlama</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Ömürlük Yapısıyla Referans Doğrulama</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Otomatikleşmiş Testler Yazma</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Testler Nasıl Yazılır</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Testlerin Nasıl Çalıştığını Kontrol Etmek</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organizasyonu</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Bir G/Ç Projesi: Komut Satırı Programı Yazmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Komut Satırı Argümanlarını Ayrıştırmak</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Dosya Okumak</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Modülerliği ve Hata Yönetimini Geliştirmek için Yeniden Düzenlemek</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Test Odaklı Geliştirme ile Kütüphanenin İşlevliğini Artırmak</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Ortam Değişkenlerini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Hata Mesajlarını Standart Çıktı yerine Standart Hata Akışına Yazdırmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Fonksiyonel Dil Özellikleri: Yineleyiciler ve Kapanış İfadeleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Kapanış İfadeleri: Ortamda Tutulabilen Anonim Fonksiyonlar</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Yineleyicilerle Bir Dizi Öğeyi İşlemek</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> G/Ç Projemizi Geliştirmek</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performans Kıyaslaması: Döngüler vs. Yineleyiciler</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo ve Crates.io Hakkında Daha Fazla Bilgi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Dağıtım Profilleriyle İnşaları Özelleştirmek</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io'da Bir Kasa Paylaşmak</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Çalışma Alanları</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install ile Crates.io'dan Derlenmişleri Yüklemek</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Özel Komutlarla Cargo'yu Genişletmek</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Akıllı İşaretçiler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Yığındaki Verileri İşaretlemek için Box&lt;T&gt; Kullanmak</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Akıllı İşaretçilere Deref ile Normal Referanslar Gibi Tanım Yapmak</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop Tanımlamasıyla Temizlik Aşamasında Kod Çalıştırmak</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Referans Sayaçlı Akıllı İşaretçi</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; ve İç Değişebilirlik Modeli</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referans Döngüleri Bellek Sızdırabilir</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Korkusuz Eşzamanlılık</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Kodu Eşzamanlı Çalıştırmak için İş Parçacıklarını Kullanmak</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Konular Arasında Veri Aktarmak için İleti Geçişini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Paylaşımlı Eşzamanlık</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync ve Send Tanımlarıyla Genişletilebilir Eşzamanlılık</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust'taki Nesne Yönemimli Programlama Özellikleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Nesne Yönelimli Dillerin Karakteristik Özellikleri</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Farklı Türlerdeki Değerlere İzin Veren Özellik Tanımlarını Kullanma</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Nesneye Yönelik Tasarım Modelini Süreklemek</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Modeller ve Eşleştirme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Modeller Her Yerde Kullanılabilir</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Reddedilebilirlik: Modelin Eşleştirmede Başarısız Olup Olmayacağı</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Model Söz Dizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Gelişmiş Özellikler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Güvensiz Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Gelişmiş Tanımlar</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Gelişmiş Türler</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Gelimiş Fonksiyonlar ve Kapanış İfadeleri</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makrolar</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Projesi: Çoklu İş Parçacıklı Web Sunucusu İnşa Etmek</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Tek İş Parçacıklı Web Sunucusu İnşa Etmek</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Tek İş Parçacıklı Sunucumuzu Çok Parçacıklı Sunucuya Çevirmek</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Zarifçe Kapatmak ve Temizlemek</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Eklemeler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Anahtar Sözcükler</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatörler ve Semboller</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Türetilebilir Tanımlar</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Kullanışlı Geliştirme Araçları</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Sürümler</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Kitap'ın Çevirileri</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust ve “Gecelik Rust” Nasıl Yapıldı</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Programlama Dili</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ferhatgec/kitap" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="numaralandırılmış-yapı-tanımlamak"><a class="header" href="#numaralandırılmış-yapı-tanımlamak">Numaralandırılmış Yapı Tanımlamak</a></h2>
<p>Yapıların size <code>width</code> ve <code>height</code> üyeleri olan bir <code>Rectangle</code> gibi ilgili üyeleri ve 
verileri gruplandırmanın bir yolunu verdiği yerde, numaralandırmalar size bir değerin 
olası bir değer kümesinden biri olduğunu söylemenin bir yolunu verir. 
Örneğin, <code>Rectangle</code>'ın <code>Circle</code> ve <code>Triangle</code>'ı da içeren olası şekillerden biri 
olduğunu söylemek isteyebiliriz. Bunu yapmak için Rust, bu olasılıkları bir <code>enum</code> 
olarak kodlamamıza izin verir.</p>
<p>Kodda ifade etmek isteyebileceğimiz bir duruma bakalım ve bu durumda numaralandırmaların 
neden yapılardan daha yararlı ve daha uygun olduğunu görelim. IP adresleriyle çalışmamız 
gerektiğini farz edin. Şu anda IP adresleri için iki ana standart kullanılmaktadır: 
V4 ve V6. Programımızın karşılaşacağı bir IP adresi için tek olasılık bunlar olduğundan, 
tüm olası değişkenleri sıralayabiliriz, bu da numaralandırmanın adını aldığı yerdir.</p>
<p>Herhangi bir IP adresi, V4 veya V6 adresi olabilir, 
ancak ikisi aynı anda olamaz. IP adreslerinin bu özelliği, <code>enum</code> veri yapısını 
uygun hale getirir, çünkü bir <code>enum</code> değeri onun türevlerinden yalnızca biri olabilir. 
Hem V4 hem de V6 adresleri hala temelde IP adresleridir, bu nedenle kod herhangi bir 
IP adresi için geçerli olan durumları işlerken aynı tür olarak ele alınmalıdır.</p>
<p>Bu kavramı bir <code>IpAddrKind</code> numaralandırması tanımlayarak ve bir IP adresinin olabileceği 
olası türleri V4 ve V6 olarak listeleyerek kodda ifade edebiliriz. 
Bunlar, numaralandırmanın varyantlarıdır:</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p><code>IpAddrKind</code> artık kodumuzun başka bir yerinde kullanabileceğimiz özel bir veri türüdür.</p>
<h3 id="enum-değerleri"><a class="header" href="#enum-değerleri"><code>enum</code> Değerleri</a></h3>
<p><code>IpAddrKind</code>'in iki varyantının her birinin örneklerini şu şekilde oluşturabiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>Numaralandırmanın türevlerinin, tanımlayıcısının altında ad alanlı olduğuna ve 
ikisini ayırmak için çift iki nokta üst üste (<code>:</code>) kullandığımıza dikkat edin. 
Bu kullanışlıdır çünkü artık her iki <code>IpAddrKind::V4</code> ve <code>IpAddrKind::V6</code> değeri aynı 
türdedir: <code>IpAddrKind</code>. Daha sonra, örneğin, herhangi bir <code>IpAddrKind</code> alan bir 
fonksiyon tanımlayabiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}
</code></pre></pre>
<p>Ve bu fonksiyonu her iki değişkenle de çağırabiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>Numaralandırma kullanmanın daha da fazla avantajı vardır. IP adresi <em>türümüz</em> hakkında daha 
fazla düşünürsek, şu anda gerçek IP adresi verilerini saklamanın bir yolu yok; sadece ne tür olduğunu biliyoruz. Bölüm 5'te yapılar hakkında yeni öğrendiğinize göre, bu sorunu Liste 6-1'de gösterildiği gibi yapılarla çözmeye cazip gelebilirsiniz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from(&quot;127.0.0.1&quot;),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from(&quot;::1&quot;),
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 6-1: Bir IP adresinin verilerinin ve <code>IpAddrKind</code> değişkeninin
<code>struct</code> kullanılarak saklanması</span></p>
<p>Burada, iki üyesi olan bir <code>IpAddr</code> yapısı tanımladık: 
<code>IpAddrKind</code> türünde bir tür üyesi (daha önce tanımladığımız numaralandırma) ve 
<code>String</code> türünde bir adres üyesi. Bu yapının iki örneğine sahibiz. 
Birincisi <code>home</code>'dır ve <code>127.0.0.1</code> ilişkili adres verileriyle kendi türünde 
<code>IpAddrKind::V4</code> değerine sahiptir. İkinci örnek geri döngüdür. Tür değeri <code>V6</code> olarak 
<code>IpAddrKind</code>'in diğer türevine sahiptir ve onunla ilişkili <code>::1</code> adresine sahiptir. 
Tür ve adres değerlerini bir araya toplamak için bir yapı kullandık, 
bu yüzden şimdi değişken değerle ilişkilendirildi.</p>
<p>Bununla birlikte, aynı kavramı yalnızca bir numaralandırma kullanarak temsil etmek daha özlüdür: 
bir yapı içindeki bir numaralandırma yerine, verileri doğrudan her bir numaralandırma 
değişkenine koyabiliriz. <code>IpAddr</code> <code>enum</code>'un bu yeni tanımı, 
hem <code>V4</code> hem de <code>V6</code> varyantlarının ilişkili <code>String</code> değerlerine sahip olacağını söylüyor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p><code>enum</code>'un her türevine doğrudan veri ekliyoruz, bu nedenle ekstra bir yapıya gerek yok. 
Burada ayrıca numaralandırmaların nasıl çalıştığına dair başka bir ayrıntıyı görmek daha kolaydır:
tanımladığımız her bir numaralandırma değişkeninin adı aynı zamanda numaralandırmanın bir örneğini
oluşturan bir fonksiyon haline gelir. Diğer bir deyişle, <code>IpAddr::V4()</code>, 
bir <code>String</code> bağımsız değişkeni alan ve <code>IpAddr</code> türünün bir örneğini döndüren bir fonksiyon çağrısıdır.
<code>enum</code>'u tanımlamanın bir sonucu olarak bu yapıcı fonksiyonu otomatik olarak tanımlarız.</p>
<p>Bir yapı yerine bir numaralandırma kullanmanın başka bir avantajı daha vardır: her değişken, 
farklı türde ve miktarda ilişkili veriye sahip olabilir. V4 tip IP adresleri her zaman 
0 ile 255 arasında değerlere sahip dört sayısal bileşene sahip olacaktır:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>V4 ve V6 IP adreslerini depolamak için veri yapılarını tanımlamanın birkaç farklı yolunu gösterdik. 
Ancak, ortaya çıktığı gibi, IP adreslerini saklamak ve hangi tür olduklarını kodlamak istemek o kadar
yaygın ki, <a href="../std/net/enum.IpAddr.html">standart kütüphanenin kullanabileceğimiz bir tanımı var!</a><!-- ignore --> 
Standart kütüphanenin <code>IpAddr</code>'yi nasıl tanımladığına bakalım: tanımladığımız ve kullandığımız 
tam <code>enum</code> ve varyantlara sahiptir, ancak adres verilerini varyantların içine, 
her varyant için farklı tanımlanmış iki farklı yapı şeklinde gömer:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<p>Bu kod, herhangi bir türde veriyi bir numaralandırma değişkeninin içine koyabileceğinizi gösterir: 
örneğin dizgiler, sayısal türler veya yapılar. Hatta başka bir numaralandırma ekleyebilirsiniz! 
Ayrıca, standart kütüphane türleri genellikle bulabileceklerinizden çok daha karmaşık değildir.</p>
<p>Standart kütüphanenin <code>IpAddr</code> için bir tanım içermesine rağmen, standart kütüphanenin tanımını 
kapsamımıza almadığımız için kendi tanımımızı çakışmadan oluşturup kullanabileceğimize dikkat edin. 
Bölüm 7'de türleri kapsama almak hakkında daha fazla konuşacağız.</p>
<p>Liste 6-2'deki başka bir numaralandırma örneğine bakalım: bu, türevlerinde gömülü çok çeşitli türlere sahiptir.</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Liste 6-2: Varyantlarının her biri farklı miktar ve türde değerleri saklayan bir
<code>Message</code> numaralandırması</span></p>
<p>Bu numaralandırmanın farklı türlerde dört çeşidi vardır:</p>
<ul>
<li><code>Quit</code> onunla ilişkili hiçbir veriye sahip değil.</li>
<li><code>Move</code> bir yapının yaptığı gibi alanları adlandırmıştır.</li>
<li><code>Write</code> tek bir <code>String</code>'i dahil eder.</li>
<li><code>ChangeColor</code> üç tane <code>i32</code> değerini dahil eder.</li>
</ul>
<p>Liste 6-2'dekiler gibi değişkenlerle bir numaralandırma tanımlamak, 
farklı türde yapı tanımları tanımlamaya benzer, ancak numaralandırmanın <code>struct</code> anahtar sözcüğünü
kullanmaması ve tüm değişkenlerin <code>Message</code> türü altında gruplandırılması dışında. 
Aşağıdaki yapılar, önceki numaralandırma değişkenlerinin sahip olduğu aynı verileri tutabilir:</p>
<pre><pre class="playground"><code class="language-rust">struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Ancak, her biri kendi tipine sahip olan farklı yapıları kullanırsak, 
bu tür mesajların herhangi birini almak için, tek bir mesaj olan Liste 6-2'de 
tanımlanan <code>Message</code> <code>enum</code>'u ile yapabileceğimiz kadar kolay bir fonksiyon tanımlayamazdık.</p>
<p>Numaralandırmalar ve yapılar arasında bir benzerlik daha vardır: 
<code>impl</code> kullanarak yapılar üzerinde yöntemleri tanımlayabildiğimiz gibi, 
<code>enum</code>'lar üzerinde de yöntemler tanımlayabiliriz. İşte <code>Message</code> <code>enum</code>'umuzda 
tanımlayabileceğimiz <code>call</code> adında bir metod:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from(&quot;hello&quot;));
    m.call();
<span class="boring">}
</span></code></pre></pre>
<p>Metodun gövdesi, metodu çağırdığımız değeri almak için <code>self</code>'i kullanır.
Bu örnekte, <code>m</code> adında <code>Message::Write(String::from(&quot;hello&quot;))</code>'yu tutan bir değişken oluşturduk 
ve <code>m.call()</code> çalıştığında <code>self</code> <code>call</code> metodunun gövdesinde olacak.</p>
<p>Standart kütüphanedeki çok yaygın ve kullanışlı olan başka bir numaralandırmaya bakalım: 
<code>Option</code>.</p>
<h3 id="option-numaralandırması-ve-null-değerlerine-göre-avantajları"><a class="header" href="#option-numaralandırması-ve-null-değerlerine-göre-avantajları"><code>Option</code> Numaralandırması ve <code>Null</code> Değerlerine Göre Avantajları</a></h3>
<p>Bu bölüm, standart kütüphane tarafından tanımlanan başka bir numaralandırma olan 
<code>Option</code>'ın örnek olay incelemesini incelemektedir. <code>Option</code> türü, bir değerin 
bir şey olabileceği veya hiçbir şey olamayacağı çok yaygın senaryoyu kodlar.</p>
<p>Örneğin, öğeleri içeren bir listenin ilkini talep ederseniz, bir değer alırsınız. 
Boş bir listenin ilk maddesini talep ederseniz, hiçbir şey alamazsınız. Bu kavramı 
tür sistemi cinsinden ifade etmek, derleyicinin, ele almanız gereken tüm durumları ele alıp 
almadığınızı kontrol edebileceği anlamına gelir; bu işlevsellik, diğer programlama dillerinde 
son derece yaygın olan hataları önleyebilir.</p>
<p>Programlama dili tasarımı genellikle hangi özellikleri eklediğinize göre düşünülür, 
ancak hariç tuttuğunuz özellikler de önemlidir. Rust, diğer birçok dilde bulunan 
<em>null</em> özelliğine sahip değildir. <em>null</em>, hiçbir değer olmadığı anlamına gelen bir değerdir. 
<em>null</em> olan dillerde, değişkenler her zaman iki durumdan birinde olabilir: <em>null</em> veya <em>null</em> değil.</p>
<p><em>null</em>'un mucidi Tony Hoare, “Null References: The Billion Dollar Mistake,” adlı 2009 sunumunda şunları söylüyor:</p>
<blockquote>
<p>Ben buna milyar dolarlık hatam diyorum. O zaman, nesne yönelimli bir dilde 
referanslar için ilk kapsamlı tip sistemini tasarlıyordum. Amacım, derleyici tarafından 
otomatik olarak gerçekleştirilen kontrol ile referansların tüm kullanımının kesinlikle güvenli
olmasını sağlamaktı. Ancak, uygulanması çok kolay olduğu için boş bir referans koymanın 
cazibesine karşı koyamadım. Bu, son kırk yılda muhtemelen milyarlarca dolarlık acıya 
ve hasara neden olan sayısız hataya, güvenlik açığına ve sistem çökmesine neden oldu.</p>
</blockquote>
<p>Boş değerlerle ilgili sorun, boş olmayan bir değer olarak boş bir değer kullanmaya çalışırsanız, 
bir tür hata almanızdır. Bu boş veya boş olmayan özellik yaygın olduğundan, 
bu tür bir hatayı yapmak son derece kolaydır.</p>
<p>Bununla birlikte, <em>null</em>'un ifade etmeye çalıştığı kavram hala kullanışlıdır: 
<em>null</em>, şu anda geçersiz olan veya herhangi bir nedenle mevcut olmayan bir değerdir.</p>
<p>Sorun gerçekten konseptte değil, uygulanmasındadır. Bu nedenle, Rust'ın boş değerleri yoktur, 
ancak var olan veya olmayan bir değer kavramını kodlayabilen bir numaralandırmaya sahiptir. 
Bu numaralandırma <code>Option&lt;T&gt;</code>'dir ve <a href="../std/option/enum.Option.html">standart kütüphane tarafından</a><!-- ignore -->
aşağıdaki gibi tanımlanır:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Option&lt;T&gt;</code> <code>enum</code>'u o kadar kullanışlıdır ki, girişe bile dahil edilmiştir; 
Bunu açıkça kapsama sokmanız gerekmez. Varyantları da başlangıç bölümüne dahil edilmiştir: 
<code>Some</code> ve <code>None</code>'ı doğrudan <code>Option::</code> ön eki olmadan kullanabilirsiniz. <code>Option&lt;T&gt;</code> numaralandırma 
hala normal bir numaralandırmadır ve <code>Some(T)</code> ve <code>None</code> hala <code>Option&lt;T&gt;</code> türünün varyantlarıdır.</p>
<p><code>&lt;T&gt;</code> sözdizimi, Rust'ın henüz bahsetmediğimiz bir özelliğidir. 
Bu genel bir tür parametresidir ve yaygınları Bölüm 10'da daha ayrıntılı olarak ele alacağız. 
Şimdilik, bilmeniz gereken tek şey <code>&lt;T&gt;</code>'nin <code>Option</code> <code>enum</code>'unun <code>Some</code> varyantının herhangi bir 
türden tek bir veri parçasını tutabileceği anlamına geldiğidir. 
Sayı türlerini ve dize türlerini tutmak için <code>Option</code> değerlerini kullanmanın bazı örnekleri:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<p><code>some_number</code> türü <code>Option&lt;i32&gt;</code> şeklindedir. <code>some_char</code> türü, farklı bir tür olan 
<code>Option&lt;char&gt;</code>'dır. Rust, <code>Some</code> varyantı içinde bir değer belirttiğimiz için bu türlerin 
çıkarımını yapabilir. <code>absent_number</code> için Rust, genel <code>Otpion</code> türüne açıklama eklememizi gerektirir:
derleyici, yalnızca <code>None</code> değerine bakarak karşılık gelen <code>Some</code> varyantının tutacağı türü çıkaramaz.
Burada, <code>absent_number</code> için <code>Option&lt;i32&gt;</code> türünde olmasını kastettiğimizi Rust'a söylüyoruz.</p>
<p>Bir <code>Some</code> değerine sahip olduğumuzda, bir değerin mevcut olduğunu ve değerin <code>Some</code> içinde tutulduğunu
biliriz. <code>None</code> değerine sahip olduğumuzda, bir anlamda <em>null</em> ile aynı anlama gelir: 
geçerli bir değerimiz yoktur. Öyleyse neden <code>Option&lt;T&gt;</code> seçeneğine sahip olmak boş değere sahip 
olmaktan daha iyidir?</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}
</span></code></pre>
<p>Bu kodu çalıştırırsak şöyle bir hata mesajı alırız:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
</code></pre>
<p>Aslında bu hata mesajı, farklı türler oldukları için Rust'ın bir <code>i8</code> ve bir <code>Option&lt;i8&gt;</code> nasıl 
ekleneceğini anlamadığı anlamına gelir. Rust'ta <code>i8</code> gibi bir değerimiz olduğunda, 
derleyici her zaman geçerli bir değere sahip olmamızı sağlayacaktır. 
Bu değeri kullanmadan önce <em>null</em> değerini kontrol etmek zorunda kalmadan güvenle ilerleyebiliriz. 
Yalnızca bir <code>Option&lt;i8&gt;</code> olduğunda (veya hangi tür değerle çalışırsak çalışalım), 
muhtemelen bir değere sahip olmama konusunda endişelenmemiz gerekir ve derleyici, 
değeri kullanmadan önce bu durumu ele aldığımızdan emin olacaktır.</p>
<p>Başka bir deyişle, onunla <code>T</code> işlemleri gerçekleştirmeden önce <code>Option&lt;T&gt;</code> öğesini <code>T</code>'ye dönüştürmeniz
gerekir. Genellikle bu, <em>null</em> ile ilgili en yaygın sorunlardan birini yakalamaya yardımcı olur: 
bir şeyin gerçekte boş olmadığını varsaymak.</p>
<p>Yanlış bir şekilde boş olmayan bir değer varsayma riskini ortadan kaldırmak, 
kodunuza daha fazla güvenmenize yardımcı olur. Muhtemelen <em>null</em> olabilecek bir değere sahip olmak için, 
bu değerin türünü <code>Option&lt;T&gt;</code> yaparak açıkça seçmelisiniz. Ardından, bu değeri kullandığınızda, 
değer boş olduğunda durumu açıkça ele almanız gerekir. Bir değerin <code>Option&lt;T&gt;</code> olmayan bir türü 
olduğu her yerde, değerin boş olmadığını güvenle varsayabilirsiniz. 
Bu, Rust'ın <em>null</em>'ın yaygınlığını sınırlamak ve Rust kodunun güvenliğini artırmak için kasıtlı bir 
tasarım kararıydı.</p>
<p>Öyleyse, <code>Option&lt;T&gt;</code> türünde bir değeriniz olduğunda, bu değeri kullanabilmeniz için <code>Some</code> varyantından 
<code>T</code> değerini nasıl alırsınız? <code>Option&lt;T&gt;</code> <code>enum</code>'u, çeşitli durumlarda yararlı olan çok sayıda yönteme
sahiptir; <a href="../std/option/enum.Option.html">dokümantasyonundan</a><!-- ignore --> kontrol edebilirsiniz. <code>Option&lt;T&gt;</code> üzerindeki metodlara aşina olmak, 
Rust ile olan yolculuğunuzda son derece yararlı olacaktır.</p>
<p>Genel olarak, bir <code>Option&lt;T&gt;</code> değeri kullanmak için her bir değişkeni işleyecek bir koda sahip olmak
istersiniz. Yalnızca bir <code>Some(T)</code> değerine sahip olduğunuzda çalışacak bir kod istiyorsunuz 
ve bu kodun iç <code>T</code>'yi kullanmasına izin veriliyor. <code>None</code> değeriniz varsa ve bu kodda başka bir kodun
çalıştırılmasını istiyorsunuz. bir <code>T</code> değeri mevcuttur. <code>match</code> ifadesi, 
numaralandırmalarla kullanıldığında tam da bunu yapan bir kontrol akışı yapısıdır: 
sahip olduğu numaralandırmanın hangi türevine bağlı olarak farklı kod çalıştırır ve bu kod, 
eşleşen değerin içindeki verileri kullanabilir.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch06-00-enums.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch06-02-match.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch06-00-enums.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch06-02-match.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>


    </body>
</html>
