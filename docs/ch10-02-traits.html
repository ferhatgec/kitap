<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tanımlar: Yaygın Davranış Tanımlama - Rust Programlama Dili</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Rust Programlama Dili</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Ön söz</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Başlangıç</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Başlarken</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Yükleme</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Merhaba, Dünya!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Merhaba, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Tahmin Oyunu Programlamak</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Yaygın Programlama Kavramları</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Değişkenler ve Değişebilirlik</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Fonksiyonlar</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Yorum Satırları</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrol Akışı</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Sahipliği Anlamak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Sahiplik Nedir?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referanslar ve Ödünç Alma Mekanizması</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Dilim Türü</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> İlintili Verileri Yapılandırmak için Yapıları Kullanmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Yapıları Tanımlamak ve Örneklendirmek</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Yapıları Kullanan Örnek Bir Program</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Metod Söz dizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Numaralandırılmış Yapılar ve Model Eşleme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Numaralandırılmış Yapı Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match Kontrol Akış Yapısı</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let ile Kısa Kontrol Akış Yapısı</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Büyüyen Projeleri Paketler, Kasalar ve Modüllerle Yönetme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paketler ve Kasalar</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Gizlilik ve Kontrol Kapsamı için Modüller Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Modül Ağacındaki bir Öğeyi Referanslama Yolları</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use Kullanarak Yolları Kapsama Getirmek</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Modülleri Farklı Dosyalara Ayırmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Yaygın Koleksiyon Türleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Veri Listelerini Vektörlerle Tutmak</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8 ile Kodlanmış Dizgiyi Tutmak</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> İlişkili Değerlerle Anahtarları Saklamak</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Hata Yönetimi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! ile Kurtarılamayan Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result ile Kurtarılabilir Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!lemek ya da panic!lememek</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Yaygın Türler, Tanımlar ve Ömürlükler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Yaygın Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html" class="active"><strong aria-hidden="true">10.2.</strong> Tanımlar: Yaygın Davranış Tanımlama</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Ömürlük Yapısıyla Referans Doğrulama</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Otomatikleşmiş Testler Yazma</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Testler Nasıl Yazılır</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Testlerin Nasıl Çalıştığını Kontrol Etmek</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organizasyonu</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Bir G/Ç Projesi: Komut Satırı Programı Yazmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Komut Satırı Argümanlarını Ayrıştırmak</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Dosya Okumak</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Modülerliği ve Hata Yönetimini Geliştirmek için Yeniden Düzenlemek</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Test Odaklı Geliştirme ile Kütüphanenin İşlevliğini Artırmak</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Ortam Değişkenlerini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Hata Mesajlarını Standart Çıktı yerine Standart Hata Akışına Yazdırmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Fonksiyonel Dil Özellikleri: Yineleyiciler ve Kapanış İfadeleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Kapanış İfadeleri: Ortamda Tutulabilen Anonim Fonksiyonlar</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Yineleyicilerle Bir Dizi Öğeyi İşlemek</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> G/Ç Projemizi Geliştirmek</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performans Kıyaslaması: Döngüler vs. Yineleyiciler</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo ve Crates.io Hakkında Daha Fazla Bilgi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Dağıtım Profilleriyle İnşaları Özelleştirmek</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io'da Bir Kasa Paylaşmak</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Çalışma Alanları</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install ile Crates.io'dan Derlenmişleri Yüklemek</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Özel Komutlarla Cargo'yu Genişletmek</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Akıllı İşaretçiler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Yığındaki Verileri İşaretlemek için Box&lt;T&gt; Kullanmak</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Akıllı İşaretçilere Deref ile Normal Referanslar Gibi Tanım Yapmak</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop Tanımlamasıyla Temizlik Aşamasında Kod Çalıştırmak</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Referans Sayaçlı Akıllı İşaretçi</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; ve İç Değişebilirlik Modeli</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referans Döngüleri Bellek Sızdırabilir</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Korkusuz Eşzamanlılık</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Kodu Eşzamanlı Çalıştırmak için İş Parçacıklarını Kullanmak</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Konular Arasında Veri Aktarmak için İleti Geçişini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Paylaşımlı Eşzamanlık</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync ve Send Tanımlarıyla Genişletilebilir Eşzamanlılık</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust'taki Nesne Yönemimli Programlama Özellikleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Nesne Yönelimli Dillerin Karakteristik Özellikleri</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Farklı Türlerdeki Değerlere İzin Veren Özellik Tanımlarını Kullanma</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Nesneye Yönelik Tasarım Modelini Süreklemek</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Modeller ve Eşleştirme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Modeller Her Yerde Kullanılabilir</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Reddedilebilirlik: Modelin Eşleştirmede Başarısız Olup Olmayacağı</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Model Söz Dizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Gelişmiş Özellikler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Güvensiz Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Gelişmiş Tanımlar</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Gelişmiş Türler</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Gelimiş Fonksiyonlar ve Kapanış İfadeleri</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makrolar</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Projesi: Çoklu İş Parçacıklı Web Sunucusu İnşa Etmek</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Tek İş Parçacıklı Web Sunucusu İnşa Etmek</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Tek İş Parçacıklı Sunucumuzu Çok Parçacıklı Sunucuya Çevirmek</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Zarifçe Kapatmak ve Temizlemek</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Eklemeler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Anahtar Sözcükler</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatörler ve Semboller</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Türetilebilir Tanımlar</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Kullanışlı Geliştirme Araçları</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Sürümler</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Kitap'ın Çevirileri</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust ve “Gecelik Rust” Nasıl Yapıldı</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Programlama Dili</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ferhatgec/kitap" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="tanımlar-paylaşılan-davranışı-tanımlama"><a class="header" href="#tanımlar-paylaşılan-davranışı-tanımlama">Tanımlar: Paylaşılan Davranışı Tanımlama</a></h2>
<p>Bir <em>tanım</em>, belirli bir türün sahip olduğu ve diğer türlerle paylaşabileceği işlevselliği tanımlar. 
Paylaşılan davranışı soyut bir şekilde tanımlamak için tanımları kullanabiliriz. Genel bir türün belirli davranışlara sahip herhangi 
bir tür olabileceğini belirtmek için tanım sınırlarını kullanabiliriz.</p>
<blockquote>
<p>Not: Tanımlar, bazı farklılıklara rağmen diğer dillerde genellikle <em>arayüz</em> olarak adlandırılan 
bir özelliğe benzer.</p>
</blockquote>
<h3 id="tanım-tanımlama"><a class="header" href="#tanım-tanımlama"><em>Tanım</em> Tanımlama</a></h3>
<p>Bir türün davranışı, o tür üzerinde çağırabileceğimiz metodlardan oluşur. 
Tüm türler üzerinde aynı metodları çağırabiliyorsak, farklı tipler aynı davranışı paylaşır. 
Tanım tanımları, bir amacı gerçekleştirmek için gerekli olan bir dizi davranışı tanımlamak üzere metod imzalarını 
bir araya getirmenin bir yoludur.</p>
<p>Örneğin, çeşitli tür ve miktarlarda metin tutan birden fazla yapımız olduğunu varsayalım: 
belirli bir konumda dosyalanmış bir haberi tutan bir NewsArticle yapısı ve yeni bir tweet mi, retweet mi yoksa başka bir tweet'e yanıt mı olduğunu gösteren meta verilerle birlikte en fazla 280 karaktere sahip olabilen bir Tweet.</p>
<p>Bir <code>NewsArticle</code> veya <code>Tweet</code> örneğinde saklanabilecek verilerin özetlerini görüntüleyebilen <code>aggregator</code> adlı bir 
medya toplayıcı kütüphane kasası yapmak istiyoruz. Bunu yapmak için, her türden bir özete ihtiyacımız var ve bir 
örnek üzerinde bir summarize yöntemi çağırarak bu özeti talep edeceğiz. Liste 10-12, bu davranışı ifade eden bir genel
<code>Summary</code> tanımının tanımlanmasını göstermektedir.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
</code></pre>
<p><span class="caption">Liste 10-12: <code>summarize</code> metoduyla sağlanan davranıştan oluşan bir <code>Summary</code> tanımı</span></p>
<p>Burada, <code>trait</code> anahtar sözcüğünü ve ardından bu durumda <code>Summary</code> olan <code>trait</code>'in adını kullanarak bir <code>trait</code> bildiriyoruz. 
Ayrıca, birkaç örnekte göreceğimiz gibi, bu kasaya bağlı kasaların da bu tanımı kullanabilmesi için tanımı <code>pub</code> olarak bildirdik. 
Süslü parantezlerin içinde, bu tanımı uygulayan türlerin davranışlarını tanımlayan metod imzalarını bildiriyoruz; 
bu durumda <code>fn summarize(&amp;self) -&gt; String</code> olacaktır.</p>
<p>Metod imzasından sonra, süslü parantezler içinde bir sürekleme sağlamak yerine noktalı virgül kullanırız. 
Bu tanımı uygulayan her tür, metodun gövdesi için kendi özel davranışını sağlamalıdır. Derleyici, <code>Summary</code> tanımına sahip 
herhangi bir türün <code>summarize</code> metodunun tam olarak bu imza ile tanımlanmasını zorunlu kılacaktır.</p>
<p>Bir tanımın gövdesinde birden fazla metod olabilir: metod imzaları her satırda bir tane listelenir ve her satır noktalı virgülle biter.</p>
<h3 id="tür-Üzerinde-tanım-uygulama"><a class="header" href="#tür-Üzerinde-tanım-uygulama">Tür Üzerinde Tanım Uygulama</a></h3>
<p><code>Summary</code> tanımının metodlarının istenen imzalarını tanımladığımıza göre, bunu medya toplayıcımızdaki türlere uygulayabiliriz. 
Liste 10-13, <code>Summary</code> tanımının <code>NewsArticle</code> yapısı üzerinde, <code>summarize</code>'ın dönüş değerini oluşturmak için başlığı, 
yazarı ve konumu kullanan bir süreklemesini göstermektedir. Tweet yapısı için, tweet içeriğinin zaten 280 karakterle sınırlı olduğunu 
varsayarak, <code>summarize</code> özelliğini kullanıcı adı ve ardından tweet metninin tamamı olarak tanımlarız.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
</code></pre>
<p><span class="caption">Liste 10-13: <code>NewsArticle</code> ve <code>Tweet</code> türlerine <code>Summary</code> tanımının süreklenmesi</span></p>
<p>Bir tür üzerinde bir tanım süreklemek, normal metodları süreklemeye benzer. Aradaki fark, <code>impl</code>'den sonra süreklemek istediğimiz 
özellik adını koymamız, ardından <code>for</code> anahtar sözcüğünü kullanmamız ve ardından tanımı uygulamak istediğimiz türün adını belirtmemizdir. 
<code>impl</code> bloğunun içine, <em>tanım</em> tanımının <strong>tanımladığı</strong> metod imzalarını koyarız. Her imzadan sonra noktalı virgül eklemek yerine, 
süslü parantezler kullanırız ve metod gövdesini, tanımın metodlarının belirli bir tür için sahip olmasını istediğimiz belirli 
davranışla doldururuz.</p>
<p>Artık kütüphane <code>NewsArticle</code> ve <code>Tweet</code> üzerinde <code>Summary</code> tanımını süreklediğine göre, kasa kullanıcıları <code>NewsArticle</code> ve 
<code>Tweet</code> örnekleri üzerindeki tanım metodlarını normal metodları çağırdığımız şekilde çağırabilir. Tek fark, kullanıcının türlerin 
yanı sıra tanımı da kapsam içine alması gerektiğidir. İşte ikili bir kasanın <code>aggregator</code> kütüphane kasamızı nasıl kullanabileceğine dair 
bir örnek:</p>
<pre><code class="language-rust ignore">use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
}
</code></pre>
<p>Bu kod <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code> yazdırır.</p>
<p><code>aggregator</code> kasamıza bağımlı olan diğer kasalar da <code>Summary</code> tanımını kendi türlerinde süreklemek için kapsam içine alabilir. 
Unutulmaması gereken bir kısıtlama, bir özelliği bir tür üzerinde yalnızca tanım veya türden en az birinin kasamız için yerel olması 
durumunda uygulayabileceğimizdir. Örneğin, <code>Tweet</code> türü <code>aggregator</code> kasamız için yerel olduğundan, <code>Display</code> gibi standart kütüphane 
özelliklerini <code>Tweet</code> gibi gizli bir tür üzerinde kasa işlevselliğimizin bir parçası olarak sürekleyebiliriz. 
Ayrıca <code>Summary</code> tanımını <code>Vec&lt;T&gt;</code> üzerinde de sürekleyebiliriz, çünkü <code>Summary</code> tanımı kasamız için yereldir.</p>
<p>Ancak harici tanımları harici türler üzerinde uygulayamayız. Örneğin, <code>Display</code> tanımını <code>Vec&lt;T&gt;</code> üzerinde; kasamızda sürekleyemeyiz, 
çünkü <code>Display</code> ve <code>Vec&lt;T&gt;</code> standart kütüphanede tanımlanmıştır ve kasamız için yerel değildir. Bu kısıtlama, <em>tutarlılık</em> adı verilen bir 
özelliğin ve daha spesifik olarak, ana tür mevcut olmadığı için bu şekilde adlandırılan <em>yetim kuralının</em> bir parçasıdır. 
Bu kural, başkalarının kodunun sizin kodunuzu bozamamasını ve bunun tersinin de geçerli olmamasını sağlar. 
Bu kural olmasaydı, iki kasa aynı tür için aynı tanımı sürekleyebilirdi ve Rust hangi süreklemeyi kullanacağını bilemezdi.</p>
<h3 id="varsayılan-süreklemeler"><a class="header" href="#varsayılan-süreklemeler">Varsayılan Süreklemeler</a></h3>
<p>Bazen, her türdeki tüm metodlar için sürekleme gerektirmek yerine, bir tanımdaki metodlardan bazıları veya 
tümü için varsayılan davranışa sahip olmak yararlıdır. Daha sonra, tanımı belirli bir tür üzerinde süreklerken, 
her bir metodun varsayılan davranışını koruyabilir veya geçersiz kılabiliriz.</p>
<p>Liste 10-14'te, Liste 10-12'de yaptığımız gibi yalnızca metod imzasını tanımlamak yerine <code>Summary</code> tanımının <code>summarize</code> metodu için 
varsayılan bir dizgi belirtiyoruz.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 10-14: <code>Summarize</code> metodunun varsayılan süreklemesiyle bir <code>Summary</code> tanımının yazılması</span></p>
<p><code>NewsArticle</code> örneklerini özetlemek üzere varsayılan bir sürekleme kullanmak istediğimiz için, 
<code>impl Summary for NewsArticle {}</code> ile boş bir <code>impl</code> bloğu belirtiriz.</p>
<p>Artık <code>NewsArticle</code> üzerinde <code>summarize</code> metodunu doğrudan tanımlamıyor olsak da, 
varsayılan bir sürekleme sağladık ve <code>NewsArticle</code>'ın <code>Summary</code> tanımını süreklediğini belirttik. 
Sonuç olarak, bir <code>NewsArticle</code> örneği üzerinde <code>summarize</code> metodunu aşağıdaki gibi çağırabiliriz:</p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
        location: String::from(&quot;Pittsburgh, PA, USA&quot;),
        author: String::from(&quot;Iceburgh&quot;),
        content: String::from(
            &quot;The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.&quot;,
        ),
    };

    println!(&quot;New article available! {}&quot;, article.summarize());
<span class="boring">}
</span></code></pre>
<p>Bu kod <code>New article available! (Read more...)</code> çıktısını verir.</p>
<p>Varsayılan bir sürekleme oluşturmak, Liste 10-13'teki <code>Tweet</code>'deki <code>Summary</code> süreklemesinde herhangi bir değişiklik yapmamızı 
gerektirmez. Bunun nedeni, varsayılan bir süreklemeyi geçersiz kılma söz diziminin, varsayılan bir süreklemeye sahip olmayan 
bir tanım metodunu sürekleme söz dizimiyle aynı olmasıdır.</p>
<p>Varsayılan süreklemeler, diğer metodların varsayılan bir süreklemesi olmasa bile aynı tanımdaki diğer metodları çağırabilir. 
Bu şekilde, bir özellik çok sayıda yararlı işlevsellik sağlayabilir ve uygulayıcıların bunun yalnızca küçük bir bölümünü 
belirtmesini gerektirebilir. Örneğin, <code>Summary</code> tanımını, süreklenmesi gerekli olan bir <code>summarize_author</code> metoduna sahip olacak 
şekilde tanımlayabilir ve ardından <code>summarize_author</code> metodunu çağıran varsayılan bir süreklemeye sahip bir <code>summarize</code> metodu tanımlayabiliriz:</p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;@{}&quot;, self.username)
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><code>Summary</code>'in bu sürümünü kullanmak için, özelliği bir türe süreklediğimizde yalnızca <code>summary_author</code>'u tanımlamamız gerekir:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
</code></pre>
<p><code>summarize_author</code>'ı tanımladıktan sonra, <code>Tweet</code> yapısının örnekleri üzerinde <code>summarize</code>'ı çağırabiliriz ve 
<code>summarize</code>'ın varsayılan süreklemesi, sağladığımız <code>summarize_author</code> tanımını çağıracaktır. 
<code>summarize_author</code> tanımını süreklediğimiz için, <code>Summary</code> tanımı bize daha fazla kod yazmamızı gerektirmeden 
<code>summarize</code> metodunun davranışını vermiştir.</p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre>
<p>Bu kod <code>1 new tweet: (Read more from @horse_ebooks...)</code> çıktısını verecektir.</p>
<p>Aynı metodun geçersiz kılınan bir süreklemesinden varsayılan süreklemeyi çağırmanın mümkün olmadığını unutmayın.</p>
<h3 id="parametre-olarak-tanımlar"><a class="header" href="#parametre-olarak-tanımlar">Parametre olarak Tanımlar</a></h3>
<p>Artık tanımları nasıl tanımlayacağınızı ve sürekleyeceğinizi bildiğinize göre, 
birçok farklı türü kabul eden fonksiyonları tanımlamak için tanımları nasıl kullanacağımızı keşfedebiliriz. 
Liste 10-13'te <code>NewsArticle</code> ve <code>Tweet</code> türleri üzerinde süreklediğimiz <code>Summary</code> tanımını, <code>Summary</code> tanımını sürekleyen bir 
türden olan <code>item</code> parametresi üzerinde <code>summarize</code> metodunu çağıran <code>notify</code> fonksiyonunu tanımlamak için kullanacağız. 
Bunu yapmak için, aşağıdaki gibi <code>impl Trait</code> söz dizimini kullanırız:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<p>Öğe parametresi için somut bir tür yerine, 
<code>impl</code> anahtar sözcüğünü ve tanım adını belirtiriz. Bu parametre, belirtilen tanımı uygulayan herhangi bir 
türü kabul eder. <code>notify</code>'ın gövdesinde, <code>item</code> üzerinde <code>Summary</code> tanımından gelen <code>summarize</code> gibi herhangi bir metodu çağırabiliriz. 
<code>notify</code>'ı çağırabilir ve <code>NewsArticle</code> veya <code>Tweet</code>'in herhangi bir örneğini aktarabiliriz. Fonksiyonu <code>String</code> veya 
<code>i32</code> gibi başka bir türle çağıran kod derlenmez çünkü bu türler <code>Summary</code> tanımını uygulamaz.</p>
<h4 id="tanıma-bağlılık-söz-dizimi"><a class="header" href="#tanıma-bağlılık-söz-dizimi">Tanıma Bağlılık Söz Dizimi</a></h4>
<p><code>impl Trait</code> söz dizimi basit durumlar için çalışır, ancak aslında <em>tanıma bağlılık</em> olarak bilinen daha uzun bir form için 
<em>söz dizimi tatlılığıdır</em>; şöyle görünür:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<p>Bu uzun form önceki bölümdeki örneğe eş değerdir ancak daha ayrıntılıdır. Tanıma bağlılık, iki nokta üst üste 
işaretinden sonra ve köşeli parantezler içinde yaygın tür parametresinin bildirimiyle birlikte yerleştiririz.</p>
<p><code>impl Trait</code> söz dizimi kullanışlıdır ve basit durumlarda daha özlü bir kod sağlarken, tanıma bağlılık söz dizimi 
karmaşık durumlarda daha farklı bir şekilde kendini ifade edebilir. Örneğin, <code>Summary</code> öğesini uygulayan iki parametreye sahip olabiliriz. 
Bunu <code>impl Trait</code> sö zdizimi ile yapmak şu şekilde görünür:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {
</code></pre>
<p>Bu fonksiyonun <code>item1</code> ve <code>item2</code>'nin farklı türlere sahip olmasına izin vermesini istiyorsak 
(her iki tür de <code>Summary</code>'yi süreklediği sürece) <code>impl Trait</code> kullanmak uygundur. 
Ancak her iki parametrenin de aynı türde olmasını istiyorsak, aşağıdaki gibi, tanıma bağlılığı kullanmalıyız:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {
</code></pre>
<p><code>item1</code> ve <code>item2</code> parametrelerinin türü olarak belirtilen <code>T</code> yaygın türü; fonksiyonu, <code>item1</code> ve <code>item2</code> için argüman olarak 
aktarılan değerin somut türünün aynı olması gerektiği şekilde kısıtlar.</p>
<h4 id="-söz-dizimi-ile-birden-fazla-tanıma-bağlılığın-belirtilmesi"><a class="header" href="#-söz-dizimi-ile-birden-fazla-tanıma-bağlılığın-belirtilmesi"><code>+</code> Söz Dizimi ile Birden Fazla Tanıma Bağlılığın Belirtilmesi</a></h4>
<p>Birden fazla tanıma bağlılığı da belirleyebiliriz. Diyelim ki <code>notify</code>'ın öğe üzerinde özetlemenin yanı sıra görüntüleme 
biçimlendirmesini de kullanmasını istedik: <code>notify</code> tanımında öğenin hem <code>Display</code> hem de <code>Summary</code>'i süreklemesi gerektiğini belirtiriz. 
Bunu <code>+</code> söz dizimini kullanarak da yapabiliriz:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {
</code></pre>
<p><code>+</code> söz dizimi, yaygın türlerdeki tanıma bağlılıkta da geçerlidir:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {
</code></pre>
<p>Belirtilen iki tanıma bağlılık ile, <code>notify</code> öğesinin gövdesi <code>summarize</code>'ı çağırabilir ve <code>item</code>'ı 
biçimlendirmek için <code>{}</code> kullanabilir.</p>
<h4 id="where-ile-daha-net-tanıma-bağlılık"><a class="header" href="#where-ile-daha-net-tanıma-bağlılık"><code>where</code> ile Daha Net Tanıma Bağlılık</a></h4>
<p>Çok fazla tanıma bağlılık kullanmanın dezavantajları vardır. Her yaygın kendine özgü tanıma bağlılığa sahiptir, 
bu nedenle birden fazla yaygın tür parametresi olan fonksiyonlar, fonksiyonun adı ve parametre listesi arasında 
çok sayıda tanıma bağlılık bilgisi içerebilir ve bu da fonksiyon imzasının okunmasını zorlaştırır. 
Bu nedenle Rust, fonksiyon imzasından sonra <code>where</code> içinde tanıma bağlılığı belirtmek için alternatif bir söz dizime sahiptir. </p>
<p>Yani bunu yazmak yerine:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre>
<p><code>where</code> kullanabiliriz:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>Bu fonksiyonun imzası daha az karmaşıktır: fonksiyon adı, parametre listesi ve dönüş türü birbirine yakındır, 
çok sayıda tamıma bağlılığı olmayan bir fonksiyona benzer.</p>
<h3 id="tanımları-sürekleyen-dönüş-türleri"><a class="header" href="#tanımları-sürekleyen-dönüş-türleri">Tanımları Sürekleyen Dönüş Türleri</a></h3>
<p>Burada gösterildiği gibi, bir tanımı sürekleyen bir türden bir değer döndürmek için <code>return</code> konumunda
<code>impl Trait</code> söz dizimini de kullanabiliriz:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    }
}
</code></pre>
<p>Dönüş türü için <code>impl Summary</code> kullanarak, <code>returns_summarizable</code> fonksiyonunun somut türü belirtmeden <code>Summary</code> 
tanımını sürekleyen bir türü döndürdüğünü belirtiyoruz. Bu durumda, <code>returns_summarizable</code> <code>Tweet</code> döndürür, 
ancak bu fonksiyonu çağıran kodun bunu bilmesine gerek yoktur.</p>
<p>Bir geri dönüş türünü yalnızca uyguladığı özelliğe göre belirtme yeteneği, özellikle Bölüm 13'te ele aldığımız kapanış ifadeleri ve 
yineleyiciler bağlamında kullanışlıdır. Kapanış ifadeleri ve yineleyiciler yalnızca derleyicinin bildiği türler veya 
belirtilmesi çok uzun olan türler oluşturur. <code>impl Trait</code> söz dizimi, çok uzun bir tür yazmanıza gerek kalmadan bir fonksiyonun 
<code>Iterator</code> tanımını sürekleyen bir tür döndürdüğünü kısaca belirtmenizi sağlar.</p>
<p>Ancak, <code>impl Trait</code>'i yalnızca tek bir tür döndürüyorsanız kullanabilirsiniz. Örneğin, dönüş türü <code>impl Summary</code> olarak belirtilen 
bir <code>NewsArticle</code> veya <code>Tweet</code> döndüren bu kod çalışmaz:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &quot;Penguins win the Stanley Cup Championship!&quot;,
            ),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(
                &quot;The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.&quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(
                &quot;of course, as you probably already know, people&quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}
</code></pre>
<p>Derleyicide <code>impl Trait</code> söz diziminin nasıl süreklendiğine ilişkin kısıtlamalar nedeniyle <code>NewsArticle</code> veya <code>Tweet</code> döndürülmesine 
izin verilmez. Bu davranışa sahip bir fonksiyonun nasıl yazılacağını Bölüm 17'deki 
<a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Farklı Türlerde Değerlere İzin Veren Tanım Nesnelerini Kullanma”</a><!-- ignore --> 
kısmında ele alacağız.</p>
<h3 id="tanıma-bağlılık-ile-largest-fonksiyonunu-düzeltme"><a class="header" href="#tanıma-bağlılık-ile-largest-fonksiyonunu-düzeltme">Tanıma Bağlılık ile <code>largest</code> Fonksiyonunu Düzeltme</a></h3>
<p>Artık yaygın tür parametresinin bağlılıklarını kullanarak istediğiniz davranışı nasıl belirleyeceğinizi bildiğinize göre, 
yaygın tür parametresi kullanan <code>largest</code> fonksiyonunun tanımını düzeltmek için Liste 10-5'e dönelim! Bu kodu en son çalıştırmayı 
denediğimizde bu hatayı almıştık:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p><code>largest</code>'in gövdesinde, daha büyük (<code>&gt;</code>) operatörünü kullanarak <code>T</code> türündeki iki değeri karşılaştırmak istedik. 
Bu operatör standart kütüphane özelliği <code>std::cmp::PartialOrd</code> üzerinde varsayılan bir metod olarak tanımlandığından, 
<code>T</code>'ye tanıma bağlılıktan dolayı <code>PartialOrd</code>'u süreklememiz gerekir, böylece <code>largest</code> fonksiyonu karşılaştırabileceğimiz 
herhangi bir türden dilimler üzerinde çalışabilir. <code>PartialOrd</code>'u kapsam içine almamıza gerek yok çünkü o zaten kapsama otomatik
olarak dahildir... Yani, <code>largest</code>'in imzasını aşağıdaki gibi değiştirin:</p>
<pre><code class="language-rust ignore">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
<span class="boring">    let mut largest = list[0];
</span><span class="boring">
</span><span class="boring">    for &amp;item in list {
</span><span class="boring">        if item &gt; largest {
</span><span class="boring">            largest = item;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    largest
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let number_list = vec![34, 50, 25, 100, 65];
</span><span class="boring">
</span><span class="boring">    let result = largest(&amp;number_list);
</span><span class="boring">    println!(&quot;The largest number is {}&quot;, result);
</span><span class="boring">
</span><span class="boring">    let char_list = vec!['y', 'm', 'a', 'q'];
</span><span class="boring">
</span><span class="boring">    let result = largest(&amp;char_list);
</span><span class="boring">    println!(&quot;The largest char is {}&quot;, result);
</span><span class="boring">}
</span></code></pre>
<p>Bu sefer kodu derlediğimizde farklı hatalar alıyoruz:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&amp;list[0]`

error[E0507]: cannot move out of a shared reference
 --&gt; src/main.rs:4:18
  |
4 |     for &amp;item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&amp;`: `item`

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10` due to 2 previous errors
</code></pre>
<p>Buranın en önemli noktası, <code>kopyalanmamış bir dilim olan [T] türünün dışına çıkamaz</code> (<code>cannot move out of type [T], a non-copy slice</code>) hatasıdır. 
<code>largest</code> fonksiyonunun yaygın olmayan versiyonlarında, yalnızca en büyük <code>i32</code> veya <code>char</code>'ı bulmaya çalışıyorduk. 
Bkz. <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">“Sadece Yığıt Kullanan Veriler: Kopyalama”</a><!-- ignore --> konusuna bakın, <code>i32</code> ve <code>char</code> gibi bilinen bir 
boyuta sahip türler yığıtta saklanabilir, böylece <code>Copy</code> tanımı süreklenebilir. Ancak, <code>largest</code> fonksiyonunu genelleştirdiğimizde, 
<code>list</code> parametresinin içinde <code>Copy</code> tanımını süreklemeyen türler olması mümkün hale geldi. Sonuç olarak, 
değeri <code>list[0]</code>'ten <code>largest</code> değişkenine taşıyamayız, bu da bu hataya neden olur.</p>
<p>Bu kodu yalnızca <code>Copy</code> tanımını sürekleyen türlerle birlikte çağırmak için, <code>T</code>'nin tanıma bağlılık listesine <code>Copy</code>'i ekleyebiliriz! 
Liste 10-15, fonksiyona aktardığımız dilimdeki değerlerin türleri <code>i32</code> ve <code>char</code> gibi <code>PartialOrd</code> <em>ve</em> <code>Copy</code> tanımlarını süreklediği sürece 
derlenecek yaygın <code>largest</code> fonksiyonunun tam kodunu gösterir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Liste 10-15: <code>PartialOrd</code> ve <code>Copy</code> tanımlarını sürekleyen herhangi bir yaygın tür 
üzerinde çalışan <code>largest</code> fonksiyonunun düzgün çalışan versiyonu</span></p>
<p><code>largest</code> fonksiyonunu <code>Copy</code> tanımını sürekleyen türlerle sınırlamak istemiyorsak, 
<code>T</code>'nin <code>Copy</code> yerine <code>Clone</code> tanımına sahip olduğunu belirtebiliriz. Böylece, <code>largest</code> fonksiyonunun sahibi olmasını istediğimizde 
dilimdeki her değeri klonlayabiliriz. <code>Clone</code> fonksiyonunu kullanmak, <code>String</code> gibi yığın verisine sahip türler söz konusu olduğunda 
potansiyel olarak daha fazla yığın tahsisi yapacağımız anlamına gelir ve büyük miktarda veriyle çalışıyorsak yığın tahsisleri yavaş olabilir.</p>
<p>Ayrıca, fonksiyonun dilimdeki bir <code>T</code> değerine bir referans döndürmesini sağlayarak <code>largest</code>'ı sürekleyebiliriz. 
Dönüş türünü <code>T</code> yerine <code>&amp;T</code> olarak değiştirirsek, böylece fonksiyonun gövdesini bir referans döndürecek şekilde değiştirirsek, 
<code>Clone</code> veya <code>Copy</code> tanıma bağlılıklarına ihtiyacımız olmaz ve yığın tahsisatlarından kaçınabiliriz. 
Bu alternatif çözümleri kendi başınıza yazmayı deneyin! Yaşam süreleri ile ilgili hatalara takılırsanız, 
okumaya devam edin: “Yaşam Süreleri ile Referansları Doğrulama” bölümü durumu açıklayacaktır, 
ancak bu meydan okumaları çözmek için yaşam süreleri gerekli değildir.</p>
<h3 id="metodları-koşullu-olarak-süreklemek-için-tanıma-bağlılığı-kullanma"><a class="header" href="#metodları-koşullu-olarak-süreklemek-için-tanıma-bağlılığı-kullanma">Metodları Koşullu Olarak Süreklemek için Tanıma Bağlılığı Kullanma</a></h3>
<p>Yaygın tür parametreleri kullanan bir <code>impl bloğu</code> ile bağlı bir tanım kullanarak, 
belirtilen tanımları sürekleyen türler için metodları koşullu olarak sürekleyebiliriz. Örneğin, Liste 10-16'daki <code>Pair&lt;T&gt;</code> türü her 
zaman yeni bir <code>Pair&lt;T&gt;</code> örneği döndürmek için <code>new</code> fonksiyonunu çağırır (Bölüm 5'teki <a href="ch05-03-method-syntax.html#defining-methods">“Metodları Tanımlama”</a><!-- ignore --> 
bölümünden <code>Self</code>'in <code>impl</code> bloğunun türü için bir tür takma ad olduğunu hatırlayın, bu durumda <code>Pair&lt;T&gt;</code>'dir). 
Ancak bir sonraki <code>impl</code> bloğunda, <code>Pair&lt;T&gt;</code> yalnızca iç tipi <code>T</code>, karşılaştırmayı sağlayan <code>PartialOrd</code> tanımını ve 
yazdırmayı sağlayan <code>Display</code> tanımını süreklerse <code>cmp_display</code> metodunu sürekleyebilir.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
</code></pre>
<p><span class="caption">Liste 10-16: <em>Tanıma bağlılığa</em> bağlı olarak metodları yaygın bir tür üzerinde koşullu ,
olarak süreklemek</span></p>
<p>Ayrıca, başka bir tanımı sürekleyen herhangi bir tür için bir tanımı koşullu olarak sürekleyebiliriz. 
Bir tanımın, tanıma bağlılığı karşılayan herhangi bir tür üzerindeki süreklemelerine 
<em>kapsamlı sürekleme</em> denir ve Rust standart kütüphanesinde yaygın olarak kullanılır. 
Örneğin, standart kütüphane <code>Display</code> tanımını sürekleyen herhangi bir tür üzerinde <code>ToString</code> tanımını sürekler. 
Standart kütüphanedeki <code>impl</code> bloğu bu koda benzer:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>Standart kütüphane bu <em>kapsamlı süreklemeye</em> sahip olduğundan, <code>Display</code> tanımını sürekleyen herhangi bir tür üzerinde 
<code>ToString</code> tanımı tarafından tanımlanan <code>to_string</code> metodunu çağırabiliriz. Örneğin, tam sayılar <code>Display</code> tanımını 
süreklediği için tam sayıları karşılık gelen <code>String</code> değerlerine dönüştürebiliriz:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<p><em>Kapsamlı süreklemeler</em>, tanımın dokümantasyonunun “Implementors” bölümünde görünür.</p>
<p>Tanımlar ve tanıma bağlılık, yinelemeyi azaltmak için yaygın tür parametrelerini kullanan kod yazmamıza ve 
aynı zamanda derleyiciye yaygın türün belirli bir davranışa sahip olmasını istediğimizi belirtmemize olanak tanır. 
Derleyici daha sonra kodumuzla birlikte kullanılan tüm somut tiplerin doğru davranışı sağlayıp sağlamadığını kontrol etmek için 
tanıma bağlılık bilgisini kullanabilir. Dinamik olarak yazılan dillerde, metodu tanımlamayan bir tür üzerinde bir metod çağırırsak 
çalışma zamanında bir hata alırız. Ancak Rust bu hataları derleme zamanına taşır, böylece kodumuz daha çalışmadan önce sorunları 
düzeltmek zorunda kalırız. Ayrıca, derleme zamanında zaten kontrol ettiğimiz için çalışma zamanında davranışı kontrol eden kod yazmak 
zorunda kalmayız. Bunu yapmak, yaygınların esnekliğinden vazgeçmek zorunda kalmadan performansı artırır.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-01-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch10-03-lifetime-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-01-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch10-03-lifetime-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>


    </body>
</html>
