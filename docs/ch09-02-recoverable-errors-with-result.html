<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Result ile Kurtarılabilir Hatalar - Rust Programlama Dili</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Rust Programlama Dili</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Ön söz</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Başlangıç</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Başlarken</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Yükleme</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Merhaba, Dünya!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Merhaba, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Tahmin Oyunu Programlamak</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Yaygın Programlama Kavramları</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Değişkenler ve Değişebilirlik</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Fonksiyonlar</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Yorum Satırları</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrol Akışı</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Sahipliği Anlamak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Sahiplik Nedir?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referanslar ve Ödünç Alma Mekanizması</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Dilim Türü</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> İlintili Verileri Yapılandırmak için Yapıları Kullanmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Yapıları Tanımlamak ve Örneklendirmek</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Yapıları Kullanan Örnek Bir Program</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Metod Söz dizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Numaralandırılmış Yapılar ve Model Eşleme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Numaralandırılmış Yapı Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match Kontrol Akış Yapısı</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let ile Kısa Kontrol Akış Yapısı</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Büyüyen Projeleri Paketler, Kasalar ve Modüllerle Yönetme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paketler ve Kasalar</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Gizlilik ve Kontrol Kapsamı için Modüller Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Modül Ağacındaki bir Öğeyi Referanslama Yolları</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use Kullanarak Yolları Kapsama Getirmek</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Modülleri Farklı Dosyalara Ayırmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Yaygın Koleksiyon Türleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Veri Listelerini Vektörlerle Tutmak</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8 ile Kodlanmış Dizgiyi Tutmak</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> İlişkili Değerlerle Anahtarları Saklamak</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Hata Yönetimi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! ile Kurtarılamayan Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html" class="active"><strong aria-hidden="true">9.2.</strong> Result ile Kurtarılabilir Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!lemek ya da panic!lememek</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Yaygın Türler, Tanımlar ve Ömürlükler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Yaygın Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Tanımlar: Yaygın Davranış Tanımlama</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Ömürlük Yapısıyla Referans Doğrulama</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Otomatikleşmiş Testler Yazma</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Testler Nasıl Yazılır</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Testlerin Nasıl Çalıştığını Kontrol Etmek</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organizasyonu</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Bir G/Ç Projesi: Komut Satırı Programı Yazmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Komut Satırı Argümanlarını Ayrıştırmak</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Dosya Okumak</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Modülerliği ve Hata Yönetimini Geliştirmek için Yeniden Düzenlemek</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Test Odaklı Geliştirme ile Kütüphanenin İşlevliğini Artırmak</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Ortam Değişkenlerini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Hata Mesajlarını Standart Çıktı yerine Standart Hata Akışına Yazdırmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Fonksiyonel Dil Özellikleri: Yineleyiciler ve Kapanış İfadeleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Kapanış İfadeleri: Ortamda Tutulabilen Anonim Fonksiyonlar</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Yineleyicilerle Bir Dizi Öğeyi İşlemek</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> G/Ç Projemizi Geliştirmek</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performans Kıyaslaması: Döngüler vs. Yineleyiciler</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo ve Crates.io Hakkında Daha Fazla Bilgi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Dağıtım Profilleriyle İnşaları Özelleştirmek</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io'da Bir Kasa Paylaşmak</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Çalışma Alanları</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install ile Crates.io'dan Derlenmişleri Yüklemek</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Özel Komutlarla Cargo'yu Genişletmek</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Akıllı İşaretçiler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Yığındaki Verileri İşaretlemek için Box&lt;T&gt; Kullanmak</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Akıllı İşaretçilere Deref ile Normal Referanslar Gibi Tanım Yapmak</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop Tanımlamasıyla Temizlik Aşamasında Kod Çalıştırmak</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Referans Sayaçlı Akıllı İşaretçi</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; ve İç Değişebilirlik Modeli</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referans Döngüleri Bellek Sızdırabilir</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Korkusuz Eşzamanlılık</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Kodu Eşzamanlı Çalıştırmak için İş Parçacıklarını Kullanmak</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Konular Arasında Veri Aktarmak için İleti Geçişini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Paylaşımlı Eşzamanlık</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync ve Send Tanımlarıyla Genişletilebilir Eşzamanlılık</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust'taki Nesne Yönemimli Programlama Özellikleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Nesne Yönelimli Dillerin Karakteristik Özellikleri</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Farklı Türlerdeki Değerlere İzin Veren Özellik Tanımlarını Kullanma</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Nesneye Yönelik Tasarım Modelini Süreklemek</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Modeller ve Eşleştirme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Modeller Her Yerde Kullanılabilir</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Reddedilebilirlik: Modelin Eşleştirmede Başarısız Olup Olmayacağı</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Model Söz Dizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Gelişmiş Özellikler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Güvensiz Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Gelişmiş Tanımlar</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Gelişmiş Türler</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Gelimiş Fonksiyonlar ve Kapanış İfadeleri</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makrolar</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Projesi: Çoklu İş Parçacıklı Web Sunucusu İnşa Etmek</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Tek İş Parçacıklı Web Sunucusu İnşa Etmek</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Tek İş Parçacıklı Sunucumuzu Çok Parçacıklı Sunucuya Çevirmek</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Zarifçe Kapatmak ve Temizlemek</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Eklemeler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Anahtar Sözcükler</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatörler ve Semboller</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Türetilebilir Tanımlar</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Kullanışlı Geliştirme Araçları</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Sürümler</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Kitap'ın Çevirileri</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust ve “Gecelik Rust” Nasıl Yapıldı</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Programlama Dili</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ferhatgec/kitap" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="result-İle-kurtarılabilir-hatalar"><a class="header" href="#result-İle-kurtarılabilir-hatalar"><code>Result</code> İle Kurtarılabilir Hatalar</a></h2>
<p>Çoğu hata, programın tamamen durdurulmasını gerektirecek kadar ciddi değildir. Bazen, bir fonksiyon başarısız olduğunda, 
kolayca yorumlayabileceğiniz ve yanıt verebileceğiniz bir nedenden dolayı başarısız olur. Örneğin, bir dosyayı açmaya çalışırsanız 
ve dosya mevcut olmadığı için bu işlem başarısız olursa, işlemi sonlandırmak yerine dosyayı oluşturmak isteyebilirsiniz.</p>
<p>Bölüm 2'deki <a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">“<code>Result</code> Türü ile Potansiyel Başarısızlığı Ele Alma”</a><!-- ignore --> kısmından, 
<code>Result</code> <code>enum</code>'unun aşağıdaki gibi <code>Ok</code> ve <code>Err</code> olmak üzere iki değişken olarak tanımlandığını hatırlayın:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p><code>T</code> ve <code>E</code> yaygın tür parametreleridir: yaygın türleri Bölüm 10'da daha ayrıntılı olarak tartışacağız. 
Şu anda bilmeniz gereken şey, <code>T</code>'nin <code>Ok</code> değişkeni içinde bir başarı durumunda döndürülecek değerin türünü temsil ettiği ve <code>E</code>'nin Err 
değişkeni içinde bir başarısızlık durumunda döndürülecek hatanın türünü temsil ettiğidir. <code>Result</code> bu yaygın tür parametrelerine 
sahip olduğu için, döndürmek istediğimiz başarılı değer ile hata değerinin farklı olabileceği birçok farklı durumda <code>Result</code> türünü ve 
üzerinde tanımlı fonksiyonları kullanabiliriz.</p>
<p>Fonksiyon başarısız olabileceği için <code>Result</code> değeri döndüren bir fonksiyon çağıralım. Liste 9-3'te bir dosya açmaya çalışıyoruz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">Liste 9-3: Dosya açmak</span></p>
<p><code>File::open</code> öğesinin dönüş türü <code>Result&lt;T, E&gt;</code>'dir. Yaygın parametre <code>T</code>, <code>File::open</code> tarafından başarı değerinin türü olan 
<code>std::fs::File</code> ile tanımlanmıştır, bu da bir dosya tanıtıcısıdır. Hata değerinde kullanılan <code>E</code>'nin türü <code>std::io::Error</code>'dır. 
Bu dönüş türü, <code>File::open</code> çağrısının başarılı olabileceği ve okuyabileceğimiz veya yazabileceğimiz bir dosya tanıtıcısı döndürebileceği 
anlamına gelir. Fonksiyon çağrısı başarısız da olabilir: örneğin, dosya mevcut olmayabilir veya dosyaya erişim iznimiz olmayabilir. 
<code>File::open</code> fonksiyonunun bize başarılı ya da başarısız olduğunu söyleyecek ve aynı zamanda bize dosya tanıtıcısı ya da hata 
bilgisi verecek bir yolu olmalıdır. Bu bilgi tam olarak <code>Result</code> <code>enum</code>'unun anlattığı şeydir.</p>
<p><code>File::open</code> fonksiyonunun başarılı olduğu durumda, <code>greeting_file_result</code> değişkenindeki değer, 
bir dosya tanıtıcısı içeren <code>Ok</code> tanımı olacaktır. Başarısız olduğu durumda, <code>greeting_file_result</code> değişkenindeki değer, 
meydana gelen hata türü hakkında daha fazla bilgi içeren <code>Err</code> tanımı olacaktır.</p>
<p><code>File::open</code>'ın döndürdüğü değere bağlı olarak farklı eylemler gerçekleştirmek için Liste 9-3'teki koda ekleme yapmamız gerekir. 
Liste 9-4, Bölüm 6'da tartıştığımız temel bir araç olan <code>match</code> ifadesini kullanarak <code>Result</code>'u ele almanın bir yolunu göstermektedir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&quot;Problem opening the file: {:?}&quot;, error),
    };
}
</code></pre></pre>
<p><span class="caption">Liste 9-4: Döndürülebilecek <code>Result</code> değişkenlerini işlemek için <code>match</code> 
ifadesi kullanma</span></p>
<p><code>Option</code> <code>enum</code>'u gibi <code>Result</code> <code>enum</code>'u ve varyantlarının da <code>prelude</code> tarafından kapsama alındığına dikkat edin, 
bu nedenle <code>match</code> kollarında <code>Ok</code> ve <code>Err</code> varyantlarından önce <code>Result::</code> belirtmemize gerek yoktur.</p>
<p><code>Result</code>, <code>Ok</code> olduğunda, bu kod <code>Ok</code> değişkeninden iç dosya değerini döndürür ve daha sonra bu dosya tanıtıcısı 
değerini <code>greeting_file</code> değişkenine atar. <code>match</code>'ten sonra, dosya tanıtıcısını okuma veya yazma için kullanabiliriz.</p>
<p><code>match</code>'in diğer kolu, <code>File::open</code>'dan <code>Err</code> değeri aldığımız durumu ele alır. Bu örnekte, <code>panic!</code> makrosunu çağırmayı seçtik. 
Geçerli dizinimizde <code>hello.txt</code> adında bir dosya yoksa ve bu kodu çalıştırırsak, <code>panic!</code> makrosundan aşağıdaki çıktıyı görürüz:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Her zamanki gibi, bu çıktı bize tam olarak neyin yanlış gittiğini söyler.</p>
<h3 id="farklı-hatalarda-eşleştirme"><a class="header" href="#farklı-hatalarda-eşleştirme">Farklı Hatalarda Eşleştirme</a></h3>
<p>Liste 9-4'teki kod, <code>File::open</code>'ın neden başarısız olduğuna bakmadan <code>panic!</code> yapacaktır. 
Ancak, farklı başarısızlık nedenleri için farklı eylemler gerçekleştirmek istiyoruz: <code>File::open</code> dosya mevcut 
olmadığı için başarısız olduysa, dosyayı oluşturmak ve yeni dosyanın tanıtıcısını döndürmek istiyoruz. 
<code>File::open</code> başka bir nedenle başarısız olduysa - örneğin, dosyayı açma iznimiz olmadığı için - kodun yine de Liste 9-4'te 
olduğu gibi <code>panic!</code> yapmasını istiyoruz. Bunun için Liste 9-5'te gösterilen bir iç <code>match</code> ifadesi ekleriz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Problem creating the file: {:?}&quot;, e),
            }
            other_error =&gt; {
                panic!(&quot;Problem opening the file: {:?}&quot;, other_error);
            }
        }
    };
}
</code></pre>
<p><span class="caption">Liste 9-5: Farklı türdeki hataları farklı şekillerde ele alma</span></p>
<p><code>File::open</code>'ın <code>Err</code> değişkeni içinde döndürdüğü değerin türü, standart kütüphane tarafından sağlanan bir yapı olan 
<code>io::Error</code>'dır. Bu <code>struct</code>, bir <code>io::ErrorKind</code> değeri elde etmek için çağırabileceğimiz bir <code>kind</code> metoduna sahiptir. 
<code>io::ErrorKind</code> <code>enum</code>'u standart kütüphane tarafından sağlanır ve bir <code>io</code> işleminden kaynaklanabilecek farklı hata türlerini temsil 
eden varyantlara sahiptir. Kullanmak istediğimiz değişken, açmaya çalıştığımız dosyanın henüz mevcut olmadığını gösteren <code>ErrorKind::NotFound</code>'dur. 
Bu yüzden <code>greeting_file_result</code> ile eşleşiyoruz, ancak <code>error.kind()</code> ile de bir iç <code>match</code>'imiz var.</p>
<p>İç <code>match</code>'te kontrol etmek istediğimiz koşul, <code>error.kind()</code> tarafından döndürülen değerin <code>ErrorKind</code> <code>enum</code>'unun <code>NotFound</code> varyantı 
olup olmadığıdır. Eğer varsa, dosyayı <code>File::create</code> ile oluşturmaya çalışırız. Ancak, <code>File::create</code> de başarısız olabileceğinden, 
iç <code>match</code> ifadesinde ikinci bir kola ihtiyacımız var. Dosya oluşturulamadığında, farklı bir hata mesajı yazdırılır. 
Dış <code>match</code>'in ikinci kolu aynı kalır, böylece program eksik dosya hatası dışındaki herhangi bir hatada panik yapar.</p>
<blockquote>
<h3 id="resultt-e-ile-match-kullanmanın-alternatifleri"><a class="header" href="#resultt-e-ile-match-kullanmanın-alternatifleri"><code>Result&lt;T, E&gt;</code> ile <code>match</code> Kullanmanın Alternatifleri</a></h3>
<p>Çok fazla <code>match</code> var! <code>match</code> ifadesi çok kullanışlıdır ancak aynı zamanda çok ilkeldir. 
Bölüm 13'te, <code>Result&lt;T, E&gt;</code> üzerinde tanımlanan birçok metodla birlikte kullanılan kapanış ifadeleri hakkında bilgi 
edineceksiniz. Bu metodlar, kodunuzdaki <code>Result&lt;T, E&gt;</code> değerlerini işlerken <code>match</code> kullanmaktan daha özlü olabilir.</p>
<p>Örneğin, Liste 9-5'te gösterilen aynı mantığı bu kez kapanış ifadelerini ve <code>unwrap_or_else</code> metodunu kullanarak 
yazmanın başka bir yolunu aşağıda bulabilirsiniz:</p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| {
                panic!(&quot;Problem creating the file: {:?}&quot;, error);
            })
        } else {
            panic!(&quot;Problem opening the file: {:?}&quot;, error);
        }
    });
}
</code></pre>
<p>Bu kod Liste 9-5 ile aynı davranışa sahip olsa da, herhangi bir <code>match</code> ifadesi içermez ve okunması daha temizdir. 
Bölüm 13'ü okuduktan sonra bu örneğe geri dönün ve standart kütüphane dokümantasyonundan <code>unwrap_or_else</code> metoduna bakın. 
Bu metodlardan çok daha fazlası, hatalarla uğraşırken iç içe geçmiş büyük <code>match</code> ifadelerini temizleyebilir.</p>
</blockquote>
<h3 id="panik-hatası-kısayolları-unwrap-ve-expect"><a class="header" href="#panik-hatası-kısayolları-unwrap-ve-expect">Panik Hatası Kısayolları: <code>unwrap</code> ve <code>expect</code></a></h3>
<p><code>match</code> kullanmak yeterince işe yarar, ancak biraz ayrıntılı olabilir ve amacı her zaman iyi iletmez. 
<code>Result&lt;T, E&gt;</code> türü, çeşitli ve daha spesifik görevleri yerine getirmek için üzerinde tanımlanmış birçok yardımcı metoda sahiptir. 
<code>unwrap</code> metodu, tıpkı Liste 9-4'te yazdığımız <code>match</code> ifadesi gibi uygulanan bir kısayol yöntemidir. 
<code>Result</code> değeri <code>Ok</code> varyantı ise unwrap, <code>Ok</code> içindeki değeri döndürür. <code>Result</code> değeri <code>Err</code> değişkeniyse, 
<code>unwrap</code> bizim için <code>panic!</code> makrosunu çağırır. İşte <code>unwrap</code>'in iş başında olduğu bir örnek:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<p>Bu kodu <em>hello.txt</em> dosyası olmadan çalıştırırsak, <code>unwrap</code> yönteminin yaptığı <code>panic!</code> çağrısından
bir hata mesajı görürüz:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<p>Benzer şekilde, <code>expect</code> metodu da <code>panic!</code> hata mesajını seçmemizi sağlar. <code>unwrap</code> yerine <code>expect</code> kullanmak ve 
iyi hata mesajları sağlamak, amacınızı iletebilir ve paniğin kaynağını bulmayı kolaylaştırabilir. 
<code>expect</code>'in söz dizimi şu şekildedir:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;)
        .expect(&quot;hello.txt should be included in this project&quot;);
}
</code></pre></pre>
<p><code>expect</code>'i <code>unwrap</code> ile aynı şekilde kullanırız: dosya tanıtıcısını döndürmek veya <code>panic!</code> makrosunu çağırmak için. 
<code>expect</code> tarafından <code>panic!</code> çağrısında kullanılan hata mesajı, <code>unwrap</code>'ın kullandığı varsayılan <code>panic!</code> mesajı yerine 
<code>expect</code>'e aktardığımız parametre olacaktır. İşte böyle görünüyor:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at 'hello.txt should be included in this project: Error
{ repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<p>Üretim kalitesindeki kodlarda, çoğu Rustsever <code>unwrap</code> yerine <code>expect</code>'i seçer ve işlemin neden her zaman 
başarılı olmasının beklendiği hakkında daha fazla bağlam verir. Bu şekilde, varsayımlarınızın yanlış olduğu kanıtlanırsa, 
hata ayıklamada kullanabileceğiniz daha fazla bilgiye sahip olursunuz.</p>
<h3 id="hataların-yayılması"><a class="header" href="#hataların-yayılması">Hataların Yayılması</a></h3>
<p>Bir fonksiyonun süreklemesi başarısız olabilecek bir şeyi çağırdığında, hatayı fonksiyonun kendi içinde ele almak yerine, 
hatayı çağıran koda döndürebilirsiniz, böylece işlev ne yapacağına karar verebilir. 
Bu, hatanın yayılması olarak bilinir ve hatanın nasıl ele alınması gerektiğini belirleyen daha fazla bilgi veya 
mantığın kodunuzun bağlamında mevcut olandan daha fazla olabileceği çağıran koda daha fazla kontrol sağlar.</p>
<p>Örneğin, Liste 9-6'da bir dosyadan kullanıcı adı okuyan bir fonksiyon gösterilmektedir. 
Dosya mevcut değilse veya okunamıyorsa, bu fonksiyon; hataları, fonksiyonu çağıran koda döndürür.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open(&quot;hello.txt&quot;);

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 9-6: <code>match</code> kullanarak arama koduna hata 
döndüren bir fonksiyon</span></p>
<p>Bu fonksiyon çok daha kısa bir şekilde yazılabilir, ancak hata işlemeyi keşfetmek için çoğunu manuel olarak yaparak başlayacağız; 
sonunda daha kısa yolu göstereceğiz. Önce fonksiyonun dönüş tipine bakalım: <code>Result&lt;String, io::Error&gt;</code>. 
Bu, fonksiyonun <code>Result&lt;T, E&gt;</code> türünde bir değer döndürdüğü anlamına gelir; burada yaygın parametre <code>T</code>, somut <code>String</code> türüyle 
ve yaygın tür <code>E</code>, somut <code>io::Error</code> tipiyle doldurulmuştur.</p>
<p>Bu fonksiyon sorunsuz bir şekilde başarılı olursa, bu fonksiyonu çağıran kod, bu fonksiyonun dosyadan okuduğu kullanıcı 
adı olan bir <code>String</code> içeren bir <code>Ok</code> değeri alacaktır. Bu fonksiyon herhangi bir sorunla karşılaşırsa, çağıran kod, 
sorunların ne olduğu hakkında daha fazla bilgi içeren <code>io::Error</code> tanımını tutan bir <code>Err</code> değeri alır. 
Bu fonksiyonun geri dönüş türü olarak <code>io::Error</code>'ı seçtik çünkü bu fonksiyonun gövdesinde çağırdığımız ve başarısız olabilecek 
her iki işlemden (<code>File::open</code> fonksiyonu ve <code>read_to_string</code> metodu) dönen hata değerinin türü budur.</p>
<p>Fonksiyonun gövdesi <code>File::open</code> fonksiyonunu çağırarak başlar. Ardından <code>Result</code> değerini Liste 9-4'teki <code>match</code>'e benzer 
bir <code>match</code> ile ele alıyoruz. <code>File::open</code> başarılı olursa, <code>file</code> kalıp değişkenindeki dosya tanıtıcısı <code>username_file</code> değişkenindeki 
değer olur ve fonksiyon devam eder. <code>Err</code> durumunda, <code>panic!</code> çağrısı yapmak yerine, <code>return</code> anahtar sözcüğünü kullanarak 
fonksiyondan erken döneriz ve <code>File::open</code>'dan gelen hata değerini, şimdi <code>e</code> kalıp değişkeninde, bu fonksiyonun hata değeri olarak
çağıran koda geri aktarırız.</p>
<p>Dolayısıyla, <code>username_file</code> içinde bir dosya tanıtıcımız varsa, fonksiyon <code>username</code> değişkeninde yeni bir <code>String</code> oluşturur ve 
dosyanın içeriğini <code>username</code> içine okumak için <code>username_file</code> içindeki dosya tanıtıcısında <code>read_to_string</code> metodunu çağırır. 
<code>read_to_string</code> metodu da <code>Result</code> döndürür, çünkü <code>File::open</code> başarılı olsa bile başarısız olabilir. 
Bu nedenle, <code>Result</code>'u işlemek için başka bir <code>match</code>'e ihtiyacımız var: <code>read_to_string</code> başarılı olursa, fonksiyonumuz başarılı olmuştur ve 
şimdi bir <code>Ok</code>'a sarılmış <code>username</code>'de bulunan dosyadan kullanıcı adını döndürürüz. <code>read_to_string</code> başarısız olursa, 
<code>File::open</code>'ın dönüş değerini işleyen <code>match</code>'te hata değerini döndürdüğümüz şekilde hata değerini döndürürüz. Ancak, 
bu fonksiyondaki son ifade olduğu için açıkça <code>return</code> dememize gerek yoktur.</p>
<p>Bu kodu çağıran kod daha sonra kullanıcı adı içeren bir <code>Ok</code> değeri ya da <code>io::Error</code> içeren bir <code>Err</code> değeri almayı işleyecektir. 
Bu değerlerle ne yapılacağına çağıran kod karar verir. Çağıran kod bir <code>Err</code> değeri alırsa, <code>panic!</code> çağrısı yapabilir ve programı 
çökertebilir, varsayılan bir kullanıcı adı kullanabilir veya örneğin kullanıcı adını bir dosyadan başka bir yerden arayabilir. 
Çağıran kodun gerçekte ne yapmaya çalıştığı hakkında yeterli bilgiye sahip değiliz, bu nedenle uygun şekilde işlemesi için 
tüm başarı veya hata bilgilerini yukarı doğru yayıyoruz.</p>
<p>Bu hata yayma eğilimi Rust'ta o kadar yaygındır ki, Rust bunu kolaylaştırmak için <code>?</code> soru işareti operatörünü sağlar.</p>
<h4 id="hataları-yaymak-İçin-bir-kısayol--operatörü"><a class="header" href="#hataları-yaymak-İçin-bir-kısayol--operatörü">Hataları Yaymak İçin Bir Kısayol: <code>?</code> Operatörü</a></h4>
<p>Liste 9-7, Liste 9-6'dakiyle aynı fonksiyona sahip bir <code>read_username_from_file</code> süreklemesini göstermektedir, 
ancak bu sürekleme <code>?</code> işlecini kullanmaktadır.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open(&quot;hello.txt&quot;)?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 9-7: <code>?</code> operatörünü kullanarak arama koduna hata döndüren bir
fonksiyon</span></p>
<p>Bir <code>Result</code> değerinden sonra yerleştirilen <code>?</code> işareti, Liste 9-6'da <code>Result</code> değerlerini işlemek için tanımladığımız 
<code>match</code> ifadeleriyle hemen hemen aynı şekilde çalışacak şekilde tanımlanmıştır. <code>Result</code>'un değeri bir <code>Ok</code> ise, <code>Ok</code>'un içindeki 
değer bu ifadeden döndürülür ve program devam eder. Değer <code>Err</code> ise, <code>return</code> anahtar sözcüğünü kullanmışız gibi tüm fonksiyondan <code>Err</code> 
döndürülür, böylece hata değeri çağıran koda yayılır.</p>
<p>Liste 9-6'daki <code>match</code> ifadesinin yaptığı ile <code>?</code> operatörünün yaptığı arasında bir fark vardır: <code>?</code> operatörünün çağrıldığı 
hata değerleri, standart kütüphanedeki <code>From</code> tanımında tanımlanan ve değerleri bir türden diğerine dönüştürmek için kullanılan <code>from</code> 
fonksiyonundan geçer. <code>?</code> işleci <code>from</code> fonksiyonunu çağırdığında, alınan hata türü geçerli fonksiyonun dönüş türünde tanımlanan 
hata türüne dönüştürülür. Bu, bir fonksiyonun birçok farklı nedenden dolayı başarısız olsa bile, bir fonksiyonun başarısız 
olabileceği tüm yolları temsil etmek için tek bir hata türü döndürdüğünde kullanışlıdır.</p>
<p>Örneğin, Liste 9-7'deki <code>read_username_from_file</code> fonksiyonunu <code>OurError</code> adında tanımladığımız özel bir hata türünü döndürecek şekilde
değiştirebiliriz. Bir <code>io::Error</code>'dan bir <code>OurError</code> tanımı oluşturmak için <code>impl From&lt;io::Error&gt; for OurError</code> olarak tanımlarsak,
<code>read_username_from_file</code>'ın gövdesindeki <code>?</code> operatör çağrıları, fonksiyona daha fazla kod eklemeye gerek kalmadan <code>from</code>'u çağıracak ve 
hata türlerini dönüştürecektir.</p>
<p>Liste 9-7 bağlamında, <code>File::open</code> çağrısının sonundaki <code>?</code>, <code>Ok</code> içindeki değeri <code>username_file</code> değişkenine döndürecektir. 
Bir hata oluşursa, <code>?</code> işleci tüm fonksiyonlardan erken dönecek ve çağıran koda herhangi bir <code>Err</code> değeri verecektir. 
Aynı şey <code>read_to_string</code> çağrısının sonundaki <code>?</code> için de geçerlidir.</p>
<p><code>?</code> işleci, çok sayıda kopyala-yapıştır kodu ortadan kaldırır ve bu fonksiyonun süreklenmesini de daha basit hale getirir. 
Hatta Liste 9-8'de gösterildiği gibi, <code>?</code>'den hemen sonra metod çağrılarını zincirleyerek bu kodu daha da kısaltabiliriz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 9-8: <code>?</code> operatöründen sonra zincirleme yöntemi çağrıları</span></p>
<p><code>username</code>'de yeni <code>String</code>'in oluşturulmasını fonksiyonun başına taşıdık; sıkıntısız çalışacaktır. 
Bir <code>username_file</code> değişkeni oluşturmak yerine <code>read_to_string</code> çağrısını doğrudan <code>File::open(&quot;hello.txt&quot;)?</code> sonucunun üzerine zincirledik. 
Hala bir <code>?</code> <code>read_to_string</code> çağrısının sonunda ve hata döndürmek yerine hem <code>File::open</code> hem de <code>read_to_string</code> başarılı olduğunda 
<code>username</code>'i içeren <code>Ok</code> değerini döndürürüz. İşlevsellik yine Liste 9-6 ve Liste 9-7'deki ile aynıdır; bu sadece yazmanın farklı, 
daha ergonomik bir yolu.</p>
<p>Liste 9-9, <code>fs::read_to_string</code> kullanarak bunu daha da kısaltmanın bir yolunu gösterir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 9-9: Dosyayı açıp okumak yerine <code>fs::read_to_string</code> kullanma</span></p>
<p>Bir dosyayı bir <code>String</code>'e okumak oldukça yaygın bir işlemdir, bu nedenle standart kütüphane dosyayı açan, 
yeni bir <code>String</code> oluşturan, dosyanın içeriğini okuyan, içeriği bu <code>String</code>'e atayan ve geri döndüren kullanışlı <code>fs::read_to_string</code> 
fonksiyonunu sağlar. Elbette, <code>fs::read_to_string</code> kullanmak bize tüm hata işlemlerini açıklama fırsatı vermez, bu yüzden önce uzun yoldan yaptık.</p>
<h4 id="-operatörünün-kullanılabileceği-yerler"><a class="header" href="#-operatörünün-kullanılabileceği-yerler"><code>?</code> Operatörünün Kullanılabileceği Yerler</a></h4>
<p><code>?</code> işleci yalnızca dönüş türü <code>?</code> işlecinin kullanıldığı değerle uyumlu olan fonksiyonlarda kullanılabilir. 
Bunun nedeni, <code>?</code> işlecinin, Liste 9-6'da tanımladığımız <code>match</code> ifadesiyle aynı şekilde, bir değerin fonksiyondan erken dönüşünü 
gerçekleştirmek üzere tanımlanmış olmasıdır. Liste 9-6'da, <code>match</code> <code>Result</code> değeri kullanıyordu ve erken dönüş kolu <code>Err(e)</code> 
değeri döndürüyordu. Bu dönüşle uyumlu olması için fonksiyonun dönüş tipi bir <code>Result</code> olmalıdır.</p>
<p>Liste 9-10'da, <code>?</code> operatörünü <code>?</code> kullandığımız değerin türüyle uyumsuz bir geri dönüş türüne sahip <code>main</code> 
fonksiyonunda kullanırsak alacağımız hataya bakalım:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<p><span class="caption">Liste 9-10: <code>()</code> döndüren <code>main</code> fonksiyonunda <code>?</code> kullanmaya çalışırsak derlenmeyecektir</span></p>
<p>Bu kod, başarısız olabilecek bir dosya açar. <code>?</code> işleci <code>File::open</code> tarafından döndürülen <code>Result</code> değerini takip eder, 
ancak bu <code>main</code> fonksiyonunun dönüş türü <code>Result</code> değil <code>()</code>'dir. Bu kodu derlediğimizde aşağıdaki hata mesajını alırız:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:36
  |
3 | / fn main() {
4 | |     let f = File::open(&quot;hello.txt&quot;)?;
  | |                                    ^ cannot use the `?` operator in a function that returns `()`
5 | | }
  | |_- this function should return `Result` or `Option` to accept `?`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` due to previous error
</code></pre>
<p>Bu hata, <code>?</code> operatörünü yalnızca <code>Result</code>, <code>Option</code> veya <code>FromResidual</code>'ı sürekleyen başka bir tür döndüren bir 
fonksiyonda kullanabileceğimize işaret eder.</p>
<p>Hatayı düzeltmek için iki seçeneğiniz vardır. Seçeneklerden biri, bunu engelleyen herhangi bir kısıtlama olmadığı sürece fonksiyonunuzun dönüş 
türünü <code>?</code> operatörünü kullandığınız değerle uyumlu olacak şekilde değiştirmektir. Diğer teknik ise, <code>Result&lt;T, E&gt;</code>'yi uygun olan şekilde 
işlemek için <code>match</code> veya <code>Result&lt;T, E&gt;</code> yöntemlerinden birini kullanmaktır.</p>
<p>Hata mesajında ayrıca <code>?</code> operatörünün <code>Option&lt;T&gt;</code> değerleriyle de kullanılabileceği belirtilmiştir. <code>Result</code> üzerinde <code>?</code> kullanımında olduğu 
gibi, <code>Option</code> üzerinde <code>?</code> kullanımını da yalnızca <code>Option</code> döndüren bir fonksiyonda kullanabilirsiniz. 
Bir <code>Option&lt;T&gt;</code> üzerinde çağrıldığında <code>?</code> operatörünün davranışı, bir <code>Result&lt;T, E&gt;</code> üzerinde çağrıldığında gösterdiği davranışa benzer: 
değer <code>None</code> ise, <code>None</code> o noktada fonksiyondan erken döndürülür. Değer <code>Some</code> ise, <code>Some</code> içindeki değer ifadenin sonuç değeridir ve 
fonksiyon devam eder. Liste 9-11'de, verilen metindeki ilk satırın son karakterini bulan bir fonksiyon örneği vardır:</p>
<pre><pre class="playground"><code class="language-rust">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line(&quot;Hello, world\nHow are you today?&quot;),
</span><span class="boring">        Some('d')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(&quot;&quot;), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line(&quot;\nhi&quot;), None);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 9-11: Bir <code>Option&lt;T&gt;</code> değerinde <code>?</code> 
operatörünü kullanma</span></p>
<p>Bu fonksiyon <code>Option&lt;char&gt;</code> döndürür, çünkü orada bir karakter olması mümkündür, ancak olmaması da mümkündür. 
Bu kod, metin dizgisi dilim argümanını alır ve dizedeki satırlar üzerinde bir yineleyici döndüren <code>lines</code> metodunu çağırır. 
Bu fonksiyon ilk satırı incelemek istediğinden, yineleyiciden ilk değeri almak için yineleyicide <code>next</code> öğesini çağırır. 
Eğer <code>text</code> boş dizgiyse, <code>next</code>'e yapılan bu çağrı <code>None</code> değerini döndürür, bu durumda durdurmak için <code>?</code> kullanırız ve 
<code>last_char_of_first_line</code>'dan <code>None</code> değerini döndürürüz. <code>text</code> boş değilse, <code>next</code> çağrısı metindeki ilk satırın dizgi dilimini içeren 
<code>Some</code> değerini döndürür.</p>
<p><code>?</code> dizgi dilimini çıkarır ve karakterlerinin bir yineleyicisini almak için bu dizgi dilimi üzerinde <code>chars</code>'ı çağırabiliriz. 
Bu ilk satırdaki son karakterle ilgilendiğimizden, yineleyicideki son öğeyi döndürmek için <code>last</code> öğesini çağırırız. 
Bu bir <code>Option</code>'dur çünkü ilk satırın boş bir dizgi olması mümkündür, örneğin metin boş bir satırla başlıyorsa ancak <code>&quot;\nhi&quot;</code> gibi diğer 
satırlarda karakterler varsa. Ancak, ilk satırda bir son karakter varsa, <code>Some</code> değişkeninde döndürülür. Ortadaki <code>?</code> operatörü bize 
bu mantığı ifade etmek için kısa bir yol sunar ve fonksiyonu tek bir satırda yazmamıza olanak tanır. 
<code>Option</code> üzerinde <code>?</code> operatörünü kullanamasaydık, bu mantığı daha fazla metod çağrısı veya bir <code>match</code> ifadesi kullanarak uygulamamız gerekirdi.
Kısaca Rust bu ameleliği sizin üzerinizden alır.</p>
<p><code>Result</code> döndüren bir fonksiyonda bir <code>Result</code> üzerinde <code>?</code> operatörünü kullanabileceğinizi ve <code>Option</code> döndüren bir 
fonksiyonda bir <code>Option</code> üzerinde <code>?</code> operatörünü kullanabileceğinizi, ancak karıştırıp eşleştiremeyeceğinizi unutmayın. 
<code>?</code> işleci bir <code>Result</code>'u otomatik olarak <code>Option</code>'a dönüştürmez veya tam tersini yapmaz; bu gibi durumlarda, dönüştürmeyi 
açıkça yapmak için <code>Result</code> üzerinde <code>Ok</code> metodu veya <code>Option</code> üzerinde <code>ok_or</code> metodu gibi metodları kullanabilirsiniz.</p>
<p>Şimdiye kadar kullandığımız tüm <code>main</code> fonksiyonlar <code>()</code> döndürüyordu. <code>main</code> fonksiyonu özeldir, çünkü çalıştırılabilir 
programların giriş ve çıkış noktasıdır ve programların beklendiği gibi davranması için dönüş türünün ne olabileceği 
konusunda kısıtlamalar vardır.</p>
<p>Neyse ki <code>main</code> aynı zamanda bir <code>Result&lt;(), E&gt;</code> de döndürebilir. Liste 9-12, Liste 9-10'daki kodu içerir, 
ancak <code>main</code>'in dönüş türünü <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> olarak değiştirdik ve sonuna bir dönüş değeri 
<code>Ok(())</code> ekledik. Bu kod şimdi derlenecektir:</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open(&quot;hello.txt&quot;)?;

    Ok(())
}
</code></pre>
<p><span class="caption">Liste 9-12: <code>main</code>'i <code>Result&lt;(), E&gt;</code> döndürecek şekilde değiştirmek, <code>Result</code> değerlerinde 
<code>?</code> operatörünün kullanılmasına izin verir</span></p>
<p><code>Box&lt;dyn Error&gt;</code> türü bir <em>tanım nesnesidir</em> ve 17. Bölümdeki 
<a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Farklı Türlerde Değerlere İzin Veren Tanım Nesnelerini Kullanma”</a><!-- ignore --> kısmında bundan bahsedeceğiz. 
Şimdilik, <code>Box&lt;dyn Error&gt;</code> türünü “hatanın her türlüsü” olarak okuyabilirsiniz. Hata türü <code>Box&lt;dyn Error&gt;</code> olan bir <code>main</code>'de, 
<code>Result</code> değeri üzerinde <code>?</code> kullanılmasına izin verilir, çünkü herhangi bir <code>Err</code> değerinin erken döndürülmesine izin verir. 
Bu <code>main</code>'in gövdesi yalnızca <code>std::io::Error</code> türünde hatalar döndürecek olsa da, <code>Box&lt;dyn Error&gt;</code> belirtilerek, 
<code>main</code> gövdesine başka hatalar döndüren başka kodlar eklense bile bu imza doğru olmaya devam edecektir.</p>
<p><code>main</code>, <code>Result&lt;(), E&gt;</code> döndürdüğünde, <code>main</code> <code>Ok(())</code> döndürürse yürütülebilir dosya <code>0</code> değeriyle çıkar ve <code>main</code> <code>Err</code> değeri döndürürse 
<em>sıfır olmayan</em> bir değerle çıkar. C'de yazılmış çalıştırılabilir dosyalar çıktıklarında tam sayı döndürür: 
başarıyla çıkan programlar <code>0</code> döndürür ve hata veren programlar 0 dışında bir tam sayı döndürür. 
Rust da bu kuralla uyumlu olmak için çalıştırılabilir dosyadan tam sayı döndürür.</p>
<p><code>main</code> fonksiyonu, <code>ExitCode</code> döndüren bir fonksiyon raporu içeren <code>std::process::Termination</code> tanımını sürekleyen herhangi bir türü 
döndürebilir. Kendi türleriniz için <code>Termination</code> tanımını sürekleme hakkında daha fazla bilgi için standart kütüphane 
dokümantasyonuna bakın.</p>
<p><code>panic!</code> çağrısı yapmanın veya <code>Result</code> döndürmenin ayrıntılarını tartıştığımıza göre, 
hangi durumlarda hangisinin kullanılmasının uygun olacağına nasıl karar verileceği konusuna geri dönelim.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-01-unrecoverable-errors-with-panic.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch09-03-to-panic-or-not-to-panic.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-01-unrecoverable-errors-with-panic.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch09-03-to-panic-or-not-to-panic.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>


    </body>
</html>
