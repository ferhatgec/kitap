<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>UTF-8 ile Kodlanmış Dizgiyi Tutmak - Rust Programlama Dili</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Rust Programlama Dili</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Ön söz</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Başlangıç</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Başlarken</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Yükleme</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Merhaba, Dünya!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Merhaba, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Tahmin Oyunu Programlamak</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Yaygın Programlama Kavramları</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Değişkenler ve Değişebilirlik</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Fonksiyonlar</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Yorum Satırları</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrol Akışı</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Sahipliği Anlamak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Sahiplik Nedir?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referanslar ve Ödünç Alma Mekanizması</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Dilim Türü</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> İlintili Verileri Yapılandırmak için Yapıları Kullanmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Yapıları Tanımlamak ve Örneklendirmek</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Yapıları Kullanan Örnek Bir Program</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Metod Söz dizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Numaralandırılmış Yapılar ve Model Eşleme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Numaralandırılmış Yapı Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match Kontrol Akış Yapısı</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let ile Kısa Kontrol Akış Yapısı</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Büyüyen Projeleri Paketler, Kasalar ve Modüllerle Yönetme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paketler ve Kasalar</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Gizlilik ve Kontrol Kapsamı için Modüller Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Modül Ağacındaki bir Öğeyi Referanslama Yolları</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use Kullanarak Yolları Kapsama Getirmek</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Modülleri Farklı Dosyalara Ayırmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Yaygın Koleksiyon Türleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Veri Listelerini Vektörlerle Tutmak</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html" class="active"><strong aria-hidden="true">8.2.</strong> UTF-8 ile Kodlanmış Dizgiyi Tutmak</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> İlişkili Değerlerle Anahtarları Saklamak</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Hata Yönetimi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! ile Kurtarılamayan Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result ile Kurtarılabilir Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!lemek ya da panic!lememek</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Yaygın Türler, Tanımlar ve Ömürlükler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Yaygın Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Tanımlar: Yaygın Davranış Tanımlama</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Ömürlük Yapısıyla Referans Doğrulama</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Otomatikleşmiş Testler Yazma</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Testler Nasıl Yazılır</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Testlerin Nasıl Çalıştığını Kontrol Etmek</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organizasyonu</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Bir G/Ç Projesi: Komut Satırı Programı Yazmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Komut Satırı Argümanlarını Ayrıştırmak</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Dosya Okumak</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Modülerliği ve Hata Yönetimini Geliştirmek için Yeniden Düzenlemek</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Test Odaklı Geliştirme ile Kütüphanenin İşlevliğini Artırmak</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Ortam Değişkenlerini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Hata Mesajlarını Standart Çıktı yerine Standart Hata Akışına Yazdırmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Fonksiyonel Dil Özellikleri: Yineleyiciler ve Kapanış İfadeleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Kapanış İfadeleri: Ortamda Tutulabilen Anonim Fonksiyonlar</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Yineleyicilerle Bir Dizi Öğeyi İşlemek</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> G/Ç Projemizi Geliştirmek</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performans Kıyaslaması: Döngüler vs. Yineleyiciler</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo ve Crates.io Hakkında Daha Fazla Bilgi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Dağıtım Profilleriyle İnşaları Özelleştirmek</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io'da Bir Kasa Paylaşmak</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Çalışma Alanları</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install ile Crates.io'dan Derlenmişleri Yüklemek</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Özel Komutlarla Cargo'yu Genişletmek</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Akıllı İşaretçiler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Yığındaki Verileri İşaretlemek için Box&lt;T&gt; Kullanmak</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Akıllı İşaretçilere Deref ile Normal Referanslar Gibi Tanım Yapmak</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop Tanımlamasıyla Temizlik Aşamasında Kod Çalıştırmak</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Referans Sayaçlı Akıllı İşaretçi</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; ve İç Değişebilirlik Modeli</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referans Döngüleri Bellek Sızdırabilir</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Korkusuz Eşzamanlılık</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Kodu Eşzamanlı Çalıştırmak için İş Parçacıklarını Kullanmak</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Konular Arasında Veri Aktarmak için İleti Geçişini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Paylaşımlı Eşzamanlık</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync ve Send Tanımlarıyla Genişletilebilir Eşzamanlılık</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust'taki Nesne Yönemimli Programlama Özellikleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Nesne Yönelimli Dillerin Karakteristik Özellikleri</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Farklı Türlerdeki Değerlere İzin Veren Özellik Tanımlarını Kullanma</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Nesneye Yönelik Tasarım Modelini Süreklemek</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Modeller ve Eşleştirme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Modeller Her Yerde Kullanılabilir</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Reddedilebilirlik: Modelin Eşleştirmede Başarısız Olup Olmayacağı</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Model Söz Dizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Gelişmiş Özellikler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Güvensiz Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Gelişmiş Tanımlar</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Gelişmiş Türler</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Gelimiş Fonksiyonlar ve Kapanış İfadeleri</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makrolar</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Projesi: Çoklu İş Parçacıklı Web Sunucusu İnşa Etmek</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Tek İş Parçacıklı Web Sunucusu İnşa Etmek</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Tek İş Parçacıklı Sunucumuzu Çok Parçacıklı Sunucuya Çevirmek</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Zarifçe Kapatmak ve Temizlemek</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Eklemeler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Anahtar Sözcükler</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatörler ve Semboller</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Türetilebilir Tanımlar</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Kullanışlı Geliştirme Araçları</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Sürümler</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Kitap'ın Çevirileri</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust ve “Gecelik Rust” Nasıl Yapıldı</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Programlama Dili</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ferhatgec/kitap" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="utf-8-kodlu-metni-dizgilerde-saklama"><a class="header" href="#utf-8-kodlu-metni-dizgilerde-saklama">UTF-8 Kodlu Metni Dizgilerde Saklama</a></h2>
<p>Dizgilerden Bölüm 4'te bahsetmiştik, ancak şimdi onlara daha derinlemesine bakacağız. 
Yeni Rustseverler genellikle üç nedenden dolayı dizgilere takılırlar: Rust'ın olası hataları açığa çıkarma eğilimi, 
dizgilerin birçok programcının düşündüğünden daha karmaşık bir veri yapısı olması ve UTF-8. 
Bu faktörler, diğer programlama dillerinden geldiğinizde zor görünebilecek bir şekilde birleşir.</p>
<p>Dizgileri koleksiyonlar bağlamında ele alıyoruz çünkü dizgiler bir bayt koleksiyonu ve bu baytlar metin olarak yorumlandığında yararlı 
işlevler sağlayan bazı metodlar olarak uygulanmaktadır. Bu bölümde, <code>String</code> üzerinde her koleksiyon türünün sahip olduğu oluşturma, 
güncelleme ve okuma gibi işlemlerden bahsedeceğiz. Ayrıca, <code>String</code>'in diğer koleksiyonlardan farklı olduğu yönleri, yani bir 
<code>String</code>'de indekslemenin, insanların ve bilgisayarların <code>String</code> verilerini yorumlama biçimleri arasındaki farklar nedeniyle nasıl karmaşıklaştığını tartışacağız.</p>
<h3 id="dizgi-nedir"><a class="header" href="#dizgi-nedir">Dizgi Nedir?</a></h3>
<p>İlk olarak <em>dizgi</em> terimi ile ne kastettiğimizi tanımlayacağız. Rust'ın çekirdek dilinde yalnızca bir dizgi tipi vardır, 
bu da genellikle ödünç alınmış <code>&amp;str</code> biçiminde görülen dizgi dilimi <code>str</code>'dir. Bölüm 4'te, başka bir yerde saklanan bazı UTF-8 kodlu dizgi 
verilerine referans olan dizgi dilimlerinden bahsetmiştik. Örneğin dizgi değişmezleri, programın ikili dosyasında saklanır ve bu 
nedenle dizgi dilimleridir.</p>
<p>Çekirdek dile kodlanmak yerine Rust'ın standart kütüphanesi tarafından sağlanan <code>String</code> türü, büyütülebilir, değiştirilebilir, 
sahipli, UTF-8 kodlu bir dize türüdür. Rustseverler Rust'ta “dizgilerden” bahsettiklerinde, <code>String</code> ya da dizgi dilimi <code>&amp;str</code> tiplerinden 
birine atıfta bulunuyor olabilirler, sadece bu tiplerden birine değil. Bu bölüm büyük ölçüde <code>String</code> hakkında olsa da, 
her iki tür de Rust'ın standart kütüphanesinde yoğun olarak kullanılır ve hem <code>String</code> hem de string dilimleri UTF-8 kodludur.</p>
<h3 id="yeni-bir-string-oluşturma"><a class="header" href="#yeni-bir-string-oluşturma">Yeni Bir <code>String</code> Oluşturma</a></h3>
<p><code>Vec&lt;T&gt;</code> ile kullanılabilen işlemlerin çoğu <code>String</code> ile de kullanılabilir, çünkü <code>String</code> aslında bazı ekstra garantilere, 
kısıtlamalara ve yeteneklere sahip bir bayt vektörü etrafında bir sarmalayıcı olarak uygulanmaktadır. <code>Vec&lt;T&gt;</code> ve <code>String</code> ile 
aynı şekilde çalışan bir fonksiyon örneği, Liste 8-11'de gösterilen bir örnek oluşturmak için <code>new</code> fonksiyonudur.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-11: Yeni, boş bir <code>String</code> oluşturma</span></p>
<p>Bu satır, daha sonra içine veri yükleyebileceğimiz <code>s</code> adında yeni bir boş dizgi oluşturur. 
Genellikle, dizgiyi başlatmak istediğimiz bazı başlangıç verilerimiz olacaktır. Bunun için, dizgi değişmezlerinin yaptığı 
gibi <code>Display</code> tanımını sürekleyen herhangi bir türde kullanılabilen <code>to_string</code> metodunu kullanırız.</p>
<p>Liste 8-12'de iki örnek gösterilmektedir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let data = &quot;initial contents&quot;;

    let s = data.to_string();

    // the method also works on a literal directly:
    let s = &quot;initial contents&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-12: Bir dize değişmezinden bir <code>String</code> oluşturmak için <code>to_string</code> metodunu 
kullanma</span></p>
<p><code>String::from</code> fonksiyonunu bir dizgi değişmezinden <code>String</code> oluşturmak için de kullanabiliriz. 
Liste 8-13'teki kod, Liste 8-12'deki <code>to_string</code> kullanan koda eş değerdir.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;initial contents&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-13: Bir dizgi değişmezinden <code>String</code> oluşturmak için <code>String::from</code> fonksiyonunu 
kullanma</span></p>
<p>Dizgiler pek çok şey için kullanıldığından, dizgiler için pek çok farklı genel API kullanabiliriz ve bu da bize pek çok seçenek sunar. 
Bazıları gereksiz görünebilir, ancak hepsinin önemli amacı vardır! Bu durumda, <code>String::from</code> ve <code>to_string</code> aynı şeyi yapar, 
bu nedenle hangisini seçeceğiniz bir stil ve okunabilirlik meselesidir.</p>
<p>Dizgilerin UTF-8 kodlu olduğunu unutmayın, bu nedenle Liste 8-14'te gösterildiği gibi uygun şekilde kodlanmış herhangi bir 
veriyi bunlara dahil edebiliriz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let hello = String::from(&quot;السلام عليكم&quot;);
    let hello = String::from(&quot;Dobrý den&quot;);
    let hello = String::from(&quot;Hello&quot;);
    let hello = String::from(&quot;שָׁלוֹם&quot;);
    let hello = String::from(&quot;नमस्ते&quot;);
    let hello = String::from(&quot;こんにちは&quot;);
    let hello = String::from(&quot;안녕하세요&quot;);
    let hello = String::from(&quot;你好&quot;);
    let hello = String::from(&quot;Olá&quot;);
    let hello = String::from(&quot;Здравствуйте&quot;);
    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-14: Farklı dillerdeki selamlamaları dizgilerde saklama</span></p>
<p>Bunların tamamı geçerli <code>String</code> değerleridir. </p>
<h3 id="stringi-güncelleme"><a class="header" href="#stringi-güncelleme"><code>String</code>'i Güncelleme</a></h3>
<p>Bir <code>String</code>'in boyutu büyüyebilir ve içine daha fazla veri koyarsanız, tıpkı bir <code>Vec&lt;T&gt;</code>'nin içeriği gibi içeriği değişebilir. 
Ayrıca, <code>String</code> değerlerini birleştirmek için <code>+</code> operatörünü veya <code>format!</code> makrosunu rahatlıkla kullanabilirsiniz.</p>
<h4 id="push_str-ve-push-ile-stringe-ekleme-yapmak"><a class="header" href="#push_str-ve-push-ile-stringe-ekleme-yapmak"><code>push_str</code> ve <code>push</code> ile <code>String</code>'e ekleme yapmak</a></h4>
<p>Liste 8-15'te gösterildiği gibi, bir dizgi dilimi eklemek için <code>push_str</code> 
metodunu kullanarak bir <code>String</code>'i büyütebiliriz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;foo&quot;);
    s.push_str(&quot;bar&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-15: <code>push_str</code> metodunu kullanarak bir <code>String</code>'e bir dizgi 
dilimi ekleme</span></p>
<p>Bu iki satırdan sonra, <code>s</code> <code>foobar</code>'ı içerecektir. <code>push_str</code> metodu bir dizgi dilimi alır çünkü parametrenin sahipliğini 
almak zorunda değilizdir. Örneğin, Liste 8-16'daki kodda, içeriğini <code>s1</code>'e ekledikten sonra <code>s2</code>'yi kullanabilmek istiyoruz.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s1 = String::from(&quot;foo&quot;);
    let s2 = &quot;bar&quot;;
    s1.push_str(s2);
    println!(&quot;s2 is {}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-16: İçeriğini bir <code>String</code>'e ekledikten sonra dizgi dilimini 
kullanma</span></p>
<p>Eğer <code>push_str</code> metodu <code>s2</code>'nin sahipliğini alsaydı, değerini son satıra yazdıramazdık. 
Ancak, bu kod beklediğimiz gibi çalışıyor!</p>
<p><code>push</code> metodu parametre olarak tek bir karakter alır ve onu <code>String</code>'e ekler. Liste 8-17, <code>push</code> metodunu kullanarak bir 
<code>String</code>'e “l” harfini ekler.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;lo&quot;);
    s.push('l');
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-17: <code>push</code> kullanarak <code>String</code>'e 
karakter ekleme</span></p>
<p>Sonuç olarak, <code>s</code>, <em><code>lol</code></em> içerecektir.</p>
<h4 id="-operatörü-veya-format-makrosu-ile-birleştirme"><a class="header" href="#-operatörü-veya-format-makrosu-ile-birleştirme"><code>+</code> Operatörü veya <code>format!</code> Makrosu ile birleştirme</a></h4>
<p>Çoğu zaman, mevcut iki dizgiyi birleştirmek isteyeceksiniz. Bunu yapmanın bir yolu, Liste 8-18'de gösterildiği gibi 
<code>+</code> operatörünü kullanmaktır.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;Hello, &quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Liste 8-18: İki <code>String</code> değerini yeni bir <code>String</code> değeriyle birleştirmek 
için <code>+</code> operatörünü kullanmak</span></p>
<p><code>s3</code> dizgisi <code>Hello, world!</code> içerecektir. Ekleme işleminden sonra <code>s1</code>'in artık geçerli olmamasının ve 
<code>s2</code>'ye bir referans kullanmamızın nedeni, <code>+</code> operatörünü kullandığımızda çağrılan metodun imzasıyla ilgilidir. 
Imzası aşağıdaki gibi görünen <code>add</code> metodunu kullanır:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>Standart kütüphanede, yaygınlar ve ilişkili türler kullanılarak tanımlanmış eklentiler görürsünüz. 
Burada, bu metodu <code>String</code> değerleriyle çağırdığımızda olan şey olan somut türlerle değiştirdik. 
Yaygınları Bölüm 10'da tartışacağız. Bu imza bize <code>+</code> operatörünün zor kısımlarını anlamamız için gereken ipuçlarını verir.</p>
<p>İlk olarak, <code>s2</code> bir <code>&amp;</code> içerir, yani ilk dizgiye ikinci dizginin bir referansını ekliyoruz. Bunun nedeni <code>add</code> fonksiyonundaki 
<code>s</code> parametresidir: bir <code>String</code>'e yalnızca bir <code>&amp;str</code> ekleyebiliriz; iki <code>String</code> değerini birbirine ekleyemeyiz. 
Ama bekleyin - <code>&amp;s2</code>'nin türü, <code>add</code> fonksiyonunun ikinci parametresinde belirtildiği gibi <code>&amp;str</code> değil, <code>&amp;String</code>'dir. </p>
<p>Öyleyse Liste 8-18 neden derleniyor?</p>
<p><code>add</code> çağrısında <code>&amp;s2</code>'yi kullanabilmemizin nedeni, derleyicinin <code>&amp;String</code> argümanını <code>&amp;str</code>'e zorlayabilmesidir. 
<code>add</code> metodunu çağırdığımızda, Rust burada <code>&amp;s2</code>'yi <code>&amp;s2[..]</code>'ye dönüştüren bir <em><code>deref</code> zorlaması</em> kullanır. 
<em><code>deref</code> zorlamasını</em> Bölüm 15'te daha derinlemesine tartışacağız. <code>add</code>, <code>s</code> parametresinin sahipliğini almadığından, 
<code>s2</code> bu işlemden sonra hala geçerli bir <code>String</code> olacaktır.</p>
<p>İkinci olarak, imzada <code>add</code>'in <code>self</code>'in sahipliğini aldığını görebiliriz, çünkü <code>self</code>'in <code>&amp;'</code>si yoktur. 
Bu, Liste 8-18'deki <code>s1</code>'in <code>add</code> çağrısına taşınacağı ve bundan sonra artık geçerli olmayacağı anlamına gelir. 
Dolayısıyla, <code>let s3 = s1 + &amp;s2;</code> ifade yapısı her iki dizgiyi de kopyalayıp yeni bir tane oluşturacak gibi görünse de, 
bu ifade yapısı aslında <code>s1</code>'in sahipliğini alır, <code>s2</code>'nin içeriğinin bir kopyasını ekler ve ardından sonucun sahipliğini döndürür. 
Başka bir deyişle, çok sayıda kopya oluşturuyormuş gibi görünür ancak oluşturmaz; uygulama kopyalamadan daha verimlidir.</p>
<p>Birden fazla dizgiyi birleştirmemiz gerekirse, <code>+</code> operatörünün davranışı hantal hale gelir:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}
</span></code></pre></pre>
<p>Bu noktada, <code>s</code> <code>tic-tac-toe</code> olacak. Tüm <code>+</code> ve <code>&quot;</code> karakterleri ile neler olup bittiğini görmek zordur. 
Daha karmaşık dizgi birleştirmeleri için <code>format!</code> makrosunu kullanabiliriz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
<span class="boring">}
</span></code></pre></pre>
<p>Bu kod da aynı şekilde <code>s</code>'yi <code>tic-tac-toe</code> olarak ayarlar. <code>format!</code> makrosu <code>println!</code> gibi çalışır, 
ancak çıktıyı ekrana yazdırmak yerine, içeriği içeren bir <code>String</code> döndürür. Kodun <code>format!</code> kullanan versiyonunun okunması 
çok daha kolaydır ve <code>format!</code> makrosu tarafından oluşturulan kod referanslar kullanır, böylece bu çağrı parametrelerinden 
herhangi birinin sahipliğini almaz.</p>
<h3 id="dizgilerde-İndeksleme"><a class="header" href="#dizgilerde-İndeksleme">Dizgilerde İndeksleme</a></h3>
<p>Diğer birçok programlama dilinde, bir dizedeki karakterlere indeksle referans vererek tek tek erişmek geçerli ve yaygın bir işlemdir. 
Ancak, Rust'ta indeksleme söz dizimini kullanarak bir <code>String</code>'in parçalarına erişmeye çalışırsanız, 
bir hata alırsınız. Liste 8-19'daki geçersiz kodu düşünün.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let h = s1[0];
<span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 8-19: İndeksleme söz dizimini <code>String</code> ile kullanmaya çalışmak</span></p>
<p>Bu kod aşağıdaki hataya sebebiyet verecektir:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `String` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index&lt;{integer}&gt;` is not implemented for `String`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` due to previous error
</code></pre>
<p>Hata ve not hikayeyi anlatıyor: Rust dizgileri indekslemeyi desteklemez. Ama neden desteklemiyor? 
Bu soruyu yanıtlamak için, Rust'ın dizgileri bellekte nasıl sakladığını tartışmamız gerekir.</p>
<h4 id="dahili-temsil"><a class="header" href="#dahili-temsil">Dahili Temsil</a></h4>
<p><code>String</code>, <code>Vec&lt;u8&gt;</code> kullanan bir sarmalayıcıdır. Liste 8-14'teki düzgün kodlanmış UTF-8 örnek dizgilerimizden bazılarına bakalım. </p>
<p>İlk olarak, buna bakalım:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;السلام عليكم&quot;);
</span><span class="boring">    let hello = String::from(&quot;Dobrý den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;שָׁלוֹם&quot;);
</span><span class="boring">    let hello = String::from(&quot;नमस्ते&quot;);
</span><span class="boring">    let hello = String::from(&quot;こんにちは&quot;);
</span><span class="boring">    let hello = String::from(&quot;안녕하세요&quot;);
</span><span class="boring">    let hello = String::from(&quot;你好&quot;);
</span><span class="boring">    let hello = String::from(&quot;Olá&quot;);
</span><span class="boring">    let hello = String::from(&quot;Здравствуйте&quot;);
</span>    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Bu durumda, <code>len</code> <code>4</code> olacaktır, bu da “Hola” dizgisini depolayan vektörün 4 bayt uzunluğunda olduğu anlamına gelir. 
UTF-8'de kodlandığında bu harflerin her biri 1 bayt alır. Ancak aşağıdaki satır sizi şaşırtabilir. 
(Bu dizenin Arapça 3 rakamı ile değil, büyük Kiril harfi Ze ile başladığına dikkat edin).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;السلام عليكم&quot;);
</span><span class="boring">    let hello = String::from(&quot;Dobrý den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;שָׁלוֹם&quot;);
</span><span class="boring">    let hello = String::from(&quot;नमस्ते&quot;);
</span><span class="boring">    let hello = String::from(&quot;こんにちは&quot;);
</span><span class="boring">    let hello = String::from(&quot;안녕하세요&quot;);
</span><span class="boring">    let hello = String::from(&quot;你好&quot;);
</span><span class="boring">    let hello = String::from(&quot;Olá&quot;);
</span>    let hello = String::from(&quot;Здравствуйте&quot;);
<span class="boring">    let hello = String::from(&quot;Hola&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>Dizginin ne kadar uzunlukta olduğu sorulduğunda 12 diyebilirsiniz. 
Aslında Rust'ın cevabı 24'tür: UTF-8'de “Здравствуйте” yi kodlamak için gereken bayt sayısı budur, 
çünkü bu dizgideki her Unicode skaler değeri 2 bayt depolama alanı alır. Bu nedenle, dizginin baytlarındaki bir 
indeks her zaman geçerli bir Unicode skaler değeriyle ilişkili olmayacaktır. </p>
<p>Kanıt için bu geçersiz Rust kodunu düşünün:</p>
<pre><code class="language-rust ignore does_not_compile">let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];
</code></pre>
<p><code>answer</code>'ın ilk harf olan <code>З</code> olmayacağını zaten biliyorsunuz. UTF-8'de kodlandığında, <code>З</code>'nin ilk baytı <code>208</code> ve ikincisi <code>151</code>'dir, 
bu nedenle cevabın aslında <code>208</code> olması gerekir, ancak <code>208</code> tek başına geçerli bir karakter değildir. 
Bu dizginin ilk harfini soran bir kullanıcı muhtemelen <code>208</code> sonucunu almak istemeyecektir; 
ancak Rust'ın <code>0</code> bayt indeksinde sahip olduğu tek veri budur. Kullanıcılar, dizgi yalnızca Latin harfleri içerse bile 
genellikle bayt değerinin döndürülmesini istemezler: <code>&amp;&quot;hello&quot;[0]</code> bayt değerini döndüren geçerli bir kod olsaydı, <code>h</code> değil <code>104</code> döndürürdü.</p>
<p>O halde cevap, beklenmedik bir değer döndürmekten ve hemen keşfedilemeyecek hatalara neden olmaktan kaçınmak için Rust'ın 
bu kodu hiç derlememesi ve geliştirme sürecinin başlarında yanlış anlamaları önlemesidir.</p>
<h3 id="baytlar-ve-skaler-değerler-ve-grapheme-kümeleri-amanın"><a class="header" href="#baytlar-ve-skaler-değerler-ve-grapheme-kümeleri-amanın">Baytlar ve Skaler Değerler ve Grapheme Kümeleri! Amanın!</a></h3>
<p>UTF-8 ile ilgili bir başka nokta da, Rust'ın bakış açısından dizgilere bakmanın aslında üç ilgili yolu olduğudur: 
baytlar, skaler değerler ve grapheme kümeleri (<em>harf</em> olarak adlandırdığımız şeye en yakın şey).</p>
<p>Devanagari alfabesiyle yazılmış Hintçe “नमस्ते” kelimesine bakarsak, bu kelime aşağıdaki gibi görünen 
<code>u8</code> değerlerinden oluşan bir vektör olarak saklanır:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Bu 18 bayttır ve bilgisayarlar bu verileri nihai olarak bu şekilde depolar. 
Bunlara Unicode skaler değerleri olarak bakarsak, ki Rust'ın <code>char</code> türü budur, bu baytlar şöyle görünür:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>Burada altı <code>char</code> değeri vardır, ancak dördüncü ve altıncı harfler harf değildir: 
bunlar kendi başlarına bir anlam ifade etmeyen aksan işaretleridir. 
Son olarak, bunlara grapheme kümeleri olarak bakarsak, bir kişinin Hintçe kelimeyi oluşturan 
dört harf olarak adlandıracağı şeyi elde ederiz:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Rust, bilgisayarların depoladığı ham dizgi verilerini yorumlamak için farklı yollar sağlar, 
böylece veriler hangi insan dilinde olursa olsun her program ihtiyaç duyduğu yorumu seçebilir.</p>
<p>Rust'ın bir karakteri elde etmek için bir String içinde indeksleme yapmamıza izin vermemesinin son bir nedeni, 
indeksleme işlemlerinin her zaman sabit zaman (O(1)) almasının beklenmesidir. Ancak bir <code>String</code> ile bu performansı garanti 
etmek mümkün değildir, çünkü Rust'ın kaç tane geçerli karakter olduğunu belirlemek için başlangıçtan indekse kadar içerik boyunca 
yürümesi gerekir.</p>
<h3 id="stringi-dilimleme"><a class="header" href="#stringi-dilimleme"><code>String</code>'i Dilimleme</a></h3>
<p>Bir dizeye indeksleme yapmak genellikle kötü bir fikirdir çünkü dizeye indeksleme işleminin dönüş türünün ne olması gerektiği 
açık değildir: bayt değeri, karakter, grapheme kümesi veya dizgi dilimi. Bu nedenle, dizgi dilimleri oluşturmak için 
gerçekten indis kullanmanız gerekiyorsa, Rust sizden daha spesifik olmanızı bekler.</p>
<p>Tek bir sayı ile <code>[]</code> kullanarak indeksleme yapmak yerine, belirli baytları içeren bir dizgi dilimi oluşturmak 
için <code>[]</code> ile bir aralığı kullanabilirsiniz:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
<span class="boring">}
</span></code></pre></pre>
<p>Burada <code>s</code>, dizginin ilk 4 baytını içeren bir <code>&amp;str</code> olacaktır. Daha önce, bu karakterlerin her birinin 
2 bayt olduğundan bahsetmiştik, bu da <code>s</code>'nin <code>Зд</code> olacağı anlamına gelir.</p>
<p>Eğer bir karakterin baytlarının sadece bir kısmını <code>&amp;hello[0..1]</code> gibi bir şeyle dilimlemeye çalışsaydık, 
Rust çalışma zamanında bir vektörde geçersiz bir indekse erişildiğinde olduğu gibi paniğe kapılırdı:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/main.rs:4:14
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Dizgi dilimleri oluşturmak için aralıkları dikkatli kullanmalısınız, çünkü yanlış kullanım programınızı çökertebilir.</p>
<h3 id="string-Üzerinde-yineleme-yöntemleri"><a class="header" href="#string-Üzerinde-yineleme-yöntemleri"><code>String</code> Üzerinde Yineleme Yöntemleri</a></h3>
<p>Dizgi parçaları üzerinde işlem yapmanın en iyi yolu, karakter mi yoksa bayt mı istediğinizi açıkça belirtmektir. 
Tek tek Unicode skaler değerleri için <code>chars</code> metodunu kullanabilirsiniz. “Зд” üzerinde <code>chars</code> metodu çağrıldığında <code>char</code> türünde 
iki değer ayrılır ve döndürülür; her bir öğeye erişmek için sonuç üzerinde yineleme yapabilirsiniz:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;Зд&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
<span class="boring">}
</span></code></pre></pre>
<p>Bu kod aşağıdakileri yazdıracaktır:</p>
<pre><code class="language-text">З
д
</code></pre>
<p>Alternatif olarak, <code>bytes</code> yöntemi, kullanımınız için uygun olabilecek her ham baytı döndürür:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;Зд&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
<span class="boring">}
</span></code></pre></pre>
<p>Bu kod, bu dizgiyi oluşturan dört baytı yazdıracaktır:</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>Ancak geçerli Unicode skaler değerlerinin 1 bayttan fazla olabileceğini unutmayın.</p>
<p>Devanagari alfabesinde olduğu gibi dizelerden grapheme kümeleri elde etmek karmaşıktır, 
bu nedenle bu fonksiyon direkt standart kütüphane tarafından sağlanmamaktadır. </p>
<p>İhtiyacınız olan işlevsellik buysa <a href="https://crates.io/">crates.io</a><!-- ignore -->'da işe yarayabilecek 
kasalar mevcuttur.</p>
<h3 id="stringler-o-kadar-da-basit-değildir"><a class="header" href="#stringler-o-kadar-da-basit-değildir"><code>String</code>'ler O Kadar da Basit Değildir</a></h3>
<p>Özetlemek gerekirse, dizgiler karmaşıktır. Farklı programlama dilleri, bu karmaşıklığın programcıya nasıl sunulacağı 
konusunda farklı seçimler yapar. Rust, <code>String</code> verilerinin doğru işlenmesini tüm Rust programları için varsayılan 
davranış haline getirmeyi seçmiştir, bu da programcıların UTF-8 verilerini önceden ele almak için daha fazla düşünmesi gerektiği 
anlamına gelir. Bu değiş tokuş, dizelerin karmaşıklığını diğer programlama dillerinde göründüğünden daha fazla ortaya çıkarır, 
ancak geliştirme yaşam döngünüzün ilerleyen aşamalarında <em>ASCII</em> olmayan karakterleri içeren hataları ele almak zorunda kalmanızı önler.</p>
<p>İyi haber şu ki, standart kütüphane bu karmaşık durumların doğru şekilde ele alınmasına yardımcı olmak için <code>String</code> ve 
<code>&amp;str</code> türlerinden oluşturulmuş çok sayıda işlevsellik sunar. Bir dizgi içinde arama yapmak için <code>contains</code> ve bir dizginin 
parçalarını başka bir dizgiyle değiştirmek için <code>replace</code> gibi yararlı metodlara ulaşmak için ilgili dokümantasyonlara
göz attığınızdan emin olun.</p>
<p>Daha az karışık bir şeye geçelim: <em>anahtar-kilit koleksiyonları</em>!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch08-01-vectors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch08-03-hash-maps.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch08-01-vectors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch08-03-hash-maps.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>


    </body>
</html>
