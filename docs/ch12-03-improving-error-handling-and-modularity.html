<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Modülerliği ve Hata Yönetimini Geliştirmek için Yeniden Düzenlemek - Rust Programlama Dili</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Rust Programlama Dili</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Ön söz</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Başlangıç</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Başlarken</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Yükleme</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Merhaba, Dünya!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Merhaba, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Tahmin Oyunu Programlamak</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Yaygın Programlama Kavramları</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Değişkenler ve Değişebilirlik</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Fonksiyonlar</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Yorum Satırları</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrol Akışı</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Sahipliği Anlamak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Sahiplik Nedir?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referanslar ve Ödünç Alma Mekanizması</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Dilim Türü</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> İlintili Verileri Yapılandırmak için Yapıları Kullanmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Yapıları Tanımlamak ve Örneklendirmek</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Yapıları Kullanan Örnek Bir Program</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Metod Söz dizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Numaralandırılmış Yapılar ve Model Eşleme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Numaralandırılmış Yapı Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match Kontrol Akış Yapısı</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let ile Kısa Kontrol Akış Yapısı</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Büyüyen Projeleri Paketler, Kasalar ve Modüllerle Yönetme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Paketler ve Kasalar</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Gizlilik ve Kontrol Kapsamı için Modüller Tanımlamak</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Modül Ağacındaki bir Öğeyi Referanslama Yolları</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use Kullanarak Yolları Kapsama Getirmek</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Modülleri Farklı Dosyalara Ayırmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Yaygın Koleksiyon Türleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Veri Listelerini Vektörlerle Tutmak</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8 ile Kodlanmış Dizgiyi Tutmak</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> İlişkili Değerlerle Anahtarları Saklamak</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Hata Yönetimi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! ile Kurtarılamayan Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result ile Kurtarılabilir Hatalar</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!lemek ya da panic!lememek</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Yaygın Türler, Tanımlar ve Ömürlükler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Yaygın Veri Türleri</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Tanımlar: Yaygın Davranış Tanımlama</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Ömürlük Yapısıyla Referans Doğrulama</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Otomatikleşmiş Testler Yazma</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Testler Nasıl Yazılır</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Testlerin Nasıl Çalıştığını Kontrol Etmek</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organizasyonu</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Bir G/Ç Projesi: Komut Satırı Programı Yazmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Komut Satırı Argümanlarını Ayrıştırmak</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Dosya Okumak</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html" class="active"><strong aria-hidden="true">12.3.</strong> Modülerliği ve Hata Yönetimini Geliştirmek için Yeniden Düzenlemek</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Test Odaklı Geliştirme ile Kütüphanenin İşlevliğini Artırmak</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Ortam Değişkenlerini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Hata Mesajlarını Standart Çıktı yerine Standart Hata Akışına Yazdırmak</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Fonksiyonel Dil Özellikleri: Yineleyiciler ve Kapanış İfadeleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Kapanış İfadeleri: Ortamda Tutulabilen Anonim Fonksiyonlar</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Yineleyicilerle Bir Dizi Öğeyi İşlemek</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> G/Ç Projemizi Geliştirmek</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performans Kıyaslaması: Döngüler vs. Yineleyiciler</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo ve Crates.io Hakkında Daha Fazla Bilgi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Dağıtım Profilleriyle İnşaları Özelleştirmek</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io'da Bir Kasa Paylaşmak</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Çalışma Alanları</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install ile Crates.io'dan Derlenmişleri Yüklemek</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Özel Komutlarla Cargo'yu Genişletmek</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Akıllı İşaretçiler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Yığındaki Verileri İşaretlemek için Box&lt;T&gt; Kullanmak</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Akıllı İşaretçilere Deref ile Normal Referanslar Gibi Tanım Yapmak</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop Tanımlamasıyla Temizlik Aşamasında Kod Çalıştırmak</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, Referans Sayaçlı Akıllı İşaretçi</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; ve İç Değişebilirlik Modeli</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referans Döngüleri Bellek Sızdırabilir</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Korkusuz Eşzamanlılık</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Kodu Eşzamanlı Çalıştırmak için İş Parçacıklarını Kullanmak</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Konular Arasında Veri Aktarmak için İleti Geçişini Kullanmak</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Paylaşımlı Eşzamanlık</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Sync ve Send Tanımlarıyla Genişletilebilir Eşzamanlılık</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust'taki Nesne Yönemimli Programlama Özellikleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Nesne Yönelimli Dillerin Karakteristik Özellikleri</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Farklı Türlerdeki Değerlere İzin Veren Özellik Tanımlarını Kullanma</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Nesneye Yönelik Tasarım Modelini Süreklemek</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Modeller ve Eşleştirme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Modeller Her Yerde Kullanılabilir</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Reddedilebilirlik: Modelin Eşleştirmede Başarısız Olup Olmayacağı</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Model Söz Dizimi</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Gelişmiş Özellikler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Güvensiz Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Gelişmiş Tanımlar</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Gelişmiş Türler</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Gelimiş Fonksiyonlar ve Kapanış İfadeleri</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makrolar</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Projesi: Çoklu İş Parçacıklı Web Sunucusu İnşa Etmek</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Tek İş Parçacıklı Web Sunucusu İnşa Etmek</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Tek İş Parçacıklı Sunucumuzu Çok Parçacıklı Sunucuya Çevirmek</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Zarifçe Kapatmak ve Temizlemek</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Eklemeler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Anahtar Sözcükler</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatörler ve Semboller</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Türetilebilir Tanımlar</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Kullanışlı Geliştirme Araçları</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Sürümler</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Kitap'ın Çevirileri</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust ve “Gecelik Rust” Nasıl Yapıldı</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Programlama Dili</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ferhatgec/kitap" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="modülerliği-ve-hata-İşlemeyi-geliştirmek-için-yeniden-düzenleme"><a class="header" href="#modülerliği-ve-hata-İşlemeyi-geliştirmek-için-yeniden-düzenleme">Modülerliği ve Hata İşlemeyi Geliştirmek için Yeniden Düzenleme</a></h2>
<p>Programımızı iyileştirmek için, programın yapısı ve olası hataları nasıl ele aldığı ile ilgili dört sorunu çözeceğiz. 
İlk olarak, <code>ma'n</code> fonksiyonumuz artık iki görevi yerine getiriyor: argümanları ayrıştırıyor ve dosyaları okuyor. 
Programımız büyüdükçe, ana fonksiyonun yerine getirdiği ayrı görevlerin sayısı artacaktır. Bir fonksiyon sorumluluk kazandıkça,
hakkında mantık yürütmek daha zor, test etmek daha zor ve parçalarından birini bozmadan değiştirmek daha zor hale gelir. 
Her fonksiyonun tek bir görevden sorumlu olması için işlevleri ayırmak en iyisidir.</p>
<p>Bu konu aynı zamanda ikinci sorunla da bağlantılıdır: sorgu ve dosya adı programımız için yapılandırma değişkenleri olsa da, 
içerik gibi değişkenler programın mantığını gerçekleştirmek için kullanılır. main ne kadar uzun olursa, 
o kadar çok değişkeni kapsama almamız gerekecektir; ne kadar çok değişkeni kapsama alırsak, her birinin amacını takip etmek o
kadar zor olacaktır. Amaçlarını netleştirmek için yapılandırma değişkenlerini tek bir yapıda gruplamak en iyisidir.</p>
<p>Üçüncü sorun, dosyayı okuma başarısız olduğunda bir hata mesajı yazdırmak için <code>expect</code> kullandık, ancak hata mesajı sadece 
<code>Something went wrong reading the file</code> yazıyor. Bir dosyayı okumak çeşitli şekillerde başarısız olabilir: örneğin, 
dosya eksik olabilir veya dosyayı açmak için iznimiz olmayabilir. Şu anda, durum ne olursa olsun, her şey için aynı hata mesajını 
yazdırırız ve bu da kullanıcıya hiçbir bilgi vermeyiz.</p>
<p>Dördüncüsü, farklı hataları işlemek için tekrar tekrar <code>expect</code> kullanıyoruz ve kullanıcı programımızı yeterli argüman belirtmeden 
çalıştırırsa, Rust'tan sorunu açıkça açıklamayan bir <code>index out of bounds</code> hatası alacaktır. Tüm hata işleme kodunun tek bir yerde olması 
en iyisidir, böylece gelecekteki bakımcılar hata işleme mantığının değişmesi gerektiğinde koda başvurmak için tek bir yere sahip olurlar.
Tüm hata işleme kodunun tek bir yerde olması, son kullanıcılarımız için anlamlı olacak mesajları yazdırmamızı da sağlayacaktır.</p>
<p>Projemizi yeniden düzenleyerek bu dört sorunu ele alalım.</p>
<h3 id="İkili-projeler-için-endişelerin-ayrılması"><a class="header" href="#İkili-projeler-için-endişelerin-ayrılması">İkili Projeler için Endişelerin Ayrılması</a></h3>
<p>Birden fazla görevin sorumluluğunun ana fonksiyona verilmesine ilişkin organizasyonel sorun, 
birçok ikili projede ortaktır. Sonuç olarak, Rust topluluğu, ana program büyümeye başladığında ikili bir programın ayrı 
endişelerini bölmek için yönergeler geliştirmiştir. Bu süreç aşağıdaki adımlardan oluşur:</p>
<ul>
<li>Programınızı <em>main.rs</em> ve <em>lib.rs</em> olarak ayırın ve programınızın ana mantığını <em>lib.rs</em>'e taşıyın.</li>
<li>Komut satırı ayrıştırma mantığınız küçük olduğu sürece <em>main.rs</em> içinde kalabilir.</li>
<li>Komut satırı ayrıştırma mantığı karmaşıklaşmaya başladığında, <em>main.rs</em>'den çıkarın ve <em>lib.rs</em>'e taşıyın.</li>
</ul>
<p>Bu işlemlerden sonra <code>main</code> fonksiyonunda kalanlar aşağıdakilerle sınırlı olmalıdır:</p>
<ul>
<li>Komut satırı ayrıştırma mantığını argüman değerleriyle çağırmak</li>
<li>Diğer yapılandırmaları ayarlama</li>
<li><em>lib.rs</em> içinde bir <code>run</code> fonksiyonu çağırma</li>
<li><code>run</code> bir hata döndürürse hatayı işleme</li>
</ul>
<p>Bu model endişeleri ayırmakla ilgilidir: <em>main.rs</em> programı çalıştırır ve <em>lib.rs</em> eldeki görevin tüm mantığını ele alır. 
<code>main</code> fonksiyonunu doğrudan test edemeyeceğiniz için, bu yapı programınızın tüm mantığını <em>lib.rs</em>'deki fonksiyonlara taşıyarak 
test etmenizi sağlar. <em>main.rs</em>'de kalan kod, okunarak doğruluğu teyit edilebilecek kadar küçük olacaktır. </p>
<p>Bu süreci takip ederek programımızı yeniden düzenleyelim.</p>
<h4 id="argüman-ayrıştırıcısını-Çıkarma"><a class="header" href="#argüman-ayrıştırıcısını-Çıkarma">Argüman Ayrıştırıcısını Çıkarma</a></h4>
<p>Komut satırı ayrıştırma mantığını <em>src/lib.rs</em>'ye taşımaya hazırlanmak için argümanları ayrıştırma işlevini 
<code>main</code>'in çağıracağı bir fonksiyona çıkaracağız. Liste 12-5, şimdilik <em>src/main.rs</em> içinde tanımlayacağımız yeni <code>parse_config</code> 
fonksiyonunu çağıran <code>main</code>'in yeni başlangıcını göstermektedir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, filename) = parse_config(&amp;args);

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, query);
</span><span class="boring">    println!(&quot;In file {}&quot;, filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename)
</span><span class="boring">        .expect(&quot;Something went wrong reading the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let filename = &amp;args[2];

    (query, filename)
}
</code></pre>
<p><span class="caption">Liste 12-5: <code>parse_config</code> fonksiyonunun <code>main</code>'den çıkarılması</span></p>
<p>Komut satırı argümanlarını hala bir vektörde topluyoruz, ancak 1. indeksteki argüman değerini sorgu değişkenine ve 
2. indeksteki argüman değerini <code>main</code> içindeki dosya adı değişkenine atamak yerine, tüm vektörü <code>parse_config</code>'e aktarıyoruz. 
<code>parse_config</code> daha sonra hangi argümanın hangi değişkene gideceğini belirleyen mantığı tutar ve değerleri <code>main</code>'e geri aktarır. 
<code>query</code> ve <code>filename</code> değişkenlerini hala <code>main</code> içinde oluşturuyoruz, ancak <code>main</code> artık komut satırı argümanlarının ve 
değişkenlerin nasıl karşılık geldiğini belirleme sorumluluğuna sahip değil.</p>
<p>Bu yeniden çalışma küçük programımız için aşırı gibi görünebilir, ancak küçük, artan adımlarla yeniden düzenliyoruz. 
Bu değişikliği yaptıktan sonra, argüman ayrıştırmanın hala çalıştığını doğrulamak için programı tekrar çalıştırın. 
İlerlemenizi sık sık kontrol etmek, ortaya çıktıklarında sorunların nedenini belirlemeye yardımcı olmak için iyidir.</p>
<h4 id="yapılandırma-değerlerini-gruplama"><a class="header" href="#yapılandırma-değerlerini-gruplama">Yapılandırma Değerlerini Gruplama</a></h4>
<p><code>parse_config</code>'i daha da geliştirmek için küçük bir adım daha atabiliriz. Şu anda bir <code>tuple</code> döndürüyoruz, ancak hemen ardından bu 
<code>tuple</code>'ı tekrar ayrı parçalara ayırıyoruz. Bu, belki de henüz doğru soyutlamaya sahip olmadığımızın bir işaretidir.</p>
<p>İyileştirme için yer olduğunu gösteren bir başka gösterge de <code>parse_config</code>'in <code>config</code> kısmıdır, 
bu da döndürdüğümüz iki değerin ilişkili olduğunu ve her ikisinin de bir yapılandırma değerinin parçası olduğunu ima eder. 
Şu anda bu anlamı, iki değeri bir <code>tuple</code> olarak gruplamak dışında verinin yapısında aktarmıyoruz; bunun yerine iki değeri 
<code>struct</code> içine koyacağız ve <code>struct</code> alanlarının her birine anlamlı bir isim vereceğiz. Bunu yapmak, bu kodun gelecekteki 
bakımcılarının farklı değerlerin birbirleriyle nasıl ilişkili olduğunu ve amaçlarının ne olduğunu anlamalarını kolaylaştıracaktır.</p>
<p>Liste 12-6, <code>parse_config</code>'de yapılan iyileştirmeleri göstermektedir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    let contents = fs::read_to_string(config.filename)
        .expect(&quot;Something went wrong reading the file&quot;);

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span>}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
</code></pre>
<p><span class="caption">Liste 12-6: <code>Config</code> yapısının örneğini döndürmek için <code>parse_config</code> öğesini 
yeniden düzenleme</span></p>
<p><code>query</code> ve <code>filename</code> adında alanlara sahip olacak şekilde tanımlanmış <code>Config</code> adında bir yapı ekledik. <code>parse_config</code>'in imzası artık 
<code>Config</code> değeri döndürdüğünü gösteriyor. Eskiden <code>args</code> içindeki <code>String</code> değerlerine referans veren dizgi dilimleri döndürdüğümüz 
<code>parse_config</code> gövdesinde, artık <code>Config</code>'i <code>String</code> değerlerini içerecek şekilde tanımlıyoruz. <code>main</code> içindeki <code>args</code> değişkeni argüman 
değerlerinin sahibidir ve yalnızca <code>parse_config</code> fonksiyonunun bunları ödünç almasına izin verir, bu da <code>Config</code>'in <code>args</code> içindeki 
değerlerin sahipliğini almaya çalışması durumunda Rust'ın ödünç alma kurallarını ihlal edeceğimiz anlamına gelir.</p>
<p><code>String</code> verilerini yönetebileceğimiz birkaç yol vardır; biraz verimsiz olsa da en kolay yol, değerler üzerinde <code>clone</code> metodunu çağırmaktır. 
Bu,<code> Config</code> örneğinin sahip olması için verilerin tam bir kopyasını oluşturacaktır, bu da dizgi verilerine bir referans depolamaktan daha 
fazla zaman ve bellek gerektirir. Bununla birlikte, verileri klonlamak kodumuzu çok basit hale getirir çünkü referansların yaşam sürelerini
yönetmek zorunda değiliz; bu durumda, basitlik kazanmak için biraz performanstan vazgeçmek değerli bir değiş tokuştur.</p>
<blockquote>
<h3 id="clone-kullanmanın-getirileri"><a class="header" href="#clone-kullanmanın-getirileri"><code>clone</code> Kullanmanın Getirileri</a></h3>
<p>Birçok Rustsever arasında, çalışma zamanı maliyeti nedeniyle sahiplik sorunlarını çözmek için 
<code>clone</code> kullanmaktan kaçınma eğilimi vardır. Bölüm 13'te, bu tür durumlarda nasıl daha verimli yöntemler 
kullanacağınızı öğreneceksiniz. Ancak şimdilik, ilerlemeye devam etmek için birkaç dizgiyi kopyalamanızda bir sakınca yok 
çünkü bu kopyaları yalnızca bir kez yapacaksınız ve <code>filename</code> ve <code>query</code> dizginiz çok küçük. İlk geçişinizde kodu aşırı optimize 
etmeye çalışmaktansa biraz verimsiz çalışan bir programa sahip olmak daha iyidir. Rust ile daha deneyimli hale geldikçe, 
en verimli çözümle başlamak daha kolay olacaktır, ancak şimdilik <code>clone</code> kullanmak tamamen kabul edilebilir.</p>
</blockquote>
<p><code>main</code>'i, <code>parse_config</code> tarafından döndürülen <code>Config</code> örneğini <code>config</code> adlı bir değişkene atayacak şekilde güncelledik 
ve daha önce ayrı <code>query</code> ve <code>filename</code> değişkenlerini kullanan kodu güncelledik, böylece artık bunun yerine <code>Config</code> yapısındaki alanları 
kullanıyor.</p>
<p>Artık kodumuz <code>query</code> ve <code>filename</code>'in ilişkili olduğunu ve amaçlarının programın nasıl çalışacağını yapılandırmak olduğunu daha açık bir 
şekilde ifade ediyor. Bu değerleri kullanan herhangi bir kod, bunları <code>config</code> örneğinde amaçlarına göre adlandırılmış alanlarda bulmayı bilir.</p>
<h4 id="config-için-bir-yapıcı-oluşturma"><a class="header" href="#config-için-bir-yapıcı-oluşturma"><code>Config</code> için Bir Yapıcı Oluşturma</a></h4>
<p>Şimdiye kadar, komut satırı argümanlarını ayrıştırmaktan sorumlu mantığı <code>main</code>'den çıkardık ve <code>parse_config</code> fonksiyonuna yerleştirdik. 
Bunu yapmak, <code>query</code> ve <code>filename</code> değerlerinin ilişkili olduğunu ve bu ilişkinin kodumuzda aktarılması gerektiğini görmemize yardımcı oldu. 
Daha sonra <code>query</code> ve <code>filename</code>'in amaçlarını adlandırmak ve <code>parse_config</code> fonksiyonundan değerlerin adlarını <code>struct</code> alan adları olarak 
döndürebilmek için bir <code>Config</code> <code>struct</code>'ı ekledik.</p>
<p>Artık <code>parse_config</code> fonksiyonunun amacı bir <code>Config</code> örneği oluşturmak olduğuna göre, <code>parse_config</code>'i düz bir fonksiyondan <code>Config</code> yapısıyla 
ilişkili <code>new</code> adlı bir fonksiyona dönüştürebiliriz. Bu değişikliği yapmak kodu daha deyimsel hale getirecektir. Standart kütüphanedeki <code>String</code> 
gibi türlerin örneklerini <code>String::new</code> fonksiyonunu çağırarak oluşturabiliriz. Benzer şekilde, <code>parse_config</code>'i <code>Config</code> ile ilişkili yeni 
bir fonksiyona dönüştürerek, <code>Config::new</code>'i çağırarak <code>Config</code>'in örneklerini oluşturabileceğiz. Liste 12-7 yapmamız 
gereken değişiklikleri göstermektedir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.filename)
</span><span class="boring">        .expect(&quot;Something went wrong reading the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span>
    // --snip--
}

// --snip--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
</code></pre>
<p><span class="caption">Liste 12-7: <code>parse_config</code>'i <code>Config::new</code> ile değiştirme</span></p>
<p><code>main</code>'de <code>parse_config</code> çağrısı yaptığımız yeri <code>Config::new</code> çağrısı yapacak şekilde güncelledik. 
<code>parse_config</code>'in adını <code>new</code> olarak değiştirdik ve yeni fonksiyonu <code>Config</code> ile ilişkilendiren <code>impl</code> bloğunun içine taşıdık. 
Çalıştığından emin olmak için bu kodu tekrar derlemeyi deneyin.</p>
<h3 id="hata-İşlemeyi-düzeltme"><a class="header" href="#hata-İşlemeyi-düzeltme">Hata İşlemeyi Düzeltme</a></h3>
<p>Şimdi hata işlememizi düzeltmeye çalışacağız. <code>args</code> vektöründeki değerlere indeks <code>1</code> veya indeks <code>2</code>'den erişmeye çalışmanın, 
vektör üçten az öğe içeriyorsa programın paniklemesine neden olacağını hatırlayın. Programı herhangi bir argüman olmadan çalıştırmayı 
deneyin; şöyle görünecektir:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:27:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p><code>index out of bounds: the len is 1 but the index is 1</code>, programcılara yönelik detaylı bir hata mesajıdır. 
Son kullanıcılarımızın bunun yerine ne yapmaları gerektiğini anlamalarına yardımcı olmaz. Şimdi bunu düzeltelim.</p>
<h3 id="hata-mesajını-İyileştirme"><a class="header" href="#hata-mesajını-İyileştirme">Hata Mesajını İyileştirme</a></h3>
<p>Liste 12-8'de, yeni fonksiyona 1. ve 2. dizine erişmeden önce dilimin yeterince uzun olduğunu doğrulayacak bir kontrol ekliyoruz. 
Dilim yeterince uzun değilse, program paniğe kapılır ve daha iyi bir hata mesajı görüntüler.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.filename)
</span><span class="boring">        .expect(&quot;Something went wrong reading the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --snip--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!(&quot;not enough arguments&quot;);
        }
        // --snip--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, filename }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 12-8: Bağımsız değişken sayısı için bir kontrol ekleme</span></p>
<p>Bu kod, <a href="ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation">Liste 9-13'te yazdığımız <code>Guess::new</code> fonksiyonuna benzer</a><!-- ignore -->; burada <code>value</code> bağımsız değişkeni 
geçerli değerler aralığının dışında kaldığında <code>panic!</code> yapar. Bir değer aralığını kontrol etmek yerine, <code>args</code> uzunluğunun en az 
3 olduğunu kontrol ediyoruz ve fonksiyonun geri kalanı bu koşulun sağlandığı varsayımı altında çalışabilir. Eğer <code>args</code> üçten az öğeye sahipse, 
bu koşul doğru olur ve programı hemen sonlandırmak için <code>panic!</code> makrosunu çağırırız.</p>
<p>Bu ekstra birkaç satırlık yeni kodla, hatanın şimdi nasıl göründüğünü görmek için programı herhangi bir 
argüman olmadan tekrar çalıştıralım:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Bu çıktı daha iyi: artık makul bir hata mesajımız var. Ancak, kullanıcılarımıza vermek istemediğimiz gereksiz bilgilere de sahibiz. 
Belki de Liste 9-13'te kullandığımız tekniği burada kullanmak en iyisi değildir: <a href="ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling">Bölüm 9'da tartışıldığı gibi</a><!-- ignore -->, 
<code>panic!</code> çağrısı bir kullanım probleminden ziyade bir programlama problemi için daha uygundur. Bunun yerine, 
Bölüm 9'da öğrendiğiniz diğer tekniği kullanacağız— başarı ya da hatayı gösteren <a href="ch09-02-recoverable-errors-with-result.html"><code>Result</code>'u döndürmek</a><!-- ignore -->.</p>
<h4 id="panic-yerine-newden-result-döndürme"><a class="header" href="#panic-yerine-newden-result-döndürme"><code>panic!</code> Yerine <code>new</code>'den <code>Result</code> Döndürme</a></h4>
<p>Bunun yerine, başarılı durumda bir <code>Config</code> örneği içeren ve hata durumunda sorunu açıklayan bir <code>Result</code> değeri döndürebiliriz. 
<code>Config::new</code> <code>main</code> ile iletişim kurarken, bir sorun olduğunu belirtmek için <code>Result</code> türünü kullanabiliriz. </p>
<p>Daha sonra <code>main</code>'i, <code>panic!</code>'in neden olduğu <code>main</code> iş parçacığı ve <code>RUST_BACKTRACE</code> ile ilgili çevreleyen metin olmadan 
kullanıcılarımız için <code>Err</code> varyantını daha pratik bir hataya dönüştürmek için değiştirebiliriz.</p>
<p>Liste 12-9, <code>Config::new</code>'in dönüş değerinde ve <code>Result</code> döndürmek için gereken fonksiyonun gövdesinde yapmamız gereken 
değişiklikleri göstermektedir. Bunun <code>main</code>'i de güncellemeden derlenmeyeceğini unutmayın, ki bunu bir sonraki listede yapacağız.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.filename)
</span><span class="boring">        .expect(&quot;Something went wrong reading the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
</code></pre>
<p><span class="caption">Liste 12-9: <code>Config::new</code>'den <code>Result</code> Döndürme</span></p>
<p>Yeni fonksiyonumuz artık başarı durumunda bir <code>Config</code> örneği ve hata durumunda <code>&amp;'static str</code> içeren bir <code>Result</code> döndürmektedir. 
Hata değerlerimiz her zaman <code>'static</code> ömüre sahip dizgi değişmezleri olacaktır.</p>
<p>Yeni fonksiyonun gövdesinde iki değişiklik yaptık: kullanıcı yeterli argüman iletmediğinde <code>panic!</code> çağrısı yapmak yerine, 
artık bir <code>Err</code> değeri döndürüyoruz ve <code>Config</code> dönüş değerini bir <code>Ok</code> içinde tuttuk. Bu değişiklikler fonksiyonun yeni tür imzasına 
uygun olmasını sağlar.</p>
<p><code>Config::new</code>'den <code>Err</code> değeri döndürmek, <code>main</code> fonksiyonun yeni fonksiyondan dönen <code>Result</code> değerini işlemesini ve hata 
durumunda süreçten daha temiz bir şekilde çıkmasını sağlar.</p>
<h4 id="confignew-Çağrısı-ve-hataların-İşlenmesi"><a class="header" href="#confignew-Çağrısı-ve-hataların-İşlenmesi"><code>Config::new</code> Çağrısı ve Hataların İşlenmesi</a></h4>
<p>Hata durumunu ele almak ve kullanıcı dostu bir mesaj yazdırmak için, Liste 12-10'da gösterildiği gibi, 
<code>Config::new</code> tarafından döndürülen <code>Result</code>'u ele almak üzere <code>main</code>'i güncellememiz gerekir. Ayrıca, komut satırı aracından 
sıfır olmayan bir hata koduyla çıkma sorumluluğunu <code>panic!</code>'ten alacağız ve elle sürekleyeceğiz. Sıfır olmayan bir çıkış durumu, 
programımızı çağıran sürece programın bir hata durumuyla çıktığını bildirmek için kullanılan bir kuraldır.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.filename)
</span><span class="boring">        .expect(&quot;Something went wrong reading the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 12-10: Yeni bir <code>Config</code> oluşturma başarısız olursa bir hata koduyla çıkmak</span></p>
<p>Bu listelemede, henüz ayrıntılı olarak ele almadığımız bir metod kullandık: standart kütüphane tarafından <code>Result&lt;T, E&gt;</code> üzerinde 
tanımlanan <code>unwrap_or_else</code>. <code>unwrap_or_else</code>'i kullanmak, panik yaratmayan bazı özel hata işleme yöntemleri tanımlamamızı sağlar. 
Eğer <code>Result</code> <code>Ok</code> değerinde ise, bu metodun davranışı <code>unwrap</code>'a benzer: <code>Ok</code>'un sarmaladığı iç değeri döndürür. 
Ancak, değer <code>Err</code> değeriyse, bu metod, tanımladığımız ve <code>unwrap_or_else</code>'ye argüman olarak aktardığımız anonim bir fonksiyon olan 
kapanış ifadesindeki kodu çağırır. Kapanış ifadelerini <a href="ch13-00-functional-features.html">Bölüm 13</a><!-- ignore -->'te daha ayrıntılı olarak ele alacağız. 
Şimdilik, <code>unwrap_or_else</code>'nin  <code>Err</code>'nin iç değerini, yani bu durumda Liste 12-9'da eklediğimiz <code>&quot;not enough arguments&quot;</code> statik dizgisini, 
dikey <em>aktarmalar</em> arasında görünen <code>err</code> argümanı içinde kapanış ifadesini aktaracağını bilmeniz yeterlidir. 
Daha sonra kapanış ifadesi içindeki kod çalıştığında <code>err</code> değerini kullanabilir.</p>
<p>Standart kütüphaneden <code>process</code>'i kapsam içine almak için yeni bir <code>use</code> satırı ekledik. Hata durumunda çalıştırılacak kapanış ifadesi
içindeki kod yalnızca iki satırdır: <code>err</code> değerini yazdırırız ve ardından <code>process::exit</code>'i çağırırız. <code>process::exit</code> fonksiyonu programı 
hemen durduracak ve çıkış durum kodu olarak aktarılan sayıyı döndürecektir. Bu, Liste 12-8'de kullandığımız <code>panic!</code>-tabanlı işleme benzer, 
ancak artık tüm ekstra çıktıları almıyoruz. Hadi deneyelim:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>Harika! Bu çıktı, kullanıcılarımız için çok daha güzel.</p>
<h3 id="mainden-mantığı-Çıkarma"><a class="header" href="#mainden-mantığı-Çıkarma"><code>main</code>'den Mantığı Çıkarma</a></h3>
<p>Yapılandırma ayrıştırmasını yeniden düzenlemeyi bitirdiğimize göre, şimdi programın mantığına dönelim. </p>
<p><a href="#separation-of-concerns-for-binary-projects">“İkili Projeler için İşlerin Ayrılması”</a><!-- ignore --> 
bölümünde belirttiğimiz gibi, yapılandırmayı ayarlamak veya hataları ele almakla ilgili olmayan <code>main</code>'de şu anda bulunan tüm mantığı 
tutacak <code>run</code> adlı bir fonksiyon çıkaracağız. İşimiz bittiğinde, <code>main</code> kısa ve öz olacak ve inceleme yoluyla doğrulanması 
kolay olacak ve diğer tüm mantık için testler yazabileceğiz.</p>
<p>Liste 12-11 ayıklanmış çalıştırma fonksiyonunu göstermektedir. Şimdilik sadece fonksiyonu ayıklayarak küçük ve aşamalı bir iyileştirme yapıyoruz.
Fonksiyonu <em>src/main.rs</em> içinde tanımlıyoruz.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.filename)
        .expect(&quot;Something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}

// --snip--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 12-11: Program mantığının geri kalanını içeren <code>run</code>'ın 
çıkarılması</span></p>
<p><code>run</code> fonksiyonu artık dosyanın okunmasından başlayarak <code>main</code>'den kalan tüm mantığı içerir. 
<code>run</code> fonksiyonu <code>Config</code> örneğini bir argüman olarak alır.</p>
<h4 id="run-fonksiyonundan-hata-döndürme"><a class="header" href="#run-fonksiyonundan-hata-döndürme"><code>run</code> Fonksiyonundan Hata Döndürme</a></h4>
<p>Kalan program mantığının <code>run</code> fonksiyonuna ayrılmasıyla, Liste 12-9'da <code>Config::new</code> ile yaptığımız gibi hata işlemeyi geliştirebiliriz. 
Bir şeyler ters gittiğinde programın <code>expect</code>'i çağırarak paniklemesine izin vermek yerine, <code>run</code> fonksiyonu <code>Result&lt;T, E&gt;</code> döndürecektir. 
Bu, hataları ele alma mantığını <code>main</code>'de kullanıcı dostu bir şekilde daha da birleştirmemizi sağlayacaktır. Liste 12-12, <code>run</code>'ın 
imzasında ve gövdesinde yapmamız gereken değişiklikleri göstermektedir.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --snip--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    println!(&quot;With text:\n{}&quot;, contents);

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">Liste 12-12: <code>Result</code> döndürmek için <code>run</code>'ı değiştirme</span></p>
<p>Burada üç önemli değişiklik yaptık. İlk olarak, <code>run</code> fonksiyonunun dönüş tipini <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> olarak değiştirdik. 
Bu fonksiyon daha önce birim tipi olan <code>()'</code>i döndürüyordu ve bunu <code>Ok</code> durumunda döndürülen değer olarak tutuyoruz.</p>
<p>Hata türü için <code>Box&lt;dyn Error&gt;</code> tanım nesnesini kullandık (ve <code>std::error::Error</code>'ı en üstte bir <code>use</code> deyimiyle kapsama aldık). 
Tanım nesnelerini <a href="ch17-00-oop.html">Bölüm 17</a><!-- ignore -->'de ele alacağız. Şimdilik, <code>Box&lt;dyn Error&gt;</code>'un fonksiyonun <code>Error</code> tanımını sürekleyen 
tür döndüreceği anlamına geldiğini bilin, ancak dönüş değerinin hangi tür olacağını belirtmek zorunda değiliz. 
Bu bize farklı hata durumlarında farklı türlerde olabilecek hata değerleri döndürme esnekliği sağlar. 
<code>dyn</code> anahtar sözcüğü “dinamikin” kısaltmasıdır.</p>
<p>İkinci olarak, <a href="ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">Bölüm 9</a><!-- ignore -->'da bahsettiğimiz gibi <code>?</code> operatörü için <code>expect</code> çağrısını kaldırdık. 
Bir hatada <code>panic!</code> yerine, <code>?</code> işleci çağıranın işlemesi için geçerli fonksiyondan hata değerini döndürecektir.</p>
<p>Üçüncü olarak, <code>run</code> fonksiyonu artık başarı durumunda bir <code>Ok</code> değeri döndürmektedir. İmzada <code>run</code> fonksiyonunun başarı tipini 
<code>()</code> olarak bildirdik, bu da birim tür değerini <code>Ok</code> değerine sarmamız gerektiği anlamına geliyor. Bu <code>Ok(())</code> söz dizimi ilk başta biraz 
garip görünebilir, <code>ancak ()</code>'yi bu şekilde kullanmak, <code>run</code>'ı yalnızca yan etkileri için çağırdığımızı belirtmenin deyimsel yoludur; 
ihtiyacımız olan bir değer döndürmez.</p>
<p>Bu kodu çalıştırdığınızda, derlenecek ancak bir uyarı görüntülenecektir:</p>
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `minigrep` (bin &quot;minigrep&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Rust bize kodumuzun <code>Result</code> değerini göz ardı ettiğini ve <code>Result</code> değerinin bir hata oluştuğunu gösterebileceğini söyler. 
Ancak bir hata olup olmadığını kontrol etmiyoruz ve derleyici bize muhtemelen burada bazı hata işleme kodlarına sahip olmamız gerektiğini 
hatırlatıyor! Şimdi bu sorunu düzeltelim.</p>
<h4 id="mainde-Çalıştırmadan-dönen-hataları-İşleme"><a class="header" href="#mainde-Çalıştırmadan-dönen-hataları-İşleme"><code>main</code>'de Çalıştırmadan Dönen Hataları İşleme</a></h4>
<p>Hataları kontrol edeceğiz ve bunları Liste 12-10'da <code>Config::new</code> ile kullandığımıza benzer bir teknik kullanarak ele alacağız, 
ancak küçük bir farkla:</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><code>run</code>'ın bir <code>Err</code> değeri döndürüp döndürmediğini kontrol etmek ve döndürürse <code>process::exit(1)</code>'i çağırmak için <code>unwrap_or_else</code> yerine 
<code>if let</code> kullanırız. <code>run</code> fonksiyonu, <code>Config::new</code>'in <code>Config</code> örneğini döndürdüğü gibi <code>unwrap</code> etmek istediğimiz bir değer döndürmez. 
<code>run</code> başarı durumunda <code>()</code> değerini döndürdüğü için, yalnızca bir hatayı tespit etmekle ilgileniyoruz, bu nedenle <code>unwrap_or_else</code>'in 
yalnızca <code>()</code> değerini döndürmesine gerek yok.</p>
<p><code>if let</code> ve <code>unwrap_or_else</code> fonksiyonlarının gövdeleri her iki durumda da aynıdır: hatayı yazdırır ve çıkarız.</p>
<h3 id="kodu-kütüphane-kasasına-bölme"><a class="header" href="#kodu-kütüphane-kasasına-bölme">Kodu Kütüphane Kasasına Bölme</a></h3>
<p><code>minigrep</code> projemiz şu ana kadar iyi görünüyor! Şimdi <em>src/main.rs</em> dosyasını böleceğiz ve <em>src/lib.rs</em> dosyasına bazı kodlar koyacağız. 
Bu şekilde kodu test edebilir ve daha az sorumluluğu olan bir <em>src/main.rs</em> dosyasına sahip olabiliriz.</p>
<p><code>main</code> fonksiyonu olmayan tüm kodları <em>src/main.rs</em> dosyasından <em>src/lib.rs</em> dosyasına taşıyalım:</p>
<ul>
<li><code>run</code> fonksiyonu tanımı</li>
<li>İlişkili <code>use</code> deyimleri</li>
<li><code>Config</code>'in tanımı</li>
<li><code>Config::new</code> fonksiyon tanımı</li>
</ul>
<p><em>src/lib.rs</em> dosyasının içeriği Liste 12-13'te gösterilen imzalara sahip olmalıdır (kısa olması için fonksiyonların gövdelerini atladık). 
Liste 12-14'te <em>src/main.rs</em>'yi değiştirene kadar bunun derlenmeyeceğini unutmayın.</p>
<p><span class="filename">Dosya adı: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --snip--
<span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}
</code></pre>
<p><span class="caption">Liste 12-13: <code>Config</code> ve <code>run</code>'ı <em>src/lib.rs</em>'e taşıma</span></p>
<p><code>pub</code> anahtar sözcüğünü bolca kullandık: <code>Config</code> üzerinde, <code>Config</code>'in alanları üzerinde, <code>new</code> metodu üzerinde ve <code>run</code> fonksiyonu üzerinde. 
Artık test edebileceğimiz herkese açık bir API'ye sahip bir kütüphane kasamız var!</p>
<p>Şimdi <em>src/lib.rs</em> dosyasına taşıdığımız kodu, Liste 12-14'te gösterildiği gibi 
<em>src/main.rs</em> dosyasındaki ikili kasanın kapsamına almamız gerekiyor.</p>
<p><span class="filename">Dosya adı: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.filename);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // --snip--
<span class="boring">        println!(&quot;Application error: {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span>    }
}
</code></pre>
<p><span class="caption">Liste 12-14: <em>src/main.rs</em> içinde <code>minigrep</code> kütüphanesini kullanma</span></p>
<p><code>Config</code> türünü kütüphane kasasından ikili kasanın kapsamına getirmek için <code>use minigrep::Config</code> satırı ekliyoruz ve 
<code>run</code> fonksiyonunun önüne kasa adımızı ekliyoruz. Artık tüm fonksiyonlar birbirine bağlı olmalı ve çalışmalıdır. 
Programı <code>cargo run</code> ile çalıştırın ve her şeyin doğru çalıştığından emin olun.</p>
<p>Vay be! Sanki bu <strong>seni</strong> ve <em>beni</em> çok yormuş gibi duruyor, ancak gelecekte başarılı olmak için bunları yapmalıydık. 
Artık hataları ele almak çok daha kolay ve kodu daha modüler hale getirdik. Bundan sonraki neredeyse tüm işlerimiz <em>src/lib.rs</em> içinde 
yapılacak.</p>
<p>Eski kodla zor olan ancak yeni kodla kolay olan bir şeyi yaparak bu yeni modülerlikten yararlanalım: 
bazı testler yazacağız!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-02-reading-a-file.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch12-04-testing-the-librarys-functionality.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-02-reading-a-file.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch12-04-testing-the-librarys-functionality.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>


    </body>
</html>
